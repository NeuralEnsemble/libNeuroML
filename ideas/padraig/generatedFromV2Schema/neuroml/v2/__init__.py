#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Feb  1 18:40:02 2012 by generateDS.py version 2.7b_pg.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class Annotation(GeneratedsSuper):
    """Placeholder for MIRIAM related metadata, among others."""
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if Annotation.subclass:
            return Annotation.subclass(*args_, **kwargs_)
        else:
            return Annotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def export(self, outfile, level, namespace_='', name_='Annotation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Annotation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Annotation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Annotation', fromsubclass_=False):
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Annotation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'Annotation')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class Annotation


class includeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, href=None, valueOf_=None, mixedclass_=None, content_=None):
        self.href = _cast(None, href)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if includeType.subclass:
            return includeType.subclass(*args_, **kwargs_)
        else:
            return includeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getHref(self): return self.href
    def setHref(self, href): self.href = href
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='includeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='includeType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='includeType'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='includeType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='includeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class includeType


class VoltageConcDepBlock(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, blockConcentration=None, scalingConc=None, type_=None, species=None, scalingVolt=None):
        self.blockConcentration = _cast(None, blockConcentration)
        self.scalingConc = _cast(None, scalingConc)
        self.type_ = _cast(None, type_)
        self.species = _cast(None, species)
        self.scalingVolt = _cast(None, scalingVolt)
        pass
    def factory(*args_, **kwargs_):
        if VoltageConcDepBlock.subclass:
            return VoltageConcDepBlock.subclass(*args_, **kwargs_)
        else:
            return VoltageConcDepBlock(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getBlockConcentration(self): return self.blockConcentration
    def setBlockConcentration(self, blockConcentration): self.blockConcentration = blockConcentration
    def validate_Nml2Quantity_concentration(self, value):
        # Validate type Nml2Quantity_concentration, a restriction on xs:string.
        pass
    def getScalingConc(self): return self.scalingConc
    def setScalingConc(self, scalingConc): self.scalingConc = scalingConc
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def getSpecies(self): return self.species
    def setSpecies(self, species): self.species = species
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        pass
    def getScalingVolt(self): return self.scalingVolt
    def setScalingVolt(self, scalingVolt): self.scalingVolt = scalingVolt
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='VoltageConcDepBlock', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VoltageConcDepBlock')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VoltageConcDepBlock'):
        if self.blockConcentration is not None and 'blockConcentration' not in already_processed:
            already_processed.append('blockConcentration')
            outfile.write(' blockConcentration=%s' % (quote_attrib(self.blockConcentration), ))
        if self.scalingConc is not None and 'scalingConc' not in already_processed:
            already_processed.append('scalingConc')
            outfile.write(' scalingConc=%s' % (quote_attrib(self.scalingConc), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.species is not None and 'species' not in already_processed:
            already_processed.append('species')
            outfile.write(' species=%s' % (quote_attrib(self.species), ))
        if self.scalingVolt is not None and 'scalingVolt' not in already_processed:
            already_processed.append('scalingVolt')
            outfile.write(' scalingVolt=%s' % (quote_attrib(self.scalingVolt), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VoltageConcDepBlock', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VoltageConcDepBlock'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.blockConcentration is not None and 'blockConcentration' not in already_processed:
            already_processed.append('blockConcentration')
            showIndent(outfile, level)
            outfile.write('blockConcentration = "%s",\n' % (self.blockConcentration,))
        if self.scalingConc is not None and 'scalingConc' not in already_processed:
            already_processed.append('scalingConc')
            showIndent(outfile, level)
            outfile.write('scalingConc = "%s",\n' % (self.scalingConc,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.species is not None and 'species' not in already_processed:
            already_processed.append('species')
            showIndent(outfile, level)
            outfile.write('species = "%s",\n' % (self.species,))
        if self.scalingVolt is not None and 'scalingVolt' not in already_processed:
            already_processed.append('scalingVolt')
            showIndent(outfile, level)
            outfile.write('scalingVolt = "%s",\n' % (self.scalingVolt,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('blockConcentration', node)
        if value is not None and 'blockConcentration' not in already_processed:
            already_processed.append('blockConcentration')
            self.blockConcentration = value
            self.validate_Nml2Quantity_concentration(self.blockConcentration)    # validate type Nml2Quantity_concentration
        value = find_attr_value_('scalingConc', node)
        if value is not None and 'scalingConc' not in already_processed:
            already_processed.append('scalingConc')
            self.scalingConc = value
            self.validate_Nml2Quantity_concentration(self.scalingConc)    # validate type Nml2Quantity_concentration
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('species', node)
        if value is not None and 'species' not in already_processed:
            already_processed.append('species')
            self.species = value
            self.validate_NmlId(self.species)    # validate type NmlId
        value = find_attr_value_('scalingVolt', node)
        if value is not None and 'scalingVolt' not in already_processed:
            already_processed.append('scalingVolt')
            self.scalingVolt = value
            self.validate_Nml2Quantity_voltage(self.scalingVolt)    # validate type Nml2Quantity_voltage
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VoltageConcDepBlock


class Plasticity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tauRec=None, tauFac=None, initReleaseProb=None):
        self.tauRec = _cast(None, tauRec)
        self.tauFac = _cast(None, tauFac)
        self.initReleaseProb = _cast(None, initReleaseProb)
        pass
    def factory(*args_, **kwargs_):
        if Plasticity.subclass:
            return Plasticity.subclass(*args_, **kwargs_)
        else:
            return Plasticity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTauRec(self): return self.tauRec
    def setTauRec(self, tauRec): self.tauRec = tauRec
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        pass
    def getTauFac(self): return self.tauFac
    def setTauFac(self, tauFac): self.tauFac = tauFac
    def getInitReleaseProb(self): return self.initReleaseProb
    def setInitReleaseProb(self, initReleaseProb): self.initReleaseProb = initReleaseProb
    def validate_ZeroToOne(self, value):
        # Validate type ZeroToOne, a restriction on xs:double.
        pass
    def export(self, outfile, level, namespace_='', name_='Plasticity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Plasticity')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Plasticity'):
        if self.tauRec is not None and 'tauRec' not in already_processed:
            already_processed.append('tauRec')
            outfile.write(' tauRec=%s' % (quote_attrib(self.tauRec), ))
        if self.tauFac is not None and 'tauFac' not in already_processed:
            already_processed.append('tauFac')
            outfile.write(' tauFac=%s' % (quote_attrib(self.tauFac), ))
        if self.initReleaseProb is not None and 'initReleaseProb' not in already_processed:
            already_processed.append('initReleaseProb')
            outfile.write(' initReleaseProb=%s' % (quote_attrib(self.initReleaseProb), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Plasticity', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Plasticity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.tauRec is not None and 'tauRec' not in already_processed:
            already_processed.append('tauRec')
            showIndent(outfile, level)
            outfile.write('tauRec = "%s",\n' % (self.tauRec,))
        if self.tauFac is not None and 'tauFac' not in already_processed:
            already_processed.append('tauFac')
            showIndent(outfile, level)
            outfile.write('tauFac = "%s",\n' % (self.tauFac,))
        if self.initReleaseProb is not None and 'initReleaseProb' not in already_processed:
            already_processed.append('initReleaseProb')
            showIndent(outfile, level)
            outfile.write('initReleaseProb = %e,\n' % (self.initReleaseProb,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tauRec', node)
        if value is not None and 'tauRec' not in already_processed:
            already_processed.append('tauRec')
            self.tauRec = value
            self.validate_Nml2Quantity_time(self.tauRec)    # validate type Nml2Quantity_time
        value = find_attr_value_('tauFac', node)
        if value is not None and 'tauFac' not in already_processed:
            already_processed.append('tauFac')
            self.tauFac = value
            self.validate_Nml2Quantity_time(self.tauFac)    # validate type Nml2Quantity_time
        value = find_attr_value_('initReleaseProb', node)
        if value is not None and 'initReleaseProb' not in already_processed:
            already_processed.append('initReleaseProb')
            try:
                self.initReleaseProb = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (initReleaseProb): %s' % exp)
            self.validate_ZeroToOne(self.initReleaseProb)    # validate type ZeroToOne
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Plasticity


class SegmentParent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fractionAlong='1', segment=None):
        self.fractionAlong = _cast(None, fractionAlong)
        self.segment = _cast(None, segment)
        pass
    def factory(*args_, **kwargs_):
        if SegmentParent.subclass:
            return SegmentParent.subclass(*args_, **kwargs_)
        else:
            return SegmentParent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getFractionAlong(self): return self.fractionAlong
    def setFractionAlong(self, fractionAlong): self.fractionAlong = fractionAlong
    def validate_ZeroToOne(self, value):
        # Validate type ZeroToOne, a restriction on xs:double.
        pass
    def getSegment(self): return self.segment
    def setSegment(self, segment): self.segment = segment
    def validate_SegmentId(self, value):
        # Validate type SegmentId, a restriction on xs:nonNegativeInteger.
        pass
    def export(self, outfile, level, namespace_='', name_='SegmentParent', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SegmentParent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SegmentParent'):
        if self.fractionAlong is not None and 'fractionAlong' not in already_processed:
            already_processed.append('fractionAlong')
            outfile.write(' fractionAlong=%s' % (quote_attrib(self.fractionAlong), ))
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            outfile.write(' segment=%s' % (quote_attrib(self.segment), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SegmentParent', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SegmentParent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fractionAlong is not None and 'fractionAlong' not in already_processed:
            already_processed.append('fractionAlong')
            showIndent(outfile, level)
            outfile.write('fractionAlong = %e,\n' % (self.fractionAlong,))
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            showIndent(outfile, level)
            outfile.write('segment = %d,\n' % (self.segment,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fractionAlong', node)
        if value is not None and 'fractionAlong' not in already_processed:
            already_processed.append('fractionAlong')
            try:
                self.fractionAlong = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (fractionAlong): %s' % exp)
            self.validate_ZeroToOne(self.fractionAlong)    # validate type ZeroToOne
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            try:
                self.segment = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.segment < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_SegmentId(self.segment)    # validate type SegmentId
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SegmentParent


class Point3DWithDiam(GeneratedsSuper):
    """A 3D point with diameter."""
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, z=None, diameter=None):
        self.y = _cast(float, y)
        self.x = _cast(float, x)
        self.z = _cast(float, z)
        self.diameter = _cast(float, diameter)
        pass
    def factory(*args_, **kwargs_):
        if Point3DWithDiam.subclass:
            return Point3DWithDiam.subclass(*args_, **kwargs_)
        else:
            return Point3DWithDiam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getZ(self): return self.z
    def setZ(self, z): self.z = z
    def getDiameter(self): return self.diameter
    def setDiameter(self, diameter): self.diameter = diameter
    def export(self, outfile, level, namespace_='', name_='Point3DWithDiam', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Point3DWithDiam')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Point3DWithDiam'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            outfile.write(' diameter="%s"' % self.gds_format_double(self.diameter, input_name='diameter'))
    def exportChildren(self, outfile, level, namespace_='', name_='Point3DWithDiam', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Point3DWithDiam'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = %e,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = %e,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            showIndent(outfile, level)
            outfile.write('z = %e,\n' % (self.z,))
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            showIndent(outfile, level)
            outfile.write('diameter = %e,\n' % (self.diameter,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            try:
                self.y = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            try:
                self.x = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.append('z')
            try:
                self.z = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
        value = find_attr_value_('diameter', node)
        if value is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            try:
                self.diameter = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (diameter): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Point3DWithDiam


class ProximalDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, translationStart=None):
        self.translationStart = _cast(float, translationStart)
        pass
    def factory(*args_, **kwargs_):
        if ProximalDetails.subclass:
            return ProximalDetails.subclass(*args_, **kwargs_)
        else:
            return ProximalDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTranslationStart(self): return self.translationStart
    def setTranslationStart(self, translationStart): self.translationStart = translationStart
    def export(self, outfile, level, namespace_='', name_='ProximalDetails', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProximalDetails')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProximalDetails'):
        if self.translationStart is not None and 'translationStart' not in already_processed:
            already_processed.append('translationStart')
            outfile.write(' translationStart="%s"' % self.gds_format_double(self.translationStart, input_name='translationStart'))
    def exportChildren(self, outfile, level, namespace_='', name_='ProximalDetails', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ProximalDetails'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.translationStart is not None and 'translationStart' not in already_processed:
            already_processed.append('translationStart')
            showIndent(outfile, level)
            outfile.write('translationStart = %e,\n' % (self.translationStart,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('translationStart', node)
        if value is not None and 'translationStart' not in already_processed:
            already_processed.append('translationStart')
            try:
                self.translationStart = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (translationStart): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProximalDetails


class DistalDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, normalizationEnd=None):
        self.normalizationEnd = _cast(float, normalizationEnd)
        pass
    def factory(*args_, **kwargs_):
        if DistalDetails.subclass:
            return DistalDetails.subclass(*args_, **kwargs_)
        else:
            return DistalDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNormalizationEnd(self): return self.normalizationEnd
    def setNormalizationEnd(self, normalizationEnd): self.normalizationEnd = normalizationEnd
    def export(self, outfile, level, namespace_='', name_='DistalDetails', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DistalDetails')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DistalDetails'):
        if self.normalizationEnd is not None and 'normalizationEnd' not in already_processed:
            already_processed.append('normalizationEnd')
            outfile.write(' normalizationEnd="%s"' % self.gds_format_double(self.normalizationEnd, input_name='normalizationEnd'))
    def exportChildren(self, outfile, level, namespace_='', name_='DistalDetails', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DistalDetails'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.normalizationEnd is not None and 'normalizationEnd' not in already_processed:
            already_processed.append('normalizationEnd')
            showIndent(outfile, level)
            outfile.write('normalizationEnd = %e,\n' % (self.normalizationEnd,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('normalizationEnd', node)
        if value is not None and 'normalizationEnd' not in already_processed:
            already_processed.append('normalizationEnd')
            try:
                self.normalizationEnd = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (normalizationEnd): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DistalDetails


class Member(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, segment=None):
        self.segment = _cast(None, segment)
        pass
    def factory(*args_, **kwargs_):
        if Member.subclass:
            return Member.subclass(*args_, **kwargs_)
        else:
            return Member(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSegment(self): return self.segment
    def setSegment(self, segment): self.segment = segment
    def validate_SegmentId(self, value):
        # Validate type SegmentId, a restriction on xs:nonNegativeInteger.
        pass
    def export(self, outfile, level, namespace_='', name_='Member', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Member')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Member'):
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            outfile.write(' segment=%s' % (quote_attrib(self.segment), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Member', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Member'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            showIndent(outfile, level)
            outfile.write('segment = %d,\n' % (self.segment,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            try:
                self.segment = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.segment < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_SegmentId(self.segment)    # validate type SegmentId
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Member


class Include(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, segmentGroup=None):
        self.segmentGroup = _cast(None, segmentGroup)
        pass
    def factory(*args_, **kwargs_):
        if Include.subclass:
            return Include.subclass(*args_, **kwargs_)
        else:
            return Include(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSegmentGroup(self): return self.segmentGroup
    def setSegmentGroup(self, segmentGroup): self.segmentGroup = segmentGroup
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Include', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Include')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Include'):
        if self.segmentGroup is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            outfile.write(' segmentGroup=%s' % (quote_attrib(self.segmentGroup), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Include', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Include'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.segmentGroup is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            showIndent(outfile, level)
            outfile.write('segmentGroup = "%s",\n' % (self.segmentGroup,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('segmentGroup', node)
        if value is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            self.segmentGroup = value
            self.validate_NmlId(self.segmentGroup)    # validate type NmlId
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Include


class Path(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fromxx=None, to=None):
        self.fromxx = fromxx
        self.to = to
    def factory(*args_, **kwargs_):
        if Path.subclass:
            return Path.subclass(*args_, **kwargs_)
        else:
            return Path(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getFrom(self): return self.fromxx
    def setFrom(self, fromxx): self.fromxx = fromxx
    def getTo(self): return self.to
    def setTo(self, to): self.to = to
    def export(self, outfile, level, namespace_='', name_='Path', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Path')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Path'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Path', fromsubclass_=False):
        if self.fromxx is not None:
            self.fromxx.export(outfile, level, namespace_, name_='from')
        if self.to is not None:
            self.to.export(outfile, level, namespace_, name_='to')
    def hasContent_(self):
        if (
            self.fromxx is not None or
            self.to is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Path'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.fromxx is not None:
            showIndent(outfile, level)
            outfile.write('fromxx=model_.SegmentEndPoint(\n')
            self.fromxx.exportLiteral(outfile, level, name_='from')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.to is not None:
            showIndent(outfile, level)
            outfile.write('to=model_.SegmentEndPoint(\n')
            self.to.exportLiteral(outfile, level, name_='to')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'from':
            obj_ = SegmentEndPoint.factory()
            obj_.build(child_)
            self.setFrom(obj_)
        elif nodeName_ == 'to':
            obj_ = SegmentEndPoint.factory()
            obj_.build(child_)
            self.setTo(obj_)
# end class Path


class SubTree(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fromxx=None, to=None):
        self.fromxx = fromxx
        self.to = to
    def factory(*args_, **kwargs_):
        if SubTree.subclass:
            return SubTree.subclass(*args_, **kwargs_)
        else:
            return SubTree(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getFrom(self): return self.fromxx
    def setFrom(self, fromxx): self.fromxx = fromxx
    def getTo(self): return self.to
    def setTo(self, to): self.to = to
    def export(self, outfile, level, namespace_='', name_='SubTree', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubTree')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubTree'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SubTree', fromsubclass_=False):
        if self.fromxx is not None:
            self.fromxx.export(outfile, level, namespace_, name_='from')
        if self.to is not None:
            self.to.export(outfile, level, namespace_, name_='to')
    def hasContent_(self):
        if (
            self.fromxx is not None or
            self.to is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubTree'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.fromxx is not None:
            showIndent(outfile, level)
            outfile.write('fromxx=model_.SegmentEndPoint(\n')
            self.fromxx.exportLiteral(outfile, level, name_='from')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.to is not None:
            showIndent(outfile, level)
            outfile.write('to=model_.SegmentEndPoint(\n')
            self.to.exportLiteral(outfile, level, name_='to')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'from':
            obj_ = SegmentEndPoint.factory()
            obj_.build(child_)
            self.setFrom(obj_)
        elif nodeName_ == 'to':
            obj_ = SegmentEndPoint.factory()
            obj_.build(child_)
            self.setTo(obj_)
# end class SubTree


class SegmentEndPoint(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, segment=None):
        self.segment = _cast(None, segment)
        pass
    def factory(*args_, **kwargs_):
        if SegmentEndPoint.subclass:
            return SegmentEndPoint.subclass(*args_, **kwargs_)
        else:
            return SegmentEndPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSegment(self): return self.segment
    def setSegment(self, segment): self.segment = segment
    def validate_SegmentId(self, value):
        # Validate type SegmentId, a restriction on xs:nonNegativeInteger.
        pass
    def export(self, outfile, level, namespace_='', name_='SegmentEndPoint', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SegmentEndPoint')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SegmentEndPoint'):
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            outfile.write(' segment=%s' % (quote_attrib(self.segment), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SegmentEndPoint', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SegmentEndPoint'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            showIndent(outfile, level)
            outfile.write('segment = %d,\n' % (self.segment,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            try:
                self.segment = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.segment < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_SegmentId(self.segment)    # validate type SegmentId
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SegmentEndPoint


class MembraneProperties(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, channelPopulation=None, channelDensity=None, spikeThresh=None, specificCapacitance=None, initMembPotential=None, reversalPotential=None):
        if channelPopulation is None:
            self.channelPopulation = []
        else:
            self.channelPopulation = channelPopulation
        if channelDensity is None:
            self.channelDensity = []
        else:
            self.channelDensity = channelDensity
        if spikeThresh is None:
            self.spikeThresh = []
        else:
            self.spikeThresh = spikeThresh
        if specificCapacitance is None:
            self.specificCapacitance = []
        else:
            self.specificCapacitance = specificCapacitance
        if initMembPotential is None:
            self.initMembPotential = []
        else:
            self.initMembPotential = initMembPotential
        if reversalPotential is None:
            self.reversalPotential = []
        else:
            self.reversalPotential = reversalPotential
    def factory(*args_, **kwargs_):
        if MembraneProperties.subclass:
            return MembraneProperties.subclass(*args_, **kwargs_)
        else:
            return MembraneProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getChannelPopulation(self): return self.channelPopulation
    def setChannelPopulation(self, channelPopulation): self.channelPopulation = channelPopulation
    def addChannelPopulation(self, value): self.channelPopulation.append(value)
    def insertChannelPopulation(self, index, value): self.channelPopulation[index] = value
    def getChannelDensity(self): return self.channelDensity
    def setChannelDensity(self, channelDensity): self.channelDensity = channelDensity
    def addChannelDensity(self, value): self.channelDensity.append(value)
    def insertChannelDensity(self, index, value): self.channelDensity[index] = value
    def getSpikeThresh(self): return self.spikeThresh
    def setSpikeThresh(self, spikeThresh): self.spikeThresh = spikeThresh
    def addSpikeThresh(self, value): self.spikeThresh.append(value)
    def insertSpikeThresh(self, index, value): self.spikeThresh[index] = value
    def getSpecificCapacitance(self): return self.specificCapacitance
    def setSpecificCapacitance(self, specificCapacitance): self.specificCapacitance = specificCapacitance
    def addSpecificCapacitance(self, value): self.specificCapacitance.append(value)
    def insertSpecificCapacitance(self, index, value): self.specificCapacitance[index] = value
    def getInitMembPotential(self): return self.initMembPotential
    def setInitMembPotential(self, initMembPotential): self.initMembPotential = initMembPotential
    def addInitMembPotential(self, value): self.initMembPotential.append(value)
    def insertInitMembPotential(self, index, value): self.initMembPotential[index] = value
    def getReversalPotential(self): return self.reversalPotential
    def setReversalPotential(self, reversalPotential): self.reversalPotential = reversalPotential
    def addReversalPotential(self, value): self.reversalPotential.append(value)
    def insertReversalPotential(self, index, value): self.reversalPotential[index] = value
    def export(self, outfile, level, namespace_='', name_='MembraneProperties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MembraneProperties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MembraneProperties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MembraneProperties', fromsubclass_=False):
        for channelPopulation_ in self.channelPopulation:
            channelPopulation_.export(outfile, level, namespace_, name_='channelPopulation')
        for channelDensity_ in self.channelDensity:
            channelDensity_.export(outfile, level, namespace_, name_='channelDensity')
        for spikeThresh_ in self.spikeThresh:
            spikeThresh_.export(outfile, level, namespace_, name_='spikeThresh')
        for specificCapacitance_ in self.specificCapacitance:
            specificCapacitance_.export(outfile, level, namespace_, name_='specificCapacitance')
        for initMembPotential_ in self.initMembPotential:
            initMembPotential_.export(outfile, level, namespace_, name_='initMembPotential')
        for reversalPotential_ in self.reversalPotential:
            reversalPotential_.export(outfile, level, namespace_, name_='reversalPotential')
    def hasContent_(self):
        if (
            self.channelPopulation or
            self.channelDensity or
            self.spikeThresh or
            self.specificCapacitance or
            self.initMembPotential or
            self.reversalPotential
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MembraneProperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('channelPopulation=[\n')
        level += 1
        for channelPopulation_ in self.channelPopulation:
            showIndent(outfile, level)
            outfile.write('model_.ChannelPopulation(\n')
            channelPopulation_.exportLiteral(outfile, level, name_='ChannelPopulation')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('channelDensity=[\n')
        level += 1
        for channelDensity_ in self.channelDensity:
            showIndent(outfile, level)
            outfile.write('model_.ChannelDensity(\n')
            channelDensity_.exportLiteral(outfile, level, name_='ChannelDensity')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('spikeThresh=[\n')
        level += 1
        for spikeThresh_ in self.spikeThresh:
            showIndent(outfile, level)
            outfile.write('model_.ValueAcrossSegOrSegGroup(\n')
            spikeThresh_.exportLiteral(outfile, level, name_='ValueAcrossSegOrSegGroup')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('specificCapacitance=[\n')
        level += 1
        for specificCapacitance_ in self.specificCapacitance:
            showIndent(outfile, level)
            outfile.write('model_.ValueAcrossSegOrSegGroup(\n')
            specificCapacitance_.exportLiteral(outfile, level, name_='ValueAcrossSegOrSegGroup')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('initMembPotential=[\n')
        level += 1
        for initMembPotential_ in self.initMembPotential:
            showIndent(outfile, level)
            outfile.write('model_.ValueAcrossSegOrSegGroup(\n')
            initMembPotential_.exportLiteral(outfile, level, name_='ValueAcrossSegOrSegGroup')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('reversalPotential=[\n')
        level += 1
        for reversalPotential_ in self.reversalPotential:
            showIndent(outfile, level)
            outfile.write('model_.ReversalPotential(\n')
            reversalPotential_.exportLiteral(outfile, level, name_='ReversalPotential')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'channelPopulation':
            obj_ = ChannelPopulation.factory()
            obj_.build(child_)
            self.channelPopulation.append(obj_)
        elif nodeName_ == 'channelDensity':
            obj_ = ChannelDensity.factory()
            obj_.build(child_)
            self.channelDensity.append(obj_)
        elif nodeName_ == 'spikeThresh':
            class_obj_ = self.get_class_obj_(child_, ValueAcrossSegOrSegGroup)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.spikeThresh.append(obj_)
        elif nodeName_ == 'specificCapacitance':
            class_obj_ = self.get_class_obj_(child_, ValueAcrossSegOrSegGroup)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.specificCapacitance.append(obj_)
        elif nodeName_ == 'initMembPotential':
            class_obj_ = self.get_class_obj_(child_, ValueAcrossSegOrSegGroup)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.initMembPotential.append(obj_)
        elif nodeName_ == 'reversalPotential':
            obj_ = ReversalPotential.factory()
            obj_.build(child_)
            self.reversalPotential.append(obj_)
# end class MembraneProperties


class ValueAcrossSegOrSegGroup(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, segment=None, segmentGroup='all', value=None, extensiontype_=None):
        self.segment = _cast(None, segment)
        self.segmentGroup = _cast(None, segmentGroup)
        self.value = _cast(None, value)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ValueAcrossSegOrSegGroup.subclass:
            return ValueAcrossSegOrSegGroup.subclass(*args_, **kwargs_)
        else:
            return ValueAcrossSegOrSegGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSegment(self): return self.segment
    def setSegment(self, segment): self.segment = segment
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        pass
    def getSegmentGroup(self): return self.segmentGroup
    def setSegmentGroup(self, segmentGroup): self.segmentGroup = segmentGroup
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def validate_Nml2Quantity(self, value):
        # Validate type Nml2Quantity, a restriction on xs:string.
        pass
    def getExtensiontype_(self): return self.extensiontype_
    def setExtensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ValueAcrossSegOrSegGroup', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueAcrossSegOrSegGroup')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValueAcrossSegOrSegGroup'):
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            outfile.write(' segment=%s' % (quote_attrib(self.segment), ))
        if self.segmentGroup is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            outfile.write(' segmentGroup=%s' % (quote_attrib(self.segmentGroup), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ValueAcrossSegOrSegGroup', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValueAcrossSegOrSegGroup'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            showIndent(outfile, level)
            outfile.write('segment = "%s",\n' % (self.segment,))
        if self.segmentGroup is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            showIndent(outfile, level)
            outfile.write('segmentGroup = "%s",\n' % (self.segmentGroup,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            self.segment = value
            self.validate_NmlId(self.segment)    # validate type NmlId
        value = find_attr_value_('segmentGroup', node)
        if value is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            self.segmentGroup = value
            self.validate_NmlId(self.segmentGroup)    # validate type NmlId
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
            self.validate_Nml2Quantity(self.value)    # validate type Nml2Quantity
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ValueAcrossSegOrSegGroup


class VariableParameter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, segmentGroup=None, parameter=None, inhomogeneousValue=None):
        self.segmentGroup = _cast(None, segmentGroup)
        self.parameter = _cast(None, parameter)
        self.inhomogeneousValue = inhomogeneousValue
    def factory(*args_, **kwargs_):
        if VariableParameter.subclass:
            return VariableParameter.subclass(*args_, **kwargs_)
        else:
            return VariableParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getInhomogeneousValue(self): return self.inhomogeneousValue
    def setInhomogeneousValue(self, inhomogeneousValue): self.inhomogeneousValue = inhomogeneousValue
    def getSegmentGroup(self): return self.segmentGroup
    def setSegmentGroup(self, segmentGroup): self.segmentGroup = segmentGroup
    def getParameter(self): return self.parameter
    def setParameter(self, parameter): self.parameter = parameter
    def export(self, outfile, level, namespace_='', name_='VariableParameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VariableParameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VariableParameter'):
        if self.segmentGroup is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            outfile.write(' segmentGroup=%s' % (self.gds_format_string(quote_attrib(self.segmentGroup).encode(ExternalEncoding), input_name='segmentGroup'), ))
        if self.parameter is not None and 'parameter' not in already_processed:
            already_processed.append('parameter')
            outfile.write(' parameter=%s' % (self.gds_format_string(quote_attrib(self.parameter).encode(ExternalEncoding), input_name='parameter'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VariableParameter', fromsubclass_=False):
        if self.inhomogeneousValue is not None:
            self.inhomogeneousValue.export(outfile, level, namespace_, name_='inhomogeneousValue')
    def hasContent_(self):
        if (
            self.inhomogeneousValue is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VariableParameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.segmentGroup is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            showIndent(outfile, level)
            outfile.write('segmentGroup = "%s",\n' % (self.segmentGroup,))
        if self.parameter is not None and 'parameter' not in already_processed:
            already_processed.append('parameter')
            showIndent(outfile, level)
            outfile.write('parameter = "%s",\n' % (self.parameter,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.inhomogeneousValue is not None:
            showIndent(outfile, level)
            outfile.write('inhomogeneousValue=model_.InhomogeneousValue(\n')
            self.inhomogeneousValue.exportLiteral(outfile, level, name_='inhomogeneousValue')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('segmentGroup', node)
        if value is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            self.segmentGroup = value
        value = find_attr_value_('parameter', node)
        if value is not None and 'parameter' not in already_processed:
            already_processed.append('parameter')
            self.parameter = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inhomogeneousValue':
            obj_ = InhomogeneousValue.factory()
            obj_.build(child_)
            self.setInhomogeneousValue(obj_)
# end class VariableParameter


class InhomogeneousValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, inhomogeneousParam=None, value=None):
        self.inhomogeneousParam = _cast(None, inhomogeneousParam)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if InhomogeneousValue.subclass:
            return InhomogeneousValue.subclass(*args_, **kwargs_)
        else:
            return InhomogeneousValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getInhomogeneousParam(self): return self.inhomogeneousParam
    def setInhomogeneousParam(self, inhomogeneousParam): self.inhomogeneousParam = inhomogeneousParam
    def getValue(self): return self.value
    def setValue(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='InhomogeneousValue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InhomogeneousValue')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InhomogeneousValue'):
        if self.inhomogeneousParam is not None and 'inhomogeneousParam' not in already_processed:
            already_processed.append('inhomogeneousParam')
            outfile.write(' inhomogeneousParam=%s' % (self.gds_format_string(quote_attrib(self.inhomogeneousParam).encode(ExternalEncoding), input_name='inhomogeneousParam'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InhomogeneousValue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InhomogeneousValue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.inhomogeneousParam is not None and 'inhomogeneousParam' not in already_processed:
            already_processed.append('inhomogeneousParam')
            showIndent(outfile, level)
            outfile.write('inhomogeneousParam = "%s",\n' % (self.inhomogeneousParam,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inhomogeneousParam', node)
        if value is not None and 'inhomogeneousParam' not in already_processed:
            already_processed.append('inhomogeneousParam')
            self.inhomogeneousParam = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InhomogeneousValue


class ReversalPotential(ValueAcrossSegOrSegGroup):
    subclass = None
    superclass = ValueAcrossSegOrSegGroup
    def __init__(self, segment=None, segmentGroup='all', value=None, species=None):
        super(ReversalPotential, self).__init__(segment, segmentGroup, value, )
        self.species = _cast(None, species)
        pass
    def factory(*args_, **kwargs_):
        if ReversalPotential.subclass:
            return ReversalPotential.subclass(*args_, **kwargs_)
        else:
            return ReversalPotential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSpecies(self): return self.species
    def setSpecies(self, species): self.species = species
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='ReversalPotential', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReversalPotential')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReversalPotential'):
        super(ReversalPotential, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReversalPotential')
        if self.species is not None and 'species' not in already_processed:
            already_processed.append('species')
            outfile.write(' species=%s' % (quote_attrib(self.species), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReversalPotential', fromsubclass_=False):
        super(ReversalPotential, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(ReversalPotential, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ReversalPotential'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.species is not None and 'species' not in already_processed:
            already_processed.append('species')
            showIndent(outfile, level)
            outfile.write('species = "%s",\n' % (self.species,))
        super(ReversalPotential, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReversalPotential, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('species', node)
        if value is not None and 'species' not in already_processed:
            already_processed.append('species')
            self.species = value
            self.validate_NmlId(self.species)    # validate type NmlId
        super(ReversalPotential, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ReversalPotential, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ReversalPotential


class Species(ValueAcrossSegOrSegGroup):
    """Specifying the ion here again is redundant, the ion name should be
    the same as id. Kept for now until LEMS implementation can
    select by id. TODO: remove."""
    subclass = None
    superclass = ValueAcrossSegOrSegGroup
    def __init__(self, segment=None, segmentGroup='all', value=None, ion=None, id=None, decayingPoolConcentrationModel=None, concentrationModel=None, fixedConcentration=None):
        super(Species, self).__init__(segment, segmentGroup, value, )
        self.ion = _cast(None, ion)
        self.id = _cast(None, id)
        self.decayingPoolConcentrationModel = decayingPoolConcentrationModel
        self.concentrationModel = concentrationModel
        self.fixedConcentration = fixedConcentration
    def factory(*args_, **kwargs_):
        if Species.subclass:
            return Species.subclass(*args_, **kwargs_)
        else:
            return Species(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDecayingPoolConcentrationModel(self): return self.decayingPoolConcentrationModel
    def setDecayingPoolConcentrationModel(self, decayingPoolConcentrationModel): self.decayingPoolConcentrationModel = decayingPoolConcentrationModel
    def getConcentrationModel(self): return self.concentrationModel
    def setConcentrationModel(self, concentrationModel): self.concentrationModel = concentrationModel
    def getFixedConcentration(self): return self.fixedConcentration
    def setFixedConcentration(self, fixedConcentration): self.fixedConcentration = fixedConcentration
    def getIon(self): return self.ion
    def setIon(self, ion): self.ion = ion
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        pass
    def getId(self): return self.id
    def setId(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='Species', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Species')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Species'):
        super(Species, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Species')
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            outfile.write(' ion=%s' % (quote_attrib(self.ion), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Species', fromsubclass_=False):
        super(Species, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.decayingPoolConcentrationModel is not None:
            self.decayingPoolConcentrationModel.export(outfile, level, namespace_, name_='decayingPoolConcentrationModel', )
        if self.concentrationModel is not None:
            self.concentrationModel.export(outfile, level, namespace_, name_='concentrationModel', )
        if self.fixedConcentration is not None:
            self.fixedConcentration.export(outfile, level, namespace_, name_='fixedConcentration', )
    def hasContent_(self):
        if (
            self.decayingPoolConcentrationModel is not None or
            self.concentrationModel is not None or
            self.fixedConcentration is not None or
            super(Species, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Species'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            showIndent(outfile, level)
            outfile.write('ion = "%s",\n' % (self.ion,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        super(Species, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Species, self).exportLiteralChildren(outfile, level, name_)
        if self.decayingPoolConcentrationModel is not None:
            showIndent(outfile, level)
            outfile.write('decayingPoolConcentrationModel=model_.DecayingPoolConcentrationModel(\n')
            self.decayingPoolConcentrationModel.exportLiteral(outfile, level, name_='decayingPoolConcentrationModel')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.concentrationModel is not None:
            showIndent(outfile, level)
            outfile.write('concentrationModel=model_.ConcentrationModel_D(\n')
            self.concentrationModel.exportLiteral(outfile, level, name_='concentrationModel')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fixedConcentration is not None:
            showIndent(outfile, level)
            outfile.write('fixedConcentration=model_.FixedConcentration(\n')
            self.fixedConcentration.exportLiteral(outfile, level, name_='fixedConcentration')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            self.ion = value
            self.validate_NmlId(self.ion)    # validate type NmlId
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
            self.validate_NmlId(self.id)    # validate type NmlId
        super(Species, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'decayingPoolConcentrationModel':
            class_obj_ = self.get_class_obj_(child_, DecayingPoolConcentrationModel)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.setDecayingPoolConcentrationModel(obj_)
        elif nodeName_ == 'concentrationModel':
            obj_ = ConcentrationModel_D.factory()
            obj_.build(child_)
            self.setConcentrationModel(obj_)
        elif nodeName_ == 'fixedConcentration':
            obj_ = FixedConcentration.factory()
            obj_.build(child_)
            self.setFixedConcentration(obj_)
        super(Species, self).buildChildren(child_, node, nodeName_, True)
# end class Species


class FixedConcentration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, concentration=None):
        self.concentration = _cast(None, concentration)
        pass
    def factory(*args_, **kwargs_):
        if FixedConcentration.subclass:
            return FixedConcentration.subclass(*args_, **kwargs_)
        else:
            return FixedConcentration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getConcentration(self): return self.concentration
    def setConcentration(self, concentration): self.concentration = concentration
    def validate_Nml2Quantity_concentration(self, value):
        # Validate type Nml2Quantity_concentration, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='FixedConcentration', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedConcentration')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedConcentration'):
        if self.concentration is not None and 'concentration' not in already_processed:
            already_processed.append('concentration')
            outfile.write(' concentration=%s' % (quote_attrib(self.concentration), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FixedConcentration', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedConcentration'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.concentration is not None and 'concentration' not in already_processed:
            already_processed.append('concentration')
            showIndent(outfile, level)
            outfile.write('concentration = "%s",\n' % (self.concentration,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('concentration', node)
        if value is not None and 'concentration' not in already_processed:
            already_processed.append('concentration')
            self.concentration = value
            self.validate_Nml2Quantity_concentration(self.concentration)    # validate type Nml2Quantity_concentration
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FixedConcentration


class DecayingPoolConcentrationModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extConcentration=None, resting_conc=None, decay_constant=None, shell_thickness=None, initialConcentration=None, extensiontype_=None):
        self.extConcentration = _cast(None, extConcentration)
        self.resting_conc = _cast(None, resting_conc)
        self.decay_constant = _cast(None, decay_constant)
        self.shell_thickness = _cast(None, shell_thickness)
        self.initialConcentration = _cast(None, initialConcentration)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DecayingPoolConcentrationModel.subclass:
            return DecayingPoolConcentrationModel.subclass(*args_, **kwargs_)
        else:
            return DecayingPoolConcentrationModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getExtConcentration(self): return self.extConcentration
    def setExtConcentration(self, extConcentration): self.extConcentration = extConcentration
    def validate_Nml2Quantity_concentration(self, value):
        # Validate type Nml2Quantity_concentration, a restriction on xs:string.
        pass
    def getResting_conc(self): return self.resting_conc
    def setResting_conc(self, resting_conc): self.resting_conc = resting_conc
    def getDecay_constant(self): return self.decay_constant
    def setDecay_constant(self, decay_constant): self.decay_constant = decay_constant
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        pass
    def getShell_thickness(self): return self.shell_thickness
    def setShell_thickness(self, shell_thickness): self.shell_thickness = shell_thickness
    def validate_Nml2Quantity_length(self, value):
        # Validate type Nml2Quantity_length, a restriction on xs:string.
        pass
    def getInitialConcentration(self): return self.initialConcentration
    def setInitialConcentration(self, initialConcentration): self.initialConcentration = initialConcentration
    def getExtensiontype_(self): return self.extensiontype_
    def setExtensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='DecayingPoolConcentrationModel', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DecayingPoolConcentrationModel')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DecayingPoolConcentrationModel'):
        if self.extConcentration is not None and 'extConcentration' not in already_processed:
            already_processed.append('extConcentration')
            outfile.write(' extConcentration=%s' % (quote_attrib(self.extConcentration), ))
        if self.resting_conc is not None and 'resting_conc' not in already_processed:
            already_processed.append('resting_conc')
            outfile.write(' resting_conc=%s' % (quote_attrib(self.resting_conc), ))
        if self.decay_constant is not None and 'decay_constant' not in already_processed:
            already_processed.append('decay_constant')
            outfile.write(' decay_constant=%s' % (quote_attrib(self.decay_constant), ))
        if self.shell_thickness is not None and 'shell_thickness' not in already_processed:
            already_processed.append('shell_thickness')
            outfile.write(' shell_thickness=%s' % (quote_attrib(self.shell_thickness), ))
        if self.initialConcentration is not None and 'initialConcentration' not in already_processed:
            already_processed.append('initialConcentration')
            outfile.write(' initialConcentration=%s' % (quote_attrib(self.initialConcentration), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='DecayingPoolConcentrationModel', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DecayingPoolConcentrationModel'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.extConcentration is not None and 'extConcentration' not in already_processed:
            already_processed.append('extConcentration')
            showIndent(outfile, level)
            outfile.write('extConcentration = "%s",\n' % (self.extConcentration,))
        if self.resting_conc is not None and 'resting_conc' not in already_processed:
            already_processed.append('resting_conc')
            showIndent(outfile, level)
            outfile.write('resting_conc = "%s",\n' % (self.resting_conc,))
        if self.decay_constant is not None and 'decay_constant' not in already_processed:
            already_processed.append('decay_constant')
            showIndent(outfile, level)
            outfile.write('decay_constant = "%s",\n' % (self.decay_constant,))
        if self.shell_thickness is not None and 'shell_thickness' not in already_processed:
            already_processed.append('shell_thickness')
            showIndent(outfile, level)
            outfile.write('shell_thickness = "%s",\n' % (self.shell_thickness,))
        if self.initialConcentration is not None and 'initialConcentration' not in already_processed:
            already_processed.append('initialConcentration')
            showIndent(outfile, level)
            outfile.write('initialConcentration = "%s",\n' % (self.initialConcentration,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('extConcentration', node)
        if value is not None and 'extConcentration' not in already_processed:
            already_processed.append('extConcentration')
            self.extConcentration = value
            self.validate_Nml2Quantity_concentration(self.extConcentration)    # validate type Nml2Quantity_concentration
        value = find_attr_value_('resting_conc', node)
        if value is not None and 'resting_conc' not in already_processed:
            already_processed.append('resting_conc')
            self.resting_conc = value
            self.validate_Nml2Quantity_concentration(self.resting_conc)    # validate type Nml2Quantity_concentration
        value = find_attr_value_('decay_constant', node)
        if value is not None and 'decay_constant' not in already_processed:
            already_processed.append('decay_constant')
            self.decay_constant = value
            self.validate_Nml2Quantity_time(self.decay_constant)    # validate type Nml2Quantity_time
        value = find_attr_value_('shell_thickness', node)
        if value is not None and 'shell_thickness' not in already_processed:
            already_processed.append('shell_thickness')
            self.shell_thickness = value
            self.validate_Nml2Quantity_length(self.shell_thickness)    # validate type Nml2Quantity_length
        value = find_attr_value_('initialConcentration', node)
        if value is not None and 'initialConcentration' not in already_processed:
            already_processed.append('initialConcentration')
            self.initialConcentration = value
            self.validate_Nml2Quantity_concentration(self.initialConcentration)    # validate type Nml2Quantity_concentration
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DecayingPoolConcentrationModel


class ConcentrationModel_D(DecayingPoolConcentrationModel):
    subclass = None
    superclass = DecayingPoolConcentrationModel
    def __init__(self, extConcentration=None, resting_conc=None, decay_constant=None, shell_thickness=None, initialConcentration=None, type_=None):
        super(ConcentrationModel_D, self).__init__(extConcentration, resting_conc, decay_constant, shell_thickness, initialConcentration, )
        self.type_ = _cast(None, type_)
        pass
    def factory(*args_, **kwargs_):
        if ConcentrationModel_D.subclass:
            return ConcentrationModel_D.subclass(*args_, **kwargs_)
        else:
            return ConcentrationModel_D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='ConcentrationModel_D', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConcentrationModel_D')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConcentrationModel_D'):
        super(ConcentrationModel_D, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConcentrationModel_D')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ConcentrationModel_D', fromsubclass_=False):
        super(ConcentrationModel_D, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(ConcentrationModel_D, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConcentrationModel_D'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        super(ConcentrationModel_D, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConcentrationModel_D, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        super(ConcentrationModel_D, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ConcentrationModel_D, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ConcentrationModel_D


class IntracellularProperties(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, species=None, resistivity=None):
        if species is None:
            self.species = []
        else:
            self.species = species
        if resistivity is None:
            self.resistivity = []
        else:
            self.resistivity = resistivity
    def factory(*args_, **kwargs_):
        if IntracellularProperties.subclass:
            return IntracellularProperties.subclass(*args_, **kwargs_)
        else:
            return IntracellularProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSpecies(self): return self.species
    def setSpecies(self, species): self.species = species
    def addSpecies(self, value): self.species.append(value)
    def insertSpecies(self, index, value): self.species[index] = value
    def getResistivity(self): return self.resistivity
    def setResistivity(self, resistivity): self.resistivity = resistivity
    def addResistivity(self, value): self.resistivity.append(value)
    def insertResistivity(self, index, value): self.resistivity[index] = value
    def export(self, outfile, level, namespace_='', name_='IntracellularProperties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntracellularProperties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IntracellularProperties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IntracellularProperties', fromsubclass_=False):
        for species_ in self.species:
            species_.export(outfile, level, namespace_, name_='species')
        for resistivity_ in self.resistivity:
            resistivity_.export(outfile, level, namespace_, name_='resistivity')
    def hasContent_(self):
        if (
            self.species or
            self.resistivity
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IntracellularProperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('species=[\n')
        level += 1
        for species_ in self.species:
            showIndent(outfile, level)
            outfile.write('model_.Species(\n')
            species_.exportLiteral(outfile, level, name_='Species')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('resistivity=[\n')
        level += 1
        for resistivity_ in self.resistivity:
            showIndent(outfile, level)
            outfile.write('model_.ValueAcrossSegOrSegGroup(\n')
            resistivity_.exportLiteral(outfile, level, name_='ValueAcrossSegOrSegGroup')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'species':
            obj_ = Species.factory()
            obj_.build(child_)
            self.species.append(obj_)
        elif nodeName_ == 'resistivity':
            class_obj_ = self.get_class_obj_(child_, ValueAcrossSegOrSegGroup)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.resistivity.append(obj_)
# end class IntracellularProperties


class SpaceStructure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ySpacing=None, zStart=0, yStart=0, zSpacing=None, xStart=0, xSpacing=None):
        self.ySpacing = _cast(float, ySpacing)
        self.zStart = _cast(float, zStart)
        self.yStart = _cast(float, yStart)
        self.zSpacing = _cast(float, zSpacing)
        self.xStart = _cast(float, xStart)
        self.xSpacing = _cast(float, xSpacing)
        pass
    def factory(*args_, **kwargs_):
        if SpaceStructure.subclass:
            return SpaceStructure.subclass(*args_, **kwargs_)
        else:
            return SpaceStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getYSpacing(self): return self.ySpacing
    def setYSpacing(self, ySpacing): self.ySpacing = ySpacing
    def getZStart(self): return self.zStart
    def setZStart(self, zStart): self.zStart = zStart
    def getYStart(self): return self.yStart
    def setYStart(self, yStart): self.yStart = yStart
    def getZSpacing(self): return self.zSpacing
    def setZSpacing(self, zSpacing): self.zSpacing = zSpacing
    def getXStart(self): return self.xStart
    def setXStart(self, xStart): self.xStart = xStart
    def getXSpacing(self): return self.xSpacing
    def setXSpacing(self, xSpacing): self.xSpacing = xSpacing
    def export(self, outfile, level, namespace_='', name_='SpaceStructure', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpaceStructure')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpaceStructure'):
        if self.ySpacing is not None and 'ySpacing' not in already_processed:
            already_processed.append('ySpacing')
            outfile.write(' ySpacing="%s"' % self.gds_format_float(self.ySpacing, input_name='ySpacing'))
        if self.zStart is not None and 'zStart' not in already_processed:
            already_processed.append('zStart')
            outfile.write(' zStart="%s"' % self.gds_format_float(self.zStart, input_name='zStart'))
        if self.yStart is not None and 'yStart' not in already_processed:
            already_processed.append('yStart')
            outfile.write(' yStart="%s"' % self.gds_format_float(self.yStart, input_name='yStart'))
        if self.zSpacing is not None and 'zSpacing' not in already_processed:
            already_processed.append('zSpacing')
            outfile.write(' zSpacing="%s"' % self.gds_format_float(self.zSpacing, input_name='zSpacing'))
        if self.xStart is not None and 'xStart' not in already_processed:
            already_processed.append('xStart')
            outfile.write(' xStart="%s"' % self.gds_format_float(self.xStart, input_name='xStart'))
        if self.xSpacing is not None and 'xSpacing' not in already_processed:
            already_processed.append('xSpacing')
            outfile.write(' xSpacing="%s"' % self.gds_format_float(self.xSpacing, input_name='xSpacing'))
    def exportChildren(self, outfile, level, namespace_='', name_='SpaceStructure', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SpaceStructure'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ySpacing is not None and 'ySpacing' not in already_processed:
            already_processed.append('ySpacing')
            showIndent(outfile, level)
            outfile.write('ySpacing = %f,\n' % (self.ySpacing,))
        if self.zStart is not None and 'zStart' not in already_processed:
            already_processed.append('zStart')
            showIndent(outfile, level)
            outfile.write('zStart = %f,\n' % (self.zStart,))
        if self.yStart is not None and 'yStart' not in already_processed:
            already_processed.append('yStart')
            showIndent(outfile, level)
            outfile.write('yStart = %f,\n' % (self.yStart,))
        if self.zSpacing is not None and 'zSpacing' not in already_processed:
            already_processed.append('zSpacing')
            showIndent(outfile, level)
            outfile.write('zSpacing = %f,\n' % (self.zSpacing,))
        if self.xStart is not None and 'xStart' not in already_processed:
            already_processed.append('xStart')
            showIndent(outfile, level)
            outfile.write('xStart = %f,\n' % (self.xStart,))
        if self.xSpacing is not None and 'xSpacing' not in already_processed:
            already_processed.append('xSpacing')
            showIndent(outfile, level)
            outfile.write('xSpacing = %f,\n' % (self.xSpacing,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ySpacing', node)
        if value is not None and 'ySpacing' not in already_processed:
            already_processed.append('ySpacing')
            try:
                self.ySpacing = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (ySpacing): %s' % exp)
        value = find_attr_value_('zStart', node)
        if value is not None and 'zStart' not in already_processed:
            already_processed.append('zStart')
            try:
                self.zStart = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (zStart): %s' % exp)
        value = find_attr_value_('yStart', node)
        if value is not None and 'yStart' not in already_processed:
            already_processed.append('yStart')
            try:
                self.yStart = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (yStart): %s' % exp)
        value = find_attr_value_('zSpacing', node)
        if value is not None and 'zSpacing' not in already_processed:
            already_processed.append('zSpacing')
            try:
                self.zSpacing = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (zSpacing): %s' % exp)
        value = find_attr_value_('xStart', node)
        if value is not None and 'xStart' not in already_processed:
            already_processed.append('xStart')
            try:
                self.xStart = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (xStart): %s' % exp)
        value = find_attr_value_('xSpacing', node)
        if value is not None and 'xSpacing' not in already_processed:
            already_processed.append('xSpacing')
            try:
                self.xSpacing = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (xSpacing): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SpaceStructure


class Layout(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, random=None, grid=None, unstructured=None):
        self.space = _cast(None, space)
        self.random = random
        self.grid = grid
        self.unstructured = unstructured
    def factory(*args_, **kwargs_):
        if Layout.subclass:
            return Layout.subclass(*args_, **kwargs_)
        else:
            return Layout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getRandom(self): return self.random
    def setRandom(self, random): self.random = random
    def getGrid(self): return self.grid
    def setGrid(self, grid): self.grid = grid
    def getUnstructured(self): return self.unstructured
    def setUnstructured(self, unstructured): self.unstructured = unstructured
    def getSpace(self): return self.space
    def setSpace(self, space): self.space = space
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Layout', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Layout')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Layout'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.append('space')
            outfile.write(' space=%s' % (quote_attrib(self.space), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Layout', fromsubclass_=False):
        if self.random is not None:
            self.random.export(outfile, level, namespace_, name_='random', )
        if self.grid is not None:
            self.grid.export(outfile, level, namespace_, name_='grid', )
        if self.unstructured is not None:
            self.unstructured.export(outfile, level, namespace_, name_='unstructured', )
    def hasContent_(self):
        if (
            self.random is not None or
            self.grid is not None or
            self.unstructured is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Layout'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.space is not None and 'space' not in already_processed:
            already_processed.append('space')
            showIndent(outfile, level)
            outfile.write('space = "%s",\n' % (self.space,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.random is not None:
            showIndent(outfile, level)
            outfile.write('random=model_.RandomLayout(\n')
            self.random.exportLiteral(outfile, level, name_='random')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.grid is not None:
            showIndent(outfile, level)
            outfile.write('grid=model_.GridLayout(\n')
            self.grid.exportLiteral(outfile, level, name_='grid')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.unstructured is not None:
            showIndent(outfile, level)
            outfile.write('unstructured=model_.UnstructuredLayout(\n')
            self.unstructured.exportLiteral(outfile, level, name_='unstructured')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.append('space')
            self.space = value
            self.validate_NmlId(self.space)    # validate type NmlId
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'random':
            obj_ = RandomLayout.factory()
            obj_.build(child_)
            self.setRandom(obj_)
        elif nodeName_ == 'grid':
            obj_ = GridLayout.factory()
            obj_.build(child_)
            self.setGrid(obj_)
        elif nodeName_ == 'unstructured':
            obj_ = UnstructuredLayout.factory()
            obj_.build(child_)
            self.setUnstructured(obj_)
# end class Layout


class UnstructuredLayout(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, number=None):
        self.number = _cast(int, number)
        pass
    def factory(*args_, **kwargs_):
        if UnstructuredLayout.subclass:
            return UnstructuredLayout.subclass(*args_, **kwargs_)
        else:
            return UnstructuredLayout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNumber(self): return self.number
    def setNumber(self, number): self.number = number
    def export(self, outfile, level, namespace_='', name_='UnstructuredLayout', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnstructuredLayout')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnstructuredLayout'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def exportChildren(self, outfile, level, namespace_='', name_='UnstructuredLayout', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UnstructuredLayout'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            showIndent(outfile, level)
            outfile.write('number = %d,\n' % (self.number,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.append('number')
            try:
                self.number = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.number < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UnstructuredLayout


class RandomLayout(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, region=None, number=None):
        self.region = _cast(None, region)
        self.number = _cast(int, number)
        pass
    def factory(*args_, **kwargs_):
        if RandomLayout.subclass:
            return RandomLayout.subclass(*args_, **kwargs_)
        else:
            return RandomLayout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getRegion(self): return self.region
    def setRegion(self, region): self.region = region
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        pass
    def getNumber(self): return self.number
    def setNumber(self, number): self.number = number
    def export(self, outfile, level, namespace_='', name_='RandomLayout', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RandomLayout')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RandomLayout'):
        if self.region is not None and 'region' not in already_processed:
            already_processed.append('region')
            outfile.write(' region=%s' % (quote_attrib(self.region), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def exportChildren(self, outfile, level, namespace_='', name_='RandomLayout', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RandomLayout'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.region is not None and 'region' not in already_processed:
            already_processed.append('region')
            showIndent(outfile, level)
            outfile.write('region = "%s",\n' % (self.region,))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            showIndent(outfile, level)
            outfile.write('number = %d,\n' % (self.number,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('region', node)
        if value is not None and 'region' not in already_processed:
            already_processed.append('region')
            self.region = value
            self.validate_NmlId(self.region)    # validate type NmlId
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.append('number')
            try:
                self.number = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.number < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RandomLayout


class GridLayout(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, zSize=None, ySize=None, xSize=None):
        self.zSize = _cast(int, zSize)
        self.ySize = _cast(int, ySize)
        self.xSize = _cast(int, xSize)
        pass
    def factory(*args_, **kwargs_):
        if GridLayout.subclass:
            return GridLayout.subclass(*args_, **kwargs_)
        else:
            return GridLayout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getZSize(self): return self.zSize
    def setZSize(self, zSize): self.zSize = zSize
    def getYSize(self): return self.ySize
    def setYSize(self, ySize): self.ySize = ySize
    def getXSize(self): return self.xSize
    def setXSize(self, xSize): self.xSize = xSize
    def export(self, outfile, level, namespace_='', name_='GridLayout', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GridLayout')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GridLayout'):
        if self.zSize is not None and 'zSize' not in already_processed:
            already_processed.append('zSize')
            outfile.write(' zSize="%s"' % self.gds_format_integer(self.zSize, input_name='zSize'))
        if self.ySize is not None and 'ySize' not in already_processed:
            already_processed.append('ySize')
            outfile.write(' ySize="%s"' % self.gds_format_integer(self.ySize, input_name='ySize'))
        if self.xSize is not None and 'xSize' not in already_processed:
            already_processed.append('xSize')
            outfile.write(' xSize="%s"' % self.gds_format_integer(self.xSize, input_name='xSize'))
    def exportChildren(self, outfile, level, namespace_='', name_='GridLayout', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GridLayout'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.zSize is not None and 'zSize' not in already_processed:
            already_processed.append('zSize')
            showIndent(outfile, level)
            outfile.write('zSize = %d,\n' % (self.zSize,))
        if self.ySize is not None and 'ySize' not in already_processed:
            already_processed.append('ySize')
            showIndent(outfile, level)
            outfile.write('ySize = %d,\n' % (self.ySize,))
        if self.xSize is not None and 'xSize' not in already_processed:
            already_processed.append('xSize')
            showIndent(outfile, level)
            outfile.write('xSize = %d,\n' % (self.xSize,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('zSize', node)
        if value is not None and 'zSize' not in already_processed:
            already_processed.append('zSize')
            try:
                self.zSize = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.zSize < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('ySize', node)
        if value is not None and 'ySize' not in already_processed:
            already_processed.append('ySize')
            try:
                self.ySize = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ySize < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('xSize', node)
        if value is not None and 'xSize' not in already_processed:
            already_processed.append('xSize')
            try:
                self.xSize = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.xSize < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GridLayout


class Instances(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, size=None, instance=None):
        self.size = _cast(int, size)
        if instance is None:
            self.instance = []
        else:
            self.instance = instance
    def factory(*args_, **kwargs_):
        if Instances.subclass:
            return Instances.subclass(*args_, **kwargs_)
        else:
            return Instances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getInstance(self): return self.instance
    def setInstance(self, instance): self.instance = instance
    def addInstance(self, value): self.instance.append(value)
    def insertInstance(self, index, value): self.instance[index] = value
    def getSize(self): return self.size
    def setSize(self, size): self.size = size
    def export(self, outfile, level, namespace_='', name_='Instances', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Instances')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Instances'):
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='', name_='Instances', fromsubclass_=False):
        for instance_ in self.instance:
            instance_.export(outfile, level, namespace_, name_='instance')
    def hasContent_(self):
        if (
            self.instance
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Instances'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            showIndent(outfile, level)
            outfile.write('size = %d,\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('instance=[\n')
        level += 1
        for instance_ in self.instance:
            showIndent(outfile, level)
            outfile.write('model_.Instance(\n')
            instance_.exportLiteral(outfile, level, name_='Instance')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.append('size')
            try:
                self.size = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.size < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instance':
            obj_ = Instance.factory()
            obj_.build(child_)
            self.instance.append(obj_)
# end class Instances


class Instance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, i=None, k=None, j=None, id=None, location=None):
        self.i = _cast(int, i)
        self.k = _cast(int, k)
        self.j = _cast(int, j)
        self.id = _cast(int, id)
        self.location = location
    def factory(*args_, **kwargs_):
        if Instance.subclass:
            return Instance.subclass(*args_, **kwargs_)
        else:
            return Instance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getLocation(self): return self.location
    def setLocation(self, location): self.location = location
    def getI(self): return self.i
    def setI(self, i): self.i = i
    def getK(self): return self.k
    def setK(self, k): self.k = k
    def getJ(self): return self.j
    def setJ(self, j): self.j = j
    def getId(self): return self.id
    def setId(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='Instance', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Instance')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Instance'):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            outfile.write(' i="%s"' % self.gds_format_integer(self.i, input_name='i'))
        if self.k is not None and 'k' not in already_processed:
            already_processed.append('k')
            outfile.write(' k="%s"' % self.gds_format_integer(self.k, input_name='k'))
        if self.j is not None and 'j' not in already_processed:
            already_processed.append('j')
            outfile.write(' j="%s"' % self.gds_format_integer(self.j, input_name='j'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespace_='', name_='Instance', fromsubclass_=False):
        if self.location is not None:
            self.location.export(outfile, level, namespace_, name_='location', )
    def hasContent_(self):
        if (
            self.location is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Instance'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            showIndent(outfile, level)
            outfile.write('i = %d,\n' % (self.i,))
        if self.k is not None and 'k' not in already_processed:
            already_processed.append('k')
            showIndent(outfile, level)
            outfile.write('k = %d,\n' % (self.k,))
        if self.j is not None and 'j' not in already_processed:
            already_processed.append('j')
            showIndent(outfile, level)
            outfile.write('j = %d,\n' % (self.j,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.location is not None:
            showIndent(outfile, level)
            outfile.write('location=model_.Location(\n')
            self.location.exportLiteral(outfile, level, name_='location')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('i', node)
        if value is not None and 'i' not in already_processed:
            already_processed.append('i')
            try:
                self.i = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.i < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('k', node)
        if value is not None and 'k' not in already_processed:
            already_processed.append('k')
            try:
                self.k = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.k < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('j', node)
        if value is not None and 'j' not in already_processed:
            already_processed.append('j')
            try:
                self.j = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.j < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'location':
            obj_ = Location.factory()
            obj_.build(child_)
            self.setLocation(obj_)
# end class Instance


class Location(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, z=None):
        self.y = _cast(float, y)
        self.x = _cast(float, x)
        self.z = _cast(float, z)
        pass
    def factory(*args_, **kwargs_):
        if Location.subclass:
            return Location.subclass(*args_, **kwargs_)
        else:
            return Location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getY(self): return self.y
    def setY(self, y): self.y = y
    def getX(self): return self.x
    def setX(self, x): self.x = x
    def getZ(self): return self.z
    def setZ(self, z): self.z = z
    def export(self, outfile, level, namespace_='', name_='Location', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Location')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Location'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y="%s"' % self.gds_format_float(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x="%s"' % self.gds_format_float(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            outfile.write(' z="%s"' % self.gds_format_float(self.z, input_name='z'))
    def exportChildren(self, outfile, level, namespace_='', name_='Location', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Location'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = %f,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = %f,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            showIndent(outfile, level)
            outfile.write('z = %f,\n' % (self.z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            try:
                self.y = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            try:
                self.x = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.append('z')
            try:
                self.z = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (z): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Location


class SynapticConnection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, to=None, synapse=None, fromxx=None):
        self.to = _cast(None, to)
        self.synapse = _cast(None, synapse)
        self.fromxx = _cast(None, fromxx)
        pass
    def factory(*args_, **kwargs_):
        if SynapticConnection.subclass:
            return SynapticConnection.subclass(*args_, **kwargs_)
        else:
            return SynapticConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTo(self): return self.to
    def setTo(self, to): self.to = to
    def getSynapse(self): return self.synapse
    def setSynapse(self, synapse): self.synapse = synapse
    def getFrom(self): return self.fromxx
    def setFrom(self, fromxx): self.fromxx = fromxx
    def export(self, outfile, level, namespace_='', name_='SynapticConnection', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SynapticConnection')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SynapticConnection'):
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            outfile.write(' to=%s' % (self.gds_format_string(quote_attrib(self.to).encode(ExternalEncoding), input_name='to'), ))
        if self.synapse is not None and 'synapse' not in already_processed:
            already_processed.append('synapse')
            outfile.write(' synapse=%s' % (self.gds_format_string(quote_attrib(self.synapse).encode(ExternalEncoding), input_name='synapse'), ))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            outfile.write(' from=%s' % (self.gds_format_string(quote_attrib(self.fromxx).encode(ExternalEncoding), input_name='from'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SynapticConnection', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SynapticConnection'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            showIndent(outfile, level)
            outfile.write('to = "%s",\n' % (self.to,))
        if self.synapse is not None and 'synapse' not in already_processed:
            already_processed.append('synapse')
            showIndent(outfile, level)
            outfile.write('synapse = "%s",\n' % (self.synapse,))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            showIndent(outfile, level)
            outfile.write('fromxx = "%s",\n' % (self.fromxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.append('to')
            self.to = value
        value = find_attr_value_('synapse', node)
        if value is not None and 'synapse' not in already_processed:
            already_processed.append('synapse')
            self.synapse = value
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.append('from')
            self.fromxx = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SynapticConnection


class Connection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, to=None, fromxx=None):
        self.to = _cast(None, to)
        self.fromxx = _cast(None, fromxx)
        pass
    def factory(*args_, **kwargs_):
        if Connection.subclass:
            return Connection.subclass(*args_, **kwargs_)
        else:
            return Connection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTo(self): return self.to
    def setTo(self, to): self.to = to
    def getFrom(self): return self.fromxx
    def setFrom(self, fromxx): self.fromxx = fromxx
    def export(self, outfile, level, namespace_='', name_='Connection', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Connection')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Connection'):
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            outfile.write(' to=%s' % (self.gds_format_string(quote_attrib(self.to).encode(ExternalEncoding), input_name='to'), ))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            outfile.write(' from=%s' % (self.gds_format_string(quote_attrib(self.fromxx).encode(ExternalEncoding), input_name='from'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Connection', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Connection'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            showIndent(outfile, level)
            outfile.write('to = "%s",\n' % (self.to,))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            showIndent(outfile, level)
            outfile.write('fromxx = "%s",\n' % (self.fromxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.append('to')
            self.to = value
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.append('from')
            self.fromxx = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Connection


class ExplicitInput(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, input=None, target=None):
        self.input = _cast(None, input)
        self.target = _cast(None, target)
        pass
    def factory(*args_, **kwargs_):
        if ExplicitInput.subclass:
            return ExplicitInput.subclass(*args_, **kwargs_)
        else:
            return ExplicitInput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getInput(self): return self.input
    def setInput(self, input): self.input = input
    def getTarget(self): return self.target
    def setTarget(self, target): self.target = target
    def export(self, outfile, level, namespace_='', name_='ExplicitInput', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExplicitInput')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExplicitInput'):
        if self.input is not None and 'input' not in already_processed:
            already_processed.append('input')
            outfile.write(' input=%s' % (self.gds_format_string(quote_attrib(self.input).encode(ExternalEncoding), input_name='input'), ))
        if self.target is not None and 'target' not in already_processed:
            already_processed.append('target')
            outfile.write(' target=%s' % (self.gds_format_string(quote_attrib(self.target).encode(ExternalEncoding), input_name='target'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ExplicitInput', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExplicitInput'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.input is not None and 'input' not in already_processed:
            already_processed.append('input')
            showIndent(outfile, level)
            outfile.write('input = "%s",\n' % (self.input,))
        if self.target is not None and 'target' not in already_processed:
            already_processed.append('target')
            showIndent(outfile, level)
            outfile.write('target = "%s",\n' % (self.target,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('input', node)
        if value is not None and 'input' not in already_processed:
            already_processed.append('input')
            self.input = value
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.append('target')
            self.target = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExplicitInput


class Base(GeneratedsSuper):
    """Anything which can have a unique id (within its parent) i.e. most
    elements."""
    subclass = None
    superclass = None
    def __init__(self, id=None, neuroLexId=None, extensiontype_=None):
        self.id = _cast(None, id)
        self.neuroLexId = _cast(None, neuroLexId)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Base.subclass:
            return Base.subclass(*args_, **kwargs_)
        else:
            return Base(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getId(self): return self.id
    def setId(self, id): self.id = id
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        pass
    def getNeuroLexId(self): return self.neuroLexId
    def setNeuroLexId(self, neuroLexId): self.neuroLexId = neuroLexId
    def validate_NeuroLexId(self, value):
        # Validate type NeuroLexId, a restriction on xs:string.
        pass
    def getExtensiontype_(self): return self.extensiontype_
    def setExtensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='Base', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Base')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Base'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.neuroLexId is not None and 'neuroLexId' not in already_processed:
            already_processed.append('neuroLexId')
            outfile.write(' neuroLexId=%s' % (quote_attrib(self.neuroLexId), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Base', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Base'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.neuroLexId is not None and 'neuroLexId' not in already_processed:
            already_processed.append('neuroLexId')
            showIndent(outfile, level)
            outfile.write('neuroLexId = "%s",\n' % (self.neuroLexId,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
            self.validate_NmlId(self.id)    # validate type NmlId
        value = find_attr_value_('neuroLexId', node)
        if value is not None and 'neuroLexId' not in already_processed:
            already_processed.append('neuroLexId')
            self.neuroLexId = value
            self.validate_NeuroLexId(self.neuroLexId)    # validate type NeuroLexId
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Base


class Standalone(Base):
    """Elements which can stand alone and be referenced by id, e.g. cell,
    morphology."""
    subclass = None
    superclass = Base
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, extensiontype_=None):
        super(Standalone, self).__init__(id, neuroLexId, extensiontype_, )
        self.metaid = _cast(None, metaid)
        self.notes = notes
        self.annotation = annotation
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Standalone.subclass:
            return Standalone.subclass(*args_, **kwargs_)
        else:
            return Standalone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getNotes(self): return self.notes
    def setNotes(self, notes): self.notes = notes
    def validate_Notes(self, value):
        # Validate type Notes, a restriction on xs:string.
        pass
    def getAnnotation(self): return self.annotation
    def setAnnotation(self, annotation): self.annotation = annotation
    def getMetaid(self): return self.metaid
    def setMetaid(self, metaid): self.metaid = metaid
    def validate_MetaId(self, value):
        # Validate type MetaId, a restriction on xs:string.
        pass
    def getExtensiontype_(self): return self.extensiontype_
    def setExtensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='Standalone', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Standalone')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Standalone'):
        super(Standalone, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Standalone')
        if self.metaid is not None and 'metaid' not in already_processed:
            already_processed.append('metaid')
            outfile.write(' metaid=%s' % (quote_attrib(self.metaid), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Standalone', fromsubclass_=False):
        super(Standalone, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('<%snotes>%s</%snotes>\n' % (namespace_, self.gds_format_string(quote_xml(self.notes).encode(ExternalEncoding), input_name='notes'), namespace_))
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
    def hasContent_(self):
        if (
            self.notes is not None or
            self.annotation is not None or
            super(Standalone, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Standalone'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.metaid is not None and 'metaid' not in already_processed:
            already_processed.append('metaid')
            showIndent(outfile, level)
            outfile.write('metaid = "%s",\n' % (self.metaid,))
        super(Standalone, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Standalone, self).exportLiteralChildren(outfile, level, name_)
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=%s,\n' % quote_python(self.notes).encode(ExternalEncoding))
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.Annotation(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('metaid', node)
        if value is not None and 'metaid' not in already_processed:
            already_processed.append('metaid')
            self.metaid = value
            self.validate_MetaId(self.metaid)    # validate type MetaId
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(Standalone, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'notes':
            notes_ = child_.text
            notes_ = self.gds_validate_string(notes_, node, 'notes')
            self.notes = notes_
            self.validate_Notes(self.notes)    # validate type Notes
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.setAnnotation(obj_)
        super(Standalone, self).buildChildren(child_, node, nodeName_, True)
# end class Standalone


class Projection(Base):
    subclass = None
    superclass = Base
    def __init__(self, id=None, neuroLexId=None, anytypeobjs_=None):
        super(Projection, self).__init__(id, neuroLexId, )
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if Projection.subclass:
            return Projection.subclass(*args_, **kwargs_)
        else:
            return Projection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def export(self, outfile, level, namespace_='', name_='Projection', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Projection')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Projection'):
        super(Projection, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Projection')
    def exportChildren(self, outfile, level, namespace_='', name_='Projection', fromsubclass_=False):
        super(Projection, self).exportChildren(outfile, level, namespace_, name_, True)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            super(Projection, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Projection'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Projection, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Projection, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Projection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'Projection')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
        super(Projection, self).buildChildren(child_, node, nodeName_, True)
# end class Projection


class CellSet(Base):
    subclass = None
    superclass = Base
    def __init__(self, id=None, neuroLexId=None, select=None, anytypeobjs_=None):
        super(CellSet, self).__init__(id, neuroLexId, )
        self.select = _cast(None, select)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CellSet.subclass:
            return CellSet.subclass(*args_, **kwargs_)
        else:
            return CellSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def getSelect(self): return self.select
    def setSelect(self, select): self.select = select
    def export(self, outfile, level, namespace_='', name_='CellSet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CellSet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CellSet'):
        super(CellSet, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CellSet')
        if self.select is not None and 'select' not in already_processed:
            already_processed.append('select')
            outfile.write(' select=%s' % (self.gds_format_string(quote_attrib(self.select).encode(ExternalEncoding), input_name='select'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CellSet', fromsubclass_=False):
        super(CellSet, self).exportChildren(outfile, level, namespace_, name_, True)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            super(CellSet, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CellSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.select is not None and 'select' not in already_processed:
            already_processed.append('select')
            showIndent(outfile, level)
            outfile.write('select = "%s",\n' % (self.select,))
        super(CellSet, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CellSet, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('select', node)
        if value is not None and 'select' not in already_processed:
            already_processed.append('select')
            self.select = value
        super(CellSet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'CellSet')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
        super(CellSet, self).buildChildren(child_, node, nodeName_, True)
# end class CellSet


class Population(Standalone):
    subclass = None
    superclass = Standalone
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, cell=None, extracellularProperties=None, component=None, network=None, size=None, layout=None, instances=None):
        super(Population, self).__init__(id, neuroLexId, metaid, notes, annotation, )
        self.cell = _cast(None, cell)
        self.extracellularProperties = _cast(None, extracellularProperties)
        self.component = _cast(None, component)
        self.network = _cast(None, network)
        self.size = _cast(int, size)
        self.layout = layout
        self.instances = instances
    def factory(*args_, **kwargs_):
        if Population.subclass:
            return Population.subclass(*args_, **kwargs_)
        else:
            return Population(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getLayout(self): return self.layout
    def setLayout(self, layout): self.layout = layout
    def getInstances(self): return self.instances
    def setInstances(self, instances): self.instances = instances
    def getCell(self): return self.cell
    def setCell(self, cell): self.cell = cell
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        pass
    def getExtracellularProperties(self): return self.extracellularProperties
    def setExtracellularProperties(self, extracellularProperties): self.extracellularProperties = extracellularProperties
    def getComponent(self): return self.component
    def setComponent(self, component): self.component = component
    def getNetwork(self): return self.network
    def setNetwork(self, network): self.network = network
    def getSize(self): return self.size
    def setSize(self, size): self.size = size
    def export(self, outfile, level, namespace_='', name_='Population', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Population')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Population'):
        super(Population, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Population')
        if self.cell is not None and 'cell' not in already_processed:
            already_processed.append('cell')
            outfile.write(' cell=%s' % (quote_attrib(self.cell), ))
        if self.extracellularProperties is not None and 'extracellularProperties' not in already_processed:
            already_processed.append('extracellularProperties')
            outfile.write(' extracellularProperties=%s' % (quote_attrib(self.extracellularProperties), ))
        if self.component is not None and 'component' not in already_processed:
            already_processed.append('component')
            outfile.write(' component=%s' % (quote_attrib(self.component), ))
        if self.network is not None and 'network' not in already_processed:
            already_processed.append('network')
            outfile.write(' network=%s' % (quote_attrib(self.network), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='', name_='Population', fromsubclass_=False):
        super(Population, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.layout is not None:
            self.layout.export(outfile, level, namespace_, name_='layout')
        if self.instances is not None:
            self.instances.export(outfile, level, namespace_, name_='instances', )
    def hasContent_(self):
        if (
            self.layout is not None or
            self.instances is not None or
            super(Population, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Population'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cell is not None and 'cell' not in already_processed:
            already_processed.append('cell')
            showIndent(outfile, level)
            outfile.write('cell = "%s",\n' % (self.cell,))
        if self.extracellularProperties is not None and 'extracellularProperties' not in already_processed:
            already_processed.append('extracellularProperties')
            showIndent(outfile, level)
            outfile.write('extracellularProperties = "%s",\n' % (self.extracellularProperties,))
        if self.component is not None and 'component' not in already_processed:
            already_processed.append('component')
            showIndent(outfile, level)
            outfile.write('component = "%s",\n' % (self.component,))
        if self.network is not None and 'network' not in already_processed:
            already_processed.append('network')
            showIndent(outfile, level)
            outfile.write('network = "%s",\n' % (self.network,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            showIndent(outfile, level)
            outfile.write('size = %d,\n' % (self.size,))
        super(Population, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Population, self).exportLiteralChildren(outfile, level, name_)
        if self.layout is not None:
            showIndent(outfile, level)
            outfile.write('layout=model_.Layout(\n')
            self.layout.exportLiteral(outfile, level, name_='layout')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.instances is not None:
            showIndent(outfile, level)
            outfile.write('instances=model_.Instances(\n')
            self.instances.exportLiteral(outfile, level, name_='instances')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cell', node)
        if value is not None and 'cell' not in already_processed:
            already_processed.append('cell')
            self.cell = value
            self.validate_NmlId(self.cell)    # validate type NmlId
        value = find_attr_value_('extracellularProperties', node)
        if value is not None and 'extracellularProperties' not in already_processed:
            already_processed.append('extracellularProperties')
            self.extracellularProperties = value
            self.validate_NmlId(self.extracellularProperties)    # validate type NmlId
        value = find_attr_value_('component', node)
        if value is not None and 'component' not in already_processed:
            already_processed.append('component')
            self.component = value
            self.validate_NmlId(self.component)    # validate type NmlId
        value = find_attr_value_('network', node)
        if value is not None and 'network' not in already_processed:
            already_processed.append('network')
            self.network = value
            self.validate_NmlId(self.network)    # validate type NmlId
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.append('size')
            try:
                self.size = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(Population, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'layout':
            obj_ = Layout.factory()
            obj_.build(child_)
            self.setLayout(obj_)
        elif nodeName_ == 'instances':
            obj_ = Instances.factory()
            obj_.build(child_)
            self.setInstances(obj_)
        super(Population, self).buildChildren(child_, node, nodeName_, True)
# end class Population


class Region(Base):
    subclass = None
    superclass = Base
    def __init__(self, id=None, neuroLexId=None, space=None, anytypeobjs_=None):
        super(Region, self).__init__(id, neuroLexId, )
        self.space = _cast(None, space)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if Region.subclass:
            return Region.subclass(*args_, **kwargs_)
        else:
            return Region(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def getSpace(self): return self.space
    def setSpace(self, space): self.space = space
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Region', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Region')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Region'):
        super(Region, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Region')
        if self.space is not None and 'space' not in already_processed:
            already_processed.append('space')
            outfile.write(' space=%s' % (quote_attrib(self.space), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Region', fromsubclass_=False):
        super(Region, self).exportChildren(outfile, level, namespace_, name_, True)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            super(Region, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Region'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.space is not None and 'space' not in already_processed:
            already_processed.append('space')
            showIndent(outfile, level)
            outfile.write('space = "%s",\n' % (self.space,))
        super(Region, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Region, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.append('space')
            self.space = value
            self.validate_NmlId(self.space)    # validate type NmlId
        super(Region, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'Region')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
        super(Region, self).buildChildren(child_, node, nodeName_, True)
# end class Region


class Space(Base):
    subclass = None
    superclass = Base
    def __init__(self, id=None, neuroLexId=None, basedOn=None, structure=None):
        super(Space, self).__init__(id, neuroLexId, )
        self.basedOn = _cast(None, basedOn)
        self.structure = structure
    def factory(*args_, **kwargs_):
        if Space.subclass:
            return Space.subclass(*args_, **kwargs_)
        else:
            return Space(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getStructure(self): return self.structure
    def setStructure(self, structure): self.structure = structure
    def getBasedOn(self): return self.basedOn
    def setBasedOn(self, basedOn): self.basedOn = basedOn
    def validate_allowedSpaces(self, value):
        # Validate type allowedSpaces, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Space', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Space')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Space'):
        super(Space, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Space')
        if self.basedOn is not None and 'basedOn' not in already_processed:
            already_processed.append('basedOn')
            outfile.write(' basedOn=%s' % (quote_attrib(self.basedOn), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Space', fromsubclass_=False):
        super(Space, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.structure is not None:
            self.structure.export(outfile, level, namespace_, name_='structure')
    def hasContent_(self):
        if (
            self.structure is not None or
            super(Space, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Space'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.basedOn is not None and 'basedOn' not in already_processed:
            already_processed.append('basedOn')
            showIndent(outfile, level)
            outfile.write('basedOn = "%s",\n' % (self.basedOn,))
        super(Space, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Space, self).exportLiteralChildren(outfile, level, name_)
        if self.structure is not None:
            showIndent(outfile, level)
            outfile.write('structure=model_.SpaceStructure(\n')
            self.structure.exportLiteral(outfile, level, name_='structure')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('basedOn', node)
        if value is not None and 'basedOn' not in already_processed:
            already_processed.append('basedOn')
            self.basedOn = value
            self.validate_allowedSpaces(self.basedOn)    # validate type allowedSpaces
        super(Space, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'structure':
            obj_ = SpaceStructure.factory()
            obj_.build(child_)
            self.setStructure(obj_)
        super(Space, self).buildChildren(child_, node, nodeName_, True)
# end class Space


class Network(Standalone):
    subclass = None
    superclass = Standalone
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, space=None, region=None, population=None, cellSet=None, projection=None, synapticConnection=None, connection=None, explicitInput=None):
        super(Network, self).__init__(id, neuroLexId, metaid, notes, annotation, )
        if space is None:
            self.space = []
        else:
            self.space = space
        if region is None:
            self.region = []
        else:
            self.region = region
        if population is None:
            self.population = []
        else:
            self.population = population
        if cellSet is None:
            self.cellSet = []
        else:
            self.cellSet = cellSet
        if projection is None:
            self.projection = []
        else:
            self.projection = projection
        if synapticConnection is None:
            self.synapticConnection = []
        else:
            self.synapticConnection = synapticConnection
        if connection is None:
            self.connection = []
        else:
            self.connection = connection
        if explicitInput is None:
            self.explicitInput = []
        else:
            self.explicitInput = explicitInput
    def factory(*args_, **kwargs_):
        if Network.subclass:
            return Network.subclass(*args_, **kwargs_)
        else:
            return Network(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSpace(self): return self.space
    def setSpace(self, space): self.space = space
    def addSpace(self, value): self.space.append(value)
    def insertSpace(self, index, value): self.space[index] = value
    def getRegion(self): return self.region
    def setRegion(self, region): self.region = region
    def addRegion(self, value): self.region.append(value)
    def insertRegion(self, index, value): self.region[index] = value
    def getPopulation(self): return self.population
    def setPopulation(self, population): self.population = population
    def addPopulation(self, value): self.population.append(value)
    def insertPopulation(self, index, value): self.population[index] = value
    def getCellSet(self): return self.cellSet
    def setCellSet(self, cellSet): self.cellSet = cellSet
    def addCellSet(self, value): self.cellSet.append(value)
    def insertCellSet(self, index, value): self.cellSet[index] = value
    def getProjection(self): return self.projection
    def setProjection(self, projection): self.projection = projection
    def addProjection(self, value): self.projection.append(value)
    def insertProjection(self, index, value): self.projection[index] = value
    def getSynapticConnection(self): return self.synapticConnection
    def setSynapticConnection(self, synapticConnection): self.synapticConnection = synapticConnection
    def addSynapticConnection(self, value): self.synapticConnection.append(value)
    def insertSynapticConnection(self, index, value): self.synapticConnection[index] = value
    def getConnection(self): return self.connection
    def setConnection(self, connection): self.connection = connection
    def addConnection(self, value): self.connection.append(value)
    def insertConnection(self, index, value): self.connection[index] = value
    def getExplicitInput(self): return self.explicitInput
    def setExplicitInput(self, explicitInput): self.explicitInput = explicitInput
    def addExplicitInput(self, value): self.explicitInput.append(value)
    def insertExplicitInput(self, index, value): self.explicitInput[index] = value
    def export(self, outfile, level, namespace_='', name_='Network', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Network')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Network'):
        super(Network, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Network')
    def exportChildren(self, outfile, level, namespace_='', name_='Network', fromsubclass_=False):
        super(Network, self).exportChildren(outfile, level, namespace_, name_, True)
        for space_ in self.space:
            space_.export(outfile, level, namespace_, name_='space')
        for region_ in self.region:
            region_.export(outfile, level, namespace_, name_='region')
        for population_ in self.population:
            population_.export(outfile, level, namespace_, name_='population')
        for cellSet_ in self.cellSet:
            cellSet_.export(outfile, level, namespace_, name_='cellSet')
        for projection_ in self.projection:
            projection_.export(outfile, level, namespace_, name_='projection')
        for synapticConnection_ in self.synapticConnection:
            synapticConnection_.export(outfile, level, namespace_, name_='synapticConnection')
        for connection_ in self.connection:
            connection_.export(outfile, level, namespace_, name_='connection')
        for explicitInput_ in self.explicitInput:
            explicitInput_.export(outfile, level, namespace_, name_='explicitInput')
    def hasContent_(self):
        if (
            self.space or
            self.region or
            self.population or
            self.cellSet or
            self.projection or
            self.synapticConnection or
            self.connection or
            self.explicitInput or
            super(Network, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Network'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Network, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Network, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('space=[\n')
        level += 1
        for space_ in self.space:
            showIndent(outfile, level)
            outfile.write('model_.Space(\n')
            space_.exportLiteral(outfile, level, name_='Space')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('region=[\n')
        level += 1
        for region_ in self.region:
            showIndent(outfile, level)
            outfile.write('model_.Region(\n')
            region_.exportLiteral(outfile, level, name_='Region')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('population=[\n')
        level += 1
        for population_ in self.population:
            showIndent(outfile, level)
            outfile.write('model_.Population(\n')
            population_.exportLiteral(outfile, level, name_='Population')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cellSet=[\n')
        level += 1
        for cellSet_ in self.cellSet:
            showIndent(outfile, level)
            outfile.write('model_.CellSet(\n')
            cellSet_.exportLiteral(outfile, level, name_='CellSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('projection=[\n')
        level += 1
        for projection_ in self.projection:
            showIndent(outfile, level)
            outfile.write('model_.Projection(\n')
            projection_.exportLiteral(outfile, level, name_='Projection')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('synapticConnection=[\n')
        level += 1
        for synapticConnection_ in self.synapticConnection:
            showIndent(outfile, level)
            outfile.write('model_.SynapticConnection(\n')
            synapticConnection_.exportLiteral(outfile, level, name_='SynapticConnection')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connection=[\n')
        level += 1
        for connection_ in self.connection:
            showIndent(outfile, level)
            outfile.write('model_.Connection(\n')
            connection_.exportLiteral(outfile, level, name_='Connection')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('explicitInput=[\n')
        level += 1
        for explicitInput_ in self.explicitInput:
            showIndent(outfile, level)
            outfile.write('model_.ExplicitInput(\n')
            explicitInput_.exportLiteral(outfile, level, name_='ExplicitInput')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Network, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'space':
            obj_ = Space.factory()
            obj_.build(child_)
            self.space.append(obj_)
        elif nodeName_ == 'region':
            obj_ = Region.factory()
            obj_.build(child_)
            self.region.append(obj_)
        elif nodeName_ == 'population':
            obj_ = Population.factory()
            obj_.build(child_)
            self.population.append(obj_)
        elif nodeName_ == 'cellSet':
            obj_ = CellSet.factory()
            obj_.build(child_)
            self.cellSet.append(obj_)
        elif nodeName_ == 'projection':
            obj_ = Projection.factory()
            obj_.build(child_)
            self.projection.append(obj_)
        elif nodeName_ == 'synapticConnection':
            obj_ = SynapticConnection.factory()
            obj_.build(child_)
            self.synapticConnection.append(obj_)
        elif nodeName_ == 'connection':
            obj_ = Connection.factory()
            obj_.build(child_)
            self.connection.append(obj_)
        elif nodeName_ == 'explicitInput':
            obj_ = ExplicitInput.factory()
            obj_.build(child_)
            self.explicitInput.append(obj_)
        super(Network, self).buildChildren(child_, node, nodeName_, True)
# end class Network


class PulseGenerator(Standalone):
    subclass = None
    superclass = Standalone
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, delay=None, duration=None, amplitude=None):
        super(PulseGenerator, self).__init__(id, neuroLexId, metaid, notes, annotation, )
        self.delay = _cast(None, delay)
        self.duration = _cast(None, duration)
        self.amplitude = _cast(None, amplitude)
        pass
    def factory(*args_, **kwargs_):
        if PulseGenerator.subclass:
            return PulseGenerator.subclass(*args_, **kwargs_)
        else:
            return PulseGenerator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getDelay(self): return self.delay
    def setDelay(self, delay): self.delay = delay
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        pass
    def getDuration(self): return self.duration
    def setDuration(self, duration): self.duration = duration
    def getAmplitude(self): return self.amplitude
    def setAmplitude(self, amplitude): self.amplitude = amplitude
    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='PulseGenerator', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PulseGenerator')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PulseGenerator'):
        super(PulseGenerator, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PulseGenerator')
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.append('delay')
            outfile.write(' delay=%s' % (quote_attrib(self.delay), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            outfile.write(' duration=%s' % (quote_attrib(self.duration), ))
        if self.amplitude is not None and 'amplitude' not in already_processed:
            already_processed.append('amplitude')
            outfile.write(' amplitude=%s' % (quote_attrib(self.amplitude), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PulseGenerator', fromsubclass_=False):
        super(PulseGenerator, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(PulseGenerator, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PulseGenerator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.append('delay')
            showIndent(outfile, level)
            outfile.write('delay = "%s",\n' % (self.delay,))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            showIndent(outfile, level)
            outfile.write('duration = "%s",\n' % (self.duration,))
        if self.amplitude is not None and 'amplitude' not in already_processed:
            already_processed.append('amplitude')
            showIndent(outfile, level)
            outfile.write('amplitude = "%s",\n' % (self.amplitude,))
        super(PulseGenerator, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PulseGenerator, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.append('delay')
            self.delay = value
            self.validate_Nml2Quantity_time(self.delay)    # validate type Nml2Quantity_time
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            self.duration = value
            self.validate_Nml2Quantity_time(self.duration)    # validate type Nml2Quantity_time
        value = find_attr_value_('amplitude', node)
        if value is not None and 'amplitude' not in already_processed:
            already_processed.append('amplitude')
            self.amplitude = value
            self.validate_Nml2Quantity_current(self.amplitude)    # validate type Nml2Quantity_current
        super(PulseGenerator, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PulseGenerator, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PulseGenerator


class ReactionScheme(Base):
    subclass = None
    superclass = Base
    def __init__(self, id=None, neuroLexId=None, source=None, type_=None, anytypeobjs_=None):
        super(ReactionScheme, self).__init__(id, neuroLexId, )
        self.source = _cast(None, source)
        self.type_ = _cast(None, type_)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if ReactionScheme.subclass:
            return ReactionScheme.subclass(*args_, **kwargs_)
        else:
            return ReactionScheme(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def getSource(self): return self.source
    def setSource(self, source): self.source = source
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='ReactionScheme', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReactionScheme')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReactionScheme'):
        super(ReactionScheme, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReactionScheme')
        if self.source is not None and 'source' not in already_processed:
            already_processed.append('source')
            outfile.write(' source=%s' % (self.gds_format_string(quote_attrib(self.source).encode(ExternalEncoding), input_name='source'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReactionScheme', fromsubclass_=False):
        super(ReactionScheme, self).exportChildren(outfile, level, namespace_, name_, True)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            super(ReactionScheme, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ReactionScheme'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.source is not None and 'source' not in already_processed:
            already_processed.append('source')
            showIndent(outfile, level)
            outfile.write('source = "%s",\n' % (self.source,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        super(ReactionScheme, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReactionScheme, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.append('source')
            self.source = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        super(ReactionScheme, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'ReactionScheme')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
        super(ReactionScheme, self).buildChildren(child_, node, nodeName_, True)
# end class ReactionScheme


class ExtracellularProperties(Base):
    subclass = None
    superclass = Base
    def __init__(self, id=None, neuroLexId=None, temperature=None, species=None):
        super(ExtracellularProperties, self).__init__(id, neuroLexId, )
        self.temperature = _cast(None, temperature)
        if species is None:
            self.species = []
        else:
            self.species = species
    def factory(*args_, **kwargs_):
        if ExtracellularProperties.subclass:
            return ExtracellularProperties.subclass(*args_, **kwargs_)
        else:
            return ExtracellularProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSpecies(self): return self.species
    def setSpecies(self, species): self.species = species
    def addSpecies(self, value): self.species.append(value)
    def insertSpecies(self, index, value): self.species[index] = value
    def getTemperature(self): return self.temperature
    def setTemperature(self, temperature): self.temperature = temperature
    def validate_Nml2Quantity_temperature(self, value):
        # Validate type Nml2Quantity_temperature, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='ExtracellularProperties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtracellularProperties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExtracellularProperties'):
        super(ExtracellularProperties, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExtracellularProperties')
        if self.temperature is not None and 'temperature' not in already_processed:
            already_processed.append('temperature')
            outfile.write(' temperature=%s' % (quote_attrib(self.temperature), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ExtracellularProperties', fromsubclass_=False):
        super(ExtracellularProperties, self).exportChildren(outfile, level, namespace_, name_, True)
        for species_ in self.species:
            species_.export(outfile, level, namespace_, name_='species')
    def hasContent_(self):
        if (
            self.species or
            super(ExtracellularProperties, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExtracellularProperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.temperature is not None and 'temperature' not in already_processed:
            already_processed.append('temperature')
            showIndent(outfile, level)
            outfile.write('temperature = "%s",\n' % (self.temperature,))
        super(ExtracellularProperties, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ExtracellularProperties, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('species=[\n')
        level += 1
        for species_ in self.species:
            showIndent(outfile, level)
            outfile.write('model_.Species(\n')
            species_.exportLiteral(outfile, level, name_='Species')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('temperature', node)
        if value is not None and 'temperature' not in already_processed:
            already_processed.append('temperature')
            self.temperature = value
            self.validate_Nml2Quantity_temperature(self.temperature)    # validate type Nml2Quantity_temperature
        super(ExtracellularProperties, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'species':
            obj_ = Species.factory()
            obj_.build(child_)
            self.species.append(obj_)
        super(ExtracellularProperties, self).buildChildren(child_, node, nodeName_, True)
# end class ExtracellularProperties


class ChannelDensity(Base):
    """Specifying the ion here again is redundant, this will be set in
    ionChannel. It is added here TEMPORARILY as selecting all ca or
    na conducting channel populations/densities in a cell would be
    difficult otherwise. It should be removed in the longer term,
    due to possible inconsistencies in this value and that in the
    ionChannel element. TODO: remove."""
    subclass = None
    superclass = Base
    def __init__(self, id=None, neuroLexId=None, segmentGroup='all', ion=None, ionChannel=None, erev=None, condDensity=None, segment=None, variableParameter=None):
        super(ChannelDensity, self).__init__(id, neuroLexId, )
        self.segmentGroup = _cast(None, segmentGroup)
        self.ion = _cast(None, ion)
        self.ionChannel = _cast(None, ionChannel)
        self.erev = _cast(None, erev)
        self.condDensity = _cast(None, condDensity)
        self.segment = _cast(None, segment)
        if variableParameter is None:
            self.variableParameter = []
        else:
            self.variableParameter = variableParameter
    def factory(*args_, **kwargs_):
        if ChannelDensity.subclass:
            return ChannelDensity.subclass(*args_, **kwargs_)
        else:
            return ChannelDensity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getVariableParameter(self): return self.variableParameter
    def setVariableParameter(self, variableParameter): self.variableParameter = variableParameter
    def addVariableParameter(self, value): self.variableParameter.append(value)
    def insertVariableParameter(self, index, value): self.variableParameter[index] = value
    def getSegmentGroup(self): return self.segmentGroup
    def setSegmentGroup(self, segmentGroup): self.segmentGroup = segmentGroup
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        pass
    def getIon(self): return self.ion
    def setIon(self, ion): self.ion = ion
    def getIonChannel(self): return self.ionChannel
    def setIonChannel(self, ionChannel): self.ionChannel = ionChannel
    def getErev(self): return self.erev
    def setErev(self, erev): self.erev = erev
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        pass
    def getCondDensity(self): return self.condDensity
    def setCondDensity(self, condDensity): self.condDensity = condDensity
    def validate_Nml2Quantity_conductanceDensity(self, value):
        # Validate type Nml2Quantity_conductanceDensity, a restriction on xs:string.
        pass
    def getSegment(self): return self.segment
    def setSegment(self, segment): self.segment = segment
    def export(self, outfile, level, namespace_='', name_='ChannelDensity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChannelDensity')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChannelDensity'):
        super(ChannelDensity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ChannelDensity')
        if self.segmentGroup is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            outfile.write(' segmentGroup=%s' % (quote_attrib(self.segmentGroup), ))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            outfile.write(' ion=%s' % (quote_attrib(self.ion), ))
        if self.ionChannel is not None and 'ionChannel' not in already_processed:
            already_processed.append('ionChannel')
            outfile.write(' ionChannel=%s' % (quote_attrib(self.ionChannel), ))
        if self.erev is not None and 'erev' not in already_processed:
            already_processed.append('erev')
            outfile.write(' erev=%s' % (quote_attrib(self.erev), ))
        if self.condDensity is not None and 'condDensity' not in already_processed:
            already_processed.append('condDensity')
            outfile.write(' condDensity=%s' % (quote_attrib(self.condDensity), ))
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            outfile.write(' segment=%s' % (quote_attrib(self.segment), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChannelDensity', fromsubclass_=False):
        super(ChannelDensity, self).exportChildren(outfile, level, namespace_, name_, True)
        for variableParameter_ in self.variableParameter:
            variableParameter_.export(outfile, level, namespace_, name_='variableParameter')
    def hasContent_(self):
        if (
            self.variableParameter or
            super(ChannelDensity, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChannelDensity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.segmentGroup is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            showIndent(outfile, level)
            outfile.write('segmentGroup = "%s",\n' % (self.segmentGroup,))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            showIndent(outfile, level)
            outfile.write('ion = "%s",\n' % (self.ion,))
        if self.ionChannel is not None and 'ionChannel' not in already_processed:
            already_processed.append('ionChannel')
            showIndent(outfile, level)
            outfile.write('ionChannel = "%s",\n' % (self.ionChannel,))
        if self.erev is not None and 'erev' not in already_processed:
            already_processed.append('erev')
            showIndent(outfile, level)
            outfile.write('erev = "%s",\n' % (self.erev,))
        if self.condDensity is not None and 'condDensity' not in already_processed:
            already_processed.append('condDensity')
            showIndent(outfile, level)
            outfile.write('condDensity = "%s",\n' % (self.condDensity,))
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            showIndent(outfile, level)
            outfile.write('segment = "%s",\n' % (self.segment,))
        super(ChannelDensity, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ChannelDensity, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('variableParameter=[\n')
        level += 1
        for variableParameter_ in self.variableParameter:
            showIndent(outfile, level)
            outfile.write('model_.VariableParameter(\n')
            variableParameter_.exportLiteral(outfile, level, name_='VariableParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('segmentGroup', node)
        if value is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            self.segmentGroup = value
            self.validate_NmlId(self.segmentGroup)    # validate type NmlId
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.append('ion')
            self.ion = value
            self.validate_NmlId(self.ion)    # validate type NmlId
        value = find_attr_value_('ionChannel', node)
        if value is not None and 'ionChannel' not in already_processed:
            already_processed.append('ionChannel')
            self.ionChannel = value
            self.validate_NmlId(self.ionChannel)    # validate type NmlId
        value = find_attr_value_('erev', node)
        if value is not None and 'erev' not in already_processed:
            already_processed.append('erev')
            self.erev = value
            self.validate_Nml2Quantity_voltage(self.erev)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('condDensity', node)
        if value is not None and 'condDensity' not in already_processed:
            already_processed.append('condDensity')
            self.condDensity = value
            self.validate_Nml2Quantity_conductanceDensity(self.condDensity)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            self.segment = value
            self.validate_NmlId(self.segment)    # validate type NmlId
        super(ChannelDensity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'variableParameter':
            obj_ = VariableParameter.factory()
            obj_.build(child_)
            self.variableParameter.append(obj_)
        super(ChannelDensity, self).buildChildren(child_, node, nodeName_, True)
# end class ChannelDensity


class ChannelPopulation(Base):
    subclass = None
    superclass = Base
    def __init__(self, id=None, neuroLexId=None, ionChannel=None, segmentGroup='all', erev=None, number=None, segment=None, variableParameter=None):
        super(ChannelPopulation, self).__init__(id, neuroLexId, )
        self.ionChannel = _cast(None, ionChannel)
        self.segmentGroup = _cast(None, segmentGroup)
        self.erev = _cast(None, erev)
        self.number = _cast(int, number)
        self.segment = _cast(None, segment)
        if variableParameter is None:
            self.variableParameter = []
        else:
            self.variableParameter = variableParameter
    def factory(*args_, **kwargs_):
        if ChannelPopulation.subclass:
            return ChannelPopulation.subclass(*args_, **kwargs_)
        else:
            return ChannelPopulation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getVariableParameter(self): return self.variableParameter
    def setVariableParameter(self, variableParameter): self.variableParameter = variableParameter
    def addVariableParameter(self, value): self.variableParameter.append(value)
    def insertVariableParameter(self, index, value): self.variableParameter[index] = value
    def getIonChannel(self): return self.ionChannel
    def setIonChannel(self, ionChannel): self.ionChannel = ionChannel
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        pass
    def getSegmentGroup(self): return self.segmentGroup
    def setSegmentGroup(self, segmentGroup): self.segmentGroup = segmentGroup
    def getErev(self): return self.erev
    def setErev(self, erev): self.erev = erev
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        pass
    def getNumber(self): return self.number
    def setNumber(self, number): self.number = number
    def getSegment(self): return self.segment
    def setSegment(self, segment): self.segment = segment
    def export(self, outfile, level, namespace_='', name_='ChannelPopulation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChannelPopulation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChannelPopulation'):
        super(ChannelPopulation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ChannelPopulation')
        if self.ionChannel is not None and 'ionChannel' not in already_processed:
            already_processed.append('ionChannel')
            outfile.write(' ionChannel=%s' % (quote_attrib(self.ionChannel), ))
        if self.segmentGroup is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            outfile.write(' segmentGroup=%s' % (quote_attrib(self.segmentGroup), ))
        if self.erev is not None and 'erev' not in already_processed:
            already_processed.append('erev')
            outfile.write(' erev=%s' % (quote_attrib(self.erev), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            outfile.write(' segment=%s' % (quote_attrib(self.segment), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChannelPopulation', fromsubclass_=False):
        super(ChannelPopulation, self).exportChildren(outfile, level, namespace_, name_, True)
        for variableParameter_ in self.variableParameter:
            variableParameter_.export(outfile, level, namespace_, name_='variableParameter')
    def hasContent_(self):
        if (
            self.variableParameter or
            super(ChannelPopulation, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChannelPopulation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ionChannel is not None and 'ionChannel' not in already_processed:
            already_processed.append('ionChannel')
            showIndent(outfile, level)
            outfile.write('ionChannel = "%s",\n' % (self.ionChannel,))
        if self.segmentGroup is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            showIndent(outfile, level)
            outfile.write('segmentGroup = "%s",\n' % (self.segmentGroup,))
        if self.erev is not None and 'erev' not in already_processed:
            already_processed.append('erev')
            showIndent(outfile, level)
            outfile.write('erev = "%s",\n' % (self.erev,))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            showIndent(outfile, level)
            outfile.write('number = %d,\n' % (self.number,))
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            showIndent(outfile, level)
            outfile.write('segment = "%s",\n' % (self.segment,))
        super(ChannelPopulation, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ChannelPopulation, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('variableParameter=[\n')
        level += 1
        for variableParameter_ in self.variableParameter:
            showIndent(outfile, level)
            outfile.write('model_.VariableParameter(\n')
            variableParameter_.exportLiteral(outfile, level, name_='VariableParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ionChannel', node)
        if value is not None and 'ionChannel' not in already_processed:
            already_processed.append('ionChannel')
            self.ionChannel = value
            self.validate_NmlId(self.ionChannel)    # validate type NmlId
        value = find_attr_value_('segmentGroup', node)
        if value is not None and 'segmentGroup' not in already_processed:
            already_processed.append('segmentGroup')
            self.segmentGroup = value
            self.validate_NmlId(self.segmentGroup)    # validate type NmlId
        value = find_attr_value_('erev', node)
        if value is not None and 'erev' not in already_processed:
            already_processed.append('erev')
            self.erev = value
            self.validate_Nml2Quantity_voltage(self.erev)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.append('number')
            try:
                self.number = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.number < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.append('segment')
            self.segment = value
            self.validate_NmlId(self.segment)    # validate type NmlId
        super(ChannelPopulation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'variableParameter':
            obj_ = VariableParameter.factory()
            obj_.build(child_)
            self.variableParameter.append(obj_)
        super(ChannelPopulation, self).buildChildren(child_, node, nodeName_, True)
# end class ChannelPopulation


class BiophysicalProperties(Standalone):
    """Standalone element which is usually inside a single cell, but could
    be outside and referenced by id."""
    subclass = None
    superclass = Standalone
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, membraneProperties=None, intracellularProperties=None, extracellularProperties=None):
        super(BiophysicalProperties, self).__init__(id, neuroLexId, metaid, notes, annotation, )
        self.membraneProperties = membraneProperties
        self.intracellularProperties = intracellularProperties
        self.extracellularProperties = extracellularProperties
    def factory(*args_, **kwargs_):
        if BiophysicalProperties.subclass:
            return BiophysicalProperties.subclass(*args_, **kwargs_)
        else:
            return BiophysicalProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMembraneProperties(self): return self.membraneProperties
    def setMembraneProperties(self, membraneProperties): self.membraneProperties = membraneProperties
    def getIntracellularProperties(self): return self.intracellularProperties
    def setIntracellularProperties(self, intracellularProperties): self.intracellularProperties = intracellularProperties
    def getExtracellularProperties(self): return self.extracellularProperties
    def setExtracellularProperties(self, extracellularProperties): self.extracellularProperties = extracellularProperties
    def export(self, outfile, level, namespace_='', name_='BiophysicalProperties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BiophysicalProperties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BiophysicalProperties'):
        super(BiophysicalProperties, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BiophysicalProperties')
    def exportChildren(self, outfile, level, namespace_='', name_='BiophysicalProperties', fromsubclass_=False):
        super(BiophysicalProperties, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.membraneProperties is not None:
            self.membraneProperties.export(outfile, level, namespace_, name_='membraneProperties', )
        if self.intracellularProperties is not None:
            self.intracellularProperties.export(outfile, level, namespace_, name_='intracellularProperties')
        if self.extracellularProperties is not None:
            self.extracellularProperties.export(outfile, level, namespace_, name_='extracellularProperties')
    def hasContent_(self):
        if (
            self.membraneProperties is not None or
            self.intracellularProperties is not None or
            self.extracellularProperties is not None or
            super(BiophysicalProperties, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BiophysicalProperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BiophysicalProperties, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BiophysicalProperties, self).exportLiteralChildren(outfile, level, name_)
        if self.membraneProperties is not None:
            showIndent(outfile, level)
            outfile.write('membraneProperties=model_.MembraneProperties(\n')
            self.membraneProperties.exportLiteral(outfile, level, name_='membraneProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.intracellularProperties is not None:
            showIndent(outfile, level)
            outfile.write('intracellularProperties=model_.IntracellularProperties(\n')
            self.intracellularProperties.exportLiteral(outfile, level, name_='intracellularProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.extracellularProperties is not None:
            showIndent(outfile, level)
            outfile.write('extracellularProperties=model_.ExtracellularProperties(\n')
            self.extracellularProperties.exportLiteral(outfile, level, name_='extracellularProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(BiophysicalProperties, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'membraneProperties':
            obj_ = MembraneProperties.factory()
            obj_.build(child_)
            self.setMembraneProperties(obj_)
        elif nodeName_ == 'intracellularProperties':
            obj_ = IntracellularProperties.factory()
            obj_.build(child_)
            self.setIntracellularProperties(obj_)
        elif nodeName_ == 'extracellularProperties':
            obj_ = ExtracellularProperties.factory()
            obj_.build(child_)
            self.setExtracellularProperties(obj_)
        super(BiophysicalProperties, self).buildChildren(child_, node, nodeName_, True)
# end class BiophysicalProperties


class InhomogeneousParam(Base):
    subclass = None
    superclass = Base
    def __init__(self, id=None, neuroLexId=None, variable=None, metric=None, proximal=None, distal=None):
        super(InhomogeneousParam, self).__init__(id, neuroLexId, )
        self.variable = _cast(None, variable)
        self.metric = _cast(None, metric)
        self.proximal = proximal
        self.distal = distal
    def factory(*args_, **kwargs_):
        if InhomogeneousParam.subclass:
            return InhomogeneousParam.subclass(*args_, **kwargs_)
        else:
            return InhomogeneousParam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getProximal(self): return self.proximal
    def setProximal(self, proximal): self.proximal = proximal
    def getDistal(self): return self.distal
    def setDistal(self, distal): self.distal = distal
    def getVariable(self): return self.variable
    def setVariable(self, variable): self.variable = variable
    def getMetric(self): return self.metric
    def setMetric(self, metric): self.metric = metric
    def validate_Metric(self, value):
        # Validate type Metric, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='InhomogeneousParam', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InhomogeneousParam')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InhomogeneousParam'):
        super(InhomogeneousParam, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InhomogeneousParam')
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            outfile.write(' variable=%s' % (self.gds_format_string(quote_attrib(self.variable).encode(ExternalEncoding), input_name='variable'), ))
        if self.metric is not None and 'metric' not in already_processed:
            already_processed.append('metric')
            outfile.write(' metric=%s' % (quote_attrib(self.metric), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InhomogeneousParam', fromsubclass_=False):
        super(InhomogeneousParam, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.proximal is not None:
            self.proximal.export(outfile, level, namespace_, name_='proximal')
        if self.distal is not None:
            self.distal.export(outfile, level, namespace_, name_='distal')
    def hasContent_(self):
        if (
            self.proximal is not None or
            self.distal is not None or
            super(InhomogeneousParam, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InhomogeneousParam'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            showIndent(outfile, level)
            outfile.write('variable = "%s",\n' % (self.variable,))
        if self.metric is not None and 'metric' not in already_processed:
            already_processed.append('metric')
            showIndent(outfile, level)
            outfile.write('metric = "%s",\n' % (self.metric,))
        super(InhomogeneousParam, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InhomogeneousParam, self).exportLiteralChildren(outfile, level, name_)
        if self.proximal is not None:
            showIndent(outfile, level)
            outfile.write('proximal=model_.ProximalDetails(\n')
            self.proximal.exportLiteral(outfile, level, name_='proximal')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.distal is not None:
            showIndent(outfile, level)
            outfile.write('distal=model_.DistalDetails(\n')
            self.distal.exportLiteral(outfile, level, name_='distal')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('variable', node)
        if value is not None and 'variable' not in already_processed:
            already_processed.append('variable')
            self.variable = value
        value = find_attr_value_('metric', node)
        if value is not None and 'metric' not in already_processed:
            already_processed.append('metric')
            self.metric = value
            self.validate_Metric(self.metric)    # validate type Metric
        super(InhomogeneousParam, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'proximal':
            obj_ = ProximalDetails.factory()
            obj_.build(child_)
            self.setProximal(obj_)
        elif nodeName_ == 'distal':
            obj_ = DistalDetails.factory()
            obj_.build(child_)
            self.setDistal(obj_)
        super(InhomogeneousParam, self).buildChildren(child_, node, nodeName_, True)
# end class InhomogeneousParam


class SegmentGroup(Base):
    subclass = None
    superclass = Base
    def __init__(self, id=None, neuroLexId=None, member=None, include=None, path=None, subTree=None, inhomogeneousParam=None):
        super(SegmentGroup, self).__init__(id, neuroLexId, )
        if member is None:
            self.member = []
        else:
            self.member = member
        if include is None:
            self.include = []
        else:
            self.include = include
        if path is None:
            self.path = []
        else:
            self.path = path
        if subTree is None:
            self.subTree = []
        else:
            self.subTree = subTree
        if inhomogeneousParam is None:
            self.inhomogeneousParam = []
        else:
            self.inhomogeneousParam = inhomogeneousParam
    def factory(*args_, **kwargs_):
        if SegmentGroup.subclass:
            return SegmentGroup.subclass(*args_, **kwargs_)
        else:
            return SegmentGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMember(self): return self.member
    def setMember(self, member): self.member = member
    def addMember(self, value): self.member.append(value)
    def insertMember(self, index, value): self.member[index] = value
    def getInclude(self): return self.include
    def setInclude(self, include): self.include = include
    def addInclude(self, value): self.include.append(value)
    def insertInclude(self, index, value): self.include[index] = value
    def getPath(self): return self.path
    def setPath(self, path): self.path = path
    def addPath(self, value): self.path.append(value)
    def insertPath(self, index, value): self.path[index] = value
    def getSubTree(self): return self.subTree
    def setSubTree(self, subTree): self.subTree = subTree
    def addSubTree(self, value): self.subTree.append(value)
    def insertSubTree(self, index, value): self.subTree[index] = value
    def getInhomogeneousParam(self): return self.inhomogeneousParam
    def setInhomogeneousParam(self, inhomogeneousParam): self.inhomogeneousParam = inhomogeneousParam
    def addInhomogeneousParam(self, value): self.inhomogeneousParam.append(value)
    def insertInhomogeneousParam(self, index, value): self.inhomogeneousParam[index] = value
    def export(self, outfile, level, namespace_='', name_='SegmentGroup', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SegmentGroup')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SegmentGroup'):
        super(SegmentGroup, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SegmentGroup')
    def exportChildren(self, outfile, level, namespace_='', name_='SegmentGroup', fromsubclass_=False):
        super(SegmentGroup, self).exportChildren(outfile, level, namespace_, name_, True)
        for member_ in self.member:
            member_.export(outfile, level, namespace_, name_='member')
        for include_ in self.include:
            include_.export(outfile, level, namespace_, name_='include')
        for path_ in self.path:
            path_.export(outfile, level, namespace_, name_='path')
        for subTree_ in self.subTree:
            subTree_.export(outfile, level, namespace_, name_='subTree')
        for inhomogeneousParam_ in self.inhomogeneousParam:
            inhomogeneousParam_.export(outfile, level, namespace_, name_='inhomogeneousParam')
    def hasContent_(self):
        if (
            self.member or
            self.include or
            self.path or
            self.subTree or
            self.inhomogeneousParam or
            super(SegmentGroup, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SegmentGroup'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SegmentGroup, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SegmentGroup, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('member=[\n')
        level += 1
        for member_ in self.member:
            showIndent(outfile, level)
            outfile.write('model_.Member(\n')
            member_.exportLiteral(outfile, level, name_='Member')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('include=[\n')
        level += 1
        for include_ in self.include:
            showIndent(outfile, level)
            outfile.write('model_.Include(\n')
            include_.exportLiteral(outfile, level, name_='Include')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('path=[\n')
        level += 1
        for path_ in self.path:
            showIndent(outfile, level)
            outfile.write('model_.Path(\n')
            path_.exportLiteral(outfile, level, name_='Path')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('subTree=[\n')
        level += 1
        for subTree_ in self.subTree:
            showIndent(outfile, level)
            outfile.write('model_.SubTree(\n')
            subTree_.exportLiteral(outfile, level, name_='SubTree')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('inhomogeneousParam=[\n')
        level += 1
        for inhomogeneousParam_ in self.inhomogeneousParam:
            showIndent(outfile, level)
            outfile.write('model_.InhomogeneousParam(\n')
            inhomogeneousParam_.exportLiteral(outfile, level, name_='InhomogeneousParam')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SegmentGroup, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'member':
            obj_ = Member.factory()
            obj_.build(child_)
            self.member.append(obj_)
        elif nodeName_ == 'include':
            obj_ = Include.factory()
            obj_.build(child_)
            self.include.append(obj_)
        elif nodeName_ == 'path':
            obj_ = Path.factory()
            obj_.build(child_)
            self.path.append(obj_)
        elif nodeName_ == 'subTree':
            obj_ = SubTree.factory()
            obj_.build(child_)
            self.subTree.append(obj_)
        elif nodeName_ == 'inhomogeneousParam':
            obj_ = InhomogeneousParam.factory()
            obj_.build(child_)
            self.inhomogeneousParam.append(obj_)
        super(SegmentGroup, self).buildChildren(child_, node, nodeName_, True)
# end class SegmentGroup


class Segment(Base):
    subclass = None
    superclass = Base
    def __init__(self, id=None, neuroLexId=None, name=None, parent=None, proximal=None, distal=None):
        super(Segment, self).__init__(id, neuroLexId, )
        self.name = _cast(None, name)
        self.parent = parent
        self.proximal = proximal
        self.distal = distal
    def factory(*args_, **kwargs_):
        if Segment.subclass:
            return Segment.subclass(*args_, **kwargs_)
        else:
            return Segment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getParent(self): return self.parent
    def setParent(self, parent): self.parent = parent
    def getProximal(self): return self.proximal
    def setProximal(self, proximal): self.proximal = proximal
    def getDistal(self): return self.distal
    def setDistal(self, distal): self.distal = distal
    def getName(self): return self.name
    def setName(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='Segment', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Segment')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Segment'):
        super(Segment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Segment')
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Segment', fromsubclass_=False):
        super(Segment, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.parent is not None:
            self.parent.export(outfile, level, namespace_, name_='parent')
        if self.proximal is not None:
            self.proximal.export(outfile, level, namespace_, name_='proximal')
        if self.distal is not None:
            self.distal.export(outfile, level, namespace_, name_='distal', )
    def hasContent_(self):
        if (
            self.parent is not None or
            self.proximal is not None or
            self.distal is not None or
            super(Segment, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Segment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        super(Segment, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Segment, self).exportLiteralChildren(outfile, level, name_)
        if self.parent is not None:
            showIndent(outfile, level)
            outfile.write('parent=model_.SegmentParent(\n')
            self.parent.exportLiteral(outfile, level, name_='parent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.proximal is not None:
            showIndent(outfile, level)
            outfile.write('proximal=model_.Point3DWithDiam(\n')
            self.proximal.exportLiteral(outfile, level, name_='proximal')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.distal is not None:
            showIndent(outfile, level)
            outfile.write('distal=model_.Point3DWithDiam(\n')
            self.distal.exportLiteral(outfile, level, name_='distal')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        super(Segment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parent':
            obj_ = SegmentParent.factory()
            obj_.build(child_)
            self.setParent(obj_)
        elif nodeName_ == 'proximal':
            obj_ = Point3DWithDiam.factory()
            obj_.build(child_)
            self.setProximal(obj_)
        elif nodeName_ == 'distal':
            obj_ = Point3DWithDiam.factory()
            obj_.build(child_)
            self.setDistal(obj_)
        super(Segment, self).buildChildren(child_, node, nodeName_, True)
# end class Segment


class Morphology(Standalone):
    """Standalone element which is usually inside a single cell, but could
    be outside and referenced by id."""
    subclass = None
    superclass = Standalone
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, segment=None, segmentGroup=None):
        super(Morphology, self).__init__(id, neuroLexId, metaid, notes, annotation, )
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
        if segmentGroup is None:
            self.segmentGroup = []
        else:
            self.segmentGroup = segmentGroup
    def factory(*args_, **kwargs_):
        if Morphology.subclass:
            return Morphology.subclass(*args_, **kwargs_)
        else:
            return Morphology(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getSegment(self): return self.segment
    def setSegment(self, segment): self.segment = segment
    def addSegment(self, value): self.segment.append(value)
    def insertSegment(self, index, value): self.segment[index] = value
    def getSegmentGroup(self): return self.segmentGroup
    def setSegmentGroup(self, segmentGroup): self.segmentGroup = segmentGroup
    def addSegmentGroup(self, value): self.segmentGroup.append(value)
    def insertSegmentGroup(self, index, value): self.segmentGroup[index] = value
    def export(self, outfile, level, namespace_='', name_='Morphology', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Morphology')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Morphology'):
        super(Morphology, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Morphology')
    def exportChildren(self, outfile, level, namespace_='', name_='Morphology', fromsubclass_=False):
        super(Morphology, self).exportChildren(outfile, level, namespace_, name_, True)
        for segment_ in self.segment:
            segment_.export(outfile, level, namespace_, name_='segment')
        for segmentGroup_ in self.segmentGroup:
            segmentGroup_.export(outfile, level, namespace_, name_='segmentGroup')
    def hasContent_(self):
        if (
            self.segment or
            self.segmentGroup or
            super(Morphology, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Morphology'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Morphology, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Morphology, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('segment=[\n')
        level += 1
        for segment_ in self.segment:
            showIndent(outfile, level)
            outfile.write('model_.Segment(\n')
            segment_.exportLiteral(outfile, level, name_='Segment')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('segmentGroup=[\n')
        level += 1
        for segmentGroup_ in self.segmentGroup:
            showIndent(outfile, level)
            outfile.write('model_.SegmentGroup(\n')
            segmentGroup_.exportLiteral(outfile, level, name_='SegmentGroup')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Morphology, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'segment':
            obj_ = Segment.factory()
            obj_.build(child_)
            self.segment.append(obj_)
        elif nodeName_ == 'segmentGroup':
            obj_ = SegmentGroup.factory()
            obj_.build(child_)
            self.segmentGroup.append(obj_)
        super(Morphology, self).buildChildren(child_, node, nodeName_, True)
# end class Morphology


class AbstractCell(Standalone):
    subclass = None
    superclass = Standalone
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, extensiontype_=None):
        super(AbstractCell, self).__init__(id, neuroLexId, metaid, notes, annotation, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractCell.subclass:
            return AbstractCell.subclass(*args_, **kwargs_)
        else:
            return AbstractCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getExtensiontype_(self): return self.extensiontype_
    def setExtensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AbstractCell', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCell')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractCell'):
        super(AbstractCell, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractCell')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCell', fromsubclass_=False):
        super(AbstractCell, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AbstractCell, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCell'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractCell, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractCell, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AbstractCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractCell


class ConductanceBasedSynapse(Standalone):
    subclass = None
    superclass = Standalone
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, erev=None, gbase=None, extensiontype_=None):
        super(ConductanceBasedSynapse, self).__init__(id, neuroLexId, metaid, notes, annotation, extensiontype_, )
        self.erev = _cast(None, erev)
        self.gbase = _cast(None, gbase)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ConductanceBasedSynapse.subclass:
            return ConductanceBasedSynapse.subclass(*args_, **kwargs_)
        else:
            return ConductanceBasedSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getErev(self): return self.erev
    def setErev(self, erev): self.erev = erev
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        pass
    def getGbase(self): return self.gbase
    def setGbase(self, gbase): self.gbase = gbase
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        pass
    def getExtensiontype_(self): return self.extensiontype_
    def setExtensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ConductanceBasedSynapse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConductanceBasedSynapse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConductanceBasedSynapse'):
        super(ConductanceBasedSynapse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConductanceBasedSynapse')
        if self.erev is not None and 'erev' not in already_processed:
            already_processed.append('erev')
            outfile.write(' erev=%s' % (quote_attrib(self.erev), ))
        if self.gbase is not None and 'gbase' not in already_processed:
            already_processed.append('gbase')
            outfile.write(' gbase=%s' % (quote_attrib(self.gbase), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ConductanceBasedSynapse', fromsubclass_=False):
        super(ConductanceBasedSynapse, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(ConductanceBasedSynapse, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConductanceBasedSynapse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.erev is not None and 'erev' not in already_processed:
            already_processed.append('erev')
            showIndent(outfile, level)
            outfile.write('erev = "%s",\n' % (self.erev,))
        if self.gbase is not None and 'gbase' not in already_processed:
            already_processed.append('gbase')
            showIndent(outfile, level)
            outfile.write('gbase = "%s",\n' % (self.gbase,))
        super(ConductanceBasedSynapse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConductanceBasedSynapse, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('erev', node)
        if value is not None and 'erev' not in already_processed:
            already_processed.append('erev')
            self.erev = value
            self.validate_Nml2Quantity_voltage(self.erev)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('gbase', node)
        if value is not None and 'gbase' not in already_processed:
            already_processed.append('gbase')
            self.gbase = value
            self.validate_Nml2Quantity_conductance(self.gbase)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(ConductanceBasedSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ConductanceBasedSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ConductanceBasedSynapse


class Gate(Base):
    subclass = None
    superclass = Base
    def __init__(self, id=None, neuroLexId=None, instances=1, type_=None, anytypeobjs_=None):
        super(Gate, self).__init__(id, neuroLexId, )
        self.instances = _cast(int, instances)
        self.type_ = _cast(None, type_)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if Gate.subclass:
            return Gate.subclass(*args_, **kwargs_)
        else:
            return Gate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def getInstances(self): return self.instances
    def setInstances(self, instances): self.instances = instances
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def validate_gateTypes(self, value):
        # Validate type gateTypes, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Gate', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Gate')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Gate'):
        super(Gate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Gate')
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.append('instances')
            outfile.write(' instances="%s"' % self.gds_format_integer(self.instances, input_name='instances'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Gate', fromsubclass_=False):
        super(Gate, self).exportChildren(outfile, level, namespace_, name_, True)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            super(Gate, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Gate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.append('instances')
            showIndent(outfile, level)
            outfile.write('instances = %d,\n' % (self.instances,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        super(Gate, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Gate, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instances', node)
        if value is not None and 'instances' not in already_processed:
            already_processed.append('instances')
            try:
                self.instances = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.validate_gateTypes(self.type_)    # validate type gateTypes
        super(Gate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'Gate')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
        super(Gate, self).buildChildren(child_, node, nodeName_, True)
# end class Gate


class IonChannel(Standalone):
    subclass = None
    superclass = Standalone
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, conductance=None, type_=None, species=None, gate=None, gateHH=None):
        super(IonChannel, self).__init__(id, neuroLexId, metaid, notes, annotation, )
        self.conductance = _cast(None, conductance)
        self.type_ = _cast(None, type_)
        self.species = _cast(None, species)
        if gate is None:
            self.gate = []
        else:
            self.gate = gate
        if gateHH is None:
            self.gateHH = []
        else:
            self.gateHH = gateHH
    def factory(*args_, **kwargs_):
        if IonChannel.subclass:
            return IonChannel.subclass(*args_, **kwargs_)
        else:
            return IonChannel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getGate(self): return self.gate
    def setGate(self, gate): self.gate = gate
    def addGate(self, value): self.gate.append(value)
    def insertGate(self, index, value): self.gate[index] = value
    def getGateHH(self): return self.gateHH
    def setGateHH(self, gateHH): self.gateHH = gateHH
    def addGateHH(self, value): self.gateHH.append(value)
    def insertGateHH(self, index, value): self.gateHH[index] = value
    def getConductance(self): return self.conductance
    def setConductance(self, conductance): self.conductance = conductance
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        pass
    def getType(self): return self.type_
    def setType(self, type_): self.type_ = type_
    def validate_channelTypes(self, value):
        # Validate type channelTypes, a restriction on xs:string.
        pass
    def getSpecies(self): return self.species
    def setSpecies(self, species): self.species = species
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='IonChannel', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IonChannel')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IonChannel'):
        super(IonChannel, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IonChannel')
        if self.conductance is not None and 'conductance' not in already_processed:
            already_processed.append('conductance')
            outfile.write(' conductance=%s' % (quote_attrib(self.conductance), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.species is not None and 'species' not in already_processed:
            already_processed.append('species')
            outfile.write(' species=%s' % (quote_attrib(self.species), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IonChannel', fromsubclass_=False):
        super(IonChannel, self).exportChildren(outfile, level, namespace_, name_, True)
        for gate_ in self.gate:
            gate_.export(outfile, level, namespace_, name_='gate')
        for gateHH_ in self.gateHH:
            gateHH_.export(outfile, level, namespace_, name_='gateHH')
    def hasContent_(self):
        if (
            self.gate or
            self.gateHH or
            super(IonChannel, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IonChannel'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.conductance is not None and 'conductance' not in already_processed:
            already_processed.append('conductance')
            showIndent(outfile, level)
            outfile.write('conductance = "%s",\n' % (self.conductance,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.species is not None and 'species' not in already_processed:
            already_processed.append('species')
            showIndent(outfile, level)
            outfile.write('species = "%s",\n' % (self.species,))
        super(IonChannel, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IonChannel, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('gate=[\n')
        level += 1
        for gate_ in self.gate:
            showIndent(outfile, level)
            outfile.write('model_.Gate(\n')
            gate_.exportLiteral(outfile, level, name_='Gate')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('gateHH=[\n')
        level += 1
        for gateHH_ in self.gateHH:
            showIndent(outfile, level)
            outfile.write('model_.Gate(\n')
            gateHH_.exportLiteral(outfile, level, name_='Gate')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('conductance', node)
        if value is not None and 'conductance' not in already_processed:
            already_processed.append('conductance')
            self.conductance = value
            self.validate_Nml2Quantity_conductance(self.conductance)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.validate_channelTypes(self.type_)    # validate type channelTypes
        value = find_attr_value_('species', node)
        if value is not None and 'species' not in already_processed:
            already_processed.append('species')
            self.species = value
            self.validate_NmlId(self.species)    # validate type NmlId
        super(IonChannel, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gate':
            obj_ = Gate.factory()
            obj_.build(child_)
            self.gate.append(obj_)
        elif nodeName_ == 'gateHH':
            obj_ = Gate.factory()
            obj_.build(child_)
            self.gateHH.append(obj_)
        super(IonChannel, self).buildChildren(child_, node, nodeName_, True)
# end class IonChannel


class neuroml(Standalone):
    subclass = None
    superclass = Standalone
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, include=None, extracellularProperties=None, intracellularProperties=None, morphology=None, ionChannel=None, expOneSynapse=None, expTwoSynapse=None, nmdaSynapse=None, stpSynapse=None, biophysicalProperties=None, cell=None, abstractCell=None, iafTauCell=None, iafCell=None, izhikevichCell=None, adExIaFCell=None, pulseGenerator=None, network=None):
        super(neuroml, self).__init__(id, neuroLexId, metaid, notes, annotation, )
        if include is None:
            self.include = []
        else:
            self.include = include
        if extracellularProperties is None:
            self.extracellularProperties = []
        else:
            self.extracellularProperties = extracellularProperties
        if intracellularProperties is None:
            self.intracellularProperties = []
        else:
            self.intracellularProperties = intracellularProperties
        if morphology is None:
            self.morphology = []
        else:
            self.morphology = morphology
        if ionChannel is None:
            self.ionChannel = []
        else:
            self.ionChannel = ionChannel
        if expOneSynapse is None:
            self.expOneSynapse = []
        else:
            self.expOneSynapse = expOneSynapse
        if expTwoSynapse is None:
            self.expTwoSynapse = []
        else:
            self.expTwoSynapse = expTwoSynapse
        if nmdaSynapse is None:
            self.nmdaSynapse = []
        else:
            self.nmdaSynapse = nmdaSynapse
        if stpSynapse is None:
            self.stpSynapse = []
        else:
            self.stpSynapse = stpSynapse
        if biophysicalProperties is None:
            self.biophysicalProperties = []
        else:
            self.biophysicalProperties = biophysicalProperties
        if cell is None:
            self.cell = []
        else:
            self.cell = cell
        if abstractCell is None:
            self.abstractCell = []
        else:
            self.abstractCell = abstractCell
        if iafTauCell is None:
            self.iafTauCell = []
        else:
            self.iafTauCell = iafTauCell
        if iafCell is None:
            self.iafCell = []
        else:
            self.iafCell = iafCell
        if izhikevichCell is None:
            self.izhikevichCell = []
        else:
            self.izhikevichCell = izhikevichCell
        if adExIaFCell is None:
            self.adExIaFCell = []
        else:
            self.adExIaFCell = adExIaFCell
        if pulseGenerator is None:
            self.pulseGenerator = []
        else:
            self.pulseGenerator = pulseGenerator
        if network is None:
            self.network = []
        else:
            self.network = network
    def factory(*args_, **kwargs_):
        if neuroml.subclass:
            return neuroml.subclass(*args_, **kwargs_)
        else:
            return neuroml(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getInclude(self): return self.include
    def setInclude(self, include): self.include = include
    def addInclude(self, value): self.include.append(value)
    def insertInclude(self, index, value): self.include[index] = value
    def getExtracellularProperties(self): return self.extracellularProperties
    def setExtracellularProperties(self, extracellularProperties): self.extracellularProperties = extracellularProperties
    def addExtracellularProperties(self, value): self.extracellularProperties.append(value)
    def insertExtracellularProperties(self, index, value): self.extracellularProperties[index] = value
    def getIntracellularProperties(self): return self.intracellularProperties
    def setIntracellularProperties(self, intracellularProperties): self.intracellularProperties = intracellularProperties
    def addIntracellularProperties(self, value): self.intracellularProperties.append(value)
    def insertIntracellularProperties(self, index, value): self.intracellularProperties[index] = value
    def getMorphology(self): return self.morphology
    def setMorphology(self, morphology): self.morphology = morphology
    def addMorphology(self, value): self.morphology.append(value)
    def insertMorphology(self, index, value): self.morphology[index] = value
    def getIonChannel(self): return self.ionChannel
    def setIonChannel(self, ionChannel): self.ionChannel = ionChannel
    def addIonChannel(self, value): self.ionChannel.append(value)
    def insertIonChannel(self, index, value): self.ionChannel[index] = value
    def getExpOneSynapse(self): return self.expOneSynapse
    def setExpOneSynapse(self, expOneSynapse): self.expOneSynapse = expOneSynapse
    def addExpOneSynapse(self, value): self.expOneSynapse.append(value)
    def insertExpOneSynapse(self, index, value): self.expOneSynapse[index] = value
    def getExpTwoSynapse(self): return self.expTwoSynapse
    def setExpTwoSynapse(self, expTwoSynapse): self.expTwoSynapse = expTwoSynapse
    def addExpTwoSynapse(self, value): self.expTwoSynapse.append(value)
    def insertExpTwoSynapse(self, index, value): self.expTwoSynapse[index] = value
    def getNmdaSynapse(self): return self.nmdaSynapse
    def setNmdaSynapse(self, nmdaSynapse): self.nmdaSynapse = nmdaSynapse
    def addNmdaSynapse(self, value): self.nmdaSynapse.append(value)
    def insertNmdaSynapse(self, index, value): self.nmdaSynapse[index] = value
    def getStpSynapse(self): return self.stpSynapse
    def setStpSynapse(self, stpSynapse): self.stpSynapse = stpSynapse
    def addStpSynapse(self, value): self.stpSynapse.append(value)
    def insertStpSynapse(self, index, value): self.stpSynapse[index] = value
    def getBiophysicalProperties(self): return self.biophysicalProperties
    def setBiophysicalProperties(self, biophysicalProperties): self.biophysicalProperties = biophysicalProperties
    def addBiophysicalProperties(self, value): self.biophysicalProperties.append(value)
    def insertBiophysicalProperties(self, index, value): self.biophysicalProperties[index] = value
    def getCell(self): return self.cell
    def setCell(self, cell): self.cell = cell
    def addCell(self, value): self.cell.append(value)
    def insertCell(self, index, value): self.cell[index] = value
    def getAbstractCell(self): return self.abstractCell
    def setAbstractCell(self, abstractCell): self.abstractCell = abstractCell
    def addAbstractCell(self, value): self.abstractCell.append(value)
    def insertAbstractCell(self, index, value): self.abstractCell[index] = value
    def getIafTauCell(self): return self.iafTauCell
    def setIafTauCell(self, iafTauCell): self.iafTauCell = iafTauCell
    def addIafTauCell(self, value): self.iafTauCell.append(value)
    def insertIafTauCell(self, index, value): self.iafTauCell[index] = value
    def getIafCell(self): return self.iafCell
    def setIafCell(self, iafCell): self.iafCell = iafCell
    def addIafCell(self, value): self.iafCell.append(value)
    def insertIafCell(self, index, value): self.iafCell[index] = value
    def getIzhikevichCell(self): return self.izhikevichCell
    def setIzhikevichCell(self, izhikevichCell): self.izhikevichCell = izhikevichCell
    def addIzhikevichCell(self, value): self.izhikevichCell.append(value)
    def insertIzhikevichCell(self, index, value): self.izhikevichCell[index] = value
    def getAdExIaFCell(self): return self.adExIaFCell
    def setAdExIaFCell(self, adExIaFCell): self.adExIaFCell = adExIaFCell
    def addAdExIaFCell(self, value): self.adExIaFCell.append(value)
    def insertAdExIaFCell(self, index, value): self.adExIaFCell[index] = value
    def getPulseGenerator(self): return self.pulseGenerator
    def setPulseGenerator(self, pulseGenerator): self.pulseGenerator = pulseGenerator
    def addPulseGenerator(self, value): self.pulseGenerator.append(value)
    def insertPulseGenerator(self, index, value): self.pulseGenerator[index] = value
    def getNetwork(self): return self.network
    def setNetwork(self, network): self.network = network
    def addNetwork(self, value): self.network.append(value)
    def insertNetwork(self, index, value): self.network[index] = value
    def export(self, outfile, level, namespace_='', name_='neuroml', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='neuroml')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='neuroml'):
        super(neuroml, self).exportAttributes(outfile, level, already_processed, namespace_, name_='neuroml')
    def exportChildren(self, outfile, level, namespace_='', name_='neuroml', fromsubclass_=False):
        super(neuroml, self).exportChildren(outfile, level, namespace_, name_, True)
        for include_ in self.include:
            include_.export(outfile, level, namespace_, name_='include')
        for extracellularProperties_ in self.extracellularProperties:
            extracellularProperties_.export(outfile, level, namespace_, name_='extracellularProperties')
        for intracellularProperties_ in self.intracellularProperties:
            intracellularProperties_.export(outfile, level, namespace_, name_='intracellularProperties')
        for morphology_ in self.morphology:
            morphology_.export(outfile, level, namespace_, name_='morphology')
        for ionChannel_ in self.ionChannel:
            ionChannel_.export(outfile, level, namespace_, name_='ionChannel')
        for expOneSynapse_ in self.expOneSynapse:
            expOneSynapse_.export(outfile, level, namespace_, name_='expOneSynapse')
        for expTwoSynapse_ in self.expTwoSynapse:
            expTwoSynapse_.export(outfile, level, namespace_, name_='expTwoSynapse')
        for nmdaSynapse_ in self.nmdaSynapse:
            nmdaSynapse_.export(outfile, level, namespace_, name_='nmdaSynapse')
        for stpSynapse_ in self.stpSynapse:
            stpSynapse_.export(outfile, level, namespace_, name_='stpSynapse')
        for biophysicalProperties_ in self.biophysicalProperties:
            biophysicalProperties_.export(outfile, level, namespace_, name_='biophysicalProperties')
        for cell_ in self.cell:
            cell_.export(outfile, level, namespace_, name_='cell')
        for abstractCell_ in self.abstractCell:
            abstractCell_.export(outfile, level, namespace_, name_='abstractCell')
        for iafTauCell_ in self.iafTauCell:
            iafTauCell_.export(outfile, level, namespace_, name_='iafTauCell')
        for iafCell_ in self.iafCell:
            iafCell_.export(outfile, level, namespace_, name_='iafCell')
        for izhikevichCell_ in self.izhikevichCell:
            izhikevichCell_.export(outfile, level, namespace_, name_='izhikevichCell')
        for adExIaFCell_ in self.adExIaFCell:
            adExIaFCell_.export(outfile, level, namespace_, name_='adExIaFCell')
        for pulseGenerator_ in self.pulseGenerator:
            pulseGenerator_.export(outfile, level, namespace_, name_='pulseGenerator')
        for network_ in self.network:
            network_.export(outfile, level, namespace_, name_='network')
    def hasContent_(self):
        if (
            self.include or
            self.extracellularProperties or
            self.intracellularProperties or
            self.morphology or
            self.ionChannel or
            self.expOneSynapse or
            self.expTwoSynapse or
            self.nmdaSynapse or
            self.stpSynapse or
            self.biophysicalProperties or
            self.cell or
            self.abstractCell or
            self.iafTauCell or
            self.iafCell or
            self.izhikevichCell or
            self.adExIaFCell or
            self.pulseGenerator or
            self.network or
            super(neuroml, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='neuroml'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(neuroml, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(neuroml, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('include=[\n')
        level += 1
        for include_ in self.include:
            showIndent(outfile, level)
            outfile.write('model_.includeType(\n')
            include_.exportLiteral(outfile, level, name_='includeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('extracellularProperties=[\n')
        level += 1
        for extracellularProperties_ in self.extracellularProperties:
            showIndent(outfile, level)
            outfile.write('model_.ExtracellularProperties(\n')
            extracellularProperties_.exportLiteral(outfile, level, name_='ExtracellularProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('intracellularProperties=[\n')
        level += 1
        for intracellularProperties_ in self.intracellularProperties:
            showIndent(outfile, level)
            outfile.write('model_.IntracellularProperties(\n')
            intracellularProperties_.exportLiteral(outfile, level, name_='IntracellularProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('morphology=[\n')
        level += 1
        for morphology_ in self.morphology:
            showIndent(outfile, level)
            outfile.write('model_.Morphology(\n')
            morphology_.exportLiteral(outfile, level, name_='Morphology')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ionChannel=[\n')
        level += 1
        for ionChannel_ in self.ionChannel:
            showIndent(outfile, level)
            outfile.write('model_.IonChannel(\n')
            ionChannel_.exportLiteral(outfile, level, name_='IonChannel')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('expOneSynapse=[\n')
        level += 1
        for expOneSynapse_ in self.expOneSynapse:
            showIndent(outfile, level)
            outfile.write('model_.ExpOneSynapse(\n')
            expOneSynapse_.exportLiteral(outfile, level, name_='ExpOneSynapse')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('expTwoSynapse=[\n')
        level += 1
        for expTwoSynapse_ in self.expTwoSynapse:
            showIndent(outfile, level)
            outfile.write('model_.ExpTwoSynapse(\n')
            expTwoSynapse_.exportLiteral(outfile, level, name_='ExpTwoSynapse')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('nmdaSynapse=[\n')
        level += 1
        for nmdaSynapse_ in self.nmdaSynapse:
            showIndent(outfile, level)
            outfile.write('model_.NmdaSynapse(\n')
            nmdaSynapse_.exportLiteral(outfile, level, name_='NmdaSynapse')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('stpSynapse=[\n')
        level += 1
        for stpSynapse_ in self.stpSynapse:
            showIndent(outfile, level)
            outfile.write('model_.StpSynapse(\n')
            stpSynapse_.exportLiteral(outfile, level, name_='StpSynapse')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('biophysicalProperties=[\n')
        level += 1
        for biophysicalProperties_ in self.biophysicalProperties:
            showIndent(outfile, level)
            outfile.write('model_.BiophysicalProperties(\n')
            biophysicalProperties_.exportLiteral(outfile, level, name_='BiophysicalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cell=[\n')
        level += 1
        for cell_ in self.cell:
            showIndent(outfile, level)
            outfile.write('model_.Cell(\n')
            cell_.exportLiteral(outfile, level, name_='Cell')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('abstractCell=[\n')
        level += 1
        for abstractCell_ in self.abstractCell:
            showIndent(outfile, level)
            outfile.write('model_.AbstractCell(\n')
            abstractCell_.exportLiteral(outfile, level, name_='AbstractCell')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('iafTauCell=[\n')
        level += 1
        for iafTauCell_ in self.iafTauCell:
            showIndent(outfile, level)
            outfile.write('model_.IaFTauCell(\n')
            iafTauCell_.exportLiteral(outfile, level, name_='IaFTauCell')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('iafCell=[\n')
        level += 1
        for iafCell_ in self.iafCell:
            showIndent(outfile, level)
            outfile.write('model_.IaFCell(\n')
            iafCell_.exportLiteral(outfile, level, name_='IaFCell')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('izhikevichCell=[\n')
        level += 1
        for izhikevichCell_ in self.izhikevichCell:
            showIndent(outfile, level)
            outfile.write('model_.IzhikevichCell(\n')
            izhikevichCell_.exportLiteral(outfile, level, name_='IzhikevichCell')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('adExIaFCell=[\n')
        level += 1
        for adExIaFCell_ in self.adExIaFCell:
            showIndent(outfile, level)
            outfile.write('model_.AdExIaFCell(\n')
            adExIaFCell_.exportLiteral(outfile, level, name_='AdExIaFCell')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pulseGenerator=[\n')
        level += 1
        for pulseGenerator_ in self.pulseGenerator:
            showIndent(outfile, level)
            outfile.write('model_.PulseGenerator(\n')
            pulseGenerator_.exportLiteral(outfile, level, name_='PulseGenerator')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('network=[\n')
        level += 1
        for network_ in self.network:
            showIndent(outfile, level)
            outfile.write('model_.Network(\n')
            network_.exportLiteral(outfile, level, name_='Network')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(neuroml, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'include':
            obj_ = includeType.factory()
            obj_.build(child_)
            self.include.append(obj_)
        elif nodeName_ == 'extracellularProperties':
            obj_ = ExtracellularProperties.factory()
            obj_.build(child_)
            self.extracellularProperties.append(obj_)
        elif nodeName_ == 'intracellularProperties':
            obj_ = IntracellularProperties.factory()
            obj_.build(child_)
            self.intracellularProperties.append(obj_)
        elif nodeName_ == 'morphology':
            obj_ = Morphology.factory()
            obj_.build(child_)
            self.morphology.append(obj_)
        elif nodeName_ == 'ionChannel':
            obj_ = IonChannel.factory()
            obj_.build(child_)
            self.ionChannel.append(obj_)
        elif nodeName_ == 'expOneSynapse':
            obj_ = ExpOneSynapse.factory()
            obj_.build(child_)
            self.expOneSynapse.append(obj_)
        elif nodeName_ == 'expTwoSynapse':
            class_obj_ = self.get_class_obj_(child_, ExpTwoSynapse)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.expTwoSynapse.append(obj_)
        elif nodeName_ == 'nmdaSynapse':
            obj_ = NmdaSynapse.factory()
            obj_.build(child_)
            self.nmdaSynapse.append(obj_)
        elif nodeName_ == 'stpSynapse':
            obj_ = StpSynapse.factory()
            obj_.build(child_)
            self.stpSynapse.append(obj_)
        elif nodeName_ == 'biophysicalProperties':
            obj_ = BiophysicalProperties.factory()
            obj_.build(child_)
            self.biophysicalProperties.append(obj_)
        elif nodeName_ == 'cell':
            obj_ = Cell.factory()
            obj_.build(child_)
            self.cell.append(obj_)
        elif nodeName_ == 'abstractCell':
            class_obj_ = self.get_class_obj_(child_, AbstractCell)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.abstractCell.append(obj_)
        elif nodeName_ == 'iafTauCell':
            obj_ = IaFTauCell.factory()
            obj_.build(child_)
            self.iafTauCell.append(obj_)
        elif nodeName_ == 'iafCell':
            obj_ = IaFCell.factory()
            obj_.build(child_)
            self.iafCell.append(obj_)
        elif nodeName_ == 'izhikevichCell':
            obj_ = IzhikevichCell.factory()
            obj_.build(child_)
            self.izhikevichCell.append(obj_)
        elif nodeName_ == 'adExIaFCell':
            obj_ = AdExIaFCell.factory()
            obj_.build(child_)
            self.adExIaFCell.append(obj_)
        elif nodeName_ == 'pulseGenerator':
            obj_ = PulseGenerator.factory()
            obj_.build(child_)
            self.pulseGenerator.append(obj_)
        elif nodeName_ == 'network':
            obj_ = Network.factory()
            obj_.build(child_)
            self.network.append(obj_)
        super(neuroml, self).buildChildren(child_, node, nodeName_, True)
# end class neuroml


class Cell(AbstractCell):
    """Should only be used if morphology element is outside the cell. This
    points to the id of the morphologyShould only be used if
    biophysicalProperties element is outside the cell. This points
    to the id of the biophysicalProperties"""
    subclass = None
    superclass = AbstractCell
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, biophysicalProperties_attr=None, morphology_attr=None, morphology=None, biophysicalProperties=None):
        super(Cell, self).__init__(id, neuroLexId, metaid, notes, annotation, )
        self.biophysicalProperties_attr = _cast(None, biophysicalProperties_attr)
        self.morphology_attr = _cast(None, morphology_attr)
        self.morphology = morphology
        self.biophysicalProperties = biophysicalProperties
    def factory(*args_, **kwargs_):
        if Cell.subclass:
            return Cell.subclass(*args_, **kwargs_)
        else:
            return Cell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getMorphology(self): return self.morphology
    def setMorphology(self, morphology): self.morphology = morphology
    def getBiophysicalProperties(self): return self.biophysicalProperties
    def setBiophysicalProperties(self, biophysicalProperties): self.biophysicalProperties = biophysicalProperties
    def getBiophysicalProperties_attr(self): return self.biophysicalProperties_attr
    def setBiophysicalProperties_attr(self, biophysicalProperties_attr): self.biophysicalProperties_attr = biophysicalProperties_attr
    def getMorphology_attr(self): return self.morphology_attr
    def setMorphology_attr(self, morphology_attr): self.morphology_attr = morphology_attr
    def export(self, outfile, level, namespace_='', name_='Cell', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cell')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cell'):
        super(Cell, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Cell')
        if self.biophysicalProperties_attr is not None and 'biophysicalProperties_attr' not in already_processed:
            already_processed.append('biophysicalProperties_attr')
            outfile.write(' biophysicalProperties_attr=%s' % (self.gds_format_string(quote_attrib(self.biophysicalProperties_attr).encode(ExternalEncoding), input_name='biophysicalProperties_attr'), ))
        if self.morphology_attr is not None and 'morphology_attr' not in already_processed:
            already_processed.append('morphology_attr')
            outfile.write(' morphology_attr=%s' % (self.gds_format_string(quote_attrib(self.morphology_attr).encode(ExternalEncoding), input_name='morphology_attr'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Cell', fromsubclass_=False):
        super(Cell, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.morphology is not None:
            self.morphology.export(outfile, level, namespace_, name_='morphology')
        if self.biophysicalProperties is not None:
            self.biophysicalProperties.export(outfile, level, namespace_, name_='biophysicalProperties')
    def hasContent_(self):
        if (
            self.morphology is not None or
            self.biophysicalProperties is not None or
            super(Cell, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Cell'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.biophysicalProperties_attr is not None and 'biophysicalProperties_attr' not in already_processed:
            already_processed.append('biophysicalProperties_attr')
            showIndent(outfile, level)
            outfile.write('biophysicalProperties_attr = "%s",\n' % (self.biophysicalProperties_attr,))
        if self.morphology_attr is not None and 'morphology_attr' not in already_processed:
            already_processed.append('morphology_attr')
            showIndent(outfile, level)
            outfile.write('morphology_attr = "%s",\n' % (self.morphology_attr,))
        super(Cell, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Cell, self).exportLiteralChildren(outfile, level, name_)
        if self.morphology is not None:
            showIndent(outfile, level)
            outfile.write('morphology=model_.Morphology(\n')
            self.morphology.exportLiteral(outfile, level, name_='morphology')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.biophysicalProperties is not None:
            showIndent(outfile, level)
            outfile.write('biophysicalProperties=model_.BiophysicalProperties(\n')
            self.biophysicalProperties.exportLiteral(outfile, level, name_='biophysicalProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('biophysicalProperties_attr', node)
        if value is not None and 'biophysicalProperties_attr' not in already_processed:
            already_processed.append('biophysicalProperties_attr')
            self.biophysicalProperties_attr = value
        value = find_attr_value_('morphology_attr', node)
        if value is not None and 'morphology_attr' not in already_processed:
            already_processed.append('morphology_attr')
            self.morphology_attr = value
        super(Cell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'morphology':
            obj_ = Morphology.factory()
            obj_.build(child_)
            self.setMorphology(obj_)
        elif nodeName_ == 'biophysicalProperties':
            obj_ = BiophysicalProperties.factory()
            obj_.build(child_)
            self.setBiophysicalProperties(obj_)
        super(Cell, self).buildChildren(child_, node, nodeName_, True)
# end class Cell


class AdExIaFCell(AbstractCell):
    subclass = None
    superclass = AbstractCell
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, reset=None, EL=None, C=None, b=None, Idel=None, Idur=None, VT=None, delT=None, a=None, thresh=None, gL=None, Iamp=None, tauw=None):
        super(AdExIaFCell, self).__init__(id, neuroLexId, metaid, notes, annotation, )
        self.reset = _cast(None, reset)
        self.EL = _cast(None, EL)
        self.C = _cast(None, C)
        self.b = _cast(None, b)
        self.Idel = _cast(None, Idel)
        self.Idur = _cast(None, Idur)
        self.VT = _cast(None, VT)
        self.delT = _cast(None, delT)
        self.a = _cast(None, a)
        self.thresh = _cast(None, thresh)
        self.gL = _cast(None, gL)
        self.Iamp = _cast(None, Iamp)
        self.tauw = _cast(None, tauw)
        pass
    def factory(*args_, **kwargs_):
        if AdExIaFCell.subclass:
            return AdExIaFCell.subclass(*args_, **kwargs_)
        else:
            return AdExIaFCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getReset(self): return self.reset
    def setReset(self, reset): self.reset = reset
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        pass
    def getEL(self): return self.EL
    def setEL(self, EL): self.EL = EL
    def getC(self): return self.C
    def setC(self, C): self.C = C
    def validate_Nml2Quantity_capacitance(self, value):
        # Validate type Nml2Quantity_capacitance, a restriction on xs:string.
        pass
    def getB(self): return self.b
    def setB(self, b): self.b = b
    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        pass
    def getIdel(self): return self.Idel
    def setIdel(self, Idel): self.Idel = Idel
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        pass
    def getIdur(self): return self.Idur
    def setIdur(self, Idur): self.Idur = Idur
    def getVT(self): return self.VT
    def setVT(self, VT): self.VT = VT
    def getDelT(self): return self.delT
    def setDelT(self, delT): self.delT = delT
    def getA(self): return self.a
    def setA(self, a): self.a = a
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        pass
    def getThresh(self): return self.thresh
    def setThresh(self, thresh): self.thresh = thresh
    def getGL(self): return self.gL
    def setGL(self, gL): self.gL = gL
    def getIamp(self): return self.Iamp
    def setIamp(self, Iamp): self.Iamp = Iamp
    def getTauw(self): return self.tauw
    def setTauw(self, tauw): self.tauw = tauw
    def export(self, outfile, level, namespace_='', name_='AdExIaFCell', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdExIaFCell')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdExIaFCell'):
        super(AdExIaFCell, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AdExIaFCell')
        if self.reset is not None and 'reset' not in already_processed:
            already_processed.append('reset')
            outfile.write(' reset=%s' % (quote_attrib(self.reset), ))
        if self.EL is not None and 'EL' not in already_processed:
            already_processed.append('EL')
            outfile.write(' EL=%s' % (quote_attrib(self.EL), ))
        if self.C is not None and 'C' not in already_processed:
            already_processed.append('C')
            outfile.write(' C=%s' % (quote_attrib(self.C), ))
        if self.b is not None and 'b' not in already_processed:
            already_processed.append('b')
            outfile.write(' b=%s' % (quote_attrib(self.b), ))
        if self.Idel is not None and 'Idel' not in already_processed:
            already_processed.append('Idel')
            outfile.write(' Idel=%s' % (quote_attrib(self.Idel), ))
        if self.Idur is not None and 'Idur' not in already_processed:
            already_processed.append('Idur')
            outfile.write(' Idur=%s' % (quote_attrib(self.Idur), ))
        if self.VT is not None and 'VT' not in already_processed:
            already_processed.append('VT')
            outfile.write(' VT=%s' % (quote_attrib(self.VT), ))
        if self.delT is not None and 'delT' not in already_processed:
            already_processed.append('delT')
            outfile.write(' delT=%s' % (quote_attrib(self.delT), ))
        if self.a is not None and 'a' not in already_processed:
            already_processed.append('a')
            outfile.write(' a=%s' % (quote_attrib(self.a), ))
        if self.thresh is not None and 'thresh' not in already_processed:
            already_processed.append('thresh')
            outfile.write(' thresh=%s' % (quote_attrib(self.thresh), ))
        if self.gL is not None and 'gL' not in already_processed:
            already_processed.append('gL')
            outfile.write(' gL=%s' % (quote_attrib(self.gL), ))
        if self.Iamp is not None and 'Iamp' not in already_processed:
            already_processed.append('Iamp')
            outfile.write(' Iamp=%s' % (quote_attrib(self.Iamp), ))
        if self.tauw is not None and 'tauw' not in already_processed:
            already_processed.append('tauw')
            outfile.write(' tauw=%s' % (quote_attrib(self.tauw), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdExIaFCell', fromsubclass_=False):
        super(AdExIaFCell, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AdExIaFCell, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AdExIaFCell'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.reset is not None and 'reset' not in already_processed:
            already_processed.append('reset')
            showIndent(outfile, level)
            outfile.write('reset = "%s",\n' % (self.reset,))
        if self.EL is not None and 'EL' not in already_processed:
            already_processed.append('EL')
            showIndent(outfile, level)
            outfile.write('EL = "%s",\n' % (self.EL,))
        if self.C is not None and 'C' not in already_processed:
            already_processed.append('C')
            showIndent(outfile, level)
            outfile.write('C = "%s",\n' % (self.C,))
        if self.b is not None and 'b' not in already_processed:
            already_processed.append('b')
            showIndent(outfile, level)
            outfile.write('b = "%s",\n' % (self.b,))
        if self.Idel is not None and 'Idel' not in already_processed:
            already_processed.append('Idel')
            showIndent(outfile, level)
            outfile.write('Idel = "%s",\n' % (self.Idel,))
        if self.Idur is not None and 'Idur' not in already_processed:
            already_processed.append('Idur')
            showIndent(outfile, level)
            outfile.write('Idur = "%s",\n' % (self.Idur,))
        if self.VT is not None and 'VT' not in already_processed:
            already_processed.append('VT')
            showIndent(outfile, level)
            outfile.write('VT = "%s",\n' % (self.VT,))
        if self.delT is not None and 'delT' not in already_processed:
            already_processed.append('delT')
            showIndent(outfile, level)
            outfile.write('delT = "%s",\n' % (self.delT,))
        if self.a is not None and 'a' not in already_processed:
            already_processed.append('a')
            showIndent(outfile, level)
            outfile.write('a = "%s",\n' % (self.a,))
        if self.thresh is not None and 'thresh' not in already_processed:
            already_processed.append('thresh')
            showIndent(outfile, level)
            outfile.write('thresh = "%s",\n' % (self.thresh,))
        if self.gL is not None and 'gL' not in already_processed:
            already_processed.append('gL')
            showIndent(outfile, level)
            outfile.write('gL = "%s",\n' % (self.gL,))
        if self.Iamp is not None and 'Iamp' not in already_processed:
            already_processed.append('Iamp')
            showIndent(outfile, level)
            outfile.write('Iamp = "%s",\n' % (self.Iamp,))
        if self.tauw is not None and 'tauw' not in already_processed:
            already_processed.append('tauw')
            showIndent(outfile, level)
            outfile.write('tauw = "%s",\n' % (self.tauw,))
        super(AdExIaFCell, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AdExIaFCell, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reset', node)
        if value is not None and 'reset' not in already_processed:
            already_processed.append('reset')
            self.reset = value
            self.validate_Nml2Quantity_voltage(self.reset)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('EL', node)
        if value is not None and 'EL' not in already_processed:
            already_processed.append('EL')
            self.EL = value
            self.validate_Nml2Quantity_voltage(self.EL)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('C', node)
        if value is not None and 'C' not in already_processed:
            already_processed.append('C')
            self.C = value
            self.validate_Nml2Quantity_capacitance(self.C)    # validate type Nml2Quantity_capacitance
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.append('b')
            self.b = value
            self.validate_Nml2Quantity_current(self.b)    # validate type Nml2Quantity_current
        value = find_attr_value_('Idel', node)
        if value is not None and 'Idel' not in already_processed:
            already_processed.append('Idel')
            self.Idel = value
            self.validate_Nml2Quantity_time(self.Idel)    # validate type Nml2Quantity_time
        value = find_attr_value_('Idur', node)
        if value is not None and 'Idur' not in already_processed:
            already_processed.append('Idur')
            self.Idur = value
            self.validate_Nml2Quantity_time(self.Idur)    # validate type Nml2Quantity_time
        value = find_attr_value_('VT', node)
        if value is not None and 'VT' not in already_processed:
            already_processed.append('VT')
            self.VT = value
            self.validate_Nml2Quantity_voltage(self.VT)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('delT', node)
        if value is not None and 'delT' not in already_processed:
            already_processed.append('delT')
            self.delT = value
            self.validate_Nml2Quantity_voltage(self.delT)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.append('a')
            self.a = value
            self.validate_Nml2Quantity_conductance(self.a)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('thresh', node)
        if value is not None and 'thresh' not in already_processed:
            already_processed.append('thresh')
            self.thresh = value
            self.validate_Nml2Quantity_voltage(self.thresh)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('gL', node)
        if value is not None and 'gL' not in already_processed:
            already_processed.append('gL')
            self.gL = value
            self.validate_Nml2Quantity_conductance(self.gL)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('Iamp', node)
        if value is not None and 'Iamp' not in already_processed:
            already_processed.append('Iamp')
            self.Iamp = value
            self.validate_Nml2Quantity_current(self.Iamp)    # validate type Nml2Quantity_current
        value = find_attr_value_('tauw', node)
        if value is not None and 'tauw' not in already_processed:
            already_processed.append('tauw')
            self.tauw = value
            self.validate_Nml2Quantity_time(self.tauw)    # validate type Nml2Quantity_time
        super(AdExIaFCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AdExIaFCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AdExIaFCell


class IzhikevichCell(AbstractCell):
    subclass = None
    superclass = AbstractCell
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, a=None, Idel=None, c=None, b=None, d=None, Idur=None, v0=None, thresh=None, Iamp=None):
        super(IzhikevichCell, self).__init__(id, neuroLexId, metaid, notes, annotation, )
        self.a = _cast(None, a)
        self.Idel = _cast(None, Idel)
        self.c = _cast(None, c)
        self.b = _cast(None, b)
        self.d = _cast(None, d)
        self.Idur = _cast(None, Idur)
        self.v0 = _cast(None, v0)
        self.thresh = _cast(None, thresh)
        self.Iamp = _cast(None, Iamp)
        pass
    def factory(*args_, **kwargs_):
        if IzhikevichCell.subclass:
            return IzhikevichCell.subclass(*args_, **kwargs_)
        else:
            return IzhikevichCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getA(self): return self.a
    def setA(self, a): self.a = a
    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        pass
    def getIdel(self): return self.Idel
    def setIdel(self, Idel): self.Idel = Idel
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        pass
    def getC(self): return self.c
    def setC(self, c): self.c = c
    def getB(self): return self.b
    def setB(self, b): self.b = b
    def getD(self): return self.d
    def setD(self, d): self.d = d
    def getIdur(self): return self.Idur
    def setIdur(self, Idur): self.Idur = Idur
    def getV0(self): return self.v0
    def setV0(self, v0): self.v0 = v0
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        pass
    def getThresh(self): return self.thresh
    def setThresh(self, thresh): self.thresh = thresh
    def getIamp(self): return self.Iamp
    def setIamp(self, Iamp): self.Iamp = Iamp
    def export(self, outfile, level, namespace_='', name_='IzhikevichCell', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IzhikevichCell')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IzhikevichCell'):
        super(IzhikevichCell, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IzhikevichCell')
        if self.a is not None and 'a' not in already_processed:
            already_processed.append('a')
            outfile.write(' a=%s' % (quote_attrib(self.a), ))
        if self.Idel is not None and 'Idel' not in already_processed:
            already_processed.append('Idel')
            outfile.write(' Idel=%s' % (quote_attrib(self.Idel), ))
        if self.c is not None and 'c' not in already_processed:
            already_processed.append('c')
            outfile.write(' c=%s' % (quote_attrib(self.c), ))
        if self.b is not None and 'b' not in already_processed:
            already_processed.append('b')
            outfile.write(' b=%s' % (quote_attrib(self.b), ))
        if self.d is not None and 'd' not in already_processed:
            already_processed.append('d')
            outfile.write(' d=%s' % (quote_attrib(self.d), ))
        if self.Idur is not None and 'Idur' not in already_processed:
            already_processed.append('Idur')
            outfile.write(' Idur=%s' % (quote_attrib(self.Idur), ))
        if self.v0 is not None and 'v0' not in already_processed:
            already_processed.append('v0')
            outfile.write(' v0=%s' % (quote_attrib(self.v0), ))
        if self.thresh is not None and 'thresh' not in already_processed:
            already_processed.append('thresh')
            outfile.write(' thresh=%s' % (quote_attrib(self.thresh), ))
        if self.Iamp is not None and 'Iamp' not in already_processed:
            already_processed.append('Iamp')
            outfile.write(' Iamp=%s' % (quote_attrib(self.Iamp), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IzhikevichCell', fromsubclass_=False):
        super(IzhikevichCell, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(IzhikevichCell, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IzhikevichCell'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.a is not None and 'a' not in already_processed:
            already_processed.append('a')
            showIndent(outfile, level)
            outfile.write('a = "%s",\n' % (self.a,))
        if self.Idel is not None and 'Idel' not in already_processed:
            already_processed.append('Idel')
            showIndent(outfile, level)
            outfile.write('Idel = "%s",\n' % (self.Idel,))
        if self.c is not None and 'c' not in already_processed:
            already_processed.append('c')
            showIndent(outfile, level)
            outfile.write('c = "%s",\n' % (self.c,))
        if self.b is not None and 'b' not in already_processed:
            already_processed.append('b')
            showIndent(outfile, level)
            outfile.write('b = "%s",\n' % (self.b,))
        if self.d is not None and 'd' not in already_processed:
            already_processed.append('d')
            showIndent(outfile, level)
            outfile.write('d = "%s",\n' % (self.d,))
        if self.Idur is not None and 'Idur' not in already_processed:
            already_processed.append('Idur')
            showIndent(outfile, level)
            outfile.write('Idur = "%s",\n' % (self.Idur,))
        if self.v0 is not None and 'v0' not in already_processed:
            already_processed.append('v0')
            showIndent(outfile, level)
            outfile.write('v0 = "%s",\n' % (self.v0,))
        if self.thresh is not None and 'thresh' not in already_processed:
            already_processed.append('thresh')
            showIndent(outfile, level)
            outfile.write('thresh = "%s",\n' % (self.thresh,))
        if self.Iamp is not None and 'Iamp' not in already_processed:
            already_processed.append('Iamp')
            showIndent(outfile, level)
            outfile.write('Iamp = "%s",\n' % (self.Iamp,))
        super(IzhikevichCell, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IzhikevichCell, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.append('a')
            self.a = value
            self.validate_Nml2Quantity_none(self.a)    # validate type Nml2Quantity_none
        value = find_attr_value_('Idel', node)
        if value is not None and 'Idel' not in already_processed:
            already_processed.append('Idel')
            self.Idel = value
            self.validate_Nml2Quantity_time(self.Idel)    # validate type Nml2Quantity_time
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.append('c')
            self.c = value
            self.validate_Nml2Quantity_none(self.c)    # validate type Nml2Quantity_none
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.append('b')
            self.b = value
            self.validate_Nml2Quantity_none(self.b)    # validate type Nml2Quantity_none
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.append('d')
            self.d = value
            self.validate_Nml2Quantity_none(self.d)    # validate type Nml2Quantity_none
        value = find_attr_value_('Idur', node)
        if value is not None and 'Idur' not in already_processed:
            already_processed.append('Idur')
            self.Idur = value
            self.validate_Nml2Quantity_time(self.Idur)    # validate type Nml2Quantity_time
        value = find_attr_value_('v0', node)
        if value is not None and 'v0' not in already_processed:
            already_processed.append('v0')
            self.v0 = value
            self.validate_Nml2Quantity_voltage(self.v0)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('thresh', node)
        if value is not None and 'thresh' not in already_processed:
            already_processed.append('thresh')
            self.thresh = value
            self.validate_Nml2Quantity_voltage(self.thresh)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('Iamp', node)
        if value is not None and 'Iamp' not in already_processed:
            already_processed.append('Iamp')
            self.Iamp = value
            self.validate_Nml2Quantity_none(self.Iamp)    # validate type Nml2Quantity_none
        super(IzhikevichCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IzhikevichCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IzhikevichCell


class IaFCell(AbstractCell):
    subclass = None
    superclass = AbstractCell
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, reset=None, C=None, thresh=None, leakConductance=None, leakReversal=None):
        super(IaFCell, self).__init__(id, neuroLexId, metaid, notes, annotation, )
        self.reset = _cast(None, reset)
        self.C = _cast(None, C)
        self.thresh = _cast(None, thresh)
        self.leakConductance = _cast(None, leakConductance)
        self.leakReversal = _cast(None, leakReversal)
        pass
    def factory(*args_, **kwargs_):
        if IaFCell.subclass:
            return IaFCell.subclass(*args_, **kwargs_)
        else:
            return IaFCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getReset(self): return self.reset
    def setReset(self, reset): self.reset = reset
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        pass
    def getC(self): return self.C
    def setC(self, C): self.C = C
    def validate_Nml2Quantity_capacitance(self, value):
        # Validate type Nml2Quantity_capacitance, a restriction on xs:string.
        pass
    def getThresh(self): return self.thresh
    def setThresh(self, thresh): self.thresh = thresh
    def getLeakConductance(self): return self.leakConductance
    def setLeakConductance(self, leakConductance): self.leakConductance = leakConductance
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        pass
    def getLeakReversal(self): return self.leakReversal
    def setLeakReversal(self, leakReversal): self.leakReversal = leakReversal
    def export(self, outfile, level, namespace_='', name_='IaFCell', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IaFCell')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IaFCell'):
        super(IaFCell, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IaFCell')
        if self.reset is not None and 'reset' not in already_processed:
            already_processed.append('reset')
            outfile.write(' reset=%s' % (quote_attrib(self.reset), ))
        if self.C is not None and 'C' not in already_processed:
            already_processed.append('C')
            outfile.write(' C=%s' % (quote_attrib(self.C), ))
        if self.thresh is not None and 'thresh' not in already_processed:
            already_processed.append('thresh')
            outfile.write(' thresh=%s' % (quote_attrib(self.thresh), ))
        if self.leakConductance is not None and 'leakConductance' not in already_processed:
            already_processed.append('leakConductance')
            outfile.write(' leakConductance=%s' % (quote_attrib(self.leakConductance), ))
        if self.leakReversal is not None and 'leakReversal' not in already_processed:
            already_processed.append('leakReversal')
            outfile.write(' leakReversal=%s' % (quote_attrib(self.leakReversal), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IaFCell', fromsubclass_=False):
        super(IaFCell, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(IaFCell, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IaFCell'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.reset is not None and 'reset' not in already_processed:
            already_processed.append('reset')
            showIndent(outfile, level)
            outfile.write('reset = "%s",\n' % (self.reset,))
        if self.C is not None and 'C' not in already_processed:
            already_processed.append('C')
            showIndent(outfile, level)
            outfile.write('C = "%s",\n' % (self.C,))
        if self.thresh is not None and 'thresh' not in already_processed:
            already_processed.append('thresh')
            showIndent(outfile, level)
            outfile.write('thresh = "%s",\n' % (self.thresh,))
        if self.leakConductance is not None and 'leakConductance' not in already_processed:
            already_processed.append('leakConductance')
            showIndent(outfile, level)
            outfile.write('leakConductance = "%s",\n' % (self.leakConductance,))
        if self.leakReversal is not None and 'leakReversal' not in already_processed:
            already_processed.append('leakReversal')
            showIndent(outfile, level)
            outfile.write('leakReversal = "%s",\n' % (self.leakReversal,))
        super(IaFCell, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IaFCell, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reset', node)
        if value is not None and 'reset' not in already_processed:
            already_processed.append('reset')
            self.reset = value
            self.validate_Nml2Quantity_voltage(self.reset)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('C', node)
        if value is not None and 'C' not in already_processed:
            already_processed.append('C')
            self.C = value
            self.validate_Nml2Quantity_capacitance(self.C)    # validate type Nml2Quantity_capacitance
        value = find_attr_value_('thresh', node)
        if value is not None and 'thresh' not in already_processed:
            already_processed.append('thresh')
            self.thresh = value
            self.validate_Nml2Quantity_voltage(self.thresh)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('leakConductance', node)
        if value is not None and 'leakConductance' not in already_processed:
            already_processed.append('leakConductance')
            self.leakConductance = value
            self.validate_Nml2Quantity_conductance(self.leakConductance)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('leakReversal', node)
        if value is not None and 'leakReversal' not in already_processed:
            already_processed.append('leakReversal')
            self.leakReversal = value
            self.validate_Nml2Quantity_voltage(self.leakReversal)    # validate type Nml2Quantity_voltage
        super(IaFCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IaFCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IaFCell


class IaFTauCell(AbstractCell):
    subclass = None
    superclass = AbstractCell
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, reset=None, tau=None, thresh=None, leakReversal=None):
        super(IaFTauCell, self).__init__(id, neuroLexId, metaid, notes, annotation, )
        self.reset = _cast(None, reset)
        self.tau = _cast(None, tau)
        self.thresh = _cast(None, thresh)
        self.leakReversal = _cast(None, leakReversal)
        pass
    def factory(*args_, **kwargs_):
        if IaFTauCell.subclass:
            return IaFTauCell.subclass(*args_, **kwargs_)
        else:
            return IaFTauCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getReset(self): return self.reset
    def setReset(self, reset): self.reset = reset
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        pass
    def getTau(self): return self.tau
    def setTau(self, tau): self.tau = tau
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        pass
    def getThresh(self): return self.thresh
    def setThresh(self, thresh): self.thresh = thresh
    def getLeakReversal(self): return self.leakReversal
    def setLeakReversal(self, leakReversal): self.leakReversal = leakReversal
    def export(self, outfile, level, namespace_='', name_='IaFTauCell', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IaFTauCell')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IaFTauCell'):
        super(IaFTauCell, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IaFTauCell')
        if self.reset is not None and 'reset' not in already_processed:
            already_processed.append('reset')
            outfile.write(' reset=%s' % (quote_attrib(self.reset), ))
        if self.tau is not None and 'tau' not in already_processed:
            already_processed.append('tau')
            outfile.write(' tau=%s' % (quote_attrib(self.tau), ))
        if self.thresh is not None and 'thresh' not in already_processed:
            already_processed.append('thresh')
            outfile.write(' thresh=%s' % (quote_attrib(self.thresh), ))
        if self.leakReversal is not None and 'leakReversal' not in already_processed:
            already_processed.append('leakReversal')
            outfile.write(' leakReversal=%s' % (quote_attrib(self.leakReversal), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IaFTauCell', fromsubclass_=False):
        super(IaFTauCell, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(IaFTauCell, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IaFTauCell'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.reset is not None and 'reset' not in already_processed:
            already_processed.append('reset')
            showIndent(outfile, level)
            outfile.write('reset = "%s",\n' % (self.reset,))
        if self.tau is not None and 'tau' not in already_processed:
            already_processed.append('tau')
            showIndent(outfile, level)
            outfile.write('tau = "%s",\n' % (self.tau,))
        if self.thresh is not None and 'thresh' not in already_processed:
            already_processed.append('thresh')
            showIndent(outfile, level)
            outfile.write('thresh = "%s",\n' % (self.thresh,))
        if self.leakReversal is not None and 'leakReversal' not in already_processed:
            already_processed.append('leakReversal')
            showIndent(outfile, level)
            outfile.write('leakReversal = "%s",\n' % (self.leakReversal,))
        super(IaFTauCell, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IaFTauCell, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reset', node)
        if value is not None and 'reset' not in already_processed:
            already_processed.append('reset')
            self.reset = value
            self.validate_Nml2Quantity_voltage(self.reset)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('tau', node)
        if value is not None and 'tau' not in already_processed:
            already_processed.append('tau')
            self.tau = value
            self.validate_Nml2Quantity_time(self.tau)    # validate type Nml2Quantity_time
        value = find_attr_value_('thresh', node)
        if value is not None and 'thresh' not in already_processed:
            already_processed.append('thresh')
            self.thresh = value
            self.validate_Nml2Quantity_voltage(self.thresh)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('leakReversal', node)
        if value is not None and 'leakReversal' not in already_processed:
            already_processed.append('leakReversal')
            self.leakReversal = value
            self.validate_Nml2Quantity_voltage(self.leakReversal)    # validate type Nml2Quantity_voltage
        super(IaFTauCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IaFTauCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IaFTauCell


class ExpTwoSynapse(ConductanceBasedSynapse):
    subclass = None
    superclass = ConductanceBasedSynapse
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, erev=None, gbase=None, tauDecay=None, tauRise=None, extensiontype_=None):
        super(ExpTwoSynapse, self).__init__(id, neuroLexId, metaid, notes, annotation, erev, gbase, extensiontype_, )
        self.tauDecay = _cast(None, tauDecay)
        self.tauRise = _cast(None, tauRise)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ExpTwoSynapse.subclass:
            return ExpTwoSynapse.subclass(*args_, **kwargs_)
        else:
            return ExpTwoSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTauDecay(self): return self.tauDecay
    def setTauDecay(self, tauDecay): self.tauDecay = tauDecay
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        pass
    def getTauRise(self): return self.tauRise
    def setTauRise(self, tauRise): self.tauRise = tauRise
    def getExtensiontype_(self): return self.extensiontype_
    def setExtensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ExpTwoSynapse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExpTwoSynapse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExpTwoSynapse'):
        super(ExpTwoSynapse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExpTwoSynapse')
        if self.tauDecay is not None and 'tauDecay' not in already_processed:
            already_processed.append('tauDecay')
            outfile.write(' tauDecay=%s' % (quote_attrib(self.tauDecay), ))
        if self.tauRise is not None and 'tauRise' not in already_processed:
            already_processed.append('tauRise')
            outfile.write(' tauRise=%s' % (quote_attrib(self.tauRise), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ExpTwoSynapse', fromsubclass_=False):
        super(ExpTwoSynapse, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(ExpTwoSynapse, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExpTwoSynapse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.tauDecay is not None and 'tauDecay' not in already_processed:
            already_processed.append('tauDecay')
            showIndent(outfile, level)
            outfile.write('tauDecay = "%s",\n' % (self.tauDecay,))
        if self.tauRise is not None and 'tauRise' not in already_processed:
            already_processed.append('tauRise')
            showIndent(outfile, level)
            outfile.write('tauRise = "%s",\n' % (self.tauRise,))
        super(ExpTwoSynapse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ExpTwoSynapse, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tauDecay', node)
        if value is not None and 'tauDecay' not in already_processed:
            already_processed.append('tauDecay')
            self.tauDecay = value
            self.validate_Nml2Quantity_time(self.tauDecay)    # validate type Nml2Quantity_time
        value = find_attr_value_('tauRise', node)
        if value is not None and 'tauRise' not in already_processed:
            already_processed.append('tauRise')
            self.tauRise = value
            self.validate_Nml2Quantity_time(self.tauRise)    # validate type Nml2Quantity_time
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(ExpTwoSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ExpTwoSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExpTwoSynapse


class ExpOneSynapse(ConductanceBasedSynapse):
    subclass = None
    superclass = ConductanceBasedSynapse
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, erev=None, gbase=None, tauDecay=None):
        super(ExpOneSynapse, self).__init__(id, neuroLexId, metaid, notes, annotation, erev, gbase, )
        self.tauDecay = _cast(None, tauDecay)
        pass
    def factory(*args_, **kwargs_):
        if ExpOneSynapse.subclass:
            return ExpOneSynapse.subclass(*args_, **kwargs_)
        else:
            return ExpOneSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getTauDecay(self): return self.tauDecay
    def setTauDecay(self, tauDecay): self.tauDecay = tauDecay
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='ExpOneSynapse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExpOneSynapse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExpOneSynapse'):
        super(ExpOneSynapse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExpOneSynapse')
        if self.tauDecay is not None and 'tauDecay' not in already_processed:
            already_processed.append('tauDecay')
            outfile.write(' tauDecay=%s' % (quote_attrib(self.tauDecay), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ExpOneSynapse', fromsubclass_=False):
        super(ExpOneSynapse, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(ExpOneSynapse, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExpOneSynapse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.tauDecay is not None and 'tauDecay' not in already_processed:
            already_processed.append('tauDecay')
            showIndent(outfile, level)
            outfile.write('tauDecay = "%s",\n' % (self.tauDecay,))
        super(ExpOneSynapse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ExpOneSynapse, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tauDecay', node)
        if value is not None and 'tauDecay' not in already_processed:
            already_processed.append('tauDecay')
            self.tauDecay = value
            self.validate_Nml2Quantity_time(self.tauDecay)    # validate type Nml2Quantity_time
        super(ExpOneSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ExpOneSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExpOneSynapse


class StpSynapse(ExpTwoSynapse):
    subclass = None
    superclass = ExpTwoSynapse
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, erev=None, gbase=None, tauDecay=None, tauRise=None, plasticity=None):
        super(StpSynapse, self).__init__(id, neuroLexId, metaid, notes, annotation, erev, gbase, tauDecay, tauRise, )
        self.plasticity = plasticity
    def factory(*args_, **kwargs_):
        if StpSynapse.subclass:
            return StpSynapse.subclass(*args_, **kwargs_)
        else:
            return StpSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getPlasticity(self): return self.plasticity
    def setPlasticity(self, plasticity): self.plasticity = plasticity
    def export(self, outfile, level, namespace_='', name_='StpSynapse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StpSynapse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StpSynapse'):
        super(StpSynapse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StpSynapse')
    def exportChildren(self, outfile, level, namespace_='', name_='StpSynapse', fromsubclass_=False):
        super(StpSynapse, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.plasticity is not None:
            self.plasticity.export(outfile, level, namespace_, name_='plasticity', )
    def hasContent_(self):
        if (
            self.plasticity is not None or
            super(StpSynapse, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StpSynapse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StpSynapse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StpSynapse, self).exportLiteralChildren(outfile, level, name_)
        if self.plasticity is not None:
            showIndent(outfile, level)
            outfile.write('plasticity=model_.Plasticity(\n')
            self.plasticity.exportLiteral(outfile, level, name_='plasticity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StpSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'plasticity':
            obj_ = Plasticity.factory()
            obj_.build(child_)
            self.setPlasticity(obj_)
        super(StpSynapse, self).buildChildren(child_, node, nodeName_, True)
# end class StpSynapse


class NmdaSynapse(ExpTwoSynapse):
    subclass = None
    superclass = ExpTwoSynapse
    def __init__(self, id=None, neuroLexId=None, metaid=None, notes=None, annotation=None, erev=None, gbase=None, tauDecay=None, tauRise=None, voltageConcDepBlock=None):
        super(NmdaSynapse, self).__init__(id, neuroLexId, metaid, notes, annotation, erev, gbase, tauDecay, tauRise, )
        self.voltageConcDepBlock = voltageConcDepBlock
    def factory(*args_, **kwargs_):
        if NmdaSynapse.subclass:
            return NmdaSynapse.subclass(*args_, **kwargs_)
        else:
            return NmdaSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getVoltageConcDepBlock(self): return self.voltageConcDepBlock
    def setVoltageConcDepBlock(self, voltageConcDepBlock): self.voltageConcDepBlock = voltageConcDepBlock
    def export(self, outfile, level, namespace_='', name_='NmdaSynapse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NmdaSynapse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NmdaSynapse'):
        super(NmdaSynapse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NmdaSynapse')
    def exportChildren(self, outfile, level, namespace_='', name_='NmdaSynapse', fromsubclass_=False):
        super(NmdaSynapse, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.voltageConcDepBlock is not None:
            self.voltageConcDepBlock.export(outfile, level, namespace_, name_='voltageConcDepBlock', )
    def hasContent_(self):
        if (
            self.voltageConcDepBlock is not None or
            super(NmdaSynapse, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NmdaSynapse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NmdaSynapse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NmdaSynapse, self).exportLiteralChildren(outfile, level, name_)
        if self.voltageConcDepBlock is not None:
            showIndent(outfile, level)
            outfile.write('voltageConcDepBlock=model_.VoltageConcDepBlock(\n')
            self.voltageConcDepBlock.exportLiteral(outfile, level, name_='voltageConcDepBlock')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(NmdaSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'voltageConcDepBlock':
            obj_ = VoltageConcDepBlock.factory()
            obj_.build(child_)
            self.setVoltageConcDepBlock(obj_)
        super(NmdaSynapse, self).buildChildren(child_, node, nodeName_, True)
# end class NmdaSynapse


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'neuroml'
        rootClass = neuroml
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_=rootTag,
##         namespacedef_='xmlns:nml2="http://www.neuroml.org/schema/neuroml2"')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'neuroml'
        rootClass = neuroml
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="neuroml",
##         namespacedef_='xmlns:nml2="http://www.neuroml.org/schema/neuroml2"')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'neuroml'
        rootClass = neuroml
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from nml2 import *\n\n')
##     sys.stdout.write('import nml2 as model_\n\n')
##     sys.stdout.write('rootObj = model_.rootTag(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AbstractCell",
    "AdExIaFCell",
    "Annotation",
    "Base",
    "BiophysicalProperties",
    "Cell",
    "CellSet",
    "ChannelDensity",
    "ChannelPopulation",
    "ConcentrationModel_D",
    "ConductanceBasedSynapse",
    "Connection",
    "DecayingPoolConcentrationModel",
    "DistalDetails",
    "ExpOneSynapse",
    "ExpTwoSynapse",
    "ExplicitInput",
    "ExtracellularProperties",
    "FixedConcentration",
    "Gate",
    "GridLayout",
    "IaFCell",
    "IaFTauCell",
    "Include",
    "InhomogeneousParam",
    "InhomogeneousValue",
    "Instance",
    "Instances",
    "IntracellularProperties",
    "IonChannel",
    "IzhikevichCell",
    "Layout",
    "Location",
    "Member",
    "MembraneProperties",
    "Morphology",
    "Network",
    "NmdaSynapse",
    "Path",
    "Plasticity",
    "Point3DWithDiam",
    "Population",
    "Projection",
    "ProximalDetails",
    "PulseGenerator",
    "RandomLayout",
    "ReactionScheme",
    "Region",
    "ReversalPotential",
    "Segment",
    "SegmentEndPoint",
    "SegmentGroup",
    "SegmentParent",
    "Space",
    "SpaceStructure",
    "Species",
    "Standalone",
    "StpSynapse",
    "SubTree",
    "SynapticConnection",
    "UnstructuredLayout",
    "ValueAcrossSegOrSegGroup",
    "VariableParameter",
    "VoltageConcDepBlock",
    "includeType",
    "neuroml"
    ]

#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed May  3 13:39:08 2023 by generateDS.py version 2.41.3.
# Python 3.10.11 (main, Apr  5 2023, 00:00:00) [GCC 13.0.1 20230404 (Red Hat 13.0.1-0)]
#
# Command line options:
#   ('-o', 'nml.py')
#   ('--use-getter-setter', 'none')
#   ('--user-methods', 'helper_methods.py')
#   ('--export', 'write validate')
#   ('--custom-imports-template', 'gds_imports-template.py')
#
# Command line arguments:
#   NeuroML_v2.3.xsd
#
# Command line:
#   /home/asinha/.local/share/virtualenvs/neuroml-310/bin/generateDS -o "nml.py" --use-getter-setter="none" --user-methods="helper_methods.py" --export="write validate" --custom-imports-template="gds_imports-template.py" NeuroML_v2.3.xsd
#
# Current working directory (os.getcwd()):
#   nml
#

import sys

try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_

import math

from math import pi, sqrt

from operator import attrgetter

import inspect

import networkx as nx

import numpy


import neuroml

import neuroml.neuro_lex_ids

Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc


def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element


#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import (
        GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_,
    )
except ModulenotfoundExp_:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from .generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_:

    class GdsCollector_(object):
        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from .generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:

        class GeneratedsSuperSuper(object):
            pass

    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r"(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$")

        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name

            def utcoffset(self, dt):
                return self.__offset

            def tzname(self, dt):
                return self.__name

            def dst(self, dt):
                return None

        def __str__(self):
            settings = {
                "str_pretty_print": True,
                "str_indent_level": 0,
                "str_namespaceprefix": "",
                "str_name": self.__class__.__name__,
                "str_namespacedefs": "",
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings["str_indent_level"],
                pretty_print=settings["str_pretty_print"],
                namespaceprefix_=settings["str_namespaceprefix"],
                name_=settings["str_name"],
                namespacedef_=settings["str_namespacedefs"],
            )
            strval = output.getvalue()
            output.close()
            return strval

        def gds_format_string(self, input_data, input_name=""):
            return input_data

        def gds_parse_string(self, input_data, node=None, input_name=""):
            return input_data

        def gds_validate_string(self, input_data, node=None, input_name=""):
            if not input_data:
                return ""
            else:
                return input_data

        def gds_format_base64(self, input_data, input_name=""):
            return base64.b64encode(input_data).decode("ascii")

        def gds_validate_base64(self, input_data, node=None, input_name=""):
            return input_data

        def gds_format_integer(self, input_data, input_name=""):
            return "%d" % int(input_data)

        def gds_parse_integer(self, input_data, node=None, input_name=""):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, "Requires integer value: %s" % exp)
            return ival

        def gds_validate_integer(self, input_data, node=None, input_name=""):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires integer value")
            return value

        def gds_format_integer_list(self, input_data, input_name=""):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return "%s" % " ".join(input_data)

        def gds_validate_integer_list(self, input_data, node=None, input_name=""):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, "Requires sequence of integer values")
            return values

        def gds_format_float(self, input_data, input_name=""):
            return ("%.15f" % float(input_data)).rstrip("0")

        def gds_parse_float(self, input_data, node=None, input_name=""):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, "Requires float or double value: %s" % exp)
            return fval_

        def gds_validate_float(self, input_data, node=None, input_name=""):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires float value")
            return value

        def gds_format_float_list(self, input_data, input_name=""):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return "%s" % " ".join(input_data)

        def gds_validate_float_list(self, input_data, node=None, input_name=""):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, "Requires sequence of float values")
            return values

        def gds_format_decimal(self, input_data, input_name=""):
            return_value = "%s" % input_data
            if "." in return_value:
                return_value = return_value.rstrip("0")
                if return_value.endswith("."):
                    return_value = return_value.rstrip(".")
            return return_value

        def gds_parse_decimal(self, input_data, node=None, input_name=""):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires decimal value")
            return decimal_value

        def gds_validate_decimal(self, input_data, node=None, input_name=""):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires decimal value")
            return value

        def gds_format_decimal_list(self, input_data, input_name=""):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return " ".join([self.gds_format_decimal(item) for item in input_data])

        def gds_validate_decimal_list(self, input_data, node=None, input_name=""):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, "Requires sequence of decimal values")
            return values

        def gds_format_double(self, input_data, input_name=""):
            return "%s" % input_data

        def gds_parse_double(self, input_data, node=None, input_name=""):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, "Requires double or float value: %s" % exp)
            return fval_

        def gds_validate_double(self, input_data, node=None, input_name=""):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, "Requires double or float value")
            return value

        def gds_format_double_list(self, input_data, input_name=""):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return "%s" % " ".join(input_data)

        def gds_validate_double_list(self, input_data, node=None, input_name=""):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, "Requires sequence of double or float values"
                    )
            return values

        def gds_format_boolean(self, input_data, input_name=""):
            return ("%s" % input_data).lower()

        def gds_parse_boolean(self, input_data, node=None, input_name=""):
            input_data = input_data.strip()
            if input_data in ("true", "1"):
                bval = True
            elif input_data in ("false", "0"):
                bval = False
            else:
                raise_parse_error(node, "Requires boolean value")
            return bval

        def gds_validate_boolean(self, input_data, node=None, input_name=""):
            if input_data not in (
                True,
                1,
                False,
                0,
            ):
                raise_parse_error(
                    node, "Requires boolean value " "(one of True, 1, False, 0)"
                )
            return input_data

        def gds_format_boolean_list(self, input_data, input_name=""):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return "%s" % " ".join(input_data)

        def gds_validate_boolean_list(self, input_data, node=None, input_name=""):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (
                    True,
                    1,
                    False,
                    0,
                ):
                    raise_parse_error(
                        node,
                        "Requires sequence of boolean values "
                        "(one of True, 1, False, 0)",
                    )
            return values

        def gds_validate_datetime(self, input_data, node=None, input_name=""):
            return input_data

        def gds_format_datetime(self, input_data, input_name=""):
            if input_data.microsecond == 0:
                _svalue = "%04d-%02d-%02dT%02d:%02d:%02d" % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = "%04d-%02d-%02dT%02d:%02d:%02d.%s" % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ("%f" % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += "Z"
                    else:
                        if total_seconds < 0:
                            _svalue += "-"
                            total_seconds *= -1
                        else:
                            _svalue += "+"
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += "{0:02d}:{1:02d}".format(hours, minutes)
            return _svalue

        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == "Z":
                tz = GeneratedsSuper._FixedOffsetTZ(0, "UTC")
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(":")
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == "-":
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split(".")
            if len(time_parts) > 1:
                micro_seconds = int(float("0." + time_parts[1]) * 1000000)
                input_data = "%s.%s" % (
                    time_parts[0],
                    "{}".format(micro_seconds).rjust(6, "0"),
                )
                dt = datetime_.datetime.strptime(input_data, "%Y-%m-%dT%H:%M:%S.%f")
            else:
                dt = datetime_.datetime.strptime(input_data, "%Y-%m-%dT%H:%M:%S")
            dt = dt.replace(tzinfo=tz)
            return dt

        def gds_validate_date(self, input_data, node=None, input_name=""):
            return input_data

        def gds_format_date(self, input_data, input_name=""):
            _svalue = "%04d-%02d-%02d" % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += "Z"
                        else:
                            if total_seconds < 0:
                                _svalue += "-"
                                total_seconds *= -1
                            else:
                                _svalue += "+"
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += "{0:02d}:{1:02d}".format(hours, minutes)
            except AttributeError:
                pass
            return _svalue

        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == "Z":
                tz = GeneratedsSuper._FixedOffsetTZ(0, "UTC")
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(":")
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == "-":
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, "%Y-%m-%d")
            dt = dt.replace(tzinfo=tz)
            return dt.date()

        def gds_validate_time(self, input_data, node=None, input_name=""):
            return input_data

        def gds_format_time(self, input_data, input_name=""):
            if input_data.microsecond == 0:
                _svalue = "%02d:%02d:%02d" % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = "%02d:%02d:%02d.%s" % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ("%f" % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += "Z"
                    else:
                        if total_seconds < 0:
                            _svalue += "-"
                            total_seconds *= -1
                        else:
                            _svalue += "+"
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += "{0:02d}:{1:02d}".format(hours, minutes)
            return _svalue

        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1

        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == "Z":
                tz = GeneratedsSuper._FixedOffsetTZ(0, "UTC")
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(":")
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == "-":
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split(".")) > 1:
                dt = datetime_.datetime.strptime(input_data, "%H:%M:%S.%f")
            else:
                dt = datetime_.datetime.strptime(input_data, "%H:%M:%S")
            dt = dt.replace(tzinfo=tz)
            return dt.time()

        def gds_check_cardinality_(
            self, value, input_name, min_occurs=0, max_occurs=1, required=None
        ):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None:
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()
                        )
                    )
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(), min_occurs, length
                    )
                )
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(), max_occurs, length
                    )
                )

        def gds_validate_builtin_ST_(
            self,
            validator,
            value,
            input_name,
            min_occurs=None,
            max_occurs=None,
            required=None,
        ):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))

        def gds_validate_defined_ST_(
            self,
            validator,
            value,
            input_name,
            min_occurs=None,
            max_occurs=None,
            required=None,
        ):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))

        def gds_str_lower(self, instring):
            return instring.lower()

        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = "/".join(path_list)
            return path

        Tag_strip_pattern_ = re_.compile(r"\{.*\}")

        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub("", node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)

        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if "xsi" in node.nsmap:
                classname = node.get("{%s}type" % node.nsmap["xsi"])
                if classname is not None:
                    names = classname.split(":")
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1

        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content

        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))

        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = "utf-8"
                return instring.encode(encoding)
            else:
                return instring

        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode("utf8")
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result

        def __eq__(self, other):
            def excl_select_objs_(obj):
                return obj[0] != "parent_object_" and obj[0] != "gds_collector_"

            if type(self) != type(other):
                return False
            return all(
                x == y
                for x, y in zip_longest(
                    filter(excl_select_objs_, self.__dict__.items()),
                    filter(excl_select_objs_, other.__dict__.items()),
                )
            )

        def __ne__(self, other):
            return not self.__eq__(other)

        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass

        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass

        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None

        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass

        def gds_get_node_lineno_(self):
            if (
                hasattr(self, "gds_elementtree_node_")
                and self.gds_elementtree_node_ is not None
            ):
                return " near line {}".format(self.gds_elementtree_node_.sourceline)
            else:
                return ""

    def getSubclassFromModule_(module, class_):
        """Get the subclass of a class from a specific module."""
        name = class_.__name__ + "Sub"
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ""
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r"({.*})?(.*)")
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r"{(.*)}(.*)")
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write("    ")


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ""
    s1 = isinstance(inStr, BaseStrType_) and inStr or "%s" % inStr
    s2 = ""
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos : mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start() : mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace("&", "&amp;")
    s1 = s1.replace("<", "&lt;")
    s1 = s1.replace(">", "&gt;")
    return s1


def quote_attrib(inStr):
    s1 = isinstance(inStr, BaseStrType_) and inStr or "%s" % inStr
    s1 = s1.replace("&", "&amp;")
    s1 = s1.replace("<", "&lt;")
    s1 = s1.replace(">", "&gt;")
    s1 = s1.replace("\n", "&#10;")
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find("\n") == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find("\n") == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ""
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(":")
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == "xml":
            namespace = "http://www.w3.org/XML/1998/namespace"
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get(
                "{%s}%s"
                % (
                    namespace,
                    name,
                )
            )
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = "%s (element %s/line %d)" % (
            msg,
            node.tag,
            node.sourceline,
        )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8

    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value

    def getCategory(self):
        return self.category

    def getContenttype(self, content_type):
        return self.content_type

    def getValue(self):
        return self.value

    def getName(self):
        return self.name

    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:  # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name, pretty_print=pretty_print
            )

    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write("<%s>%s</%s>" % (self.name, self.value, self.name))
        elif (
            self.content_type == MixedContainer.TypeInteger
            or self.content_type == MixedContainer.TypeBoolean
        ):
            outfile.write("<%s>%d</%s>" % (self.name, self.value, self.name))
        elif (
            self.content_type == MixedContainer.TypeFloat
            or self.content_type == MixedContainer.TypeDecimal
        ):
            outfile.write("<%s>%f</%s>" % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write("<%s>%g</%s>" % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write(
                "<%s>%s</%s>" % (self.name, base64.b64encode(self.value), self.name)
            )

    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, "%s" % self.name)
            subelement.text = self.to_etree_simple()
        else:  # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)

    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (
            self.content_type == MixedContainer.TypeInteger
            or self.content_type == MixedContainer.TypeBoolean
        ):
            text = "%d" % self.value
        elif (
            self.content_type == MixedContainer.TypeFloat
            or self.content_type == MixedContainer.TypeDecimal
        ):
            text = "%f" % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = "%g" % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = "%s" % base64.b64encode(self.value)
        return text

    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value)
            )
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value)
            )
        else:  # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n'
                % (
                    self.category,
                    self.content_type,
                    self.name,
                )
            )
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(")\n")


class MemberSpec_(object):
    def __init__(
        self,
        name="",
        data_type="",
        container=0,
        optional=0,
        child_attrs=None,
        choice=None,
    ):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def set_data_type(self, data_type):
        self.data_type = data_type

    def get_data_type_chain(self):
        return self.data_type

    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return "xs:string"
        else:
            return self.data_type

    def set_container(self, container):
        self.container = container

    def get_container(self):
        return self.container

    def set_child_attrs(self, child_attrs):
        self.child_attrs = child_attrs

    def get_child_attrs(self):
        return self.child_attrs

    def set_choice(self, choice):
        self.choice = choice

    def get_choice(self):
        return self.choice

    def set_optional(self, optional):
        self.optional = optional

    def get_optional(self):
        return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Data representation classes.
#


class BlockTypes(str, Enum):
    VOLTAGE_CONC_DEP_BLOCK_MECHANISM = "voltageConcDepBlockMechanism"


class Metric(str, Enum):
    """Metric -- Allowed metrics for InhomogeneousParam"""

    PATH_LENGTHFROMROOT = "Path Length from root"


class PlasticityTypes(str, Enum):
    TSODYKS_MARKRAM_DEP_MECHANISM = "tsodyksMarkramDepMechanism"
    TSODYKS_MARKRAM_DEP_FAC_MECHANISM = "tsodyksMarkramDepFacMechanism"


class TrueOrFalse(str, Enum):
    TRUE = "true"
    FALSE = "false"


class ZeroOrOne(str, Enum):
    """ZeroOrOne -- Value which is either 0 or 1"""

    _0 = "0"
    _1 = "1"


class allowedSpaces(str, Enum):
    EUCLIDEAN__1_D = "Euclidean_1D"
    EUCLIDEAN__2_D = "Euclidean_2D"
    EUCLIDEAN__3_D = "Euclidean_3D"
    GRID__1_D = "Grid_1D"
    GRID__2_D = "Grid_2D"
    GRID__3_D = "Grid_3D"


class channelTypes(str, Enum):
    ION_CHANNEL_PASSIVE = "ionChannelPassive"
    ION_CHANNEL_HH = "ionChannelHH"


class gateTypes(str, Enum):
    GATE_H_HRATES = "gateHHrates"
    GATE_H_HRATES_TAU = "gateHHratesTau"
    GATE_H_HTAU_INF = "gateHHtauInf"
    GATE_H_HRATES_INF = "gateHHratesInf"
    GATE_H_HRATES_TAU_INF = "gateHHratesTauInf"
    GATE_HH_INSTANTANEOUS = "gateHHInstantaneous"
    GATE_KS = "gateKS"
    GATE_FRACTIONAL = "gateFractional"


class networkTypes(str, Enum):
    NETWORK = "network"
    NETWORK_WITH_TEMPERATURE = "networkWithTemperature"


class populationTypes(str, Enum):
    POPULATION = "population"
    POPULATION_LIST = "populationList"


class ComponentType(GeneratedsSuper):
    """ComponentType -- Contains an extension to NeuroML by creating custom LEMS ComponentType."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("name", "xs:string", 0, 0, {"use": "required", "name": "name"}),
        MemberSpec_(
            "extends", "xs:string", 0, 1, {"use": "optional", "name": "extends"}
        ),
        MemberSpec_(
            "description", "xs:string", 0, 1, {"use": "optional", "name": "description"}
        ),
        MemberSpec_(
            "Property",
            "Property",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "Property",
                "type": "LEMS_Property",
            },
            None,
        ),
        MemberSpec_(
            "Parameter",
            "Parameter",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "Parameter",
                "type": "Parameter",
            },
            None,
        ),
        MemberSpec_(
            "DerivedParameter",
            "DerivedParameter",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "DerivedParameter",
                "type": "DerivedParameter",
            },
            None,
        ),
        MemberSpec_(
            "Constant",
            "Constant",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "Constant",
                "type": "Constant",
            },
            None,
        ),
        MemberSpec_(
            "Exposure",
            "Exposure",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "Exposure",
                "type": "Exposure",
            },
            None,
        ),
        MemberSpec_(
            "Requirement",
            "Requirement",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "Requirement",
                "type": "Requirement",
            },
            None,
        ),
        MemberSpec_(
            "InstanceRequirement",
            "InstanceRequirement",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "InstanceRequirement",
                "type": "InstanceRequirement",
            },
            None,
        ),
        MemberSpec_(
            "Dynamics",
            "Dynamics",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "Dynamics",
                "type": "Dynamics",
            },
            None,
        ),
    ]
    subclass = None
    superclass = None

    def __init__(
        self,
        name: "a string (required)" = None,
        extends: "a string (optional)" = None,
        description: "a string (optional)" = None,
        Property: "list of Property(s) (optional)" = None,
        Parameter: "list of Parameter(s) (optional)" = None,
        DerivedParameter: "list of DerivedParameter(s) (optional)" = None,
        Constant: "list of Constant(s) (optional)" = None,
        Exposure: "list of Exposure(s) (optional)" = None,
        Requirement: "list of Requirement(s) (optional)" = None,
        InstanceRequirement: "list of InstanceRequirement(s) (optional)" = None,
        Dynamics: "list of Dynamics(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.extends = _cast(None, extends)
        self.extends_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
        self.Property_nsprefix_ = None
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        self.Parameter_nsprefix_ = None
        if DerivedParameter is None:
            self.DerivedParameter = []
        else:
            self.DerivedParameter = DerivedParameter
        self.DerivedParameter_nsprefix_ = None
        if Constant is None:
            self.Constant = []
        else:
            self.Constant = Constant
        self.Constant_nsprefix_ = None
        if Exposure is None:
            self.Exposure = []
        else:
            self.Exposure = Exposure
        self.Exposure_nsprefix_ = None
        if Requirement is None:
            self.Requirement = []
        else:
            self.Requirement = Requirement
        self.Requirement_nsprefix_ = None
        if InstanceRequirement is None:
            self.InstanceRequirement = []
        else:
            self.InstanceRequirement = InstanceRequirement
        self.InstanceRequirement_nsprefix_ = None
        if Dynamics is None:
            self.Dynamics = []
        else:
            self.Dynamics = Dynamics
        self.Dynamics_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComponentType.subclass:
            return ComponentType.subclass(*args_, **kwargs_)
        else:
            return ComponentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.Property
            or self.Parameter
            or self.DerivedParameter
            or self.Constant
            or self.Exposure
            or self.Requirement
            or self.InstanceRequirement
            or self.Dynamics
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ComponentType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ComponentType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ComponentType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ComponentType"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ComponentType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ComponentType",
    ):
        if self.name is not None and "name" not in already_processed:
            already_processed.add("name")
            outfile.write(
                " name=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.name), input_name="name"
                        )
                    ),
                )
            )
        if self.extends is not None and "extends" not in already_processed:
            already_processed.add("extends")
            outfile.write(
                " extends=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.extends), input_name="extends"
                        )
                    ),
                )
            )
        if self.description is not None and "description" not in already_processed:
            already_processed.add("description")
            outfile.write(
                " description=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.description), input_name="description"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ComponentType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for Property_ in self.Property:
            namespaceprefix_ = (
                self.Property_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Property_nsprefix_)
                else ""
            )
            Property_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Property",
                pretty_print=pretty_print,
            )
        for Parameter_ in self.Parameter:
            namespaceprefix_ = (
                self.Parameter_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Parameter_nsprefix_)
                else ""
            )
            Parameter_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Parameter",
                pretty_print=pretty_print,
            )
        for DerivedParameter_ in self.DerivedParameter:
            namespaceprefix_ = (
                self.DerivedParameter_nsprefix_ + ":"
                if (UseCapturedNS_ and self.DerivedParameter_nsprefix_)
                else ""
            )
            DerivedParameter_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="DerivedParameter",
                pretty_print=pretty_print,
            )
        for Constant_ in self.Constant:
            namespaceprefix_ = (
                self.Constant_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Constant_nsprefix_)
                else ""
            )
            Constant_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Constant",
                pretty_print=pretty_print,
            )
        for Exposure_ in self.Exposure:
            namespaceprefix_ = (
                self.Exposure_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Exposure_nsprefix_)
                else ""
            )
            Exposure_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Exposure",
                pretty_print=pretty_print,
            )
        for Requirement_ in self.Requirement:
            namespaceprefix_ = (
                self.Requirement_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Requirement_nsprefix_)
                else ""
            )
            Requirement_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Requirement",
                pretty_print=pretty_print,
            )
        for InstanceRequirement_ in self.InstanceRequirement:
            namespaceprefix_ = (
                self.InstanceRequirement_nsprefix_ + ":"
                if (UseCapturedNS_ and self.InstanceRequirement_nsprefix_)
                else ""
            )
            InstanceRequirement_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="InstanceRequirement",
                pretty_print=pretty_print,
            )
        for Dynamics_ in self.Dynamics:
            namespaceprefix_ = (
                self.Dynamics_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Dynamics_nsprefix_)
                else ""
            )
            Dynamics_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Dynamics",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.name, "name")
        self.gds_check_cardinality_(self.name, "name", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.extends, "extends")
        self.gds_check_cardinality_(self.extends, "extends", required=False)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.description, "description"
        )
        self.gds_check_cardinality_(self.description, "description", required=False)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.Property, "Property", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.Parameter, "Parameter", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.DerivedParameter, "DerivedParameter", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.Constant, "Constant", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.Exposure, "Exposure", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.Requirement, "Requirement", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.InstanceRequirement,
            "InstanceRequirement",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.Dynamics, "Dynamics", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.Property:
                item.validate_(gds_collector, recursive=True)
            for item in self.Parameter:
                item.validate_(gds_collector, recursive=True)
            for item in self.DerivedParameter:
                item.validate_(gds_collector, recursive=True)
            for item in self.Constant:
                item.validate_(gds_collector, recursive=True)
            for item in self.Exposure:
                item.validate_(gds_collector, recursive=True)
            for item in self.Requirement:
                item.validate_(gds_collector, recursive=True)
            for item in self.InstanceRequirement:
                item.validate_(gds_collector, recursive=True)
            for item in self.Dynamics:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("name", node)
        if value is not None and "name" not in already_processed:
            already_processed.add("name")
            self.name = value
        value = find_attr_value_("extends", node)
        if value is not None and "extends" not in already_processed:
            already_processed.add("extends")
            self.extends = value
        value = find_attr_value_("description", node)
        if value is not None and "description" not in already_processed:
            already_processed.add("description")
            self.description = value

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "Property":
            obj_ = LEMS_Property.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Property.append(obj_)
            obj_.original_tagname_ = "Property"
        elif nodeName_ == "Parameter":
            obj_ = Parameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Parameter.append(obj_)
            obj_.original_tagname_ = "Parameter"
        elif nodeName_ == "DerivedParameter":
            obj_ = DerivedParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DerivedParameter.append(obj_)
            obj_.original_tagname_ = "DerivedParameter"
        elif nodeName_ == "Constant":
            obj_ = Constant.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Constant.append(obj_)
            obj_.original_tagname_ = "Constant"
        elif nodeName_ == "Exposure":
            obj_ = Exposure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Exposure.append(obj_)
            obj_.original_tagname_ = "Exposure"
        elif nodeName_ == "Requirement":
            obj_ = Requirement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Requirement.append(obj_)
            obj_.original_tagname_ = "Requirement"
        elif nodeName_ == "InstanceRequirement":
            obj_ = InstanceRequirement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceRequirement.append(obj_)
            obj_.original_tagname_ = "InstanceRequirement"
        elif nodeName_ == "Dynamics":
            obj_ = Dynamics.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dynamics.append(obj_)
            obj_.original_tagname_ = "Dynamics"


# end class ComponentType


class InstanceRequirement(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("name", "xs:string", 0, 0, {"use": "required", "name": "name"}),
        MemberSpec_("type", "xs:string", 0, 0, {"use": "required", "name": "type"}),
    ]
    subclass = None
    superclass = None

    def __init__(
        self,
        name: "a string (required)" = None,
        type: "a string (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.type = _cast(None, type)
        self.type_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceRequirement
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceRequirement.subclass:
            return InstanceRequirement.subclass(*args_, **kwargs_)
        else:
            return InstanceRequirement(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="InstanceRequirement",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("InstanceRequirement")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "InstanceRequirement":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="InstanceRequirement",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="InstanceRequirement",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="InstanceRequirement",
    ):
        if self.name is not None and "name" not in already_processed:
            already_processed.add("name")
            outfile.write(
                " name=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.name), input_name="name"
                        )
                    ),
                )
            )
        if self.type is not None and "type" not in already_processed:
            already_processed.add("type")
            outfile.write(
                " type=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.type), input_name="type"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="InstanceRequirement",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.name, "name")
        self.gds_check_cardinality_(self.name, "name", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.type, "type")
        self.gds_check_cardinality_(self.type, "type", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("name", node)
        if value is not None and "name" not in already_processed:
            already_processed.add("name")
            self.name = value
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type = value

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        pass


# end class InstanceRequirement


class Dynamics(GeneratedsSuper):
    """Dynamics -- LEMS ComponentType for Dynamics"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "StateVariable",
            "StateVariable",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "StateVariable",
                "type": "StateVariable",
            },
            None,
        ),
        MemberSpec_(
            "DerivedVariable",
            "DerivedVariable",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "DerivedVariable",
                "type": "DerivedVariable",
            },
            None,
        ),
        MemberSpec_(
            "ConditionalDerivedVariable",
            "ConditionalDerivedVariable",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "ConditionalDerivedVariable",
                "type": "ConditionalDerivedVariable",
            },
            None,
        ),
        MemberSpec_(
            "TimeDerivative",
            "TimeDerivative",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "TimeDerivative",
                "type": "TimeDerivative",
            },
            None,
        ),
        MemberSpec_(
            "OnStart",
            "OnStart",
            0,
            1,
            {"maxOccurs": "1", "minOccurs": "0", "name": "OnStart", "type": "OnStart"},
            None,
        ),
        MemberSpec_(
            "OnEvent",
            "OnEvent",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "OnEvent",
                "type": "OnEvent",
            },
            None,
        ),
        MemberSpec_(
            "OnCondition",
            "OnCondition",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "OnCondition",
                "type": "OnCondition",
            },
            None,
        ),
        MemberSpec_(
            "Regime",
            "Regime",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "Regime",
                "type": "Regime",
            },
            None,
        ),
    ]
    subclass = None
    superclass = None

    def __init__(
        self,
        StateVariable: "list of StateVariable(s) (optional)" = None,
        DerivedVariable: "list of DerivedVariable(s) (optional)" = None,
        ConditionalDerivedVariable: "list of ConditionalDerivedVariable(s) (optional)" = None,
        TimeDerivative: "list of TimeDerivative(s) (optional)" = None,
        OnStart: "a OnStart (optional)" = None,
        OnEvent: "list of OnEvent(s) (optional)" = None,
        OnCondition: "list of OnCondition(s) (optional)" = None,
        Regime: "list of Regime(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if StateVariable is None:
            self.StateVariable = []
        else:
            self.StateVariable = StateVariable
        self.StateVariable_nsprefix_ = None
        if DerivedVariable is None:
            self.DerivedVariable = []
        else:
            self.DerivedVariable = DerivedVariable
        self.DerivedVariable_nsprefix_ = None
        if ConditionalDerivedVariable is None:
            self.ConditionalDerivedVariable = []
        else:
            self.ConditionalDerivedVariable = ConditionalDerivedVariable
        self.ConditionalDerivedVariable_nsprefix_ = None
        if TimeDerivative is None:
            self.TimeDerivative = []
        else:
            self.TimeDerivative = TimeDerivative
        self.TimeDerivative_nsprefix_ = None
        self.OnStart = OnStart
        self.OnStart_nsprefix_ = None
        if OnEvent is None:
            self.OnEvent = []
        else:
            self.OnEvent = OnEvent
        self.OnEvent_nsprefix_ = None
        if OnCondition is None:
            self.OnCondition = []
        else:
            self.OnCondition = OnCondition
        self.OnCondition_nsprefix_ = None
        if Regime is None:
            self.Regime = []
        else:
            self.Regime = Regime
        self.Regime_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Dynamics)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Dynamics.subclass:
            return Dynamics.subclass(*args_, **kwargs_)
        else:
            return Dynamics(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.StateVariable
            or self.DerivedVariable
            or self.ConditionalDerivedVariable
            or self.TimeDerivative
            or self.OnStart is not None
            or self.OnEvent
            or self.OnCondition
            or self.Regime
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Dynamics",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Dynamics")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Dynamics":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Dynamics"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Dynamics",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Dynamics"
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Dynamics",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for StateVariable_ in self.StateVariable:
            namespaceprefix_ = (
                self.StateVariable_nsprefix_ + ":"
                if (UseCapturedNS_ and self.StateVariable_nsprefix_)
                else ""
            )
            StateVariable_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="StateVariable",
                pretty_print=pretty_print,
            )
        for DerivedVariable_ in self.DerivedVariable:
            namespaceprefix_ = (
                self.DerivedVariable_nsprefix_ + ":"
                if (UseCapturedNS_ and self.DerivedVariable_nsprefix_)
                else ""
            )
            DerivedVariable_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="DerivedVariable",
                pretty_print=pretty_print,
            )
        for ConditionalDerivedVariable_ in self.ConditionalDerivedVariable:
            namespaceprefix_ = (
                self.ConditionalDerivedVariable_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ConditionalDerivedVariable_nsprefix_)
                else ""
            )
            ConditionalDerivedVariable_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ConditionalDerivedVariable",
                pretty_print=pretty_print,
            )
        for TimeDerivative_ in self.TimeDerivative:
            namespaceprefix_ = (
                self.TimeDerivative_nsprefix_ + ":"
                if (UseCapturedNS_ and self.TimeDerivative_nsprefix_)
                else ""
            )
            TimeDerivative_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="TimeDerivative",
                pretty_print=pretty_print,
            )
        if self.OnStart is not None:
            namespaceprefix_ = (
                self.OnStart_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OnStart_nsprefix_)
                else ""
            )
            self.OnStart.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OnStart",
                pretty_print=pretty_print,
            )
        for OnEvent_ in self.OnEvent:
            namespaceprefix_ = (
                self.OnEvent_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OnEvent_nsprefix_)
                else ""
            )
            OnEvent_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OnEvent",
                pretty_print=pretty_print,
            )
        for OnCondition_ in self.OnCondition:
            namespaceprefix_ = (
                self.OnCondition_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OnCondition_nsprefix_)
                else ""
            )
            OnCondition_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OnCondition",
                pretty_print=pretty_print,
            )
        for Regime_ in self.Regime:
            namespaceprefix_ = (
                self.Regime_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Regime_nsprefix_)
                else ""
            )
            Regime_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Regime",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.StateVariable, "StateVariable", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.DerivedVariable, "DerivedVariable", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.ConditionalDerivedVariable,
            "ConditionalDerivedVariable",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.TimeDerivative, "TimeDerivative", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(self.OnStart, "OnStart", min_occurs=0, max_occurs=1)
        self.gds_check_cardinality_(
            self.OnEvent, "OnEvent", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.OnCondition, "OnCondition", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.Regime, "Regime", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.StateVariable:
                item.validate_(gds_collector, recursive=True)
            for item in self.DerivedVariable:
                item.validate_(gds_collector, recursive=True)
            for item in self.ConditionalDerivedVariable:
                item.validate_(gds_collector, recursive=True)
            for item in self.TimeDerivative:
                item.validate_(gds_collector, recursive=True)
            if self.OnStart is not None:
                self.OnStart.validate_(gds_collector, recursive=True)
            for item in self.OnEvent:
                item.validate_(gds_collector, recursive=True)
            for item in self.OnCondition:
                item.validate_(gds_collector, recursive=True)
            for item in self.Regime:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "StateVariable":
            obj_ = StateVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StateVariable.append(obj_)
            obj_.original_tagname_ = "StateVariable"
        elif nodeName_ == "DerivedVariable":
            obj_ = DerivedVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DerivedVariable.append(obj_)
            obj_.original_tagname_ = "DerivedVariable"
        elif nodeName_ == "ConditionalDerivedVariable":
            obj_ = ConditionalDerivedVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConditionalDerivedVariable.append(obj_)
            obj_.original_tagname_ = "ConditionalDerivedVariable"
        elif nodeName_ == "TimeDerivative":
            obj_ = TimeDerivative.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeDerivative.append(obj_)
            obj_.original_tagname_ = "TimeDerivative"
        elif nodeName_ == "OnStart":
            obj_ = OnStart.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OnStart = obj_
            obj_.original_tagname_ = "OnStart"
        elif nodeName_ == "OnEvent":
            obj_ = OnEvent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OnEvent.append(obj_)
            obj_.original_tagname_ = "OnEvent"
        elif nodeName_ == "OnCondition":
            obj_ = OnCondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OnCondition.append(obj_)
            obj_.original_tagname_ = "OnCondition"
        elif nodeName_ == "Regime":
            obj_ = Regime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Regime.append(obj_)
            obj_.original_tagname_ = "Regime"


# end class Dynamics


class Case(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "condition", "xs:string", 0, 1, {"use": "optional", "name": "condition"}
        ),
        MemberSpec_("value", "xs:string", 0, 0, {"use": "required", "name": "value"}),
    ]
    subclass = None
    superclass = None

    def __init__(
        self,
        condition: "a string (optional)" = None,
        value: "a string (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.condition = _cast(None, condition)
        self.condition_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Case)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Case.subclass:
            return Case.subclass(*args_, **kwargs_)
        else:
            return Case(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Case",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Case")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Case":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Case"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Case",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Case"
    ):
        if self.condition is not None and "condition" not in already_processed:
            already_processed.add("condition")
            outfile.write(
                " condition=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.condition), input_name="condition"
                        )
                    ),
                )
            )
        if self.value is not None and "value" not in already_processed:
            already_processed.add("value")
            outfile.write(
                " value=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.value), input_name="value"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Case",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.condition, "condition"
        )
        self.gds_check_cardinality_(self.condition, "condition", required=False)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.value, "value")
        self.gds_check_cardinality_(self.value, "value", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("condition", node)
        if value is not None and "condition" not in already_processed:
            already_processed.add("condition")
            self.condition = value
        value = find_attr_value_("value", node)
        if value is not None and "value" not in already_processed:
            already_processed.add("value")
            self.value = value

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        pass


# end class Case


class TimeDerivative(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "variable", "xs:string", 0, 0, {"use": "required", "name": "variable"}
        ),
        MemberSpec_("value", "xs:string", 0, 0, {"use": "required", "name": "value"}),
    ]
    subclass = None
    superclass = None

    def __init__(
        self,
        variable: "a string (required)" = None,
        value: "a string (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.variable = _cast(None, variable)
        self.variable_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, TimeDerivative)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeDerivative.subclass:
            return TimeDerivative.subclass(*args_, **kwargs_)
        else:
            return TimeDerivative(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="TimeDerivative",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("TimeDerivative")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "TimeDerivative":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="TimeDerivative"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="TimeDerivative",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="TimeDerivative",
    ):
        if self.variable is not None and "variable" not in already_processed:
            already_processed.add("variable")
            outfile.write(
                " variable=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.variable), input_name="variable"
                        )
                    ),
                )
            )
        if self.value is not None and "value" not in already_processed:
            already_processed.add("value")
            outfile.write(
                " value=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.value), input_name="value"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="TimeDerivative",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.variable, "variable"
        )
        self.gds_check_cardinality_(self.variable, "variable", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.value, "value")
        self.gds_check_cardinality_(self.value, "value", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("variable", node)
        if value is not None and "variable" not in already_processed:
            already_processed.add("variable")
            self.variable = value
        value = find_attr_value_("value", node)
        if value is not None and "value" not in already_processed:
            already_processed.add("value")
            self.value = value

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        pass


# end class TimeDerivative


class OnStart(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "StateAssignment",
            "StateAssignment",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "1",
                "name": "StateAssignment",
                "type": "StateAssignment",
            },
            None,
        ),
    ]
    subclass = None
    superclass = None

    def __init__(
        self,
        StateAssignment: "list of StateAssignment(s) (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if StateAssignment is None:
            self.StateAssignment = []
        else:
            self.StateAssignment = StateAssignment
        self.StateAssignment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OnStart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnStart.subclass:
            return OnStart.subclass(*args_, **kwargs_)
        else:
            return OnStart(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if self.StateAssignment:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="OnStart",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OnStart")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OnStart":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="OnStart"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OnStart",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="OnStart"
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="OnStart",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for StateAssignment_ in self.StateAssignment:
            namespaceprefix_ = (
                self.StateAssignment_nsprefix_ + ":"
                if (UseCapturedNS_ and self.StateAssignment_nsprefix_)
                else ""
            )
            StateAssignment_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="StateAssignment",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.StateAssignment, "StateAssignment", min_occurs=1, max_occurs=9999999
        )
        if recursive:
            for item in self.StateAssignment:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "StateAssignment":
            obj_ = StateAssignment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StateAssignment.append(obj_)
            obj_.original_tagname_ = "StateAssignment"


# end class OnStart


class StateAssignment(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "variable", "xs:string", 0, 0, {"use": "required", "name": "variable"}
        ),
        MemberSpec_("value", "xs:string", 0, 0, {"use": "required", "name": "value"}),
    ]
    subclass = None
    superclass = None

    def __init__(
        self,
        variable: "a string (required)" = None,
        value: "a string (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.variable = _cast(None, variable)
        self.variable_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, StateAssignment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StateAssignment.subclass:
            return StateAssignment.subclass(*args_, **kwargs_)
        else:
            return StateAssignment(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="StateAssignment",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("StateAssignment")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "StateAssignment":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="StateAssignment"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="StateAssignment",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="StateAssignment",
    ):
        if self.variable is not None and "variable" not in already_processed:
            already_processed.add("variable")
            outfile.write(
                " variable=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.variable), input_name="variable"
                        )
                    ),
                )
            )
        if self.value is not None and "value" not in already_processed:
            already_processed.add("value")
            outfile.write(
                " value=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.value), input_name="value"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="StateAssignment",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.variable, "variable"
        )
        self.gds_check_cardinality_(self.variable, "variable", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.value, "value")
        self.gds_check_cardinality_(self.value, "value", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("variable", node)
        if value is not None and "variable" not in already_processed:
            already_processed.add("variable")
            self.variable = value
        value = find_attr_value_("value", node)
        if value is not None and "value" not in already_processed:
            already_processed.add("value")
            self.value = value

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        pass


# end class StateAssignment


class OnEvent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("port", "xs:string", 0, 0, {"use": "required", "name": "port"}),
        MemberSpec_(
            "StateAssignment",
            "StateAssignment",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "StateAssignment",
                "type": "StateAssignment",
            },
            None,
        ),
        MemberSpec_(
            "EventOut",
            "EventOut",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "EventOut",
                "type": "EventOut",
            },
            None,
        ),
    ]
    subclass = None
    superclass = None

    def __init__(
        self,
        port: "a string (required)" = None,
        StateAssignment: "list of StateAssignment(s) (optional)" = None,
        EventOut: "list of EventOut(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.port = _cast(None, port)
        self.port_nsprefix_ = None
        if StateAssignment is None:
            self.StateAssignment = []
        else:
            self.StateAssignment = StateAssignment
        self.StateAssignment_nsprefix_ = None
        if EventOut is None:
            self.EventOut = []
        else:
            self.EventOut = EventOut
        self.EventOut_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OnEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnEvent.subclass:
            return OnEvent.subclass(*args_, **kwargs_)
        else:
            return OnEvent(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if self.StateAssignment or self.EventOut:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="OnEvent",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OnEvent")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OnEvent":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="OnEvent"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OnEvent",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="OnEvent"
    ):
        if self.port is not None and "port" not in already_processed:
            already_processed.add("port")
            outfile.write(
                " port=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.port), input_name="port"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="OnEvent",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for StateAssignment_ in self.StateAssignment:
            namespaceprefix_ = (
                self.StateAssignment_nsprefix_ + ":"
                if (UseCapturedNS_ and self.StateAssignment_nsprefix_)
                else ""
            )
            StateAssignment_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="StateAssignment",
                pretty_print=pretty_print,
            )
        for EventOut_ in self.EventOut:
            namespaceprefix_ = (
                self.EventOut_nsprefix_ + ":"
                if (UseCapturedNS_ and self.EventOut_nsprefix_)
                else ""
            )
            EventOut_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="EventOut",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.port, "port")
        self.gds_check_cardinality_(self.port, "port", required=True)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.StateAssignment, "StateAssignment", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.EventOut, "EventOut", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.StateAssignment:
                item.validate_(gds_collector, recursive=True)
            for item in self.EventOut:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("port", node)
        if value is not None and "port" not in already_processed:
            already_processed.add("port")
            self.port = value

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "StateAssignment":
            obj_ = StateAssignment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StateAssignment.append(obj_)
            obj_.original_tagname_ = "StateAssignment"
        elif nodeName_ == "EventOut":
            obj_ = EventOut.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EventOut.append(obj_)
            obj_.original_tagname_ = "EventOut"


# end class OnEvent


class EventOut(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("port", "xs:string", 0, 0, {"use": "required", "name": "port"}),
    ]
    subclass = None
    superclass = None

    def __init__(
        self, port: "a string (required)" = None, gds_collector_=None, **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.port = _cast(None, port)
        self.port_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, EventOut)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventOut.subclass:
            return EventOut.subclass(*args_, **kwargs_)
        else:
            return EventOut(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="EventOut",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("EventOut")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "EventOut":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="EventOut"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="EventOut",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="EventOut"
    ):
        if self.port is not None and "port" not in already_processed:
            already_processed.add("port")
            outfile.write(
                " port=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.port), input_name="port"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="EventOut",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.port, "port")
        self.gds_check_cardinality_(self.port, "port", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("port", node)
        if value is not None and "port" not in already_processed:
            already_processed.add("port")
            self.port = value

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        pass


# end class EventOut


class OnCondition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("test", "xs:string", 0, 0, {"use": "required", "name": "test"}),
        MemberSpec_(
            "StateAssignment",
            "StateAssignment",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "StateAssignment",
                "type": "StateAssignment",
            },
            None,
        ),
        MemberSpec_(
            "EventOut",
            "EventOut",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "EventOut",
                "type": "EventOut",
            },
            None,
        ),
        MemberSpec_(
            "Transition",
            "Transition",
            0,
            1,
            {
                "maxOccurs": "1",
                "minOccurs": "0",
                "name": "Transition",
                "type": "Transition",
            },
            None,
        ),
    ]
    subclass = None
    superclass = None

    def __init__(
        self,
        test: "a string (required)" = None,
        StateAssignment: "list of StateAssignment(s) (optional)" = None,
        EventOut: "list of EventOut(s) (optional)" = None,
        Transition: "a Transition (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.test = _cast(None, test)
        self.test_nsprefix_ = None
        if StateAssignment is None:
            self.StateAssignment = []
        else:
            self.StateAssignment = StateAssignment
        self.StateAssignment_nsprefix_ = None
        if EventOut is None:
            self.EventOut = []
        else:
            self.EventOut = EventOut
        self.EventOut_nsprefix_ = None
        self.Transition = Transition
        self.Transition_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OnCondition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnCondition.subclass:
            return OnCondition.subclass(*args_, **kwargs_)
        else:
            return OnCondition(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if self.StateAssignment or self.EventOut or self.Transition is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="OnCondition",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OnCondition")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OnCondition":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="OnCondition"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OnCondition",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="OnCondition",
    ):
        if self.test is not None and "test" not in already_processed:
            already_processed.add("test")
            outfile.write(
                " test=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.test), input_name="test"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="OnCondition",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for StateAssignment_ in self.StateAssignment:
            namespaceprefix_ = (
                self.StateAssignment_nsprefix_ + ":"
                if (UseCapturedNS_ and self.StateAssignment_nsprefix_)
                else ""
            )
            StateAssignment_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="StateAssignment",
                pretty_print=pretty_print,
            )
        for EventOut_ in self.EventOut:
            namespaceprefix_ = (
                self.EventOut_nsprefix_ + ":"
                if (UseCapturedNS_ and self.EventOut_nsprefix_)
                else ""
            )
            EventOut_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="EventOut",
                pretty_print=pretty_print,
            )
        if self.Transition is not None:
            namespaceprefix_ = (
                self.Transition_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Transition_nsprefix_)
                else ""
            )
            self.Transition.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Transition",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.test, "test")
        self.gds_check_cardinality_(self.test, "test", required=True)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.StateAssignment, "StateAssignment", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.EventOut, "EventOut", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.Transition, "Transition", min_occurs=0, max_occurs=1
        )
        if recursive:
            for item in self.StateAssignment:
                item.validate_(gds_collector, recursive=True)
            for item in self.EventOut:
                item.validate_(gds_collector, recursive=True)
            if self.Transition is not None:
                self.Transition.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("test", node)
        if value is not None and "test" not in already_processed:
            already_processed.add("test")
            self.test = value

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "StateAssignment":
            obj_ = StateAssignment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StateAssignment.append(obj_)
            obj_.original_tagname_ = "StateAssignment"
        elif nodeName_ == "EventOut":
            obj_ = EventOut.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EventOut.append(obj_)
            obj_.original_tagname_ = "EventOut"
        elif nodeName_ == "Transition":
            obj_ = Transition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Transition = obj_
            obj_.original_tagname_ = "Transition"


# end class OnCondition


class Transition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("regime", "xs:string", 0, 0, {"use": "required", "name": "regime"}),
    ]
    subclass = None
    superclass = None

    def __init__(
        self, regime: "a string (required)" = None, gds_collector_=None, **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.regime = _cast(None, regime)
        self.regime_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Transition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Transition.subclass:
            return Transition.subclass(*args_, **kwargs_)
        else:
            return Transition(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Transition",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Transition")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Transition":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Transition"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Transition",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Transition"
    ):
        if self.regime is not None and "regime" not in already_processed:
            already_processed.add("regime")
            outfile.write(
                " regime=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.regime), input_name="regime"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Transition",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.regime, "regime")
        self.gds_check_cardinality_(self.regime, "regime", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("regime", node)
        if value is not None and "regime" not in already_processed:
            already_processed.add("regime")
            self.regime = value

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        pass


# end class Transition


class Regime(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("name", "xs:string", 0, 0, {"use": "required", "name": "name"}),
        MemberSpec_(
            "initial", "TrueOrFalse", 0, 1, {"use": "optional", "name": "initial"}
        ),
        MemberSpec_(
            "TimeDerivative",
            "TimeDerivative",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "TimeDerivative",
                "type": "TimeDerivative",
            },
            None,
        ),
        MemberSpec_(
            "OnEntry",
            "OnEntry",
            0,
            1,
            {"maxOccurs": "1", "minOccurs": "0", "name": "OnEntry", "type": "OnEntry"},
            None,
        ),
        MemberSpec_(
            "OnCondition",
            "OnCondition",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "OnCondition",
                "type": "OnCondition",
            },
            None,
        ),
    ]
    subclass = None
    superclass = None

    def __init__(
        self,
        name: "a string (required)" = None,
        initial: "a TrueOrFalse (optional)" = None,
        TimeDerivative: "list of TimeDerivative(s) (optional)" = None,
        OnEntry: "a OnEntry (optional)" = None,
        OnCondition: "list of OnCondition(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.initial = _cast(None, initial)
        self.initial_nsprefix_ = None
        if TimeDerivative is None:
            self.TimeDerivative = []
        else:
            self.TimeDerivative = TimeDerivative
        self.TimeDerivative_nsprefix_ = None
        self.OnEntry = OnEntry
        self.OnEntry_nsprefix_ = None
        if OnCondition is None:
            self.OnCondition = []
        else:
            self.OnCondition = OnCondition
        self.OnCondition_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Regime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Regime.subclass:
            return Regime.subclass(*args_, **kwargs_)
        else:
            return Regime(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_TrueOrFalse(self, value):
        # Validate type TrueOrFalse, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = ["true", "false"]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TrueOrFalse'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False

    def _hasContent(self):
        if self.TimeDerivative or self.OnEntry is not None or self.OnCondition:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Regime",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Regime")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Regime":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Regime"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Regime",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Regime"
    ):
        if self.name is not None and "name" not in already_processed:
            already_processed.add("name")
            outfile.write(
                " name=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.name), input_name="name"
                        )
                    ),
                )
            )
        if self.initial is not None and "initial" not in already_processed:
            already_processed.add("initial")
            outfile.write(
                " initial=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.initial), input_name="initial"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Regime",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for TimeDerivative_ in self.TimeDerivative:
            namespaceprefix_ = (
                self.TimeDerivative_nsprefix_ + ":"
                if (UseCapturedNS_ and self.TimeDerivative_nsprefix_)
                else ""
            )
            TimeDerivative_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="TimeDerivative",
                pretty_print=pretty_print,
            )
        if self.OnEntry is not None:
            namespaceprefix_ = (
                self.OnEntry_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OnEntry_nsprefix_)
                else ""
            )
            self.OnEntry.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OnEntry",
                pretty_print=pretty_print,
            )
        for OnCondition_ in self.OnCondition:
            namespaceprefix_ = (
                self.OnCondition_nsprefix_ + ":"
                if (UseCapturedNS_ and self.OnCondition_nsprefix_)
                else ""
            )
            OnCondition_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="OnCondition",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.name, "name")
        self.gds_check_cardinality_(self.name, "name", required=True)
        self.gds_validate_defined_ST_(
            self.validate_TrueOrFalse, self.initial, "initial"
        )
        self.gds_check_cardinality_(self.initial, "initial", required=False)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.TimeDerivative, "TimeDerivative", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(self.OnEntry, "OnEntry", min_occurs=0, max_occurs=1)
        self.gds_check_cardinality_(
            self.OnCondition, "OnCondition", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.TimeDerivative:
                item.validate_(gds_collector, recursive=True)
            if self.OnEntry is not None:
                self.OnEntry.validate_(gds_collector, recursive=True)
            for item in self.OnCondition:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("name", node)
        if value is not None and "name" not in already_processed:
            already_processed.add("name")
            self.name = value
        value = find_attr_value_("initial", node)
        if value is not None and "initial" not in already_processed:
            already_processed.add("initial")
            self.initial = value
            self.validate_TrueOrFalse(self.initial)  # validate type TrueOrFalse

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "TimeDerivative":
            obj_ = TimeDerivative.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeDerivative.append(obj_)
            obj_.original_tagname_ = "TimeDerivative"
        elif nodeName_ == "OnEntry":
            obj_ = OnEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OnEntry = obj_
            obj_.original_tagname_ = "OnEntry"
        elif nodeName_ == "OnCondition":
            obj_ = OnCondition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OnCondition.append(obj_)
            obj_.original_tagname_ = "OnCondition"


# end class Regime


class OnEntry(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "StateAssignment",
            "StateAssignment",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "1",
                "name": "StateAssignment",
                "type": "StateAssignment",
            },
            None,
        ),
    ]
    subclass = None
    superclass = None

    def __init__(
        self,
        StateAssignment: "list of StateAssignment(s) (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        if StateAssignment is None:
            self.StateAssignment = []
        else:
            self.StateAssignment = StateAssignment
        self.StateAssignment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OnEntry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnEntry.subclass:
            return OnEntry.subclass(*args_, **kwargs_)
        else:
            return OnEntry(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if self.StateAssignment:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="OnEntry",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OnEntry")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OnEntry":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="OnEntry"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OnEntry",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="OnEntry"
    ):
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="OnEntry",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for StateAssignment_ in self.StateAssignment:
            namespaceprefix_ = (
                self.StateAssignment_nsprefix_ + ":"
                if (UseCapturedNS_ and self.StateAssignment_nsprefix_)
                else ""
            )
            StateAssignment_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="StateAssignment",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.StateAssignment, "StateAssignment", min_occurs=1, max_occurs=9999999
        )
        if recursive:
            for item in self.StateAssignment:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        pass

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "StateAssignment":
            obj_ = StateAssignment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StateAssignment.append(obj_)
            obj_.original_tagname_ = "StateAssignment"


# end class OnEntry


class IncludeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("href", "xs:anyURI", 0, 0, {"use": "required", "name": "href"}),
    ]
    subclass = None
    superclass = None

    def __init__(
        self, href: "a anyURI (required)" = None, gds_collector_=None, **kwargs_
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IncludeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IncludeType.subclass:
            return IncludeType.subclass(*args_, **kwargs_)
        else:
            return IncludeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IncludeType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IncludeType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IncludeType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IncludeType"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IncludeType",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="IncludeType",
    ):
        if self.href is not None and "href" not in already_processed:
            already_processed.add("href")
            outfile.write(
                " href=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.href), input_name="href"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IncludeType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.href, "href")
        self.gds_check_cardinality_(self.href, "href", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("href", node)
        if value is not None and "href" not in already_processed:
            already_processed.add("href")
            self.href = value

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        pass


# end class IncludeType


class Q10Settings(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("type", "NmlId", 0, 0, {"use": "required", "name": "type"}),
        MemberSpec_(
            "fixed_q10",
            "Nml2Quantity_none",
            0,
            1,
            {"use": "optional", "name": "fixed_q10"},
        ),
        MemberSpec_(
            "q10_factor",
            "Nml2Quantity_none",
            0,
            1,
            {"use": "optional", "name": "q10_factor"},
        ),
        MemberSpec_(
            "experimental_temp",
            "Nml2Quantity_temperature",
            0,
            1,
            {"use": "optional", "name": "experimental_temp"},
        ),
    ]
    subclass = None
    superclass = None

    def __init__(
        self,
        type: "a NmlId (required)" = None,
        fixed_q10: "a Nml2Quantity_none (optional)" = None,
        q10_factor: "a Nml2Quantity_none (optional)" = None,
        experimental_temp: "a Nml2Quantity_temperature (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.type = _cast(None, type)
        self.type_nsprefix_ = None
        self.fixed_q10 = _cast(None, fixed_q10)
        self.fixed_q10_nsprefix_ = None
        self.q10_factor = _cast(None, q10_factor)
        self.q10_factor_nsprefix_ = None
        self.experimental_temp = _cast(None, experimental_temp)
        self.experimental_temp_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Q10Settings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Q10Settings.subclass:
            return Q10Settings.subclass(*args_, **kwargs_)
        else:
            return Q10Settings(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_none_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_none_patterns_,
                    )
                )

    validate_Nml2Quantity_none_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$"]
    ]

    def validate_Nml2Quantity_temperature(self, value):
        # Validate type Nml2Quantity_temperature, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_temperature_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_temperature_patterns_,
                    )
                )

    validate_Nml2Quantity_temperature_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(degC))$"]
    ]

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Q10Settings",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Q10Settings")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Q10Settings":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Q10Settings"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Q10Settings",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Q10Settings",
    ):
        if self.type is not None and "type" not in already_processed:
            already_processed.add("type")
            outfile.write(
                " type=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.type), input_name="type"
                        )
                    ),
                )
            )
        if self.fixed_q10 is not None and "fixed_q10" not in already_processed:
            already_processed.add("fixed_q10")
            outfile.write(
                " fixedQ10=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.fixed_q10), input_name="fixedQ10"
                        )
                    ),
                )
            )
        if self.q10_factor is not None and "q10_factor" not in already_processed:
            already_processed.add("q10_factor")
            outfile.write(
                " q10Factor=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.q10_factor), input_name="q10Factor"
                        )
                    ),
                )
            )
        if (
            self.experimental_temp is not None
            and "experimental_temp" not in already_processed
        ):
            already_processed.add("experimental_temp")
            outfile.write(
                " experimentalTemp=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.experimental_temp),
                            input_name="experimentalTemp",
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Q10Settings",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.type, "type")
        self.gds_check_cardinality_(self.type, "type", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_none, self.fixed_q10, "fixed_q10"
        )
        self.gds_check_cardinality_(self.fixed_q10, "fixed_q10", required=False)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_none, self.q10_factor, "q10_factor"
        )
        self.gds_check_cardinality_(self.q10_factor, "q10_factor", required=False)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_temperature,
            self.experimental_temp,
            "experimental_temp",
        )
        self.gds_check_cardinality_(
            self.experimental_temp, "experimental_temp", required=False
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type = value
            self.validate_NmlId(self.type)  # validate type NmlId
        value = find_attr_value_("fixedQ10", node)
        if value is not None and "fixedQ10" not in already_processed:
            already_processed.add("fixedQ10")
            self.fixed_q10 = value
            self.validate_Nml2Quantity_none(
                self.fixed_q10
            )  # validate type Nml2Quantity_none
        value = find_attr_value_("q10Factor", node)
        if value is not None and "q10Factor" not in already_processed:
            already_processed.add("q10Factor")
            self.q10_factor = value
            self.validate_Nml2Quantity_none(
                self.q10_factor
            )  # validate type Nml2Quantity_none
        value = find_attr_value_("experimentalTemp", node)
        if value is not None and "experimentalTemp" not in already_processed:
            already_processed.add("experimentalTemp")
            self.experimental_temp = value
            self.validate_Nml2Quantity_temperature(
                self.experimental_temp
            )  # validate type Nml2Quantity_temperature

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        pass


# end class Q10Settings


class VariableParameter(GeneratedsSuper):
    """VariableParameter -- Specifies a **parameter**  ( e. g. condDensity ) which can vary its value across a **segmentGroup.**  The value is calculated from **value**  attribute of the  **inhomogeneousValue**  subelement. This element is normally a child of  **channelDensityNonUniform** ,  **channelDensityNonUniformNernst**  or  **channelDensityNonUniformGHK**  and is used to calculate the value of the conductance, etc. which will vary on different parts of the cell. The **segmentGroup**  specified here needs to define an  **inhomogeneousParameter**  ( referenced from **inhomogeneousParameter**  in the  **inhomogeneousValue**  ), which calculates a **variable**  ( e. g. p ) varying across the cell ( e. g. based on the path length from soma ), which is then used in the **value**  attribute of the  **inhomogeneousValue**  ( so for example condDensity = f( p ) )"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "parameter", "xs:string", 0, 0, {"use": "required", "name": "parameter"}
        ),
        MemberSpec_(
            "segment_groups",
            "xs:string",
            0,
            0,
            {"use": "required", "name": "segment_groups"},
        ),
        MemberSpec_(
            "inhomogeneous_value",
            "InhomogeneousValue",
            0,
            1,
            {
                "minOccurs": "0",
                "name": "inhomogeneousValue",
                "type": "InhomogeneousValue",
            },
            None,
        ),
    ]
    subclass = None
    superclass = None

    def __init__(
        self,
        parameter: "a string (required)" = None,
        segment_groups: "a string (required)" = None,
        inhomogeneous_value: "a InhomogeneousValue (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.parameter = _cast(None, parameter)
        self.parameter_nsprefix_ = None
        self.segment_groups = _cast(None, segment_groups)
        self.segment_groups_nsprefix_ = None
        self.inhomogeneous_value = inhomogeneous_value
        self.inhomogeneous_value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, VariableParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableParameter.subclass:
            return VariableParameter.subclass(*args_, **kwargs_)
        else:
            return VariableParameter(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if self.inhomogeneous_value is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="VariableParameter",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("VariableParameter")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "VariableParameter":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="VariableParameter",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="VariableParameter",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="VariableParameter",
    ):
        if self.parameter is not None and "parameter" not in already_processed:
            already_processed.add("parameter")
            outfile.write(
                " parameter=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.parameter), input_name="parameter"
                        )
                    ),
                )
            )
        if (
            self.segment_groups is not None
            and "segment_groups" not in already_processed
        ):
            already_processed.add("segment_groups")
            outfile.write(
                " segmentGroup=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segment_groups), input_name="segmentGroup"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="VariableParameter",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.inhomogeneous_value is not None:
            namespaceprefix_ = (
                self.inhomogeneous_value_nsprefix_ + ":"
                if (UseCapturedNS_ and self.inhomogeneous_value_nsprefix_)
                else ""
            )
            self.inhomogeneous_value.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="inhomogeneousValue",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.parameter, "parameter"
        )
        self.gds_check_cardinality_(self.parameter, "parameter", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.segment_groups, "segment_groups"
        )
        self.gds_check_cardinality_(
            self.segment_groups, "segment_groups", required=True
        )
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.inhomogeneous_value, "inhomogeneous_value", min_occurs=0, max_occurs=1
        )
        if recursive:
            if self.inhomogeneous_value is not None:
                self.inhomogeneous_value.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("parameter", node)
        if value is not None and "parameter" not in already_processed:
            already_processed.add("parameter")
            self.parameter = value
        value = find_attr_value_("segmentGroup", node)
        if value is not None and "segmentGroup" not in already_processed:
            already_processed.add("segmentGroup")
            self.segment_groups = value

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "inhomogeneousValue":
            obj_ = InhomogeneousValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inhomogeneous_value = obj_
            obj_.original_tagname_ = "inhomogeneousValue"


# end class VariableParameter


class BaseWithoutId(GeneratedsSuper):
    """BaseWithoutId -- Base element without ID specified *yet*, e.g. for an element with a particular requirement on its id which does not comply with NmlId (e.g. Segment needs nonNegativeInteger)."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = None

    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BaseWithoutId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseWithoutId.subclass:
            return BaseWithoutId.subclass(*args_, **kwargs_)
        else:
            return BaseWithoutId(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseWithoutId",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BaseWithoutId")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BaseWithoutId":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="BaseWithoutId"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BaseWithoutId",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BaseWithoutId",
    ):
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseWithoutId",
        fromsubclass_=False,
        pretty_print=True,
    ):
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        pass


# end class BaseWithoutId


class BaseNonNegativeIntegerId(BaseWithoutId):
    """BaseNonNegativeIntegerId -- Anything which can have a unique (within its parent) id, which must be an integer zero or greater."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "id", "NonNegativeInteger", 0, 0, {"use": "required", "name": "id"}
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BaseNonNegativeIntegerId"), self).__init__(
            extensiontype_, **kwargs_
        )
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseNonNegativeIntegerId
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseNonNegativeIntegerId.subclass:
            return BaseNonNegativeIntegerId.subclass(*args_, **kwargs_)
        else:
            return BaseNonNegativeIntegerId(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def _hasContent(self):
        if super(BaseNonNegativeIntegerId, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseNonNegativeIntegerId",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BaseNonNegativeIntegerId")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BaseNonNegativeIntegerId":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseNonNegativeIntegerId",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BaseNonNegativeIntegerId",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BaseNonNegativeIntegerId",
    ):
        super(BaseNonNegativeIntegerId, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseNonNegativeIntegerId",
        )
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(
                ' id="%s"' % self.gds_format_integer(self.id, input_name="id")
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseNonNegativeIntegerId",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BaseNonNegativeIntegerId, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NonNegativeInteger, self.id, "id")
        self.gds_check_cardinality_(self.id, "id", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = self.gds_parse_integer(value, node, "id")
            if self.id < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
            self.validate_NonNegativeInteger(
                self.id
            )  # validate type NonNegativeInteger
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(BaseNonNegativeIntegerId, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BaseNonNegativeIntegerId, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class BaseNonNegativeIntegerId


class Base(BaseWithoutId):
    """Base -- Anything which can have a unique (within its parent) id of the form NmlId (spaceless combination of letters, numbers and underscore)."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("id", "NmlId", 0, 0, {"use": "required", "name": "id"}),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Base"), self).__init__(extensiontype_, **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Base)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Base.subclass:
            return Base.subclass(*args_, **kwargs_)
        else:
            return Base(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if super(Base, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Base",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Base")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Base":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Base"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Base",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Base"
    ):
        super(Base, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Base"
        )
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(
                " id=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.id), input_name="id")
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Base",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Base, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.id, "id")
        self.gds_check_cardinality_(self.id, "id", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = value
            self.validate_NmlId(self.id)  # validate type NmlId
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(Base, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Base, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class Base


class Standalone(Base):
    """Standalone -- Elements which can stand alone and be referenced by id, e.g. cell, morphology."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("metaid", "MetaId", 0, 1, {"use": "optional", "name": "metaid"}),
        MemberSpec_(
            "notes",
            ["Notes", "xs:string"],
            0,
            1,
            {"minOccurs": "0", "name": "notes", "type": "xs:string"},
            None,
        ),
        MemberSpec_(
            "properties",
            "Property",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "property",
                "type": "Property",
            },
            None,
        ),
        MemberSpec_(
            "annotation",
            "Annotation",
            0,
            1,
            {"minOccurs": "0", "name": "annotation", "type": "Annotation"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Standalone"), self).__init__(id, extensiontype_, **kwargs_)
        self.metaid = _cast(None, metaid)
        self.metaid_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        if properties is None:
            self.properties = []
        else:
            self.properties = properties
        self.properties_nsprefix_ = None
        self.annotation = annotation
        self.annotation_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Standalone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Standalone.subclass:
            return Standalone.subclass(*args_, **kwargs_)
        else:
            return Standalone(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_MetaId(self, value):
        # Validate type MetaId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_MetaId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_MetaId_patterns_,
                    )
                )

    validate_MetaId_patterns_ = [["^([a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if (
            self.notes is not None
            or self.properties
            or self.annotation is not None
            or super(Standalone, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Standalone",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Standalone")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Standalone":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Standalone"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Standalone",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Standalone"
    ):
        super(Standalone, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Standalone"
        )
        if self.metaid is not None and "metaid" not in already_processed:
            already_processed.add("metaid")
            outfile.write(
                " metaid=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.metaid), input_name="metaid"
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Standalone",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Standalone, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.notes is not None:
            namespaceprefix_ = (
                self.notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%snotes>%s</%snotes>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.notes), input_name="notes"
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        for property_ in self.properties:
            namespaceprefix_ = (
                self.properties_nsprefix_ + ":"
                if (UseCapturedNS_ and self.properties_nsprefix_)
                else ""
            )
            property_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="property",
                pretty_print=pretty_print,
            )
        if self.annotation is not None:
            namespaceprefix_ = (
                self.annotation_nsprefix_ + ":"
                if (UseCapturedNS_ and self.annotation_nsprefix_)
                else ""
            )
            self.annotation.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="annotation",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_MetaId, self.metaid, "metaid")
        self.gds_check_cardinality_(self.metaid, "metaid", required=False)
        # validate simple type children
        self.gds_validate_defined_ST_(self.validate_Notes, self.notes, "notes")
        self.gds_check_cardinality_(self.notes, "notes", min_occurs=0, max_occurs=1)
        # validate complex type children
        self.gds_check_cardinality_(
            self.properties, "properties", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.annotation, "annotation", min_occurs=0, max_occurs=1
        )
        if recursive:
            for item in self.properties:
                item.validate_(gds_collector, recursive=True)
            if self.annotation is not None:
                self.annotation.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("metaid", node)
        if value is not None and "metaid" not in already_processed:
            already_processed.add("metaid")
            self.metaid = value
            self.validate_MetaId(self.metaid)  # validate type MetaId
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(Standalone, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "notes":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "notes")
            value_ = self.gds_validate_string(value_, node, "notes")
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == "property":
            obj_ = Property.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.properties.append(obj_)
            obj_.original_tagname_ = "property"
        elif nodeName_ == "annotation":
            obj_ = Annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = "annotation"
        super(Standalone, self)._buildChildren(child_, node, nodeName_, True)


# end class Standalone


class SpikeSourcePoisson(Standalone):
    """SpikeSourcePoisson -- Spike source, generating spikes according to a Poisson process.
    \n
    :param start:
    :type start: time
    :param duration:
    :type duration: time
    :param rate:
    :type rate: per_time

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "start", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "start"}
        ),
        MemberSpec_(
            "duration",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "duration"},
        ),
        MemberSpec_(
            "rate", "Nml2Quantity_pertime", 0, 0, {"use": "required", "name": "rate"}
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        start: "a Nml2Quantity_time (required)" = None,
        duration: "a Nml2Quantity_time (required)" = None,
        rate: "a Nml2Quantity_pertime (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SpikeSourcePoisson"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.start = _cast(None, start)
        self.start_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.rate = _cast(None, rate)
        self.rate_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpikeSourcePoisson
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeSourcePoisson.subclass:
            return SpikeSourcePoisson.subclass(*args_, **kwargs_)
        else:
            return SpikeSourcePoisson(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_pertime_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_pertime_patterns_,
                    )
                )

    validate_Nml2Quantity_pertime_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$"]
    ]

    def _hasContent(self):
        if super(SpikeSourcePoisson, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpikeSourcePoisson",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SpikeSourcePoisson")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SpikeSourcePoisson":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="SpikeSourcePoisson",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SpikeSourcePoisson",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SpikeSourcePoisson",
    ):
        super(SpikeSourcePoisson, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="SpikeSourcePoisson",
        )
        if self.start is not None and "start" not in already_processed:
            already_processed.add("start")
            outfile.write(
                " start=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.start), input_name="start"
                        )
                    ),
                )
            )
        if self.duration is not None and "duration" not in already_processed:
            already_processed.add("duration")
            outfile.write(
                " duration=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.duration), input_name="duration"
                        )
                    ),
                )
            )
        if self.rate is not None and "rate" not in already_processed:
            already_processed.add("rate")
            outfile.write(
                " rate=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.rate), input_name="rate"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpikeSourcePoisson",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SpikeSourcePoisson, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.start, "start"
        )
        self.gds_check_cardinality_(self.start, "start", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.duration, "duration"
        )
        self.gds_check_cardinality_(self.duration, "duration", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_pertime, self.rate, "rate"
        )
        self.gds_check_cardinality_(self.rate, "rate", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("start", node)
        if value is not None and "start" not in already_processed:
            already_processed.add("start")
            self.start = value
            self.validate_Nml2Quantity_time(
                self.start
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("duration", node)
        if value is not None and "duration" not in already_processed:
            already_processed.add("duration")
            self.duration = value
            self.validate_Nml2Quantity_time(
                self.duration
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("rate", node)
        if value is not None and "rate" not in already_processed:
            already_processed.add("rate")
            self.rate = value
            self.validate_Nml2Quantity_pertime(
                self.rate
            )  # validate type Nml2Quantity_pertime
        super(SpikeSourcePoisson, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SpikeSourcePoisson, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class SpikeSourcePoisson


class Input(BaseNonNegativeIntegerId):
    """Input -- Specifies a single input to a **target,**  optionally giving the **segmentId**  ( default 0 ) and **fractionAlong**  the segment ( default 0. 5 )."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("target", "xs:string", 0, 0, {"use": "required", "name": "target"}),
        MemberSpec_(
            "destination", "NmlId", 0, 0, {"use": "required", "name": "destination"}
        ),
        MemberSpec_(
            "segment_id",
            "NonNegativeInteger",
            0,
            1,
            {"use": "optional", "name": "segment_id"},
        ),
        MemberSpec_(
            "fraction_along",
            "ZeroToOne",
            0,
            1,
            {"use": "optional", "name": "fraction_along"},
        ),
    ]
    subclass = None
    superclass = BaseNonNegativeIntegerId

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        target: "a string (required)" = None,
        destination: "a NmlId (required)" = None,
        segment_id: "a NonNegativeInteger (optional)" = None,
        fraction_along: "a ZeroToOne (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Input"), self).__init__(id, extensiontype_, **kwargs_)
        self.target = _cast(None, target)
        self.target_nsprefix_ = None
        self.destination = _cast(None, destination)
        self.destination_nsprefix_ = None
        self.segment_id = _cast(int, segment_id)
        self.segment_id_nsprefix_ = None
        self.fraction_along = _cast(float, fraction_along)
        self.fraction_along_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Input)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Input.subclass:
            return Input.subclass(*args_, **kwargs_)
        else:
            return Input(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def validate_ZeroToOne(self, value):
        # Validate type ZeroToOne, a restriction on xs:float.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ZeroToOne'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ZeroToOne'
                    % {"value": value, "lineno": lineno}
                )
                result = False

    def _hasContent(self):
        if super(Input, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Input",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Input")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Input":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Input"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Input",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Input"
    ):
        super(Input, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Input"
        )
        if self.target is not None and "target" not in already_processed:
            already_processed.add("target")
            outfile.write(
                " target=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.target), input_name="target"
                        )
                    ),
                )
            )
        if self.destination is not None and "destination" not in already_processed:
            already_processed.add("destination")
            outfile.write(
                " destination=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.destination), input_name="destination"
                        )
                    ),
                )
            )
        if self.segment_id is not None and "segment_id" not in already_processed:
            already_processed.add("segment_id")
            outfile.write(
                ' segmentId="%s"'
                % self.gds_format_integer(self.segment_id, input_name="segmentId")
            )
        if (
            self.fraction_along is not None
            and "fraction_along" not in already_processed
        ):
            already_processed.add("fraction_along")
            outfile.write(
                ' fractionAlong="%s"'
                % self.gds_format_float(self.fraction_along, input_name="fractionAlong")
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Input",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Input, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.target, "target")
        self.gds_check_cardinality_(self.target, "target", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.destination, "destination"
        )
        self.gds_check_cardinality_(self.destination, "destination", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NonNegativeInteger, self.segment_id, "segment_id"
        )
        self.gds_check_cardinality_(self.segment_id, "segment_id", required=False)
        self.gds_validate_defined_ST_(
            self.validate_ZeroToOne, self.fraction_along, "fraction_along"
        )
        self.gds_check_cardinality_(
            self.fraction_along, "fraction_along", required=False
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("target", node)
        if value is not None and "target" not in already_processed:
            already_processed.add("target")
            self.target = value
        value = find_attr_value_("destination", node)
        if value is not None and "destination" not in already_processed:
            already_processed.add("destination")
            self.destination = value
            self.validate_NmlId(self.destination)  # validate type NmlId
        value = find_attr_value_("segmentId", node)
        if value is not None and "segmentId" not in already_processed:
            already_processed.add("segmentId")
            self.segment_id = self.gds_parse_integer(value, node, "segmentId")
            if self.segment_id < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
            self.validate_NonNegativeInteger(
                self.segment_id
            )  # validate type NonNegativeInteger
        value = find_attr_value_("fractionAlong", node)
        if value is not None and "fractionAlong" not in already_processed:
            already_processed.add("fractionAlong")
            value = self.gds_parse_float(value, node, "fractionAlong")
            self.fraction_along = value
            self.validate_ZeroToOne(self.fraction_along)  # validate type ZeroToOne
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(Input, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Input, self)._buildChildren(child_, node, nodeName_, True)
        pass

    def _get_cell_id(self, id_string):
        if "[" in id_string:
            return int(id_string.split("[")[1].split("]")[0])
        else:
            return int(id_string.split("/")[2])

    def get_target_cell_id(self):
        """Get ID of target cell."""

        return self._get_cell_id(self.target)

    def get_segment_id(self):
        """Get the ID of the segment.

        Returns 0 if segment_id was not set.
        """
        return int(self.segment_id) if self.segment_id else 0

    def get_fraction_along(self):
        """Get fraction along.

        Returns 0.5 is fraction_along was not set.
        """

        return float(self.fraction_along) if self.fraction_along else 0.5

    def __str__(self):
        return (
            "Input "
            + str(self.id)
            + ": "
            + str(self.get_target_cell_id())
            + ":"
            + str(self.get_segment_id())
            + "("
            + "%.6f" % self.get_fraction_along()
            + ")"
        )

    # end class Input


class InputList(Base):
    """InputList -- An explicit list of  **input** s to a **population.**"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "populations", "NmlId", 0, 0, {"use": "required", "name": "populations"}
        ),
        MemberSpec_(
            "component", "NmlId", 0, 0, {"use": "required", "name": "component"}
        ),
        MemberSpec_(
            "input",
            "Input",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "input",
                "type": "Input",
            },
            None,
        ),
        MemberSpec_(
            "input_ws",
            "InputW",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "inputW",
                "type": "InputW",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        populations: "a NmlId (required)" = None,
        component: "a NmlId (required)" = None,
        input: "list of Input(s) (optional)" = None,
        input_ws: "list of InputW(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("InputList"), self).__init__(id, **kwargs_)
        self.populations = _cast(None, populations)
        self.populations_nsprefix_ = None
        self.component = _cast(None, component)
        self.component_nsprefix_ = None
        if input is None:
            self.input = []
        else:
            self.input = input
        self.input_nsprefix_ = None
        if input_ws is None:
            self.input_ws = []
        else:
            self.input_ws = input_ws
        self.input_ws_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, InputList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InputList.subclass:
            return InputList.subclass(*args_, **kwargs_)
        else:
            return InputList(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if self.input or self.input_ws or super(InputList, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="InputList",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("InputList")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "InputList":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="InputList"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="InputList",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="InputList"
    ):
        super(InputList, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="InputList"
        )
        if self.populations is not None and "populations" not in already_processed:
            already_processed.add("populations")
            outfile.write(
                " population=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.populations), input_name="population"
                        )
                    ),
                )
            )
        if self.component is not None and "component" not in already_processed:
            already_processed.add("component")
            outfile.write(
                " component=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.component), input_name="component"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="InputList",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(InputList, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for input_ in self.input:
            namespaceprefix_ = (
                self.input_nsprefix_ + ":"
                if (UseCapturedNS_ and self.input_nsprefix_)
                else ""
            )
            input_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="input",
                pretty_print=pretty_print,
            )
        for inputW_ in self.input_ws:
            namespaceprefix_ = (
                self.input_ws_nsprefix_ + ":"
                if (UseCapturedNS_ and self.input_ws_nsprefix_)
                else ""
            )
            inputW_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="inputW",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.populations, "populations"
        )
        self.gds_check_cardinality_(self.populations, "populations", required=True)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.component, "component")
        self.gds_check_cardinality_(self.component, "component", required=True)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.input, "input", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.input_ws, "input_ws", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.input:
                item.validate_(gds_collector, recursive=True)
            for item in self.input_ws:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("population", node)
        if value is not None and "population" not in already_processed:
            already_processed.add("population")
            self.populations = value
            self.validate_NmlId(self.populations)  # validate type NmlId
        value = find_attr_value_("component", node)
        if value is not None and "component" not in already_processed:
            already_processed.add("component")
            self.component = value
            self.validate_NmlId(self.component)  # validate type NmlId
        super(InputList, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "input":
            class_obj_ = self.get_class_obj_(child_, Input)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.input.append(obj_)
            obj_.original_tagname_ = "input"
        elif nodeName_ == "inputW":
            obj_ = InputW.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.input_ws.append(obj_)
            obj_.original_tagname_ = "inputW"
        super(InputList, self)._buildChildren(child_, node, nodeName_, True)

    def exportHdf5(self, h5file, h5Group):
        """Export to HDF5 file."""
        # print("Exporting InputList: "+str(self.id)+" as HDF5")

        ilGroup = h5file.create_group(h5Group, "inputList_" + self.id)
        ilGroup._f_setattr("id", self.id)
        ilGroup._f_setattr("component", self.component)
        ilGroup._f_setattr("population", self.populations)

        cols = 4

        extra_cols = {}

        num_tot = len(self.input) + len(self.input_ws)

        if len(self.input_ws) > 0:
            extra_cols["column_" + str(cols)] = "weight"
            cols += 1

        # print("Exporting "+str(num_tot)+" inputs")
        a = numpy.zeros([num_tot, cols], numpy.float32)

        count = 0

        for input in self.input:
            a[count, 0] = input.id
            a[count, 1] = input.get_target_cell_id()
            a[count, 2] = input.get_segment_id()
            a[count, 3] = input.get_fraction_along()
            count += 1

        for input in self.input_ws:
            a[count, 0] = input.id
            a[count, 1] = input.get_target_cell_id()
            a[count, 2] = input.get_segment_id()
            a[count, 3] = input.get_fraction_along()
            a[count, 4] = input.get_weight()
            count += 1

        array = h5file.create_carray(
            ilGroup, self.id, obj=a, title="Locations of inputs in " + self.id
        )

        array._f_setattr("column_0", "id")
        array._f_setattr("column_1", "target_cell_id")
        array._f_setattr("column_2", "segment_id")
        array._f_setattr("column_3", "fraction_along")
        for k in extra_cols:
            array._f_setattr(k, extra_cols[k])

    def __str__(self):
        return (
            "Input list: "
            + self.id
            + " to "
            + self.populations
            + ", component "
            + self.component
        )

    # end class InputList


class ExplicitInput(BaseWithoutId):
    """ExplicitInput -- An explicit input ( anything which extends  **basePointCurrent**  ) to a target cell in a population"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("target", "xs:string", 0, 0, {"use": "required", "name": "target"}),
        MemberSpec_("input", "xs:string", 0, 0, {"use": "required", "name": "input"}),
        MemberSpec_(
            "destination", "xs:string", 0, 1, {"use": "optional", "name": "destination"}
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        target: "a string (required)" = None,
        input: "a string (required)" = None,
        destination: "a string (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ExplicitInput"), self).__init__(**kwargs_)
        self.target = _cast(None, target)
        self.target_nsprefix_ = None
        self.input = _cast(None, input)
        self.input_nsprefix_ = None
        self.destination = _cast(None, destination)
        self.destination_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ExplicitInput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExplicitInput.subclass:
            return ExplicitInput.subclass(*args_, **kwargs_)
        else:
            return ExplicitInput(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(ExplicitInput, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ExplicitInput",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ExplicitInput")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ExplicitInput":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ExplicitInput"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ExplicitInput",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ExplicitInput",
    ):
        super(ExplicitInput, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ExplicitInput"
        )
        if self.target is not None and "target" not in already_processed:
            already_processed.add("target")
            outfile.write(
                " target=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.target), input_name="target"
                        )
                    ),
                )
            )
        if self.input is not None and "input" not in already_processed:
            already_processed.add("input")
            outfile.write(
                " input=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.input), input_name="input"
                        )
                    ),
                )
            )
        if self.destination is not None and "destination" not in already_processed:
            already_processed.add("destination")
            outfile.write(
                " destination=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.destination), input_name="destination"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ExplicitInput",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ExplicitInput, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.target, "target")
        self.gds_check_cardinality_(self.target, "target", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.input, "input")
        self.gds_check_cardinality_(self.input, "input", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.destination, "destination"
        )
        self.gds_check_cardinality_(self.destination, "destination", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("target", node)
        if value is not None and "target" not in already_processed:
            already_processed.add("target")
            self.target = value
        value = find_attr_value_("input", node)
        if value is not None and "input" not in already_processed:
            already_processed.add("input")
            self.input = value
        value = find_attr_value_("destination", node)
        if value is not None and "destination" not in already_processed:
            already_processed.add("destination")
            self.destination = value
        super(ExplicitInput, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ExplicitInput, self)._buildChildren(child_, node, nodeName_, True)
        pass

    def _get_cell_id(self, id_string):
        if "[" in id_string:
            return int(id_string.split("[")[1].split("]")[0])
        else:
            return int(id_string.split("/")[2])

    def get_target_cell_id(self):
        """Get ID of target cell."""

        return self._get_cell_id(self.target)

    def get_segment_id(self):
        """Get the ID of the segment.

        Returns 0 if segment_id was not set.
        """
        return int(self.segment_id) if self.segment_id else 0

    def get_fraction_along(self):
        """Get fraction along.

        Returns 0.5 is fraction_along was not set.
        """

        return float(self.fraction_along) if self.fraction_along else 0.5

    def __str__(self):
        return (
            "Input "
            + str(self.id)
            + ": "
            + str(self.get_target_cell_id())
            + ":"
            + str(self.get_segment_id())
            + "("
            + "%.6f" % self.get_fraction_along()
            + ")"
        )

    def get_target_cell_id(
        self,
    ):
        """Get target cell ID"""
        if "[" in self.target:
            return int(self.target.split("[")[1].split("]")[0])
        else:
            return int(self.target.split("/")[2])

    def get_target_population(
        self,
    ):
        """Get target population."""
        if "[" in self.target:
            return self.target.split("[")[0]
        else:
            return self.target.split("/")[0]

    def __str__(self):
        dest = self.destination if self.destination else "unspecified"
        return (
            "Explicit Input of type "
            + str(self.input)
            + " to "
            + self.get_target_population()
            + "(cell "
            + str(self.get_target_cell_id())
            + "), destination: "
            + dest
        )

    # end class ExplicitInput


class BaseConnection(BaseNonNegativeIntegerId):
    """BaseConnection -- Base of all synaptic connections (chemical/electrical/analog, etc.) inside projections"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "neuro_lex_id",
            "NeuroLexId",
            0,
            1,
            {"use": "optional", "name": "neuro_lex_id"},
        ),
    ]
    subclass = None
    superclass = BaseNonNegativeIntegerId

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BaseConnection"), self).__init__(
            id, extensiontype_, **kwargs_
        )
        self.neuro_lex_id = _cast(None, neuro_lex_id)
        self.neuro_lex_id_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BaseConnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseConnection.subclass:
            return BaseConnection.subclass(*args_, **kwargs_)
        else:
            return BaseConnection(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NeuroLexId(self, value):
        # Validate type NeuroLexId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NeuroLexId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NeuroLexId_patterns_,
                    )
                )

    validate_NeuroLexId_patterns_ = [["^([a-zA-Z0-9_:]*)$"]]

    def _hasContent(self):
        if super(BaseConnection, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseConnection",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BaseConnection")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BaseConnection":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="BaseConnection"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BaseConnection",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BaseConnection",
    ):
        super(BaseConnection, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="BaseConnection"
        )
        if self.neuro_lex_id is not None and "neuro_lex_id" not in already_processed:
            already_processed.add("neuro_lex_id")
            outfile.write(
                " neuroLexId=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.neuro_lex_id), input_name="neuroLexId"
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseConnection",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BaseConnection, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NeuroLexId, self.neuro_lex_id, "neuro_lex_id"
        )
        self.gds_check_cardinality_(self.neuro_lex_id, "neuro_lex_id", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("neuroLexId", node)
        if value is not None and "neuroLexId" not in already_processed:
            already_processed.add("neuroLexId")
            self.neuro_lex_id = value
            self.validate_NeuroLexId(self.neuro_lex_id)  # validate type NeuroLexId
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(BaseConnection, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BaseConnection, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class BaseConnection


class BaseProjection(Base):
    """BaseProjection -- Base for projection (set of synaptic connections) between two populations"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "presynaptic_population",
            "NmlId",
            0,
            0,
            {"use": "required", "name": "presynaptic_population"},
        ),
        MemberSpec_(
            "postsynaptic_population",
            "NmlId",
            0,
            0,
            {"use": "required", "name": "postsynaptic_population"},
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        presynaptic_population: "a NmlId (required)" = None,
        postsynaptic_population: "a NmlId (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BaseProjection"), self).__init__(
            id, extensiontype_, **kwargs_
        )
        self.presynaptic_population = _cast(None, presynaptic_population)
        self.presynaptic_population_nsprefix_ = None
        self.postsynaptic_population = _cast(None, postsynaptic_population)
        self.postsynaptic_population_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BaseProjection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseProjection.subclass:
            return BaseProjection.subclass(*args_, **kwargs_)
        else:
            return BaseProjection(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if super(BaseProjection, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseProjection",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BaseProjection")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BaseProjection":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="BaseProjection"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BaseProjection",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BaseProjection",
    ):
        super(BaseProjection, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="BaseProjection"
        )
        if (
            self.presynaptic_population is not None
            and "presynaptic_population" not in already_processed
        ):
            already_processed.add("presynaptic_population")
            outfile.write(
                " presynapticPopulation=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.presynaptic_population),
                            input_name="presynapticPopulation",
                        )
                    ),
                )
            )
        if (
            self.postsynaptic_population is not None
            and "postsynaptic_population" not in already_processed
        ):
            already_processed.add("postsynaptic_population")
            outfile.write(
                " postsynapticPopulation=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.postsynaptic_population),
                            input_name="postsynapticPopulation",
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseProjection",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BaseProjection, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.presynaptic_population, "presynaptic_population"
        )
        self.gds_check_cardinality_(
            self.presynaptic_population, "presynaptic_population", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.postsynaptic_population, "postsynaptic_population"
        )
        self.gds_check_cardinality_(
            self.postsynaptic_population, "postsynaptic_population", required=True
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("presynapticPopulation", node)
        if value is not None and "presynapticPopulation" not in already_processed:
            already_processed.add("presynapticPopulation")
            self.presynaptic_population = value
            self.validate_NmlId(self.presynaptic_population)  # validate type NmlId
        value = find_attr_value_("postsynapticPopulation", node)
        if value is not None and "postsynapticPopulation" not in already_processed:
            already_processed.add("postsynapticPopulation")
            self.postsynaptic_population = value
            self.validate_NmlId(self.postsynaptic_population)  # validate type NmlId
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(BaseProjection, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BaseProjection, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class BaseProjection


class SynapticConnection(BaseWithoutId):
    """SynapticConnection -- Explicit event connection between named components, which gets processed via a new instance of a **synapse**  component which is created on the target component"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "neuro_lex_id",
            "NeuroLexId",
            0,
            1,
            {"use": "optional", "name": "neuro_lex_id"},
        ),
        MemberSpec_("from_", "xs:string", 0, 0, {"use": "required", "name": "from_"}),
        MemberSpec_("to", "xs:string", 0, 0, {"use": "required", "name": "to"}),
        MemberSpec_(
            "synapse", "xs:string", 0, 0, {"use": "required", "name": "synapse"}
        ),
        MemberSpec_(
            "destination", "NmlId", 0, 1, {"use": "optional", "name": "destination"}
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        from_: "a string (required)" = None,
        to: "a string (required)" = None,
        synapse: "a string (required)" = None,
        destination: "a NmlId (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SynapticConnection"), self).__init__(**kwargs_)
        self.neuro_lex_id = _cast(None, neuro_lex_id)
        self.neuro_lex_id_nsprefix_ = None
        self.from_ = _cast(None, from_)
        self.from__nsprefix_ = None
        self.to = _cast(None, to)
        self.to_nsprefix_ = None
        self.synapse = _cast(None, synapse)
        self.synapse_nsprefix_ = None
        self.destination = _cast(None, destination)
        self.destination_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SynapticConnection
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SynapticConnection.subclass:
            return SynapticConnection.subclass(*args_, **kwargs_)
        else:
            return SynapticConnection(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NeuroLexId(self, value):
        # Validate type NeuroLexId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NeuroLexId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NeuroLexId_patterns_,
                    )
                )

    validate_NeuroLexId_patterns_ = [["^([a-zA-Z0-9_:]*)$"]]

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if super(SynapticConnection, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SynapticConnection",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SynapticConnection")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SynapticConnection":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="SynapticConnection",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SynapticConnection",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SynapticConnection",
    ):
        super(SynapticConnection, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="SynapticConnection",
        )
        if self.neuro_lex_id is not None and "neuro_lex_id" not in already_processed:
            already_processed.add("neuro_lex_id")
            outfile.write(
                " neuroLexId=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.neuro_lex_id), input_name="neuroLexId"
                        )
                    ),
                )
            )
        if self.from_ is not None and "from_" not in already_processed:
            already_processed.add("from_")
            outfile.write(
                " from=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.from_), input_name="from"
                        )
                    ),
                )
            )
        if self.to is not None and "to" not in already_processed:
            already_processed.add("to")
            outfile.write(
                " to=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.to), input_name="to")
                    ),
                )
            )
        if self.synapse is not None and "synapse" not in already_processed:
            already_processed.add("synapse")
            outfile.write(
                " synapse=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.synapse), input_name="synapse"
                        )
                    ),
                )
            )
        if self.destination is not None and "destination" not in already_processed:
            already_processed.add("destination")
            outfile.write(
                " destination=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.destination), input_name="destination"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SynapticConnection",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SynapticConnection, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NeuroLexId, self.neuro_lex_id, "neuro_lex_id"
        )
        self.gds_check_cardinality_(self.neuro_lex_id, "neuro_lex_id", required=False)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.from_, "from_")
        self.gds_check_cardinality_(self.from_, "from_", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.to, "to")
        self.gds_check_cardinality_(self.to, "to", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.synapse, "synapse")
        self.gds_check_cardinality_(self.synapse, "synapse", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.destination, "destination"
        )
        self.gds_check_cardinality_(self.destination, "destination", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("neuroLexId", node)
        if value is not None and "neuroLexId" not in already_processed:
            already_processed.add("neuroLexId")
            self.neuro_lex_id = value
            self.validate_NeuroLexId(self.neuro_lex_id)  # validate type NeuroLexId
        value = find_attr_value_("from", node)
        if value is not None and "from" not in already_processed:
            already_processed.add("from")
            self.from_ = value
        value = find_attr_value_("to", node)
        if value is not None and "to" not in already_processed:
            already_processed.add("to")
            self.to = value
        value = find_attr_value_("synapse", node)
        if value is not None and "synapse" not in already_processed:
            already_processed.add("synapse")
            self.synapse = value
        value = find_attr_value_("destination", node)
        if value is not None and "destination" not in already_processed:
            already_processed.add("destination")
            self.destination = value
            self.validate_NmlId(self.destination)  # validate type NmlId
        super(SynapticConnection, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SynapticConnection, self)._buildChildren(child_, node, nodeName_, True)
        pass

    def _get_cell_id(self, ref):
        """Get cell ID"""
        if "[" in ref:
            return int(ref.split("[")[1].split("]")[0])
        else:
            return int(ref.split("/")[2])

    def _get_population(self, ref):
        """Get population"""
        if "[" in ref:
            return ref.split("[")[0]
        else:
            return ref.split("/")[0]

    def __str__(self):
        dest = self.destination if self.destination else "unspecified"
        return (
            "Synaptic connection from "
            + str(self._get_population(self.from_))
            + "(cell "
            + str(self._get_cell_id(self.from_))
            + ") -> "
            + str(self._get_population(self.to))
            + "(cell "
            + str(self._get_cell_id(self.to))
            + "), syn: "
            + self.synapse
            + ", destination: "
            + dest
        )

    # end class SynapticConnection


class CellSet(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("select", "xs:string", 0, 0, {"use": "required", "name": "select"}),
        MemberSpec_(
            "__ANY__",
            "__ANY__",
            1,
            1,
            {"maxOccurs": "unbounded", "minOccurs": "0", "processContents": "skip"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        select: "a string (required)" = None,
        anytypeobjs_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("CellSet"), self).__init__(id, **kwargs_)
        self.select = _cast(None, select)
        self.select_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CellSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CellSet.subclass:
            return CellSet.subclass(*args_, **kwargs_)
        else:
            return CellSet(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if self.anytypeobjs_ or super(CellSet, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="CellSet",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CellSet")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CellSet":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="CellSet"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CellSet",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="CellSet"
    ):
        super(CellSet, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="CellSet"
        )
        if self.select is not None and "select" not in already_processed:
            already_processed.add("select")
            outfile.write(
                " select=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.select), input_name="select"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="CellSet",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(CellSet, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write("\n")

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.select, "select")
        self.gds_check_cardinality_(self.select, "select", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("select", node)
        if value is not None and "select" not in already_processed:
            already_processed.add("select")
            self.select = value
        super(CellSet, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        content_ = self.gds_build_any(child_, "CellSet")
        self.anytypeobjs_.append(content_)
        super(CellSet, self)._buildChildren(child_, node, nodeName_, True)


# end class CellSet


class Location(BaseWithoutId):
    """Location -- Specifies the ( x, y, z ) location of a single  **instance**  of a component in a  **population**
    \n
    :param x:
    :type x: none
    :param y:
    :type y: none
    :param z:
    :type z: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("x", "xs:float", 0, 0, {"use": "required", "name": "x"}),
        MemberSpec_("y", "xs:float", 0, 0, {"use": "required", "name": "y"}),
        MemberSpec_("z", "xs:float", 0, 0, {"use": "required", "name": "z"}),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        x: "a float (required)" = None,
        y: "a float (required)" = None,
        z: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Location"), self).__init__(**kwargs_)
        self.x = _cast(float, x)
        self.x_nsprefix_ = None
        self.y = _cast(float, y)
        self.y_nsprefix_ = None
        self.z = _cast(float, z)
        self.z_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Location)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Location.subclass:
            return Location.subclass(*args_, **kwargs_)
        else:
            return Location(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(Location, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Location",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Location")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Location":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Location"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Location",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Location"
    ):
        super(Location, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Location"
        )
        if self.x is not None and "x" not in already_processed:
            already_processed.add("x")
            outfile.write(' x="%s"' % self.gds_format_float(self.x, input_name="x"))
        if self.y is not None and "y" not in already_processed:
            already_processed.add("y")
            outfile.write(' y="%s"' % self.gds_format_float(self.y, input_name="y"))
        if self.z is not None and "z" not in already_processed:
            already_processed.add("z")
            outfile.write(' z="%s"' % self.gds_format_float(self.z, input_name="z"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Location",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Location, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.x, "x")
        self.gds_check_cardinality_(self.x, "x", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.y, "y")
        self.gds_check_cardinality_(self.y, "y", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.z, "z")
        self.gds_check_cardinality_(self.z, "z", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("x", node)
        if value is not None and "x" not in already_processed:
            already_processed.add("x")
            value = self.gds_parse_float(value, node, "x")
            self.x = value
        value = find_attr_value_("y", node)
        if value is not None and "y" not in already_processed:
            already_processed.add("y")
            value = self.gds_parse_float(value, node, "y")
            self.y = value
        value = find_attr_value_("z", node)
        if value is not None and "z" not in already_processed:
            already_processed.add("z")
            value = self.gds_parse_float(value, node, "z")
            self.z = value
        super(Location, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Location, self)._buildChildren(child_, node, nodeName_, True)
        pass

    def _format(self, value):
        if int(value) == value:
            return str(int(value))
        else:
            return "%.4f" % value

    def __str__(self):
        return (
            "("
            + self._format(self.x)
            + ", "
            + self._format(self.y)
            + ", "
            + self._format(self.z)
            + ")"
        )

    def __repr__(self):
        return str(self)


# end class Location


class Instance(BaseWithoutId):
    """Instance -- Specifies a single instance of a component in a  **population**  ( placed at  **location**  )."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "id", "xs:nonNegativeInteger", 0, 1, {"use": "optional", "name": "id"}
        ),
        MemberSpec_(
            "i", "xs:nonNegativeInteger", 0, 1, {"use": "optional", "name": "i"}
        ),
        MemberSpec_(
            "j", "xs:nonNegativeInteger", 0, 1, {"use": "optional", "name": "j"}
        ),
        MemberSpec_(
            "k", "xs:nonNegativeInteger", 0, 1, {"use": "optional", "name": "k"}
        ),
        MemberSpec_(
            "location", "Location", 0, 0, {"name": "location", "type": "Location"}, None
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        id: "a nonNegativeInteger (optional)" = None,
        i: "a nonNegativeInteger (optional)" = None,
        j: "a nonNegativeInteger (optional)" = None,
        k: "a nonNegativeInteger (optional)" = None,
        location: "a Location (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Instance"), self).__init__(**kwargs_)
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.i = _cast(int, i)
        self.i_nsprefix_ = None
        self.j = _cast(int, j)
        self.j_nsprefix_ = None
        self.k = _cast(int, k)
        self.k_nsprefix_ = None
        self.location = location
        self.location_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Instance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Instance.subclass:
            return Instance.subclass(*args_, **kwargs_)
        else:
            return Instance(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if self.location is not None or super(Instance, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Instance",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Instance")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Instance":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Instance"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Instance",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Instance"
    ):
        super(Instance, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Instance"
        )
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(
                ' id="%s"' % self.gds_format_integer(self.id, input_name="id")
            )
        if self.i is not None and "i" not in already_processed:
            already_processed.add("i")
            outfile.write(' i="%s"' % self.gds_format_integer(self.i, input_name="i"))
        if self.j is not None and "j" not in already_processed:
            already_processed.add("j")
            outfile.write(' j="%s"' % self.gds_format_integer(self.j, input_name="j"))
        if self.k is not None and "k" not in already_processed:
            already_processed.add("k")
            outfile.write(' k="%s"' % self.gds_format_integer(self.k, input_name="k"))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Instance",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Instance, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.location is not None:
            namespaceprefix_ = (
                self.location_nsprefix_ + ":"
                if (UseCapturedNS_ and self.location_nsprefix_)
                else ""
            )
            self.location.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="location",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_integer, self.id, "id")
        self.gds_check_cardinality_(self.id, "id", required=False)
        self.gds_validate_builtin_ST_(self.gds_validate_integer, self.i, "i")
        self.gds_check_cardinality_(self.i, "i", required=False)
        self.gds_validate_builtin_ST_(self.gds_validate_integer, self.j, "j")
        self.gds_check_cardinality_(self.j, "j", required=False)
        self.gds_validate_builtin_ST_(self.gds_validate_integer, self.k, "k")
        self.gds_check_cardinality_(self.k, "k", required=False)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.location, "location", min_occurs=1, max_occurs=1
        )
        if recursive:
            if self.location is not None:
                self.location.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = self.gds_parse_integer(value, node, "id")
            if self.id < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
        value = find_attr_value_("i", node)
        if value is not None and "i" not in already_processed:
            already_processed.add("i")
            self.i = self.gds_parse_integer(value, node, "i")
            if self.i < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
        value = find_attr_value_("j", node)
        if value is not None and "j" not in already_processed:
            already_processed.add("j")
            self.j = self.gds_parse_integer(value, node, "j")
            if self.j < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
        value = find_attr_value_("k", node)
        if value is not None and "k" not in already_processed:
            already_processed.add("k")
            self.k = self.gds_parse_integer(value, node, "k")
            if self.k < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
        super(Instance, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "location":
            obj_ = Location.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = "location"
        super(Instance, self)._buildChildren(child_, node, nodeName_, True)

    def __str__(self):
        return (
            "Instance "
            + str(self.id)
            + (" at location: " + str(self.location) if self.location else "")
        )

    def __repr__(self):
        return str(self)


# end class Instance


class GridLayout(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "x_size",
            "xs:nonNegativeInteger",
            0,
            1,
            {"use": "optional", "name": "x_size"},
        ),
        MemberSpec_(
            "y_size",
            "xs:nonNegativeInteger",
            0,
            1,
            {"use": "optional", "name": "y_size"},
        ),
        MemberSpec_(
            "z_size",
            "xs:nonNegativeInteger",
            0,
            1,
            {"use": "optional", "name": "z_size"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        x_size: "a nonNegativeInteger (optional)" = None,
        y_size: "a nonNegativeInteger (optional)" = None,
        z_size: "a nonNegativeInteger (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("GridLayout"), self).__init__(**kwargs_)
        self.x_size = _cast(int, x_size)
        self.x_size_nsprefix_ = None
        self.y_size = _cast(int, y_size)
        self.y_size_nsprefix_ = None
        self.z_size = _cast(int, z_size)
        self.z_size_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GridLayout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GridLayout.subclass:
            return GridLayout.subclass(*args_, **kwargs_)
        else:
            return GridLayout(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(GridLayout, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="GridLayout",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GridLayout")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GridLayout":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GridLayout"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GridLayout",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="GridLayout"
    ):
        super(GridLayout, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GridLayout"
        )
        if self.x_size is not None and "x_size" not in already_processed:
            already_processed.add("x_size")
            outfile.write(
                ' xSize="%s"' % self.gds_format_integer(self.x_size, input_name="xSize")
            )
        if self.y_size is not None and "y_size" not in already_processed:
            already_processed.add("y_size")
            outfile.write(
                ' ySize="%s"' % self.gds_format_integer(self.y_size, input_name="ySize")
            )
        if self.z_size is not None and "z_size" not in already_processed:
            already_processed.add("z_size")
            outfile.write(
                ' zSize="%s"' % self.gds_format_integer(self.z_size, input_name="zSize")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="GridLayout",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(GridLayout, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_integer, self.x_size, "x_size")
        self.gds_check_cardinality_(self.x_size, "x_size", required=False)
        self.gds_validate_builtin_ST_(self.gds_validate_integer, self.y_size, "y_size")
        self.gds_check_cardinality_(self.y_size, "y_size", required=False)
        self.gds_validate_builtin_ST_(self.gds_validate_integer, self.z_size, "z_size")
        self.gds_check_cardinality_(self.z_size, "z_size", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("xSize", node)
        if value is not None and "xSize" not in already_processed:
            already_processed.add("xSize")
            self.x_size = self.gds_parse_integer(value, node, "xSize")
            if self.x_size < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
        value = find_attr_value_("ySize", node)
        if value is not None and "ySize" not in already_processed:
            already_processed.add("ySize")
            self.y_size = self.gds_parse_integer(value, node, "ySize")
            if self.y_size < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
        value = find_attr_value_("zSize", node)
        if value is not None and "zSize" not in already_processed:
            already_processed.add("zSize")
            self.z_size = self.gds_parse_integer(value, node, "zSize")
            if self.z_size < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
        super(GridLayout, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(GridLayout, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class GridLayout


class RandomLayout(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "number",
            "xs:nonNegativeInteger",
            0,
            1,
            {"use": "optional", "name": "number"},
        ),
        MemberSpec_("regions", "NmlId", 0, 1, {"use": "optional", "name": "regions"}),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        number: "a nonNegativeInteger (optional)" = None,
        regions: "a NmlId (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("RandomLayout"), self).__init__(**kwargs_)
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.regions = _cast(None, regions)
        self.regions_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, RandomLayout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RandomLayout.subclass:
            return RandomLayout.subclass(*args_, **kwargs_)
        else:
            return RandomLayout(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if super(RandomLayout, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="RandomLayout",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("RandomLayout")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "RandomLayout":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="RandomLayout"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="RandomLayout",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="RandomLayout",
    ):
        super(RandomLayout, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="RandomLayout"
        )
        if self.number is not None and "number" not in already_processed:
            already_processed.add("number")
            outfile.write(
                ' number="%s"'
                % self.gds_format_integer(self.number, input_name="number")
            )
        if self.regions is not None and "regions" not in already_processed:
            already_processed.add("regions")
            outfile.write(
                " region=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.regions), input_name="region"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="RandomLayout",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(RandomLayout, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_integer, self.number, "number")
        self.gds_check_cardinality_(self.number, "number", required=False)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.regions, "regions")
        self.gds_check_cardinality_(self.regions, "regions", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("number", node)
        if value is not None and "number" not in already_processed:
            already_processed.add("number")
            self.number = self.gds_parse_integer(value, node, "number")
            if self.number < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
        value = find_attr_value_("region", node)
        if value is not None and "region" not in already_processed:
            already_processed.add("region")
            self.regions = value
            self.validate_NmlId(self.regions)  # validate type NmlId
        super(RandomLayout, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(RandomLayout, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class RandomLayout


class UnstructuredLayout(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "number",
            "xs:nonNegativeInteger",
            0,
            1,
            {"use": "optional", "name": "number"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        number: "a nonNegativeInteger (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("UnstructuredLayout"), self).__init__(**kwargs_)
        self.number = _cast(int, number)
        self.number_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnstructuredLayout
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnstructuredLayout.subclass:
            return UnstructuredLayout.subclass(*args_, **kwargs_)
        else:
            return UnstructuredLayout(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(UnstructuredLayout, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="UnstructuredLayout",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("UnstructuredLayout")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "UnstructuredLayout":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="UnstructuredLayout",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="UnstructuredLayout",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="UnstructuredLayout",
    ):
        super(UnstructuredLayout, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="UnstructuredLayout",
        )
        if self.number is not None and "number" not in already_processed:
            already_processed.add("number")
            outfile.write(
                ' number="%s"'
                % self.gds_format_integer(self.number, input_name="number")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="UnstructuredLayout",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(UnstructuredLayout, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_integer, self.number, "number")
        self.gds_check_cardinality_(self.number, "number", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("number", node)
        if value is not None and "number" not in already_processed:
            already_processed.add("number")
            self.number = self.gds_parse_integer(value, node, "number")
            if self.number < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
        super(UnstructuredLayout, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(UnstructuredLayout, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class UnstructuredLayout


class Layout(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("spaces", "NmlId", 0, 1, {"use": "optional", "name": "spaces"}),
        MemberSpec_(
            "random",
            "RandomLayout",
            0,
            0,
            {"name": "random", "type": "RandomLayout"},
            5,
        ),
        MemberSpec_(
            "grid", "GridLayout", 0, 0, {"name": "grid", "type": "GridLayout"}, 5
        ),
        MemberSpec_(
            "unstructured",
            "UnstructuredLayout",
            0,
            0,
            {"name": "unstructured", "type": "UnstructuredLayout"},
            5,
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        spaces: "a NmlId (optional)" = None,
        random: "a RandomLayout (required)" = None,
        grid: "a GridLayout (required)" = None,
        unstructured: "a UnstructuredLayout (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Layout"), self).__init__(**kwargs_)
        self.spaces = _cast(None, spaces)
        self.spaces_nsprefix_ = None
        self.random = random
        self.random_nsprefix_ = None
        self.grid = grid
        self.grid_nsprefix_ = None
        self.unstructured = unstructured
        self.unstructured_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Layout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Layout.subclass:
            return Layout.subclass(*args_, **kwargs_)
        else:
            return Layout(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if (
            self.random is not None
            or self.grid is not None
            or self.unstructured is not None
            or super(Layout, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Layout",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Layout")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Layout":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Layout"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Layout",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Layout"
    ):
        super(Layout, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Layout"
        )
        if self.spaces is not None and "spaces" not in already_processed:
            already_processed.add("spaces")
            outfile.write(
                " space=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.spaces), input_name="space"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Layout",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Layout, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.random is not None:
            namespaceprefix_ = (
                self.random_nsprefix_ + ":"
                if (UseCapturedNS_ and self.random_nsprefix_)
                else ""
            )
            self.random.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="random",
                pretty_print=pretty_print,
            )
        if self.grid is not None:
            namespaceprefix_ = (
                self.grid_nsprefix_ + ":"
                if (UseCapturedNS_ and self.grid_nsprefix_)
                else ""
            )
            self.grid.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="grid",
                pretty_print=pretty_print,
            )
        if self.unstructured is not None:
            namespaceprefix_ = (
                self.unstructured_nsprefix_ + ":"
                if (UseCapturedNS_ and self.unstructured_nsprefix_)
                else ""
            )
            self.unstructured.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="unstructured",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.spaces, "spaces")
        self.gds_check_cardinality_(self.spaces, "spaces", required=False)
        # validate simple type children
        # validate complex type children
        # cardinality check omitted for choice item random
        # self.gds_check_cardinality_(self.random, 'random', min_occurs=1, max_occurs=1)
        # cardinality check omitted for choice item grid
        # self.gds_check_cardinality_(self.grid, 'grid', min_occurs=1, max_occurs=1)
        # cardinality check omitted for choice item unstructured
        # self.gds_check_cardinality_(self.unstructured, 'unstructured', min_occurs=1, max_occurs=1)
        if recursive:
            if self.random is not None:
                self.random.validate_(gds_collector, recursive=True)
            if self.grid is not None:
                self.grid.validate_(gds_collector, recursive=True)
            if self.unstructured is not None:
                self.unstructured.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("space", node)
        if value is not None and "space" not in already_processed:
            already_processed.add("space")
            self.spaces = value
            self.validate_NmlId(self.spaces)  # validate type NmlId
        super(Layout, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "random":
            obj_ = RandomLayout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.random = obj_
            obj_.original_tagname_ = "random"
        elif nodeName_ == "grid":
            obj_ = GridLayout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.grid = obj_
            obj_.original_tagname_ = "grid"
        elif nodeName_ == "unstructured":
            obj_ = UnstructuredLayout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unstructured = obj_
            obj_.original_tagname_ = "unstructured"
        super(Layout, self)._buildChildren(child_, node, nodeName_, True)


# end class Layout


class Population(Standalone):
    """Population -- A population of components, with just one parameter for the **size,**  i. e. number of components to create. Note: quite often this is used with type= **populationList**  which means the size is determined by the number of  **instance** s ( with  **location** s ) in the list. The **size**  attribute is still set, and there will be a validation error if this does not match the number in the list.
    \n
    :param size: Number of instances of this Component to create when the population is instantiated
    :type size: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "component", "NmlId", 0, 0, {"use": "required", "name": "component"}
        ),
        MemberSpec_(
            "size", "NonNegativeInteger", 0, 1, {"use": "optional", "name": "size"}
        ),
        MemberSpec_(
            "type", "populationTypes", 0, 1, {"use": "optional", "name": "type"}
        ),
        MemberSpec_(
            "extracellular_properties",
            "NmlId",
            0,
            1,
            {"use": "optional", "name": "extracellular_properties"},
        ),
        MemberSpec_(
            "neuro_lex_id",
            "NeuroLexId",
            0,
            1,
            {"use": "optional", "name": "neuro_lex_id"},
        ),
        MemberSpec_(
            "layout",
            "Layout",
            0,
            1,
            {"minOccurs": "0", "name": "layout", "type": "Layout"},
            4,
        ),
        MemberSpec_(
            "instances",
            "Instance",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "instance", "type": "Instance"},
            4,
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        component: "a NmlId (required)" = None,
        size: "a NonNegativeInteger (optional)" = None,
        type: "a populationTypes (optional)" = None,
        extracellular_properties: "a NmlId (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        layout: "a Layout (optional)" = None,
        instances: "list of Instance(s) (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Population"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.component = _cast(None, component)
        self.component_nsprefix_ = None
        self.size = _cast(int, size)
        self.size_nsprefix_ = None
        self.type = _cast(None, type)
        self.type_nsprefix_ = None
        self.extracellular_properties = _cast(None, extracellular_properties)
        self.extracellular_properties_nsprefix_ = None
        self.neuro_lex_id = _cast(None, neuro_lex_id)
        self.neuro_lex_id_nsprefix_ = None
        self.layout = layout
        self.layout_nsprefix_ = None
        if instances is None:
            self.instances = []
        else:
            self.instances = instances
        self.instances_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Population)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Population.subclass:
            return Population.subclass(*args_, **kwargs_)
        else:
            return Population(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def validate_populationTypes(self, value):
        # Validate type populationTypes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = ["population", "populationList"]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on populationTypes'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False

    def validate_NeuroLexId(self, value):
        # Validate type NeuroLexId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NeuroLexId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NeuroLexId_patterns_,
                    )
                )

    validate_NeuroLexId_patterns_ = [["^([a-zA-Z0-9_:]*)$"]]

    def _hasContent(self):
        if (
            self.layout is not None
            or self.instances
            or super(Population, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Population",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Population")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Population":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Population"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Population",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Population"
    ):
        super(Population, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Population"
        )
        if self.component is not None and "component" not in already_processed:
            already_processed.add("component")
            outfile.write(
                " component=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.component), input_name="component"
                        )
                    ),
                )
            )
        if self.size is not None and "size" not in already_processed:
            already_processed.add("size")
            outfile.write(
                ' size="%s"' % self.gds_format_integer(self.size, input_name="size")
            )
        if self.type is not None and "type" not in already_processed:
            already_processed.add("type")
            outfile.write(
                " type=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.type), input_name="type"
                        )
                    ),
                )
            )
        if (
            self.extracellular_properties is not None
            and "extracellular_properties" not in already_processed
        ):
            already_processed.add("extracellular_properties")
            outfile.write(
                " extracellularProperties=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.extracellular_properties),
                            input_name="extracellularProperties",
                        )
                    ),
                )
            )
        if self.neuro_lex_id is not None and "neuro_lex_id" not in already_processed:
            already_processed.add("neuro_lex_id")
            outfile.write(
                " neuroLexId=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.neuro_lex_id), input_name="neuroLexId"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Population",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Population, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.layout is not None:
            namespaceprefix_ = (
                self.layout_nsprefix_ + ":"
                if (UseCapturedNS_ and self.layout_nsprefix_)
                else ""
            )
            self.layout.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="layout",
                pretty_print=pretty_print,
            )
        for instance_ in self.instances:
            namespaceprefix_ = (
                self.instances_nsprefix_ + ":"
                if (UseCapturedNS_ and self.instances_nsprefix_)
                else ""
            )
            instance_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="instance",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.component, "component")
        self.gds_check_cardinality_(self.component, "component", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NonNegativeInteger, self.size, "size"
        )
        self.gds_check_cardinality_(self.size, "size", required=False)
        self.gds_validate_defined_ST_(self.validate_populationTypes, self.type, "type")
        self.gds_check_cardinality_(self.type, "type", required=False)
        self.gds_validate_defined_ST_(
            self.validate_NmlId,
            self.extracellular_properties,
            "extracellular_properties",
        )
        self.gds_check_cardinality_(
            self.extracellular_properties, "extracellular_properties", required=False
        )
        self.gds_validate_defined_ST_(
            self.validate_NeuroLexId, self.neuro_lex_id, "neuro_lex_id"
        )
        self.gds_check_cardinality_(self.neuro_lex_id, "neuro_lex_id", required=False)
        # validate simple type children
        # validate complex type children
        # cardinality check omitted for choice item layout
        # self.gds_check_cardinality_(self.layout, 'layout', min_occurs=0, max_occurs=1)
        # cardinality check omitted for choice item instances
        # self.gds_check_cardinality_(self.instances, 'instances', min_occurs=1, max_occurs=9999999)
        if recursive:
            if self.layout is not None:
                self.layout.validate_(gds_collector, recursive=True)
            for item in self.instances:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("component", node)
        if value is not None and "component" not in already_processed:
            already_processed.add("component")
            self.component = value
            self.validate_NmlId(self.component)  # validate type NmlId
        value = find_attr_value_("size", node)
        if value is not None and "size" not in already_processed:
            already_processed.add("size")
            self.size = self.gds_parse_integer(value, node, "size")
            if self.size < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
            self.validate_NonNegativeInteger(
                self.size
            )  # validate type NonNegativeInteger
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type = value
            self.validate_populationTypes(self.type)  # validate type populationTypes
        value = find_attr_value_("extracellularProperties", node)
        if value is not None and "extracellularProperties" not in already_processed:
            already_processed.add("extracellularProperties")
            self.extracellular_properties = value
            self.validate_NmlId(self.extracellular_properties)  # validate type NmlId
        value = find_attr_value_("neuroLexId", node)
        if value is not None and "neuroLexId" not in already_processed:
            already_processed.add("neuroLexId")
            self.neuro_lex_id = value
            self.validate_NeuroLexId(self.neuro_lex_id)  # validate type NeuroLexId
        super(Population, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "layout":
            obj_ = Layout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.layout = obj_
            obj_.original_tagname_ = "layout"
        elif nodeName_ == "instance":
            obj_ = Instance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instances.append(obj_)
            obj_.original_tagname_ = "instance"
        super(Population, self)._buildChildren(child_, node, nodeName_, True)

    def exportHdf5(self, h5file, h5Group):
        """Export to HDF5 file."""
        # print("Exporting Population: "+str(self.id)+" as HDF5")

        popGroup = h5file.create_group(h5Group, "population_" + self.id)
        popGroup._f_setattr("id", self.id)
        popGroup._f_setattr("component", self.component)
        for p in self.properties:
            popGroup._f_setattr("property:" + p.tag, p.value)

        if len(self.instances) > 0:
            colCount = 3
            a = numpy.zeros([len(self.instances), colCount], numpy.float32)

            count = 0
            for instance in self.instances:
                a[count, 0] = instance.location.x
                a[count, 1] = instance.location.y
                a[count, 2] = instance.location.z

                count = count + 1

            popGroup._f_setattr("size", count)
            popGroup._f_setattr("type", "populationList")

            array = h5file.create_carray(
                popGroup, self.id, obj=a, title="Locations of cells in " + self.id
            )
            array._f_setattr("column_0", "x")
            array._f_setattr("column_1", "y")
            array._f_setattr("column_2", "z")

        else:
            popGroup._f_setattr("size", self.size)

    def get_size(self):
        return (
            len(self.instances)
            if len(self.instances) > 0
            else (self.size if self.size else 0)
        )

    def __str__(self):
        return (
            "Population: "
            + str(self.id)
            + " with "
            + str(self.get_size())
            + " components of type "
            + (self.component if self.component else "???")
        )

    # end class Population


class Region(Base):
    """Region -- Initial attempt to specify 3D region for placing cells. Work in progress. . ."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("spaces", "NmlId", 0, 1, {"use": "optional", "name": "spaces"}),
        MemberSpec_(
            "__ANY__",
            "__ANY__",
            1,
            1,
            {"maxOccurs": "unbounded", "minOccurs": "0", "processContents": "skip"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        spaces: "a NmlId (optional)" = None,
        anytypeobjs_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Region"), self).__init__(id, **kwargs_)
        self.spaces = _cast(None, spaces)
        self.spaces_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Region)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Region.subclass:
            return Region.subclass(*args_, **kwargs_)
        else:
            return Region(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if self.anytypeobjs_ or super(Region, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Region",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Region")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Region":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Region"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Region",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Region"
    ):
        super(Region, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Region"
        )
        if self.spaces is not None and "spaces" not in already_processed:
            already_processed.add("spaces")
            outfile.write(
                " space=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.spaces), input_name="space"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Region",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Region, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write("\n")

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.spaces, "spaces")
        self.gds_check_cardinality_(self.spaces, "spaces", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("space", node)
        if value is not None and "space" not in already_processed:
            already_processed.add("space")
            self.spaces = value
            self.validate_NmlId(self.spaces)  # validate type NmlId
        super(Region, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        content_ = self.gds_build_any(child_, "Region")
        self.anytypeobjs_.append(content_)
        super(Region, self)._buildChildren(child_, node, nodeName_, True)


# end class Region


class SpaceStructure(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "x_spacing", "xs:float", 0, 1, {"use": "optional", "name": "x_spacing"}
        ),
        MemberSpec_(
            "y_spacing", "xs:float", 0, 1, {"use": "optional", "name": "y_spacing"}
        ),
        MemberSpec_(
            "z_spacing", "xs:float", 0, 1, {"use": "optional", "name": "z_spacing"}
        ),
        MemberSpec_(
            "x_start", "xs:float", 0, 1, {"use": "optional", "name": "x_start"}
        ),
        MemberSpec_(
            "y_start", "xs:float", 0, 1, {"use": "optional", "name": "y_start"}
        ),
        MemberSpec_(
            "z_start", "xs:float", 0, 1, {"use": "optional", "name": "z_start"}
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        x_spacing: "a float (optional)" = None,
        y_spacing: "a float (optional)" = None,
        z_spacing: "a float (optional)" = None,
        x_start: "a float (optional)" = 0,
        y_start: "a float (optional)" = 0,
        z_start: "a float (optional)" = 0,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SpaceStructure"), self).__init__(**kwargs_)
        self.x_spacing = _cast(float, x_spacing)
        self.x_spacing_nsprefix_ = None
        self.y_spacing = _cast(float, y_spacing)
        self.y_spacing_nsprefix_ = None
        self.z_spacing = _cast(float, z_spacing)
        self.z_spacing_nsprefix_ = None
        self.x_start = _cast(float, x_start)
        self.x_start_nsprefix_ = None
        self.y_start = _cast(float, y_start)
        self.y_start_nsprefix_ = None
        self.z_start = _cast(float, z_start)
        self.z_start_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SpaceStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpaceStructure.subclass:
            return SpaceStructure.subclass(*args_, **kwargs_)
        else:
            return SpaceStructure(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(SpaceStructure, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpaceStructure",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SpaceStructure")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SpaceStructure":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SpaceStructure"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SpaceStructure",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SpaceStructure",
    ):
        super(SpaceStructure, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SpaceStructure"
        )
        if self.x_spacing is not None and "x_spacing" not in already_processed:
            already_processed.add("x_spacing")
            outfile.write(
                ' xSpacing="%s"'
                % self.gds_format_float(self.x_spacing, input_name="xSpacing")
            )
        if self.y_spacing is not None and "y_spacing" not in already_processed:
            already_processed.add("y_spacing")
            outfile.write(
                ' ySpacing="%s"'
                % self.gds_format_float(self.y_spacing, input_name="ySpacing")
            )
        if self.z_spacing is not None and "z_spacing" not in already_processed:
            already_processed.add("z_spacing")
            outfile.write(
                ' zSpacing="%s"'
                % self.gds_format_float(self.z_spacing, input_name="zSpacing")
            )
        if self.x_start != 0 and "x_start" not in already_processed:
            already_processed.add("x_start")
            outfile.write(
                ' xStart="%s"'
                % self.gds_format_float(self.x_start, input_name="xStart")
            )
        if self.y_start != 0 and "y_start" not in already_processed:
            already_processed.add("y_start")
            outfile.write(
                ' yStart="%s"'
                % self.gds_format_float(self.y_start, input_name="yStart")
            )
        if self.z_start != 0 and "z_start" not in already_processed:
            already_processed.add("z_start")
            outfile.write(
                ' zStart="%s"'
                % self.gds_format_float(self.z_start, input_name="zStart")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpaceStructure",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SpaceStructure, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(
            self.gds_validate_float, self.x_spacing, "x_spacing"
        )
        self.gds_check_cardinality_(self.x_spacing, "x_spacing", required=False)
        self.gds_validate_builtin_ST_(
            self.gds_validate_float, self.y_spacing, "y_spacing"
        )
        self.gds_check_cardinality_(self.y_spacing, "y_spacing", required=False)
        self.gds_validate_builtin_ST_(
            self.gds_validate_float, self.z_spacing, "z_spacing"
        )
        self.gds_check_cardinality_(self.z_spacing, "z_spacing", required=False)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.x_start, "x_start")
        self.gds_check_cardinality_(self.x_start, "x_start", required=False)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.y_start, "y_start")
        self.gds_check_cardinality_(self.y_start, "y_start", required=False)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.z_start, "z_start")
        self.gds_check_cardinality_(self.z_start, "z_start", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("xSpacing", node)
        if value is not None and "xSpacing" not in already_processed:
            already_processed.add("xSpacing")
            value = self.gds_parse_float(value, node, "xSpacing")
            self.x_spacing = value
        value = find_attr_value_("ySpacing", node)
        if value is not None and "ySpacing" not in already_processed:
            already_processed.add("ySpacing")
            value = self.gds_parse_float(value, node, "ySpacing")
            self.y_spacing = value
        value = find_attr_value_("zSpacing", node)
        if value is not None and "zSpacing" not in already_processed:
            already_processed.add("zSpacing")
            value = self.gds_parse_float(value, node, "zSpacing")
            self.z_spacing = value
        value = find_attr_value_("xStart", node)
        if value is not None and "xStart" not in already_processed:
            already_processed.add("xStart")
            value = self.gds_parse_float(value, node, "xStart")
            self.x_start = value
        value = find_attr_value_("yStart", node)
        if value is not None and "yStart" not in already_processed:
            already_processed.add("yStart")
            value = self.gds_parse_float(value, node, "yStart")
            self.y_start = value
        value = find_attr_value_("zStart", node)
        if value is not None and "zStart" not in already_processed:
            already_processed.add("zStart")
            value = self.gds_parse_float(value, node, "zStart")
            self.z_start = value
        super(SpaceStructure, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SpaceStructure, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class SpaceStructure


class Space(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "based_on", "allowedSpaces", 0, 1, {"use": "optional", "name": "based_on"}
        ),
        MemberSpec_(
            "structure",
            "SpaceStructure",
            0,
            1,
            {"minOccurs": "0", "name": "structure", "type": "SpaceStructure"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        based_on: "a allowedSpaces (optional)" = None,
        structure: "a SpaceStructure (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Space"), self).__init__(id, **kwargs_)
        self.based_on = _cast(None, based_on)
        self.based_on_nsprefix_ = None
        self.structure = structure
        self.structure_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Space)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Space.subclass:
            return Space.subclass(*args_, **kwargs_)
        else:
            return Space(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_allowedSpaces(self, value):
        # Validate type allowedSpaces, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "Euclidean_1D",
                "Euclidean_2D",
                "Euclidean_3D",
                "Grid_1D",
                "Grid_2D",
                "Grid_3D",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on allowedSpaces'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False

    def _hasContent(self):
        if self.structure is not None or super(Space, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Space",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Space")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Space":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Space"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Space",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Space"
    ):
        super(Space, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Space"
        )
        if self.based_on is not None and "based_on" not in already_processed:
            already_processed.add("based_on")
            outfile.write(
                " basedOn=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.based_on), input_name="basedOn"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Space",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Space, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.structure is not None:
            namespaceprefix_ = (
                self.structure_nsprefix_ + ":"
                if (UseCapturedNS_ and self.structure_nsprefix_)
                else ""
            )
            self.structure.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="structure",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_allowedSpaces, self.based_on, "based_on"
        )
        self.gds_check_cardinality_(self.based_on, "based_on", required=False)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.structure, "structure", min_occurs=0, max_occurs=1
        )
        if recursive:
            if self.structure is not None:
                self.structure.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("basedOn", node)
        if value is not None and "basedOn" not in already_processed:
            already_processed.add("basedOn")
            self.based_on = value
            self.validate_allowedSpaces(self.based_on)  # validate type allowedSpaces
        super(Space, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "structure":
            obj_ = SpaceStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.structure = obj_
            obj_.original_tagname_ = "structure"
        super(Space, self)._buildChildren(child_, node, nodeName_, True)


# end class Space


class Network(Standalone):
    """Network -- Network containing:  **population** s ( potentially of type  **populationList** , and so specifying a list of cell  **location** s );  **projection** s ( with lists of  **connection** s ) and/or  **explicitConnection** s; and  **inputList** s ( with lists of  **input** s ) and/or  **explicitInput** s. Note: often in NeuroML this will be of type  **networkWithTemperature**  if there are temperature dependent elements ( e. g. ion channels )."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("type", "networkTypes", 0, 1, {"use": "optional", "name": "type"}),
        MemberSpec_(
            "temperature",
            "Nml2Quantity_temperature",
            0,
            1,
            {"use": "optional", "name": "temperature"},
        ),
        MemberSpec_(
            "neuro_lex_id",
            "NeuroLexId",
            0,
            1,
            {"use": "optional", "name": "neuro_lex_id"},
        ),
        MemberSpec_(
            "spaces",
            "Space",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "space",
                "type": "Space",
            },
            None,
        ),
        MemberSpec_(
            "regions",
            "Region",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "region",
                "type": "Region",
            },
            None,
        ),
        MemberSpec_(
            "extracellular_properties",
            "ExtracellularPropertiesLocal",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "extracellularProperties",
                "type": "ExtracellularPropertiesLocal",
            },
            None,
        ),
        MemberSpec_(
            "populations",
            "Population",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "population", "type": "Population"},
            None,
        ),
        MemberSpec_(
            "cell_sets",
            "CellSet",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "cellSet",
                "type": "CellSet",
            },
            None,
        ),
        MemberSpec_(
            "synaptic_connections",
            "SynapticConnection",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "synapticConnection",
                "type": "SynapticConnection",
            },
            None,
        ),
        MemberSpec_(
            "projections",
            "Projection",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "projection",
                "type": "Projection",
            },
            None,
        ),
        MemberSpec_(
            "electrical_projections",
            "ElectricalProjection",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "electricalProjection",
                "type": "ElectricalProjection",
            },
            None,
        ),
        MemberSpec_(
            "continuous_projections",
            "ContinuousProjection",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "continuousProjection",
                "type": "ContinuousProjection",
            },
            None,
        ),
        MemberSpec_(
            "explicit_inputs",
            "ExplicitInput",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "explicitInput",
                "type": "ExplicitInput",
            },
            None,
        ),
        MemberSpec_(
            "input_lists",
            "InputList",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "inputList",
                "type": "InputList",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        type: "a networkTypes (optional)" = None,
        temperature: "a Nml2Quantity_temperature (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        spaces: "list of Space(s) (optional)" = None,
        regions: "list of Region(s) (optional)" = None,
        extracellular_properties: "list of ExtracellularPropertiesLocal(s) (optional)" = None,
        populations: "list of Population(s) (required)" = None,
        cell_sets: "list of CellSet(s) (optional)" = None,
        synaptic_connections: "list of SynapticConnection(s) (optional)" = None,
        projections: "list of Projection(s) (optional)" = None,
        electrical_projections: "list of ElectricalProjection(s) (optional)" = None,
        continuous_projections: "list of ContinuousProjection(s) (optional)" = None,
        explicit_inputs: "list of ExplicitInput(s) (optional)" = None,
        input_lists: "list of InputList(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Network"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.type = _cast(None, type)
        self.type_nsprefix_ = None
        self.temperature = _cast(None, temperature)
        self.temperature_nsprefix_ = None
        self.neuro_lex_id = _cast(None, neuro_lex_id)
        self.neuro_lex_id_nsprefix_ = None
        if spaces is None:
            self.spaces = []
        else:
            self.spaces = spaces
        self.spaces_nsprefix_ = None
        if regions is None:
            self.regions = []
        else:
            self.regions = regions
        self.regions_nsprefix_ = None
        if extracellular_properties is None:
            self.extracellular_properties = []
        else:
            self.extracellular_properties = extracellular_properties
        self.extracellular_properties_nsprefix_ = None
        if populations is None:
            self.populations = []
        else:
            self.populations = populations
        self.populations_nsprefix_ = None
        if cell_sets is None:
            self.cell_sets = []
        else:
            self.cell_sets = cell_sets
        self.cell_sets_nsprefix_ = None
        if synaptic_connections is None:
            self.synaptic_connections = []
        else:
            self.synaptic_connections = synaptic_connections
        self.synaptic_connections_nsprefix_ = None
        if projections is None:
            self.projections = []
        else:
            self.projections = projections
        self.projections_nsprefix_ = None
        if electrical_projections is None:
            self.electrical_projections = []
        else:
            self.electrical_projections = electrical_projections
        self.electrical_projections_nsprefix_ = None
        if continuous_projections is None:
            self.continuous_projections = []
        else:
            self.continuous_projections = continuous_projections
        self.continuous_projections_nsprefix_ = None
        if explicit_inputs is None:
            self.explicit_inputs = []
        else:
            self.explicit_inputs = explicit_inputs
        self.explicit_inputs_nsprefix_ = None
        if input_lists is None:
            self.input_lists = []
        else:
            self.input_lists = input_lists
        self.input_lists_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Network)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Network.subclass:
            return Network.subclass(*args_, **kwargs_)
        else:
            return Network(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_networkTypes(self, value):
        # Validate type networkTypes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = ["network", "networkWithTemperature"]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on networkTypes'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False

    def validate_Nml2Quantity_temperature(self, value):
        # Validate type Nml2Quantity_temperature, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_temperature_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_temperature_patterns_,
                    )
                )

    validate_Nml2Quantity_temperature_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(degC))$"]
    ]

    def validate_NeuroLexId(self, value):
        # Validate type NeuroLexId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NeuroLexId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NeuroLexId_patterns_,
                    )
                )

    validate_NeuroLexId_patterns_ = [["^([a-zA-Z0-9_:]*)$"]]

    def _hasContent(self):
        if (
            self.spaces
            or self.regions
            or self.extracellular_properties
            or self.populations
            or self.cell_sets
            or self.synaptic_connections
            or self.projections
            or self.electrical_projections
            or self.continuous_projections
            or self.explicit_inputs
            or self.input_lists
            or super(Network, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Network",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Network")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Network":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Network"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Network",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Network"
    ):
        super(Network, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Network"
        )
        if self.type is not None and "type" not in already_processed:
            already_processed.add("type")
            outfile.write(
                " type=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.type), input_name="type"
                        )
                    ),
                )
            )
        if self.temperature is not None and "temperature" not in already_processed:
            already_processed.add("temperature")
            outfile.write(
                " temperature=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.temperature), input_name="temperature"
                        )
                    ),
                )
            )
        if self.neuro_lex_id is not None and "neuro_lex_id" not in already_processed:
            already_processed.add("neuro_lex_id")
            outfile.write(
                " neuroLexId=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.neuro_lex_id), input_name="neuroLexId"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Network",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Network, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for space_ in self.spaces:
            namespaceprefix_ = (
                self.spaces_nsprefix_ + ":"
                if (UseCapturedNS_ and self.spaces_nsprefix_)
                else ""
            )
            space_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="space",
                pretty_print=pretty_print,
            )
        for region_ in self.regions:
            namespaceprefix_ = (
                self.regions_nsprefix_ + ":"
                if (UseCapturedNS_ and self.regions_nsprefix_)
                else ""
            )
            region_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="region",
                pretty_print=pretty_print,
            )
        for extracellularProperties_ in self.extracellular_properties:
            namespaceprefix_ = (
                self.extracellular_properties_nsprefix_ + ":"
                if (UseCapturedNS_ and self.extracellular_properties_nsprefix_)
                else ""
            )
            extracellularProperties_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="extracellularProperties",
                pretty_print=pretty_print,
            )
        for population_ in self.populations:
            namespaceprefix_ = (
                self.populations_nsprefix_ + ":"
                if (UseCapturedNS_ and self.populations_nsprefix_)
                else ""
            )
            population_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="population",
                pretty_print=pretty_print,
            )
        for cellSet_ in self.cell_sets:
            namespaceprefix_ = (
                self.cell_sets_nsprefix_ + ":"
                if (UseCapturedNS_ and self.cell_sets_nsprefix_)
                else ""
            )
            cellSet_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="cellSet",
                pretty_print=pretty_print,
            )
        for synapticConnection_ in self.synaptic_connections:
            namespaceprefix_ = (
                self.synaptic_connections_nsprefix_ + ":"
                if (UseCapturedNS_ and self.synaptic_connections_nsprefix_)
                else ""
            )
            synapticConnection_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="synapticConnection",
                pretty_print=pretty_print,
            )
        for projection_ in self.projections:
            namespaceprefix_ = (
                self.projections_nsprefix_ + ":"
                if (UseCapturedNS_ and self.projections_nsprefix_)
                else ""
            )
            projection_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="projection",
                pretty_print=pretty_print,
            )
        for electricalProjection_ in self.electrical_projections:
            namespaceprefix_ = (
                self.electrical_projections_nsprefix_ + ":"
                if (UseCapturedNS_ and self.electrical_projections_nsprefix_)
                else ""
            )
            electricalProjection_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="electricalProjection",
                pretty_print=pretty_print,
            )
        for continuousProjection_ in self.continuous_projections:
            namespaceprefix_ = (
                self.continuous_projections_nsprefix_ + ":"
                if (UseCapturedNS_ and self.continuous_projections_nsprefix_)
                else ""
            )
            continuousProjection_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="continuousProjection",
                pretty_print=pretty_print,
            )
        for explicitInput_ in self.explicit_inputs:
            namespaceprefix_ = (
                self.explicit_inputs_nsprefix_ + ":"
                if (UseCapturedNS_ and self.explicit_inputs_nsprefix_)
                else ""
            )
            explicitInput_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="explicitInput",
                pretty_print=pretty_print,
            )
        for inputList_ in self.input_lists:
            namespaceprefix_ = (
                self.input_lists_nsprefix_ + ":"
                if (UseCapturedNS_ and self.input_lists_nsprefix_)
                else ""
            )
            inputList_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="inputList",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_networkTypes, self.type, "type")
        self.gds_check_cardinality_(self.type, "type", required=False)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_temperature, self.temperature, "temperature"
        )
        self.gds_check_cardinality_(self.temperature, "temperature", required=False)
        self.gds_validate_defined_ST_(
            self.validate_NeuroLexId, self.neuro_lex_id, "neuro_lex_id"
        )
        self.gds_check_cardinality_(self.neuro_lex_id, "neuro_lex_id", required=False)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.spaces, "spaces", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.regions, "regions", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.extracellular_properties,
            "extracellular_properties",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.populations, "populations", min_occurs=1, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.cell_sets, "cell_sets", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.synaptic_connections,
            "synaptic_connections",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.projections, "projections", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.electrical_projections,
            "electrical_projections",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.continuous_projections,
            "continuous_projections",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.explicit_inputs, "explicit_inputs", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.input_lists, "input_lists", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.spaces:
                item.validate_(gds_collector, recursive=True)
            for item in self.regions:
                item.validate_(gds_collector, recursive=True)
            for item in self.extracellular_properties:
                item.validate_(gds_collector, recursive=True)
            for item in self.populations:
                item.validate_(gds_collector, recursive=True)
            for item in self.cell_sets:
                item.validate_(gds_collector, recursive=True)
            for item in self.synaptic_connections:
                item.validate_(gds_collector, recursive=True)
            for item in self.projections:
                item.validate_(gds_collector, recursive=True)
            for item in self.electrical_projections:
                item.validate_(gds_collector, recursive=True)
            for item in self.continuous_projections:
                item.validate_(gds_collector, recursive=True)
            for item in self.explicit_inputs:
                item.validate_(gds_collector, recursive=True)
            for item in self.input_lists:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type = value
            self.validate_networkTypes(self.type)  # validate type networkTypes
        value = find_attr_value_("temperature", node)
        if value is not None and "temperature" not in already_processed:
            already_processed.add("temperature")
            self.temperature = value
            self.validate_Nml2Quantity_temperature(
                self.temperature
            )  # validate type Nml2Quantity_temperature
        value = find_attr_value_("neuroLexId", node)
        if value is not None and "neuroLexId" not in already_processed:
            already_processed.add("neuroLexId")
            self.neuro_lex_id = value
            self.validate_NeuroLexId(self.neuro_lex_id)  # validate type NeuroLexId
        super(Network, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "space":
            obj_ = Space.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spaces.append(obj_)
            obj_.original_tagname_ = "space"
        elif nodeName_ == "region":
            obj_ = Region.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.regions.append(obj_)
            obj_.original_tagname_ = "region"
        elif nodeName_ == "extracellularProperties":
            obj_ = ExtracellularPropertiesLocal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extracellular_properties.append(obj_)
            obj_.original_tagname_ = "extracellularProperties"
        elif nodeName_ == "population":
            obj_ = Population.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.populations.append(obj_)
            obj_.original_tagname_ = "population"
        elif nodeName_ == "cellSet":
            obj_ = CellSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cell_sets.append(obj_)
            obj_.original_tagname_ = "cellSet"
        elif nodeName_ == "synapticConnection":
            obj_ = SynapticConnection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.synaptic_connections.append(obj_)
            obj_.original_tagname_ = "synapticConnection"
        elif nodeName_ == "projection":
            obj_ = Projection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.projections.append(obj_)
            obj_.original_tagname_ = "projection"
        elif nodeName_ == "electricalProjection":
            obj_ = ElectricalProjection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.electrical_projections.append(obj_)
            obj_.original_tagname_ = "electricalProjection"
        elif nodeName_ == "continuousProjection":
            obj_ = ContinuousProjection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.continuous_projections.append(obj_)
            obj_.original_tagname_ = "continuousProjection"
        elif nodeName_ == "explicitInput":
            obj_ = ExplicitInput.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.explicit_inputs.append(obj_)
            obj_.original_tagname_ = "explicitInput"
        elif nodeName_ == "inputList":
            obj_ = InputList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.input_lists.append(obj_)
            obj_.original_tagname_ = "inputList"
        super(Network, self)._buildChildren(child_, node, nodeName_, True)

    warn_count = 0

    def get_by_id(self, id):
        """Get a component by its ID

        :param id: ID of component to find
        :type id: str
        :returns:  component with specified ID or None if no component with specified ID found
        """
        all_ids = []
        for ms in self.member_data_items_:
            mlist = getattr(self, ms.get_name())
            # TODO: debug why this is required
            if mlist is None:
                continue
            for m in mlist:
                if hasattr(m, "id"):
                    if m.id == id:
                        return m
                    else:
                        all_ids.append(m.id)
        if self.warn_count < 10:
            neuroml.print_(
                "Id "
                + id
                + " not found in <network> element. All ids: "
                + str(sorted(all_ids))
            )
            self.warn_count += 1
        elif self.warn_count == 10:
            neuroml.print_(" - Suppressing further warnings about id not found...")
        return None

    def __str__(self):
        return (
            "Network "
            + str(self.id)
            + " with "
            + str(len(self.populations))
            + " population(s)"
        )

    def exportHdf5(self, h5file, h5Group):
        """Export to HDF5 file."""
        # print("Exporting Network: "+str(self.id)+" as HDF5")

        netGroup = h5file.create_group(h5Group, "network")
        netGroup._f_setattr("id", self.id)
        netGroup._f_setattr("notes", self.notes)
        if self.temperature:
            netGroup._f_setattr("temperature", self.temperature)

        for pop in self.populations:
            pop.exportHdf5(h5file, netGroup)

        if len(self.synaptic_connections) > 0:
            raise Exception("<synapticConnection> not yet supported in HDF5 export")
        if len(self.explicit_inputs) > 0:
            raise Exception("<explicitInput> not yet supported in HDF5 export")

        for proj in self.projections:
            proj.exportHdf5(h5file, netGroup)

        for eproj in self.electrical_projections:
            eproj.exportHdf5(h5file, netGroup)

        for cproj in self.continuous_projections:
            cproj.exportHdf5(h5file, netGroup)

        for il in self.input_lists:
            il.exportHdf5(h5file, netGroup)

    # end class Network


class TransientPoissonFiringSynapse(Standalone):
    """TransientPoissonFiringSynapse -- Poisson spike generator firing at **averageRate**  after a **delay**  and for a **duration,**  connected to single **synapse**  that is triggered every time a spike is generated, providing an input current. Similar to ComponentType  **poissonFiringSynapse** .
    \n
    :param averageRate:
    :type averageRate: per_time
    :param delay:
    :type delay: time
    :param duration:
    :type duration: time

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "average_rate",
            "Nml2Quantity_pertime",
            0,
            0,
            {"use": "required", "name": "average_rate"},
        ),
        MemberSpec_(
            "delay", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "delay"}
        ),
        MemberSpec_(
            "duration",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "duration"},
        ),
        MemberSpec_(
            "synapse", "xs:string", 0, 0, {"use": "required", "name": "synapse"}
        ),
        MemberSpec_(
            "spike_target",
            "xs:string",
            0,
            0,
            {"use": "required", "name": "spike_target"},
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        average_rate: "a Nml2Quantity_pertime (required)" = None,
        delay: "a Nml2Quantity_time (required)" = None,
        duration: "a Nml2Quantity_time (required)" = None,
        synapse: "a string (required)" = None,
        spike_target: "a string (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("TransientPoissonFiringSynapse"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.average_rate = _cast(None, average_rate)
        self.average_rate_nsprefix_ = None
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.synapse = _cast(None, synapse)
        self.synapse_nsprefix_ = None
        self.spike_target = _cast(None, spike_target)
        self.spike_target_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransientPoissonFiringSynapse
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransientPoissonFiringSynapse.subclass:
            return TransientPoissonFiringSynapse.subclass(*args_, **kwargs_)
        else:
            return TransientPoissonFiringSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_pertime_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_pertime_patterns_,
                    )
                )

    validate_Nml2Quantity_pertime_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$"]
    ]

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(TransientPoissonFiringSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="TransientPoissonFiringSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("TransientPoissonFiringSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "TransientPoissonFiringSynapse"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="TransientPoissonFiringSynapse",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="TransientPoissonFiringSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="TransientPoissonFiringSynapse",
    ):
        super(TransientPoissonFiringSynapse, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="TransientPoissonFiringSynapse",
        )
        if self.average_rate is not None and "average_rate" not in already_processed:
            already_processed.add("average_rate")
            outfile.write(
                " averageRate=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.average_rate), input_name="averageRate"
                        )
                    ),
                )
            )
        if self.delay is not None and "delay" not in already_processed:
            already_processed.add("delay")
            outfile.write(
                " delay=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.delay), input_name="delay"
                        )
                    ),
                )
            )
        if self.duration is not None and "duration" not in already_processed:
            already_processed.add("duration")
            outfile.write(
                " duration=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.duration), input_name="duration"
                        )
                    ),
                )
            )
        if self.synapse is not None and "synapse" not in already_processed:
            already_processed.add("synapse")
            outfile.write(
                " synapse=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.synapse), input_name="synapse"
                        )
                    ),
                )
            )
        if self.spike_target is not None and "spike_target" not in already_processed:
            already_processed.add("spike_target")
            outfile.write(
                " spikeTarget=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.spike_target), input_name="spikeTarget"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="TransientPoissonFiringSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(TransientPoissonFiringSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_pertime, self.average_rate, "average_rate"
        )
        self.gds_check_cardinality_(self.average_rate, "average_rate", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.delay, "delay"
        )
        self.gds_check_cardinality_(self.delay, "delay", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.duration, "duration"
        )
        self.gds_check_cardinality_(self.duration, "duration", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.synapse, "synapse")
        self.gds_check_cardinality_(self.synapse, "synapse", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.spike_target, "spike_target"
        )
        self.gds_check_cardinality_(self.spike_target, "spike_target", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("averageRate", node)
        if value is not None and "averageRate" not in already_processed:
            already_processed.add("averageRate")
            self.average_rate = value
            self.validate_Nml2Quantity_pertime(
                self.average_rate
            )  # validate type Nml2Quantity_pertime
        value = find_attr_value_("delay", node)
        if value is not None and "delay" not in already_processed:
            already_processed.add("delay")
            self.delay = value
            self.validate_Nml2Quantity_time(
                self.delay
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("duration", node)
        if value is not None and "duration" not in already_processed:
            already_processed.add("duration")
            self.duration = value
            self.validate_Nml2Quantity_time(
                self.duration
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("synapse", node)
        if value is not None and "synapse" not in already_processed:
            already_processed.add("synapse")
            self.synapse = value
        value = find_attr_value_("spikeTarget", node)
        if value is not None and "spikeTarget" not in already_processed:
            already_processed.add("spikeTarget")
            self.spike_target = value
        super(TransientPoissonFiringSynapse, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(TransientPoissonFiringSynapse, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class TransientPoissonFiringSynapse


class PoissonFiringSynapse(Standalone):
    """PoissonFiringSynapse -- Poisson spike generator firing at **averageRate,**  which is connected to single **synapse**  that is triggered every time a spike is generated, producing an input current. See also  **transientPoissonFiringSynapse** .
    \n
    :param averageRate: The average rate at which spikes are emitted
    :type averageRate: per_time

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "average_rate",
            "Nml2Quantity_pertime",
            0,
            0,
            {"use": "required", "name": "average_rate"},
        ),
        MemberSpec_(
            "synapse", "xs:string", 0, 0, {"use": "required", "name": "synapse"}
        ),
        MemberSpec_(
            "spike_target",
            "xs:string",
            0,
            0,
            {"use": "required", "name": "spike_target"},
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        average_rate: "a Nml2Quantity_pertime (required)" = None,
        synapse: "a string (required)" = None,
        spike_target: "a string (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("PoissonFiringSynapse"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.average_rate = _cast(None, average_rate)
        self.average_rate_nsprefix_ = None
        self.synapse = _cast(None, synapse)
        self.synapse_nsprefix_ = None
        self.spike_target = _cast(None, spike_target)
        self.spike_target_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PoissonFiringSynapse
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PoissonFiringSynapse.subclass:
            return PoissonFiringSynapse.subclass(*args_, **kwargs_)
        else:
            return PoissonFiringSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_pertime_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_pertime_patterns_,
                    )
                )

    validate_Nml2Quantity_pertime_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$"]
    ]

    def _hasContent(self):
        if super(PoissonFiringSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="PoissonFiringSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("PoissonFiringSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "PoissonFiringSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="PoissonFiringSynapse",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="PoissonFiringSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="PoissonFiringSynapse",
    ):
        super(PoissonFiringSynapse, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="PoissonFiringSynapse",
        )
        if self.average_rate is not None and "average_rate" not in already_processed:
            already_processed.add("average_rate")
            outfile.write(
                " averageRate=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.average_rate), input_name="averageRate"
                        )
                    ),
                )
            )
        if self.synapse is not None and "synapse" not in already_processed:
            already_processed.add("synapse")
            outfile.write(
                " synapse=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.synapse), input_name="synapse"
                        )
                    ),
                )
            )
        if self.spike_target is not None and "spike_target" not in already_processed:
            already_processed.add("spike_target")
            outfile.write(
                " spikeTarget=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.spike_target), input_name="spikeTarget"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="PoissonFiringSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(PoissonFiringSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_pertime, self.average_rate, "average_rate"
        )
        self.gds_check_cardinality_(self.average_rate, "average_rate", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.synapse, "synapse")
        self.gds_check_cardinality_(self.synapse, "synapse", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.spike_target, "spike_target"
        )
        self.gds_check_cardinality_(self.spike_target, "spike_target", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("averageRate", node)
        if value is not None and "averageRate" not in already_processed:
            already_processed.add("averageRate")
            self.average_rate = value
            self.validate_Nml2Quantity_pertime(
                self.average_rate
            )  # validate type Nml2Quantity_pertime
        value = find_attr_value_("synapse", node)
        if value is not None and "synapse" not in already_processed:
            already_processed.add("synapse")
            self.synapse = value
        value = find_attr_value_("spikeTarget", node)
        if value is not None and "spikeTarget" not in already_processed:
            already_processed.add("spikeTarget")
            self.spike_target = value
        super(PoissonFiringSynapse, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(PoissonFiringSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class PoissonFiringSynapse


class SpikeGeneratorPoisson(Standalone):
    """SpikeGeneratorPoisson -- Generator of spikes whose ISI is distributed according to an exponential PDF with scale: 1 / **averageRate**
    \n
    :param averageRate: The average rate at which spikes are emitted
    :type averageRate: per_time

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "average_rate",
            "Nml2Quantity_pertime",
            0,
            0,
            {"use": "required", "name": "average_rate"},
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        average_rate: "a Nml2Quantity_pertime (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SpikeGeneratorPoisson"), self).__init__(
            id, metaid, notes, properties, annotation, extensiontype_, **kwargs_
        )
        self.average_rate = _cast(None, average_rate)
        self.average_rate_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpikeGeneratorPoisson
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeGeneratorPoisson.subclass:
            return SpikeGeneratorPoisson.subclass(*args_, **kwargs_)
        else:
            return SpikeGeneratorPoisson(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_pertime_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_pertime_patterns_,
                    )
                )

    validate_Nml2Quantity_pertime_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$"]
    ]

    def _hasContent(self):
        if super(SpikeGeneratorPoisson, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpikeGeneratorPoisson",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SpikeGeneratorPoisson")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SpikeGeneratorPoisson":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="SpikeGeneratorPoisson",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SpikeGeneratorPoisson",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SpikeGeneratorPoisson",
    ):
        super(SpikeGeneratorPoisson, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="SpikeGeneratorPoisson",
        )
        if self.average_rate is not None and "average_rate" not in already_processed:
            already_processed.add("average_rate")
            outfile.write(
                " averageRate=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.average_rate), input_name="averageRate"
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpikeGeneratorPoisson",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SpikeGeneratorPoisson, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_pertime, self.average_rate, "average_rate"
        )
        self.gds_check_cardinality_(self.average_rate, "average_rate", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("averageRate", node)
        if value is not None and "averageRate" not in already_processed:
            already_processed.add("averageRate")
            self.average_rate = value
            self.validate_Nml2Quantity_pertime(
                self.average_rate
            )  # validate type Nml2Quantity_pertime
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(SpikeGeneratorPoisson, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SpikeGeneratorPoisson, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class SpikeGeneratorPoisson


class SpikeGeneratorRandom(Standalone):
    """SpikeGeneratorRandom -- Generator of spikes with a random interspike interval of at least **minISI**  and at most **maxISI**
    \n
    :param maxISI: Maximum interspike interval
    :type maxISI: time
    :param minISI: Minimum interspike interval
    :type minISI: time

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "max_isi", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "max_isi"}
        ),
        MemberSpec_(
            "min_isi", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "min_isi"}
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        max_isi: "a Nml2Quantity_time (required)" = None,
        min_isi: "a Nml2Quantity_time (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SpikeGeneratorRandom"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.max_isi = _cast(None, max_isi)
        self.max_isi_nsprefix_ = None
        self.min_isi = _cast(None, min_isi)
        self.min_isi_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpikeGeneratorRandom
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeGeneratorRandom.subclass:
            return SpikeGeneratorRandom.subclass(*args_, **kwargs_)
        else:
            return SpikeGeneratorRandom(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(SpikeGeneratorRandom, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpikeGeneratorRandom",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SpikeGeneratorRandom")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SpikeGeneratorRandom":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="SpikeGeneratorRandom",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SpikeGeneratorRandom",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SpikeGeneratorRandom",
    ):
        super(SpikeGeneratorRandom, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="SpikeGeneratorRandom",
        )
        if self.max_isi is not None and "max_isi" not in already_processed:
            already_processed.add("max_isi")
            outfile.write(
                " maxISI=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.max_isi), input_name="maxISI"
                        )
                    ),
                )
            )
        if self.min_isi is not None and "min_isi" not in already_processed:
            already_processed.add("min_isi")
            outfile.write(
                " minISI=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.min_isi), input_name="minISI"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpikeGeneratorRandom",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SpikeGeneratorRandom, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.max_isi, "max_isi"
        )
        self.gds_check_cardinality_(self.max_isi, "max_isi", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.min_isi, "min_isi"
        )
        self.gds_check_cardinality_(self.min_isi, "min_isi", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("maxISI", node)
        if value is not None and "maxISI" not in already_processed:
            already_processed.add("maxISI")
            self.max_isi = value
            self.validate_Nml2Quantity_time(
                self.max_isi
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("minISI", node)
        if value is not None and "minISI" not in already_processed:
            already_processed.add("minISI")
            self.min_isi = value
            self.validate_Nml2Quantity_time(
                self.min_isi
            )  # validate type Nml2Quantity_time
        super(SpikeGeneratorRandom, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SpikeGeneratorRandom, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class SpikeGeneratorRandom


class SpikeGenerator(Standalone):
    """SpikeGenerator -- Simple generator of spikes at a regular interval set by **period**
    \n
    :param period: Time between spikes. The first spike will be emitted after this time.
    :type period: time

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "period", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "period"}
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        period: "a Nml2Quantity_time (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SpikeGenerator"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.period = _cast(None, period)
        self.period_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SpikeGenerator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeGenerator.subclass:
            return SpikeGenerator.subclass(*args_, **kwargs_)
        else:
            return SpikeGenerator(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(SpikeGenerator, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpikeGenerator",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SpikeGenerator")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SpikeGenerator":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SpikeGenerator"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SpikeGenerator",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SpikeGenerator",
    ):
        super(SpikeGenerator, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SpikeGenerator"
        )
        if self.period is not None and "period" not in already_processed:
            already_processed.add("period")
            outfile.write(
                " period=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.period), input_name="period"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpikeGenerator",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SpikeGenerator, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.period, "period"
        )
        self.gds_check_cardinality_(self.period, "period", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("period", node)
        if value is not None and "period" not in already_processed:
            already_processed.add("period")
            self.period = value
            self.validate_Nml2Quantity_time(
                self.period
            )  # validate type Nml2Quantity_time
        super(SpikeGenerator, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SpikeGenerator, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class SpikeGenerator


class TimedSynapticInput(Standalone):
    """TimedSynapticInput -- Spike array connected to a single **synapse,**  producing a current triggered by each  **spike**  in the array."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("synapse", "NmlId", 0, 0, {"use": "required", "name": "synapse"}),
        MemberSpec_(
            "spike_target",
            "xs:string",
            0,
            0,
            {"use": "required", "name": "spike_target"},
        ),
        MemberSpec_(
            "spikes",
            "Spike",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "spike",
                "type": "Spike",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        synapse: "a NmlId (required)" = None,
        spike_target: "a string (required)" = None,
        spikes: "list of Spike(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("TimedSynapticInput"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.synapse = _cast(None, synapse)
        self.synapse_nsprefix_ = None
        self.spike_target = _cast(None, spike_target)
        self.spike_target_nsprefix_ = None
        if spikes is None:
            self.spikes = []
        else:
            self.spikes = spikes
        self.spikes_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimedSynapticInput
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimedSynapticInput.subclass:
            return TimedSynapticInput.subclass(*args_, **kwargs_)
        else:
            return TimedSynapticInput(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if self.spikes or super(TimedSynapticInput, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="TimedSynapticInput",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("TimedSynapticInput")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "TimedSynapticInput":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="TimedSynapticInput",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="TimedSynapticInput",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="TimedSynapticInput",
    ):
        super(TimedSynapticInput, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="TimedSynapticInput",
        )
        if self.synapse is not None and "synapse" not in already_processed:
            already_processed.add("synapse")
            outfile.write(
                " synapse=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.synapse), input_name="synapse"
                        )
                    ),
                )
            )
        if self.spike_target is not None and "spike_target" not in already_processed:
            already_processed.add("spike_target")
            outfile.write(
                " spikeTarget=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.spike_target), input_name="spikeTarget"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="TimedSynapticInput",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(TimedSynapticInput, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for spike_ in self.spikes:
            namespaceprefix_ = (
                self.spikes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.spikes_nsprefix_)
                else ""
            )
            spike_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="spike",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.synapse, "synapse")
        self.gds_check_cardinality_(self.synapse, "synapse", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.spike_target, "spike_target"
        )
        self.gds_check_cardinality_(self.spike_target, "spike_target", required=True)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.spikes, "spikes", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.spikes:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("synapse", node)
        if value is not None and "synapse" not in already_processed:
            already_processed.add("synapse")
            self.synapse = value
            self.validate_NmlId(self.synapse)  # validate type NmlId
        value = find_attr_value_("spikeTarget", node)
        if value is not None and "spikeTarget" not in already_processed:
            already_processed.add("spikeTarget")
            self.spike_target = value
        super(TimedSynapticInput, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "spike":
            obj_ = Spike.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spikes.append(obj_)
            obj_.original_tagname_ = "spike"
        super(TimedSynapticInput, self)._buildChildren(child_, node, nodeName_, True)


# end class TimedSynapticInput


class SpikeArray(Standalone):
    """SpikeArray -- Set of spike ComponentTypes, each emitting one spike at a certain time. Can be used to feed a predetermined spike train into a cell"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "spikes",
            "Spike",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "spike",
                "type": "Spike",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        spikes: "list of Spike(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SpikeArray"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        if spikes is None:
            self.spikes = []
        else:
            self.spikes = spikes
        self.spikes_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SpikeArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeArray.subclass:
            return SpikeArray.subclass(*args_, **kwargs_)
        else:
            return SpikeArray(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if self.spikes or super(SpikeArray, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="SpikeArray",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SpikeArray")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SpikeArray":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SpikeArray"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SpikeArray",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="SpikeArray"
    ):
        super(SpikeArray, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SpikeArray"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="SpikeArray",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SpikeArray, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for spike_ in self.spikes:
            namespaceprefix_ = (
                self.spikes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.spikes_nsprefix_)
                else ""
            )
            spike_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="spike",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.spikes, "spikes", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.spikes:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(SpikeArray, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "spike":
            obj_ = Spike.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spikes.append(obj_)
            obj_.original_tagname_ = "spike"
        super(SpikeArray, self)._buildChildren(child_, node, nodeName_, True)


# end class SpikeArray


class Spike(BaseNonNegativeIntegerId):
    """Spike -- Emits a single spike at the specified **time**
    \n
    :param time: Time at which to emit one spike event
    :type time: time

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "time", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "time"}
        ),
    ]
    subclass = None
    superclass = BaseNonNegativeIntegerId

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        time: "a Nml2Quantity_time (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Spike"), self).__init__(id, **kwargs_)
        self.time = _cast(None, time)
        self.time_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Spike)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Spike.subclass:
            return Spike.subclass(*args_, **kwargs_)
        else:
            return Spike(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(Spike, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Spike",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Spike")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Spike":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Spike"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Spike",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Spike"
    ):
        super(Spike, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Spike"
        )
        if self.time is not None and "time" not in already_processed:
            already_processed.add("time")
            outfile.write(
                " time=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.time), input_name="time"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Spike",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Spike, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.time, "time"
        )
        self.gds_check_cardinality_(self.time, "time", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("time", node)
        if value is not None and "time" not in already_processed:
            already_processed.add("time")
            self.time = value
            self.validate_Nml2Quantity_time(
                self.time
            )  # validate type Nml2Quantity_time
        super(Spike, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Spike, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class Spike


class VoltageClampTriple(Standalone):
    """VoltageClampTriple -- Voltage clamp with 3 clamp levels. Applies a variable current **i**  ( through **simpleSeriesResistance**  ) to try to keep parent cell at **conditioningVoltage**  until time **delay,**  **testingVoltage**  until **delay**  + **duration,**  and **returnVoltage**  afterwards. Only enabled if **active**  = 1.
    \n
    :param active: Whether the voltage clamp is active ( 1 ) or inactive ( 0 ).
    :type active: none
    :param delay: Delay before switching from conditioningVoltage to testingVoltage.
    :type delay: time
    :param duration: Duration to hold at testingVoltage.
    :type duration: time
    :param conditioningVoltage: Target voltage before time delay
    :type conditioningVoltage: voltage
    :param testingVoltage: Target voltage between times delay and delay + duration
    :type testingVoltage: voltage
    :param returnVoltage: Target voltage after time duration
    :type returnVoltage: voltage
    :param simpleSeriesResistance: Current will be calculated by the difference in voltage between the target and parent, divided by this value
    :type simpleSeriesResistance: resistance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("active", "ZeroOrOne", 0, 0, {"use": "required", "name": "active"}),
        MemberSpec_(
            "delay", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "delay"}
        ),
        MemberSpec_(
            "duration",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "duration"},
        ),
        MemberSpec_(
            "conditioning_voltage",
            "Nml2Quantity_voltage",
            0,
            0,
            {"use": "required", "name": "conditioning_voltage"},
        ),
        MemberSpec_(
            "testing_voltage",
            "Nml2Quantity_voltage",
            0,
            0,
            {"use": "required", "name": "testing_voltage"},
        ),
        MemberSpec_(
            "return_voltage",
            "Nml2Quantity_voltage",
            0,
            0,
            {"use": "required", "name": "return_voltage"},
        ),
        MemberSpec_(
            "simple_series_resistance",
            "Nml2Quantity_resistance",
            0,
            0,
            {"use": "required", "name": "simple_series_resistance"},
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        active: "a ZeroOrOne (required)" = None,
        delay: "a Nml2Quantity_time (required)" = None,
        duration: "a Nml2Quantity_time (required)" = None,
        conditioning_voltage: "a Nml2Quantity_voltage (required)" = None,
        testing_voltage: "a Nml2Quantity_voltage (required)" = None,
        return_voltage: "a Nml2Quantity_voltage (required)" = None,
        simple_series_resistance: "a Nml2Quantity_resistance (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("VoltageClampTriple"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.active = _cast(float, active)
        self.active_nsprefix_ = None
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.conditioning_voltage = _cast(None, conditioning_voltage)
        self.conditioning_voltage_nsprefix_ = None
        self.testing_voltage = _cast(None, testing_voltage)
        self.testing_voltage_nsprefix_ = None
        self.return_voltage = _cast(None, return_voltage)
        self.return_voltage_nsprefix_ = None
        self.simple_series_resistance = _cast(None, simple_series_resistance)
        self.simple_series_resistance_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoltageClampTriple
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoltageClampTriple.subclass:
            return VoltageClampTriple.subclass(*args_, **kwargs_)
        else:
            return VoltageClampTriple(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_ZeroOrOne(self, value):
        # Validate type ZeroOrOne, a restriction on xs:double.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [0.0, 1.0]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ZeroOrOne'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def validate_Nml2Quantity_resistance(self, value):
        # Validate type Nml2Quantity_resistance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_resistance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_resistance_patterns_,
                    )
                )

    validate_Nml2Quantity_resistance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(ohm|kohm|Mohm))$"]
    ]

    def _hasContent(self):
        if super(VoltageClampTriple, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="VoltageClampTriple",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("VoltageClampTriple")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "VoltageClampTriple":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="VoltageClampTriple",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="VoltageClampTriple",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="VoltageClampTriple",
    ):
        super(VoltageClampTriple, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="VoltageClampTriple",
        )
        if self.active is not None and "active" not in already_processed:
            already_processed.add("active")
            outfile.write(
                ' active="%s"'
                % self.gds_format_double(self.active, input_name="active")
            )
        if self.delay is not None and "delay" not in already_processed:
            already_processed.add("delay")
            outfile.write(
                " delay=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.delay), input_name="delay"
                        )
                    ),
                )
            )
        if self.duration is not None and "duration" not in already_processed:
            already_processed.add("duration")
            outfile.write(
                " duration=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.duration), input_name="duration"
                        )
                    ),
                )
            )
        if (
            self.conditioning_voltage is not None
            and "conditioning_voltage" not in already_processed
        ):
            already_processed.add("conditioning_voltage")
            outfile.write(
                " conditioningVoltage=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.conditioning_voltage),
                            input_name="conditioningVoltage",
                        )
                    ),
                )
            )
        if (
            self.testing_voltage is not None
            and "testing_voltage" not in already_processed
        ):
            already_processed.add("testing_voltage")
            outfile.write(
                " testingVoltage=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.testing_voltage),
                            input_name="testingVoltage",
                        )
                    ),
                )
            )
        if (
            self.return_voltage is not None
            and "return_voltage" not in already_processed
        ):
            already_processed.add("return_voltage")
            outfile.write(
                " returnVoltage=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.return_voltage),
                            input_name="returnVoltage",
                        )
                    ),
                )
            )
        if (
            self.simple_series_resistance is not None
            and "simple_series_resistance" not in already_processed
        ):
            already_processed.add("simple_series_resistance")
            outfile.write(
                " simpleSeriesResistance=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.simple_series_resistance),
                            input_name="simpleSeriesResistance",
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="VoltageClampTriple",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(VoltageClampTriple, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_ZeroOrOne, self.active, "active")
        self.gds_check_cardinality_(self.active, "active", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.delay, "delay"
        )
        self.gds_check_cardinality_(self.delay, "delay", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.duration, "duration"
        )
        self.gds_check_cardinality_(self.duration, "duration", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage,
            self.conditioning_voltage,
            "conditioning_voltage",
        )
        self.gds_check_cardinality_(
            self.conditioning_voltage, "conditioning_voltage", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.testing_voltage, "testing_voltage"
        )
        self.gds_check_cardinality_(
            self.testing_voltage, "testing_voltage", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.return_voltage, "return_voltage"
        )
        self.gds_check_cardinality_(
            self.return_voltage, "return_voltage", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_resistance,
            self.simple_series_resistance,
            "simple_series_resistance",
        )
        self.gds_check_cardinality_(
            self.simple_series_resistance, "simple_series_resistance", required=True
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("active", node)
        if value is not None and "active" not in already_processed:
            already_processed.add("active")
            value = self.gds_parse_double(value, node, "active")
            self.active = value
            self.validate_ZeroOrOne(self.active)  # validate type ZeroOrOne
        value = find_attr_value_("delay", node)
        if value is not None and "delay" not in already_processed:
            already_processed.add("delay")
            self.delay = value
            self.validate_Nml2Quantity_time(
                self.delay
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("duration", node)
        if value is not None and "duration" not in already_processed:
            already_processed.add("duration")
            self.duration = value
            self.validate_Nml2Quantity_time(
                self.duration
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("conditioningVoltage", node)
        if value is not None and "conditioningVoltage" not in already_processed:
            already_processed.add("conditioningVoltage")
            self.conditioning_voltage = value
            self.validate_Nml2Quantity_voltage(
                self.conditioning_voltage
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("testingVoltage", node)
        if value is not None and "testingVoltage" not in already_processed:
            already_processed.add("testingVoltage")
            self.testing_voltage = value
            self.validate_Nml2Quantity_voltage(
                self.testing_voltage
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("returnVoltage", node)
        if value is not None and "returnVoltage" not in already_processed:
            already_processed.add("returnVoltage")
            self.return_voltage = value
            self.validate_Nml2Quantity_voltage(
                self.return_voltage
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("simpleSeriesResistance", node)
        if value is not None and "simpleSeriesResistance" not in already_processed:
            already_processed.add("simpleSeriesResistance")
            self.simple_series_resistance = value
            self.validate_Nml2Quantity_resistance(
                self.simple_series_resistance
            )  # validate type Nml2Quantity_resistance
        super(VoltageClampTriple, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(VoltageClampTriple, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class VoltageClampTriple


class VoltageClamp(Standalone):
    """VoltageClamp -- Voltage clamp. Applies a variable current **i**  to try to keep parent at **targetVoltage.**  Not yet fully tested!!! Consider using voltageClampTriple!!
    \n
    :param delay: Delay before change in current. Current is zero prior to this.
    :type delay: time
    :param duration: Duration for attempting to keep parent at targetVoltage. Current is zero after delay + duration.
    :type duration: time
    :param targetVoltage: Current will be applied to try to get parent to this target voltage
    :type targetVoltage: voltage
    :param simpleSeriesResistance: Current will be calculated by the difference in voltage between the target and parent, divided by this value
    :type simpleSeriesResistance: resistance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "delay", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "delay"}
        ),
        MemberSpec_(
            "duration",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "duration"},
        ),
        MemberSpec_(
            "target_voltage",
            "Nml2Quantity_voltage",
            0,
            0,
            {"use": "required", "name": "target_voltage"},
        ),
        MemberSpec_(
            "simple_series_resistance",
            "Nml2Quantity_resistance",
            0,
            0,
            {"use": "required", "name": "simple_series_resistance"},
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        delay: "a Nml2Quantity_time (required)" = None,
        duration: "a Nml2Quantity_time (required)" = None,
        target_voltage: "a Nml2Quantity_voltage (required)" = None,
        simple_series_resistance: "a Nml2Quantity_resistance (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("VoltageClamp"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.target_voltage = _cast(None, target_voltage)
        self.target_voltage_nsprefix_ = None
        self.simple_series_resistance = _cast(None, simple_series_resistance)
        self.simple_series_resistance_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, VoltageClamp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoltageClamp.subclass:
            return VoltageClamp.subclass(*args_, **kwargs_)
        else:
            return VoltageClamp(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def validate_Nml2Quantity_resistance(self, value):
        # Validate type Nml2Quantity_resistance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_resistance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_resistance_patterns_,
                    )
                )

    validate_Nml2Quantity_resistance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(ohm|kohm|Mohm))$"]
    ]

    def _hasContent(self):
        if super(VoltageClamp, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="VoltageClamp",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("VoltageClamp")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "VoltageClamp":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="VoltageClamp"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="VoltageClamp",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="VoltageClamp",
    ):
        super(VoltageClamp, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="VoltageClamp"
        )
        if self.delay is not None and "delay" not in already_processed:
            already_processed.add("delay")
            outfile.write(
                " delay=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.delay), input_name="delay"
                        )
                    ),
                )
            )
        if self.duration is not None and "duration" not in already_processed:
            already_processed.add("duration")
            outfile.write(
                " duration=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.duration), input_name="duration"
                        )
                    ),
                )
            )
        if (
            self.target_voltage is not None
            and "target_voltage" not in already_processed
        ):
            already_processed.add("target_voltage")
            outfile.write(
                " targetVoltage=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.target_voltage),
                            input_name="targetVoltage",
                        )
                    ),
                )
            )
        if (
            self.simple_series_resistance is not None
            and "simple_series_resistance" not in already_processed
        ):
            already_processed.add("simple_series_resistance")
            outfile.write(
                " simpleSeriesResistance=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.simple_series_resistance),
                            input_name="simpleSeriesResistance",
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="VoltageClamp",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(VoltageClamp, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.delay, "delay"
        )
        self.gds_check_cardinality_(self.delay, "delay", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.duration, "duration"
        )
        self.gds_check_cardinality_(self.duration, "duration", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.target_voltage, "target_voltage"
        )
        self.gds_check_cardinality_(
            self.target_voltage, "target_voltage", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_resistance,
            self.simple_series_resistance,
            "simple_series_resistance",
        )
        self.gds_check_cardinality_(
            self.simple_series_resistance, "simple_series_resistance", required=True
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("delay", node)
        if value is not None and "delay" not in already_processed:
            already_processed.add("delay")
            self.delay = value
            self.validate_Nml2Quantity_time(
                self.delay
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("duration", node)
        if value is not None and "duration" not in already_processed:
            already_processed.add("duration")
            self.duration = value
            self.validate_Nml2Quantity_time(
                self.duration
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("targetVoltage", node)
        if value is not None and "targetVoltage" not in already_processed:
            already_processed.add("targetVoltage")
            self.target_voltage = value
            self.validate_Nml2Quantity_voltage(
                self.target_voltage
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("simpleSeriesResistance", node)
        if value is not None and "simpleSeriesResistance" not in already_processed:
            already_processed.add("simpleSeriesResistance")
            self.simple_series_resistance = value
            self.validate_Nml2Quantity_resistance(
                self.simple_series_resistance
            )  # validate type Nml2Quantity_resistance
        super(VoltageClamp, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(VoltageClamp, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class VoltageClamp


class CompoundInputDL(Standalone):
    """CompoundInputDL -- Generates a current which is the sum of all its child  **basePointCurrentDL**  elements, e. g. can be a combination of  **pulseGeneratorDL** ,  **sineGeneratorDL**  elements producing a single **i.**  Scaled by **weight,**  if set"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "pulse_generator_dls",
            "PulseGeneratorDL",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "pulseGeneratorDL",
                "type": "PulseGeneratorDL",
            },
            None,
        ),
        MemberSpec_(
            "sine_generator_dls",
            "SineGeneratorDL",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "sineGeneratorDL",
                "type": "SineGeneratorDL",
            },
            None,
        ),
        MemberSpec_(
            "ramp_generator_dls",
            "RampGeneratorDL",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "rampGeneratorDL",
                "type": "RampGeneratorDL",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        pulse_generator_dls: "list of PulseGeneratorDL(s) (optional)" = None,
        sine_generator_dls: "list of SineGeneratorDL(s) (optional)" = None,
        ramp_generator_dls: "list of RampGeneratorDL(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("CompoundInputDL"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        if pulse_generator_dls is None:
            self.pulse_generator_dls = []
        else:
            self.pulse_generator_dls = pulse_generator_dls
        self.pulse_generator_dls_nsprefix_ = None
        if sine_generator_dls is None:
            self.sine_generator_dls = []
        else:
            self.sine_generator_dls = sine_generator_dls
        self.sine_generator_dls_nsprefix_ = None
        if ramp_generator_dls is None:
            self.ramp_generator_dls = []
        else:
            self.ramp_generator_dls = ramp_generator_dls
        self.ramp_generator_dls_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CompoundInputDL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompoundInputDL.subclass:
            return CompoundInputDL.subclass(*args_, **kwargs_)
        else:
            return CompoundInputDL(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.pulse_generator_dls
            or self.sine_generator_dls
            or self.ramp_generator_dls
            or super(CompoundInputDL, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="CompoundInputDL",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CompoundInputDL")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CompoundInputDL":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="CompoundInputDL"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CompoundInputDL",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CompoundInputDL",
    ):
        super(CompoundInputDL, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="CompoundInputDL"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="CompoundInputDL",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(CompoundInputDL, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for pulseGeneratorDL_ in self.pulse_generator_dls:
            namespaceprefix_ = (
                self.pulse_generator_dls_nsprefix_ + ":"
                if (UseCapturedNS_ and self.pulse_generator_dls_nsprefix_)
                else ""
            )
            pulseGeneratorDL_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="pulseGeneratorDL",
                pretty_print=pretty_print,
            )
        for sineGeneratorDL_ in self.sine_generator_dls:
            namespaceprefix_ = (
                self.sine_generator_dls_nsprefix_ + ":"
                if (UseCapturedNS_ and self.sine_generator_dls_nsprefix_)
                else ""
            )
            sineGeneratorDL_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="sineGeneratorDL",
                pretty_print=pretty_print,
            )
        for rampGeneratorDL_ in self.ramp_generator_dls:
            namespaceprefix_ = (
                self.ramp_generator_dls_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ramp_generator_dls_nsprefix_)
                else ""
            )
            rampGeneratorDL_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="rampGeneratorDL",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.pulse_generator_dls,
            "pulse_generator_dls",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.sine_generator_dls,
            "sine_generator_dls",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.ramp_generator_dls,
            "ramp_generator_dls",
            min_occurs=0,
            max_occurs=9999999,
        )
        if recursive:
            for item in self.pulse_generator_dls:
                item.validate_(gds_collector, recursive=True)
            for item in self.sine_generator_dls:
                item.validate_(gds_collector, recursive=True)
            for item in self.ramp_generator_dls:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(CompoundInputDL, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "pulseGeneratorDL":
            obj_ = PulseGeneratorDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pulse_generator_dls.append(obj_)
            obj_.original_tagname_ = "pulseGeneratorDL"
        elif nodeName_ == "sineGeneratorDL":
            obj_ = SineGeneratorDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sine_generator_dls.append(obj_)
            obj_.original_tagname_ = "sineGeneratorDL"
        elif nodeName_ == "rampGeneratorDL":
            obj_ = RampGeneratorDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ramp_generator_dls.append(obj_)
            obj_.original_tagname_ = "rampGeneratorDL"
        super(CompoundInputDL, self)._buildChildren(child_, node, nodeName_, True)


# end class CompoundInputDL


class CompoundInput(Standalone):
    """CompoundInput -- Generates a current which is the sum of all its child  **basePointCurrent**  element, e. g. can be a combination of  **pulseGenerator** ,  **sineGenerator**  elements producing a single **i.**  Scaled by **weight,**  if set"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "pulse_generators",
            "PulseGenerator",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "pulseGenerator",
                "type": "PulseGenerator",
            },
            None,
        ),
        MemberSpec_(
            "sine_generators",
            "SineGenerator",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "sineGenerator",
                "type": "SineGenerator",
            },
            None,
        ),
        MemberSpec_(
            "ramp_generators",
            "RampGenerator",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "rampGenerator",
                "type": "RampGenerator",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        pulse_generators: "list of PulseGenerator(s) (optional)" = None,
        sine_generators: "list of SineGenerator(s) (optional)" = None,
        ramp_generators: "list of RampGenerator(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("CompoundInput"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        if pulse_generators is None:
            self.pulse_generators = []
        else:
            self.pulse_generators = pulse_generators
        self.pulse_generators_nsprefix_ = None
        if sine_generators is None:
            self.sine_generators = []
        else:
            self.sine_generators = sine_generators
        self.sine_generators_nsprefix_ = None
        if ramp_generators is None:
            self.ramp_generators = []
        else:
            self.ramp_generators = ramp_generators
        self.ramp_generators_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, CompoundInput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompoundInput.subclass:
            return CompoundInput.subclass(*args_, **kwargs_)
        else:
            return CompoundInput(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.pulse_generators
            or self.sine_generators
            or self.ramp_generators
            or super(CompoundInput, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="CompoundInput",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("CompoundInput")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "CompoundInput":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="CompoundInput"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="CompoundInput",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="CompoundInput",
    ):
        super(CompoundInput, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="CompoundInput"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="CompoundInput",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(CompoundInput, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for pulseGenerator_ in self.pulse_generators:
            namespaceprefix_ = (
                self.pulse_generators_nsprefix_ + ":"
                if (UseCapturedNS_ and self.pulse_generators_nsprefix_)
                else ""
            )
            pulseGenerator_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="pulseGenerator",
                pretty_print=pretty_print,
            )
        for sineGenerator_ in self.sine_generators:
            namespaceprefix_ = (
                self.sine_generators_nsprefix_ + ":"
                if (UseCapturedNS_ and self.sine_generators_nsprefix_)
                else ""
            )
            sineGenerator_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="sineGenerator",
                pretty_print=pretty_print,
            )
        for rampGenerator_ in self.ramp_generators:
            namespaceprefix_ = (
                self.ramp_generators_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ramp_generators_nsprefix_)
                else ""
            )
            rampGenerator_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="rampGenerator",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.pulse_generators, "pulse_generators", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.sine_generators, "sine_generators", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.ramp_generators, "ramp_generators", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.pulse_generators:
                item.validate_(gds_collector, recursive=True)
            for item in self.sine_generators:
                item.validate_(gds_collector, recursive=True)
            for item in self.ramp_generators:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(CompoundInput, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "pulseGenerator":
            obj_ = PulseGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pulse_generators.append(obj_)
            obj_.original_tagname_ = "pulseGenerator"
        elif nodeName_ == "sineGenerator":
            obj_ = SineGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sine_generators.append(obj_)
            obj_.original_tagname_ = "sineGenerator"
        elif nodeName_ == "rampGenerator":
            obj_ = RampGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ramp_generators.append(obj_)
            obj_.original_tagname_ = "rampGenerator"
        super(CompoundInput, self)._buildChildren(child_, node, nodeName_, True)


# end class CompoundInput


class RampGeneratorDL(Standalone):
    """RampGeneratorDL -- Dimensionless equivalent of  **rampGenerator** . Generates a ramping current after a time **delay,**  for a fixed **duration.**  During this time the dimensionless current steadily changes from **startAmplitude**  to **finishAmplitude.**  Scaled by **weight,**  if set
    \n
    :param delay: Delay before change in current. Current is baselineAmplitude prior to this.
    :type delay: time
    :param duration: Duration for holding current at amplitude. Current is baselineAmplitude after delay + duration.
    :type duration: time
    :param startAmplitude: Amplitude of linearly varying current at time delay
    :type startAmplitude: none
    :param finishAmplitude: Amplitude of linearly varying current at time delay + duration
    :type finishAmplitude: none
    :param baselineAmplitude: Amplitude of current before time delay, and after time delay + duration
    :type baselineAmplitude: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "delay", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "delay"}
        ),
        MemberSpec_(
            "duration",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "duration"},
        ),
        MemberSpec_(
            "start_amplitude",
            "Nml2Quantity_none",
            0,
            0,
            {"use": "required", "name": "start_amplitude"},
        ),
        MemberSpec_(
            "finish_amplitude",
            "Nml2Quantity_none",
            0,
            0,
            {"use": "required", "name": "finish_amplitude"},
        ),
        MemberSpec_(
            "baseline_amplitude",
            "Nml2Quantity_none",
            0,
            0,
            {"use": "required", "name": "baseline_amplitude"},
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        delay: "a Nml2Quantity_time (required)" = None,
        duration: "a Nml2Quantity_time (required)" = None,
        start_amplitude: "a Nml2Quantity_current (required)" = None,
        finish_amplitude: "a Nml2Quantity_current (required)" = None,
        baseline_amplitude: "a Nml2Quantity_current (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("RampGeneratorDL"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.start_amplitude = _cast(None, start_amplitude)
        self.start_amplitude_nsprefix_ = None
        self.finish_amplitude = _cast(None, finish_amplitude)
        self.finish_amplitude_nsprefix_ = None
        self.baseline_amplitude = _cast(None, baseline_amplitude)
        self.baseline_amplitude_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, RampGeneratorDL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RampGeneratorDL.subclass:
            return RampGeneratorDL.subclass(*args_, **kwargs_)
        else:
            return RampGeneratorDL(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_none_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_none_patterns_,
                    )
                )

    validate_Nml2Quantity_none_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$"]
    ]

    def _hasContent(self):
        if super(RampGeneratorDL, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="RampGeneratorDL",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("RampGeneratorDL")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "RampGeneratorDL":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="RampGeneratorDL"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="RampGeneratorDL",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="RampGeneratorDL",
    ):
        super(RampGeneratorDL, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="RampGeneratorDL"
        )
        if self.delay is not None and "delay" not in already_processed:
            already_processed.add("delay")
            outfile.write(
                " delay=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.delay), input_name="delay"
                        )
                    ),
                )
            )
        if self.duration is not None and "duration" not in already_processed:
            already_processed.add("duration")
            outfile.write(
                " duration=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.duration), input_name="duration"
                        )
                    ),
                )
            )
        if (
            self.start_amplitude is not None
            and "start_amplitude" not in already_processed
        ):
            already_processed.add("start_amplitude")
            outfile.write(
                " startAmplitude=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.start_amplitude),
                            input_name="startAmplitude",
                        )
                    ),
                )
            )
        if (
            self.finish_amplitude is not None
            and "finish_amplitude" not in already_processed
        ):
            already_processed.add("finish_amplitude")
            outfile.write(
                " finishAmplitude=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.finish_amplitude),
                            input_name="finishAmplitude",
                        )
                    ),
                )
            )
        if (
            self.baseline_amplitude is not None
            and "baseline_amplitude" not in already_processed
        ):
            already_processed.add("baseline_amplitude")
            outfile.write(
                " baselineAmplitude=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.baseline_amplitude),
                            input_name="baselineAmplitude",
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="RampGeneratorDL",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(RampGeneratorDL, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.delay, "delay"
        )
        self.gds_check_cardinality_(self.delay, "delay", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.duration, "duration"
        )
        self.gds_check_cardinality_(self.duration, "duration", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_none, self.start_amplitude, "start_amplitude"
        )
        self.gds_check_cardinality_(
            self.start_amplitude, "start_amplitude", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_none, self.finish_amplitude, "finish_amplitude"
        )
        self.gds_check_cardinality_(
            self.finish_amplitude, "finish_amplitude", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_none,
            self.baseline_amplitude,
            "baseline_amplitude",
        )
        self.gds_check_cardinality_(
            self.baseline_amplitude, "baseline_amplitude", required=True
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("delay", node)
        if value is not None and "delay" not in already_processed:
            already_processed.add("delay")
            self.delay = value
            self.validate_Nml2Quantity_time(
                self.delay
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("duration", node)
        if value is not None and "duration" not in already_processed:
            already_processed.add("duration")
            self.duration = value
            self.validate_Nml2Quantity_time(
                self.duration
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("startAmplitude", node)
        if value is not None and "startAmplitude" not in already_processed:
            already_processed.add("startAmplitude")
            self.start_amplitude = value
            self.validate_Nml2Quantity_none(
                self.start_amplitude
            )  # validate type Nml2Quantity_none
        value = find_attr_value_("finishAmplitude", node)
        if value is not None and "finishAmplitude" not in already_processed:
            already_processed.add("finishAmplitude")
            self.finish_amplitude = value
            self.validate_Nml2Quantity_none(
                self.finish_amplitude
            )  # validate type Nml2Quantity_none
        value = find_attr_value_("baselineAmplitude", node)
        if value is not None and "baselineAmplitude" not in already_processed:
            already_processed.add("baselineAmplitude")
            self.baseline_amplitude = value
            self.validate_Nml2Quantity_none(
                self.baseline_amplitude
            )  # validate type Nml2Quantity_none
        super(RampGeneratorDL, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(RampGeneratorDL, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class RampGeneratorDL


class RampGenerator(Standalone):
    """RampGenerator -- Generates a ramping current after a time **delay,**  for a fixed **duration.**  During this time the current steadily changes from **startAmplitude**  to **finishAmplitude.**  Scaled by **weight,**  if set
    \n
    :param delay: Delay before change in current. Current is baselineAmplitude prior to this.
    :type delay: time
    :param duration: Duration for holding current at amplitude. Current is baselineAmplitude after delay + duration.
    :type duration: time
    :param startAmplitude: Amplitude of linearly varying current at time delay
    :type startAmplitude: current
    :param finishAmplitude: Amplitude of linearly varying current at time delay + duration
    :type finishAmplitude: current
    :param baselineAmplitude: Amplitude of current before time delay, and after time delay + duration
    :type baselineAmplitude: current

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "delay", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "delay"}
        ),
        MemberSpec_(
            "duration",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "duration"},
        ),
        MemberSpec_(
            "start_amplitude",
            "Nml2Quantity_current",
            0,
            0,
            {"use": "required", "name": "start_amplitude"},
        ),
        MemberSpec_(
            "finish_amplitude",
            "Nml2Quantity_current",
            0,
            0,
            {"use": "required", "name": "finish_amplitude"},
        ),
        MemberSpec_(
            "baseline_amplitude",
            "Nml2Quantity_current",
            0,
            0,
            {"use": "required", "name": "baseline_amplitude"},
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        delay: "a Nml2Quantity_time (required)" = None,
        duration: "a Nml2Quantity_time (required)" = None,
        start_amplitude: "a Nml2Quantity_current (required)" = None,
        finish_amplitude: "a Nml2Quantity_current (required)" = None,
        baseline_amplitude: "a Nml2Quantity_current (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("RampGenerator"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.start_amplitude = _cast(None, start_amplitude)
        self.start_amplitude_nsprefix_ = None
        self.finish_amplitude = _cast(None, finish_amplitude)
        self.finish_amplitude_nsprefix_ = None
        self.baseline_amplitude = _cast(None, baseline_amplitude)
        self.baseline_amplitude_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, RampGenerator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RampGenerator.subclass:
            return RampGenerator.subclass(*args_, **kwargs_)
        else:
            return RampGenerator(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_current_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_current_patterns_,
                    )
                )

    validate_Nml2Quantity_current_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A|uA|nA|pA))$"]
    ]

    def _hasContent(self):
        if super(RampGenerator, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="RampGenerator",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("RampGenerator")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "RampGenerator":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="RampGenerator"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="RampGenerator",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="RampGenerator",
    ):
        super(RampGenerator, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="RampGenerator"
        )
        if self.delay is not None and "delay" not in already_processed:
            already_processed.add("delay")
            outfile.write(
                " delay=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.delay), input_name="delay"
                        )
                    ),
                )
            )
        if self.duration is not None and "duration" not in already_processed:
            already_processed.add("duration")
            outfile.write(
                " duration=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.duration), input_name="duration"
                        )
                    ),
                )
            )
        if (
            self.start_amplitude is not None
            and "start_amplitude" not in already_processed
        ):
            already_processed.add("start_amplitude")
            outfile.write(
                " startAmplitude=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.start_amplitude),
                            input_name="startAmplitude",
                        )
                    ),
                )
            )
        if (
            self.finish_amplitude is not None
            and "finish_amplitude" not in already_processed
        ):
            already_processed.add("finish_amplitude")
            outfile.write(
                " finishAmplitude=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.finish_amplitude),
                            input_name="finishAmplitude",
                        )
                    ),
                )
            )
        if (
            self.baseline_amplitude is not None
            and "baseline_amplitude" not in already_processed
        ):
            already_processed.add("baseline_amplitude")
            outfile.write(
                " baselineAmplitude=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.baseline_amplitude),
                            input_name="baselineAmplitude",
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="RampGenerator",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(RampGenerator, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.delay, "delay"
        )
        self.gds_check_cardinality_(self.delay, "delay", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.duration, "duration"
        )
        self.gds_check_cardinality_(self.duration, "duration", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_current, self.start_amplitude, "start_amplitude"
        )
        self.gds_check_cardinality_(
            self.start_amplitude, "start_amplitude", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_current,
            self.finish_amplitude,
            "finish_amplitude",
        )
        self.gds_check_cardinality_(
            self.finish_amplitude, "finish_amplitude", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_current,
            self.baseline_amplitude,
            "baseline_amplitude",
        )
        self.gds_check_cardinality_(
            self.baseline_amplitude, "baseline_amplitude", required=True
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("delay", node)
        if value is not None and "delay" not in already_processed:
            already_processed.add("delay")
            self.delay = value
            self.validate_Nml2Quantity_time(
                self.delay
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("duration", node)
        if value is not None and "duration" not in already_processed:
            already_processed.add("duration")
            self.duration = value
            self.validate_Nml2Quantity_time(
                self.duration
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("startAmplitude", node)
        if value is not None and "startAmplitude" not in already_processed:
            already_processed.add("startAmplitude")
            self.start_amplitude = value
            self.validate_Nml2Quantity_current(
                self.start_amplitude
            )  # validate type Nml2Quantity_current
        value = find_attr_value_("finishAmplitude", node)
        if value is not None and "finishAmplitude" not in already_processed:
            already_processed.add("finishAmplitude")
            self.finish_amplitude = value
            self.validate_Nml2Quantity_current(
                self.finish_amplitude
            )  # validate type Nml2Quantity_current
        value = find_attr_value_("baselineAmplitude", node)
        if value is not None and "baselineAmplitude" not in already_processed:
            already_processed.add("baselineAmplitude")
            self.baseline_amplitude = value
            self.validate_Nml2Quantity_current(
                self.baseline_amplitude
            )  # validate type Nml2Quantity_current
        super(RampGenerator, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(RampGenerator, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class RampGenerator


class SineGeneratorDL(Standalone):
    """SineGeneratorDL -- Dimensionless equivalent of  **sineGenerator** . Generates a sinusoidally varying current after a time **delay,**  for a fixed **duration.**  The **period**  and maximum **amplitude**  of the current can be set as well as the **phase**  at which to start. Scaled by **weight,**  if set
    \n
    :param phase: Phase ( between 0 and 2*pi ) at which to start the varying current ( i. e. at time given by delay )
    :type phase: none
    :param delay: Delay before change in current. Current is zero prior to this.
    :type delay: time
    :param duration: Duration for holding current at amplitude. Current is zero after delay + duration.
    :type duration: time
    :param amplitude: Maximum amplitude of current
    :type amplitude: none
    :param period: Time period of oscillation
    :type period: time

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "delay", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "delay"}
        ),
        MemberSpec_(
            "phase", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "phase"}
        ),
        MemberSpec_(
            "duration",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "duration"},
        ),
        MemberSpec_(
            "amplitude",
            "Nml2Quantity_none",
            0,
            0,
            {"use": "required", "name": "amplitude"},
        ),
        MemberSpec_(
            "period", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "period"}
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        delay: "a Nml2Quantity_time (required)" = None,
        phase: "a Nml2Quantity_none (required)" = None,
        duration: "a Nml2Quantity_time (required)" = None,
        amplitude: "a Nml2Quantity_current (required)" = None,
        period: "a Nml2Quantity_time (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SineGeneratorDL"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.phase = _cast(None, phase)
        self.phase_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.amplitude = _cast(None, amplitude)
        self.amplitude_nsprefix_ = None
        self.period = _cast(None, period)
        self.period_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SineGeneratorDL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SineGeneratorDL.subclass:
            return SineGeneratorDL.subclass(*args_, **kwargs_)
        else:
            return SineGeneratorDL(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_none_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_none_patterns_,
                    )
                )

    validate_Nml2Quantity_none_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$"]
    ]

    def _hasContent(self):
        if super(SineGeneratorDL, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SineGeneratorDL",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SineGeneratorDL")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SineGeneratorDL":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SineGeneratorDL"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SineGeneratorDL",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SineGeneratorDL",
    ):
        super(SineGeneratorDL, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SineGeneratorDL"
        )
        if self.delay is not None and "delay" not in already_processed:
            already_processed.add("delay")
            outfile.write(
                " delay=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.delay), input_name="delay"
                        )
                    ),
                )
            )
        if self.phase is not None and "phase" not in already_processed:
            already_processed.add("phase")
            outfile.write(
                " phase=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.phase), input_name="phase"
                        )
                    ),
                )
            )
        if self.duration is not None and "duration" not in already_processed:
            already_processed.add("duration")
            outfile.write(
                " duration=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.duration), input_name="duration"
                        )
                    ),
                )
            )
        if self.amplitude is not None and "amplitude" not in already_processed:
            already_processed.add("amplitude")
            outfile.write(
                " amplitude=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.amplitude), input_name="amplitude"
                        )
                    ),
                )
            )
        if self.period is not None and "period" not in already_processed:
            already_processed.add("period")
            outfile.write(
                " period=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.period), input_name="period"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SineGeneratorDL",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SineGeneratorDL, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.delay, "delay"
        )
        self.gds_check_cardinality_(self.delay, "delay", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_none, self.phase, "phase"
        )
        self.gds_check_cardinality_(self.phase, "phase", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.duration, "duration"
        )
        self.gds_check_cardinality_(self.duration, "duration", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_none, self.amplitude, "amplitude"
        )
        self.gds_check_cardinality_(self.amplitude, "amplitude", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.period, "period"
        )
        self.gds_check_cardinality_(self.period, "period", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("delay", node)
        if value is not None and "delay" not in already_processed:
            already_processed.add("delay")
            self.delay = value
            self.validate_Nml2Quantity_time(
                self.delay
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("phase", node)
        if value is not None and "phase" not in already_processed:
            already_processed.add("phase")
            self.phase = value
            self.validate_Nml2Quantity_none(
                self.phase
            )  # validate type Nml2Quantity_none
        value = find_attr_value_("duration", node)
        if value is not None and "duration" not in already_processed:
            already_processed.add("duration")
            self.duration = value
            self.validate_Nml2Quantity_time(
                self.duration
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("amplitude", node)
        if value is not None and "amplitude" not in already_processed:
            already_processed.add("amplitude")
            self.amplitude = value
            self.validate_Nml2Quantity_none(
                self.amplitude
            )  # validate type Nml2Quantity_none
        value = find_attr_value_("period", node)
        if value is not None and "period" not in already_processed:
            already_processed.add("period")
            self.period = value
            self.validate_Nml2Quantity_time(
                self.period
            )  # validate type Nml2Quantity_time
        super(SineGeneratorDL, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SineGeneratorDL, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class SineGeneratorDL


class SineGenerator(Standalone):
    """SineGenerator -- Generates a sinusoidally varying current after a time **delay,**  for a fixed **duration.**  The **period**  and maximum **amplitude**  of the current can be set as well as the **phase**  at which to start. Scaled by **weight,**  if set
    \n
    :param phase: Phase ( between 0 and 2*pi ) at which to start the varying current ( i. e. at time given by delay )
    :type phase: none
    :param delay: Delay before change in current. Current is zero prior to this.
    :type delay: time
    :param duration: Duration for holding current at amplitude. Current is zero after delay + duration.
    :type duration: time
    :param amplitude: Maximum amplitude of current
    :type amplitude: current
    :param period: Time period of oscillation
    :type period: time

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "delay", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "delay"}
        ),
        MemberSpec_(
            "phase", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "phase"}
        ),
        MemberSpec_(
            "duration",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "duration"},
        ),
        MemberSpec_(
            "amplitude",
            "Nml2Quantity_current",
            0,
            0,
            {"use": "required", "name": "amplitude"},
        ),
        MemberSpec_(
            "period", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "period"}
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        delay: "a Nml2Quantity_time (required)" = None,
        phase: "a Nml2Quantity_none (required)" = None,
        duration: "a Nml2Quantity_time (required)" = None,
        amplitude: "a Nml2Quantity_current (required)" = None,
        period: "a Nml2Quantity_time (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SineGenerator"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.phase = _cast(None, phase)
        self.phase_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.amplitude = _cast(None, amplitude)
        self.amplitude_nsprefix_ = None
        self.period = _cast(None, period)
        self.period_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SineGenerator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SineGenerator.subclass:
            return SineGenerator.subclass(*args_, **kwargs_)
        else:
            return SineGenerator(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_none_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_none_patterns_,
                    )
                )

    validate_Nml2Quantity_none_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$"]
    ]

    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_current_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_current_patterns_,
                    )
                )

    validate_Nml2Quantity_current_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A|uA|nA|pA))$"]
    ]

    def _hasContent(self):
        if super(SineGenerator, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SineGenerator",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SineGenerator")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SineGenerator":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SineGenerator"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SineGenerator",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SineGenerator",
    ):
        super(SineGenerator, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SineGenerator"
        )
        if self.delay is not None and "delay" not in already_processed:
            already_processed.add("delay")
            outfile.write(
                " delay=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.delay), input_name="delay"
                        )
                    ),
                )
            )
        if self.phase is not None and "phase" not in already_processed:
            already_processed.add("phase")
            outfile.write(
                " phase=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.phase), input_name="phase"
                        )
                    ),
                )
            )
        if self.duration is not None and "duration" not in already_processed:
            already_processed.add("duration")
            outfile.write(
                " duration=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.duration), input_name="duration"
                        )
                    ),
                )
            )
        if self.amplitude is not None and "amplitude" not in already_processed:
            already_processed.add("amplitude")
            outfile.write(
                " amplitude=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.amplitude), input_name="amplitude"
                        )
                    ),
                )
            )
        if self.period is not None and "period" not in already_processed:
            already_processed.add("period")
            outfile.write(
                " period=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.period), input_name="period"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SineGenerator",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SineGenerator, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.delay, "delay"
        )
        self.gds_check_cardinality_(self.delay, "delay", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_none, self.phase, "phase"
        )
        self.gds_check_cardinality_(self.phase, "phase", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.duration, "duration"
        )
        self.gds_check_cardinality_(self.duration, "duration", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_current, self.amplitude, "amplitude"
        )
        self.gds_check_cardinality_(self.amplitude, "amplitude", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.period, "period"
        )
        self.gds_check_cardinality_(self.period, "period", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("delay", node)
        if value is not None and "delay" not in already_processed:
            already_processed.add("delay")
            self.delay = value
            self.validate_Nml2Quantity_time(
                self.delay
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("phase", node)
        if value is not None and "phase" not in already_processed:
            already_processed.add("phase")
            self.phase = value
            self.validate_Nml2Quantity_none(
                self.phase
            )  # validate type Nml2Quantity_none
        value = find_attr_value_("duration", node)
        if value is not None and "duration" not in already_processed:
            already_processed.add("duration")
            self.duration = value
            self.validate_Nml2Quantity_time(
                self.duration
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("amplitude", node)
        if value is not None and "amplitude" not in already_processed:
            already_processed.add("amplitude")
            self.amplitude = value
            self.validate_Nml2Quantity_current(
                self.amplitude
            )  # validate type Nml2Quantity_current
        value = find_attr_value_("period", node)
        if value is not None and "period" not in already_processed:
            already_processed.add("period")
            self.period = value
            self.validate_Nml2Quantity_time(
                self.period
            )  # validate type Nml2Quantity_time
        super(SineGenerator, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SineGenerator, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class SineGenerator


class PulseGeneratorDL(Standalone):
    """PulseGeneratorDL -- Dimensionless equivalent of  **pulseGenerator** . Generates a constant current pulse of a certain **amplitude**  for a specified **duration**  after a **delay.**  Scaled by **weight,**  if set
    \n
    :param delay: Delay before change in current. Current is zero prior to this.
    :type delay: time
    :param duration: Duration for holding current at amplitude. Current is zero after delay + duration.
    :type duration: time
    :param amplitude: Amplitude of current pulse
    :type amplitude: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "delay", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "delay"}
        ),
        MemberSpec_(
            "duration",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "duration"},
        ),
        MemberSpec_(
            "amplitude",
            "Nml2Quantity_none",
            0,
            0,
            {"use": "required", "name": "amplitude"},
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        delay: "a Nml2Quantity_time (required)" = None,
        duration: "a Nml2Quantity_time (required)" = None,
        amplitude: "a Nml2Quantity_current (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("PulseGeneratorDL"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.amplitude = _cast(None, amplitude)
        self.amplitude_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, PulseGeneratorDL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PulseGeneratorDL.subclass:
            return PulseGeneratorDL.subclass(*args_, **kwargs_)
        else:
            return PulseGeneratorDL(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_none_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_none_patterns_,
                    )
                )

    validate_Nml2Quantity_none_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$"]
    ]

    def _hasContent(self):
        if super(PulseGeneratorDL, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="PulseGeneratorDL",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("PulseGeneratorDL")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "PulseGeneratorDL":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="PulseGeneratorDL",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="PulseGeneratorDL",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="PulseGeneratorDL",
    ):
        super(PulseGeneratorDL, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="PulseGeneratorDL",
        )
        if self.delay is not None and "delay" not in already_processed:
            already_processed.add("delay")
            outfile.write(
                " delay=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.delay), input_name="delay"
                        )
                    ),
                )
            )
        if self.duration is not None and "duration" not in already_processed:
            already_processed.add("duration")
            outfile.write(
                " duration=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.duration), input_name="duration"
                        )
                    ),
                )
            )
        if self.amplitude is not None and "amplitude" not in already_processed:
            already_processed.add("amplitude")
            outfile.write(
                " amplitude=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.amplitude), input_name="amplitude"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="PulseGeneratorDL",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(PulseGeneratorDL, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.delay, "delay"
        )
        self.gds_check_cardinality_(self.delay, "delay", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.duration, "duration"
        )
        self.gds_check_cardinality_(self.duration, "duration", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_none, self.amplitude, "amplitude"
        )
        self.gds_check_cardinality_(self.amplitude, "amplitude", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("delay", node)
        if value is not None and "delay" not in already_processed:
            already_processed.add("delay")
            self.delay = value
            self.validate_Nml2Quantity_time(
                self.delay
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("duration", node)
        if value is not None and "duration" not in already_processed:
            already_processed.add("duration")
            self.duration = value
            self.validate_Nml2Quantity_time(
                self.duration
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("amplitude", node)
        if value is not None and "amplitude" not in already_processed:
            already_processed.add("amplitude")
            self.amplitude = value
            self.validate_Nml2Quantity_none(
                self.amplitude
            )  # validate type Nml2Quantity_none
        super(PulseGeneratorDL, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(PulseGeneratorDL, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class PulseGeneratorDL


class PulseGenerator(Standalone):
    """PulseGenerator -- Generates a constant current pulse of a certain **amplitude**  for a specified **duration**  after a **delay.**  Scaled by **weight,**  if set
    \n
    :param delay: Delay before change in current. Current is zero prior to this.
    :type delay: time
    :param duration: Duration for holding current at amplitude. Current is zero after delay + duration.
    :type duration: time
    :param amplitude: Amplitude of current pulse
    :type amplitude: current

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "delay", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "delay"}
        ),
        MemberSpec_(
            "duration",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "duration"},
        ),
        MemberSpec_(
            "amplitude",
            "Nml2Quantity_current",
            0,
            0,
            {"use": "required", "name": "amplitude"},
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        delay: "a Nml2Quantity_time (required)" = None,
        duration: "a Nml2Quantity_time (required)" = None,
        amplitude: "a Nml2Quantity_current (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("PulseGenerator"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.amplitude = _cast(None, amplitude)
        self.amplitude_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, PulseGenerator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PulseGenerator.subclass:
            return PulseGenerator.subclass(*args_, **kwargs_)
        else:
            return PulseGenerator(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_current_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_current_patterns_,
                    )
                )

    validate_Nml2Quantity_current_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A|uA|nA|pA))$"]
    ]

    def _hasContent(self):
        if super(PulseGenerator, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="PulseGenerator",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("PulseGenerator")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "PulseGenerator":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="PulseGenerator"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="PulseGenerator",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="PulseGenerator",
    ):
        super(PulseGenerator, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="PulseGenerator"
        )
        if self.delay is not None and "delay" not in already_processed:
            already_processed.add("delay")
            outfile.write(
                " delay=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.delay), input_name="delay"
                        )
                    ),
                )
            )
        if self.duration is not None and "duration" not in already_processed:
            already_processed.add("duration")
            outfile.write(
                " duration=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.duration), input_name="duration"
                        )
                    ),
                )
            )
        if self.amplitude is not None and "amplitude" not in already_processed:
            already_processed.add("amplitude")
            outfile.write(
                " amplitude=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.amplitude), input_name="amplitude"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="PulseGenerator",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(PulseGenerator, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.delay, "delay"
        )
        self.gds_check_cardinality_(self.delay, "delay", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.duration, "duration"
        )
        self.gds_check_cardinality_(self.duration, "duration", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_current, self.amplitude, "amplitude"
        )
        self.gds_check_cardinality_(self.amplitude, "amplitude", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("delay", node)
        if value is not None and "delay" not in already_processed:
            already_processed.add("delay")
            self.delay = value
            self.validate_Nml2Quantity_time(
                self.delay
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("duration", node)
        if value is not None and "duration" not in already_processed:
            already_processed.add("duration")
            self.duration = value
            self.validate_Nml2Quantity_time(
                self.duration
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("amplitude", node)
        if value is not None and "amplitude" not in already_processed:
            already_processed.add("amplitude")
            self.amplitude = value
            self.validate_Nml2Quantity_current(
                self.amplitude
            )  # validate type Nml2Quantity_current
        super(PulseGenerator, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(PulseGenerator, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class PulseGenerator


class ReactionScheme(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("source", "xs:string", 0, 0, {"use": "required", "name": "source"}),
        MemberSpec_("type", "xs:string", 0, 0, {"use": "required", "name": "type"}),
        MemberSpec_(
            "__ANY__",
            "__ANY__",
            1,
            1,
            {"maxOccurs": "unbounded", "minOccurs": "0", "processContents": "skip"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        source: "a string (required)" = None,
        type: "a string (required)" = None,
        anytypeobjs_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ReactionScheme"), self).__init__(id, **kwargs_)
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.type = _cast(None, type)
        self.type_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ReactionScheme)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReactionScheme.subclass:
            return ReactionScheme.subclass(*args_, **kwargs_)
        else:
            return ReactionScheme(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if self.anytypeobjs_ or super(ReactionScheme, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ReactionScheme",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ReactionScheme")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ReactionScheme":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ReactionScheme"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ReactionScheme",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ReactionScheme",
    ):
        super(ReactionScheme, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ReactionScheme"
        )
        if self.source is not None and "source" not in already_processed:
            already_processed.add("source")
            outfile.write(
                " source=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.source), input_name="source"
                        )
                    ),
                )
            )
        if self.type is not None and "type" not in already_processed:
            already_processed.add("type")
            outfile.write(
                " type=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.type), input_name="type"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ReactionScheme",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ReactionScheme, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write("\n")

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.source, "source")
        self.gds_check_cardinality_(self.source, "source", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.type, "type")
        self.gds_check_cardinality_(self.type, "type", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("source", node)
        if value is not None and "source" not in already_processed:
            already_processed.add("source")
            self.source = value
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type = value
        super(ReactionScheme, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        content_ = self.gds_build_any(child_, "ReactionScheme")
        self.anytypeobjs_.append(content_)
        super(ReactionScheme, self)._buildChildren(child_, node, nodeName_, True)


# end class ReactionScheme


class ExtracellularPropertiesLocal(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "species",
            "Species",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "species",
                "type": "Species",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        species: "list of Species(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ExtracellularPropertiesLocal"), self).__init__(
            id, **kwargs_
        )
        if species is None:
            self.species = []
        else:
            self.species = species
        self.species_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtracellularPropertiesLocal
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtracellularPropertiesLocal.subclass:
            return ExtracellularPropertiesLocal.subclass(*args_, **kwargs_)
        else:
            return ExtracellularPropertiesLocal(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if self.species or super(ExtracellularPropertiesLocal, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ExtracellularPropertiesLocal",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ExtracellularPropertiesLocal")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "ExtracellularPropertiesLocal"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ExtracellularPropertiesLocal",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ExtracellularPropertiesLocal",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ExtracellularPropertiesLocal",
    ):
        super(ExtracellularPropertiesLocal, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ExtracellularPropertiesLocal",
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ExtracellularPropertiesLocal",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ExtracellularPropertiesLocal, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for species_ in self.species:
            namespaceprefix_ = (
                self.species_nsprefix_ + ":"
                if (UseCapturedNS_ and self.species_nsprefix_)
                else ""
            )
            species_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="species",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.species, "species", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.species:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(ExtracellularPropertiesLocal, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "species":
            obj_ = Species.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.species.append(obj_)
            obj_.original_tagname_ = "species"
        super(ExtracellularPropertiesLocal, self)._buildChildren(
            child_, node, nodeName_, True
        )


# end class ExtracellularPropertiesLocal


class ExtracellularProperties(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "species",
            "Species",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "species",
                "type": "Species",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        species: "list of Species(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ExtracellularProperties"), self).__init__(id, **kwargs_)
        if species is None:
            self.species = []
        else:
            self.species = species
        self.species_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtracellularProperties
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtracellularProperties.subclass:
            return ExtracellularProperties.subclass(*args_, **kwargs_)
        else:
            return ExtracellularProperties(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if self.species or super(ExtracellularProperties, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ExtracellularProperties",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ExtracellularProperties")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ExtracellularProperties":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ExtracellularProperties",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ExtracellularProperties",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ExtracellularProperties",
    ):
        super(ExtracellularProperties, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ExtracellularProperties",
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ExtracellularProperties",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ExtracellularProperties, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for species_ in self.species:
            namespaceprefix_ = (
                self.species_nsprefix_ + ":"
                if (UseCapturedNS_ and self.species_nsprefix_)
                else ""
            )
            species_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="species",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.species, "species", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.species:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(ExtracellularProperties, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "species":
            obj_ = Species.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.species.append(obj_)
            obj_.original_tagname_ = "species"
        super(ExtracellularProperties, self)._buildChildren(
            child_, node, nodeName_, True
        )


# end class ExtracellularProperties


class IntracellularProperties(BaseWithoutId):
    """IntracellularProperties -- Biophysical properties related to the intracellular space within the  **cell** , such as the  **resistivity**  and the list of ionic  **species**  present. **caConc**  and **caConcExt**  are explicitly exposed here to facilitate accessing these values from other Components, even though **caConcExt**  is clearly not an intracellular property"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "species",
            "Species",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "species",
                "type": "Species",
            },
            None,
        ),
        MemberSpec_(
            "resistivities",
            "Resistivity",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "resistivity",
                "type": "Resistivity",
            },
            None,
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        species: "list of Species(s) (optional)" = None,
        resistivities: "list of Resistivity(s) (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IntracellularProperties"), self).__init__(
            extensiontype_, **kwargs_
        )
        if species is None:
            self.species = []
        else:
            self.species = species
        self.species_nsprefix_ = None
        if resistivities is None:
            self.resistivities = []
        else:
            self.resistivities = resistivities
        self.resistivities_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntracellularProperties
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntracellularProperties.subclass:
            return IntracellularProperties.subclass(*args_, **kwargs_)
        else:
            return IntracellularProperties(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.species
            or self.resistivities
            or super(IntracellularProperties, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="IntracellularProperties",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IntracellularProperties")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IntracellularProperties":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="IntracellularProperties",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IntracellularProperties",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="IntracellularProperties",
    ):
        super(IntracellularProperties, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="IntracellularProperties",
        )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="IntracellularProperties",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IntracellularProperties, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for species_ in self.species:
            namespaceprefix_ = (
                self.species_nsprefix_ + ":"
                if (UseCapturedNS_ and self.species_nsprefix_)
                else ""
            )
            species_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="species",
                pretty_print=pretty_print,
            )
        for resistivity_ in self.resistivities:
            namespaceprefix_ = (
                self.resistivities_nsprefix_ + ":"
                if (UseCapturedNS_ and self.resistivities_nsprefix_)
                else ""
            )
            resistivity_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="resistivity",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.species, "species", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.resistivities, "resistivities", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.species:
                item.validate_(gds_collector, recursive=True)
            for item in self.resistivities:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(IntracellularProperties, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "species":
            obj_ = Species.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.species.append(obj_)
            obj_.original_tagname_ = "species"
        elif nodeName_ == "resistivity":
            obj_ = Resistivity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.resistivities.append(obj_)
            obj_.original_tagname_ = "resistivity"
        super(IntracellularProperties, self)._buildChildren(
            child_, node, nodeName_, True
        )


# end class IntracellularProperties


class Species(Base):
    """Species -- Description of a chemical species identified by **ion,**  which has internal, **concentration,**  and external, **extConcentration**  values for its concentration
    \n
    :param initialConcentration:
    :type initialConcentration: concentration
    :param initialExtConcentration:
    :type initialExtConcentration: concentration

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "concentration_model",
            "NmlId",
            0,
            0,
            {"use": "required", "name": "concentration_model"},
        ),
        MemberSpec_("ion", "NmlId", 0, 1, {"use": "optional", "name": "ion"}),
        MemberSpec_(
            "initial_concentration",
            "Nml2Quantity_concentration",
            0,
            0,
            {"use": "required", "name": "initial_concentration"},
        ),
        MemberSpec_(
            "initial_ext_concentration",
            "Nml2Quantity_concentration",
            0,
            0,
            {"use": "required", "name": "initial_ext_concentration"},
        ),
        MemberSpec_(
            "segment_groups",
            "NmlId",
            0,
            1,
            {"use": "optional", "name": "segment_groups"},
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        concentration_model: "a NmlId (required)" = None,
        ion: "a NmlId (optional)" = None,
        initial_concentration: "a Nml2Quantity_concentration (required)" = None,
        initial_ext_concentration: "a Nml2Quantity_concentration (required)" = None,
        segment_groups: "a NmlId (optional)" = "all",
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Species"), self).__init__(id, **kwargs_)
        self.concentration_model = _cast(None, concentration_model)
        self.concentration_model_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        self.initial_concentration = _cast(None, initial_concentration)
        self.initial_concentration_nsprefix_ = None
        self.initial_ext_concentration = _cast(None, initial_ext_concentration)
        self.initial_ext_concentration_nsprefix_ = None
        self.segment_groups = _cast(None, segment_groups)
        self.segment_groups_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Species)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Species.subclass:
            return Species.subclass(*args_, **kwargs_)
        else:
            return Species(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_concentration(self, value):
        # Validate type Nml2Quantity_concentration, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_concentration_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_concentration_patterns_,
                    )
                )

    validate_Nml2Quantity_concentration_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(mol_per_m3|mol_per_cm3|M|mM))$"]
    ]

    def _hasContent(self):
        if super(Species, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Species",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Species")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Species":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Species"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Species",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Species"
    ):
        super(Species, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Species"
        )
        if (
            self.concentration_model is not None
            and "concentration_model" not in already_processed
        ):
            already_processed.add("concentration_model")
            outfile.write(
                " concentrationModel=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.concentration_model),
                            input_name="concentrationModel",
                        )
                    ),
                )
            )
        if self.ion is not None and "ion" not in already_processed:
            already_processed.add("ion")
            outfile.write(
                " ion=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.ion), input_name="ion")
                    ),
                )
            )
        if (
            self.initial_concentration is not None
            and "initial_concentration" not in already_processed
        ):
            already_processed.add("initial_concentration")
            outfile.write(
                " initialConcentration=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.initial_concentration),
                            input_name="initialConcentration",
                        )
                    ),
                )
            )
        if (
            self.initial_ext_concentration is not None
            and "initial_ext_concentration" not in already_processed
        ):
            already_processed.add("initial_ext_concentration")
            outfile.write(
                " initialExtConcentration=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.initial_ext_concentration),
                            input_name="initialExtConcentration",
                        )
                    ),
                )
            )
        if self.segment_groups != "all" and "segment_groups" not in already_processed:
            already_processed.add("segment_groups")
            outfile.write(
                " segmentGroup=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segment_groups), input_name="segmentGroup"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Species",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Species, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.concentration_model, "concentration_model"
        )
        self.gds_check_cardinality_(
            self.concentration_model, "concentration_model", required=True
        )
        self.gds_validate_defined_ST_(self.validate_NmlId, self.ion, "ion")
        self.gds_check_cardinality_(self.ion, "ion", required=False)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_concentration,
            self.initial_concentration,
            "initial_concentration",
        )
        self.gds_check_cardinality_(
            self.initial_concentration, "initial_concentration", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_concentration,
            self.initial_ext_concentration,
            "initial_ext_concentration",
        )
        self.gds_check_cardinality_(
            self.initial_ext_concentration, "initial_ext_concentration", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.segment_groups, "segment_groups"
        )
        self.gds_check_cardinality_(
            self.segment_groups, "segment_groups", required=False
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("concentrationModel", node)
        if value is not None and "concentrationModel" not in already_processed:
            already_processed.add("concentrationModel")
            self.concentration_model = value
            self.validate_NmlId(self.concentration_model)  # validate type NmlId
        value = find_attr_value_("ion", node)
        if value is not None and "ion" not in already_processed:
            already_processed.add("ion")
            self.ion = value
            self.validate_NmlId(self.ion)  # validate type NmlId
        value = find_attr_value_("initialConcentration", node)
        if value is not None and "initialConcentration" not in already_processed:
            already_processed.add("initialConcentration")
            self.initial_concentration = value
            self.validate_Nml2Quantity_concentration(
                self.initial_concentration
            )  # validate type Nml2Quantity_concentration
        value = find_attr_value_("initialExtConcentration", node)
        if value is not None and "initialExtConcentration" not in already_processed:
            already_processed.add("initialExtConcentration")
            self.initial_ext_concentration = value
            self.validate_Nml2Quantity_concentration(
                self.initial_ext_concentration
            )  # validate type Nml2Quantity_concentration
        value = find_attr_value_("segmentGroup", node)
        if value is not None and "segmentGroup" not in already_processed:
            already_processed.add("segmentGroup")
            self.segment_groups = value
            self.validate_NmlId(self.segment_groups)  # validate type NmlId
        super(Species, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Species, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class Species


class InhomogeneousValue(BaseWithoutId):
    """InhomogeneousValue -- Specifies the **value**  of an **inhomogeneousParameter.**  For usage see  **variableParameter**"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "inhomogeneous_parameters",
            "xs:string",
            0,
            0,
            {"use": "required", "name": "inhomogeneous_parameters"},
        ),
        MemberSpec_("value", "xs:string", 0, 0, {"use": "required", "name": "value"}),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        inhomogeneous_parameters: "a string (required)" = None,
        value: "a string (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("InhomogeneousValue"), self).__init__(**kwargs_)
        self.inhomogeneous_parameters = _cast(None, inhomogeneous_parameters)
        self.inhomogeneous_parameters_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InhomogeneousValue
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InhomogeneousValue.subclass:
            return InhomogeneousValue.subclass(*args_, **kwargs_)
        else:
            return InhomogeneousValue(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(InhomogeneousValue, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="InhomogeneousValue",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("InhomogeneousValue")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "InhomogeneousValue":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="InhomogeneousValue",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="InhomogeneousValue",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="InhomogeneousValue",
    ):
        super(InhomogeneousValue, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="InhomogeneousValue",
        )
        if (
            self.inhomogeneous_parameters is not None
            and "inhomogeneous_parameters" not in already_processed
        ):
            already_processed.add("inhomogeneous_parameters")
            outfile.write(
                " inhomogeneousParameter=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.inhomogeneous_parameters),
                            input_name="inhomogeneousParameter",
                        )
                    ),
                )
            )
        if self.value is not None and "value" not in already_processed:
            already_processed.add("value")
            outfile.write(
                " value=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.value), input_name="value"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="InhomogeneousValue",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(InhomogeneousValue, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(
            self.gds_validate_string,
            self.inhomogeneous_parameters,
            "inhomogeneous_parameters",
        )
        self.gds_check_cardinality_(
            self.inhomogeneous_parameters, "inhomogeneous_parameters", required=True
        )
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.value, "value")
        self.gds_check_cardinality_(self.value, "value", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("inhomogeneousParameter", node)
        if value is not None and "inhomogeneousParameter" not in already_processed:
            already_processed.add("inhomogeneousParameter")
            self.inhomogeneous_parameters = value
        value = find_attr_value_("value", node)
        if value is not None and "value" not in already_processed:
            already_processed.add("value")
            self.value = value
        super(InhomogeneousValue, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(InhomogeneousValue, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class InhomogeneousValue


class ChannelDensityGHK2(Base):
    """ChannelDensityGHK2 -- Time varying conductance density, **gDensity,**  which is distributed on an area of the cell, producing a current density **iDensity.**  Modified version of Jaffe et al. 1994 ( used also in Lawrence et al. 2006 ). See https://github.com/OpenSourceBrain/ghk-nernst.
    \n
    :param condDensity:
    :type condDensity: conductanceDensity

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "ion_channel", "NmlId", 0, 0, {"use": "required", "name": "ion_channel"}
        ),
        MemberSpec_(
            "cond_density",
            "Nml2Quantity_conductanceDensity",
            0,
            1,
            {"use": "optional", "name": "cond_density"},
        ),
        MemberSpec_(
            "segment_groups",
            "NmlId",
            0,
            1,
            {"use": "optional", "name": "segment_groups"},
        ),
        MemberSpec_("segments", "NmlId", 0, 1, {"use": "optional", "name": "segments"}),
        MemberSpec_("ion", "NmlId", 0, 0, {"use": "required", "name": "ion"}),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        ion_channel: "a NmlId (required)" = None,
        cond_density: "a Nml2Quantity_conductanceDensity (optional)" = None,
        segment_groups: "a NmlId (optional)" = "all",
        segments: "a NonNegativeInteger (optional)" = None,
        ion: "a NmlId (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ChannelDensityGHK2"), self).__init__(id, **kwargs_)
        self.ion_channel = _cast(None, ion_channel)
        self.ion_channel_nsprefix_ = None
        self.cond_density = _cast(None, cond_density)
        self.cond_density_nsprefix_ = None
        self.segment_groups = _cast(None, segment_groups)
        self.segment_groups_nsprefix_ = None
        self.segments = _cast(None, segments)
        self.segments_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityGHK2
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityGHK2.subclass:
            return ChannelDensityGHK2.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityGHK2(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_conductanceDensity(self, value):
        # Validate type Nml2Quantity_conductanceDensity, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductanceDensity_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductanceDensity_patterns_,
                    )
                )

    validate_Nml2Quantity_conductanceDensity_patterns_ = [
        [
            "^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S_per_m2|mS_per_cm2|S_per_cm2))$"
        ]
    ]

    def _hasContent(self):
        if super(ChannelDensityGHK2, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ChannelDensityGHK2",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ChannelDensityGHK2")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ChannelDensityGHK2":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityGHK2",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ChannelDensityGHK2",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ChannelDensityGHK2",
    ):
        super(ChannelDensityGHK2, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityGHK2",
        )
        if self.ion_channel is not None and "ion_channel" not in already_processed:
            already_processed.add("ion_channel")
            outfile.write(
                " ionChannel=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.ion_channel), input_name="ionChannel"
                        )
                    ),
                )
            )
        if self.cond_density is not None and "cond_density" not in already_processed:
            already_processed.add("cond_density")
            outfile.write(
                " condDensity=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.cond_density), input_name="condDensity"
                        )
                    ),
                )
            )
        if self.segment_groups != "all" and "segment_groups" not in already_processed:
            already_processed.add("segment_groups")
            outfile.write(
                " segmentGroup=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segment_groups), input_name="segmentGroup"
                        )
                    ),
                )
            )
        if self.segments is not None and "segments" not in already_processed:
            already_processed.add("segments")
            outfile.write(
                " segment=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segments), input_name="segment"
                        )
                    ),
                )
            )
        if self.ion is not None and "ion" not in already_processed:
            already_processed.add("ion")
            outfile.write(
                " ion=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.ion), input_name="ion")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ChannelDensityGHK2",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ChannelDensityGHK2, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.ion_channel, "ion_channel"
        )
        self.gds_check_cardinality_(self.ion_channel, "ion_channel", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductanceDensity,
            self.cond_density,
            "cond_density",
        )
        self.gds_check_cardinality_(self.cond_density, "cond_density", required=False)
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.segment_groups, "segment_groups"
        )
        self.gds_check_cardinality_(
            self.segment_groups, "segment_groups", required=False
        )
        self.gds_validate_defined_ST_(self.validate_NmlId, self.segments, "segments")
        self.gds_check_cardinality_(self.segments, "segments", required=False)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.ion, "ion")
        self.gds_check_cardinality_(self.ion, "ion", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("ionChannel", node)
        if value is not None and "ionChannel" not in already_processed:
            already_processed.add("ionChannel")
            self.ion_channel = value
            self.validate_NmlId(self.ion_channel)  # validate type NmlId
        value = find_attr_value_("condDensity", node)
        if value is not None and "condDensity" not in already_processed:
            already_processed.add("condDensity")
            self.cond_density = value
            self.validate_Nml2Quantity_conductanceDensity(
                self.cond_density
            )  # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_("segmentGroup", node)
        if value is not None and "segmentGroup" not in already_processed:
            already_processed.add("segmentGroup")
            self.segment_groups = value
            self.validate_NmlId(self.segment_groups)  # validate type NmlId
        value = find_attr_value_("segment", node)
        if value is not None and "segment" not in already_processed:
            already_processed.add("segment")
            self.segments = value
            self.validate_NmlId(self.segments)  # validate type NmlId
        value = find_attr_value_("ion", node)
        if value is not None and "ion" not in already_processed:
            already_processed.add("ion")
            self.ion = value
            self.validate_NmlId(self.ion)  # validate type NmlId
        super(ChannelDensityGHK2, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ChannelDensityGHK2, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class ChannelDensityGHK2


class ChannelDensityGHK(Base):
    """ChannelDensityGHK -- Specifies a time varying conductance density, **gDensity,**  which is distributed on an area of the cell, producing a current density **iDensity**  and whose reversal potential is calculated from the Goldman Hodgkin Katz equation. Hard coded for Ca only! See https://github.com/OpenSourceBrain/ghk-nernst.
    \n
    :param permeability:
    :type permeability: permeability

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "ion_channel", "NmlId", 0, 0, {"use": "required", "name": "ion_channel"}
        ),
        MemberSpec_(
            "permeability",
            "Nml2Quantity_permeability",
            0,
            0,
            {"use": "required", "name": "permeability"},
        ),
        MemberSpec_(
            "segment_groups",
            "NmlId",
            0,
            1,
            {"use": "optional", "name": "segment_groups"},
        ),
        MemberSpec_("segments", "NmlId", 0, 1, {"use": "optional", "name": "segments"}),
        MemberSpec_("ion", "NmlId", 0, 0, {"use": "required", "name": "ion"}),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        ion_channel: "a NmlId (required)" = None,
        permeability: "a Nml2Quantity_permeability (required)" = None,
        segment_groups: "a NmlId (optional)" = "all",
        segments: "a NonNegativeInteger (optional)" = None,
        ion: "a NmlId (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ChannelDensityGHK"), self).__init__(id, **kwargs_)
        self.ion_channel = _cast(None, ion_channel)
        self.ion_channel_nsprefix_ = None
        self.permeability = _cast(None, permeability)
        self.permeability_nsprefix_ = None
        self.segment_groups = _cast(None, segment_groups)
        self.segment_groups_nsprefix_ = None
        self.segments = _cast(None, segments)
        self.segments_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ChannelDensityGHK)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityGHK.subclass:
            return ChannelDensityGHK.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityGHK(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_permeability(self, value):
        # Validate type Nml2Quantity_permeability, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_permeability_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_permeability_patterns_,
                    )
                )

    validate_Nml2Quantity_permeability_patterns_ = [
        [
            "^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(m_per_s|um_per_ms|cm_per_s|cm_per_ms))$"
        ]
    ]

    def _hasContent(self):
        if super(ChannelDensityGHK, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ChannelDensityGHK",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ChannelDensityGHK")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ChannelDensityGHK":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityGHK",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ChannelDensityGHK",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ChannelDensityGHK",
    ):
        super(ChannelDensityGHK, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityGHK",
        )
        if self.ion_channel is not None and "ion_channel" not in already_processed:
            already_processed.add("ion_channel")
            outfile.write(
                " ionChannel=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.ion_channel), input_name="ionChannel"
                        )
                    ),
                )
            )
        if self.permeability is not None and "permeability" not in already_processed:
            already_processed.add("permeability")
            outfile.write(
                " permeability=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.permeability), input_name="permeability"
                        )
                    ),
                )
            )
        if self.segment_groups != "all" and "segment_groups" not in already_processed:
            already_processed.add("segment_groups")
            outfile.write(
                " segmentGroup=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segment_groups), input_name="segmentGroup"
                        )
                    ),
                )
            )
        if self.segments is not None and "segments" not in already_processed:
            already_processed.add("segments")
            outfile.write(
                " segment=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segments), input_name="segment"
                        )
                    ),
                )
            )
        if self.ion is not None and "ion" not in already_processed:
            already_processed.add("ion")
            outfile.write(
                " ion=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.ion), input_name="ion")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ChannelDensityGHK",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ChannelDensityGHK, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.ion_channel, "ion_channel"
        )
        self.gds_check_cardinality_(self.ion_channel, "ion_channel", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_permeability, self.permeability, "permeability"
        )
        self.gds_check_cardinality_(self.permeability, "permeability", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.segment_groups, "segment_groups"
        )
        self.gds_check_cardinality_(
            self.segment_groups, "segment_groups", required=False
        )
        self.gds_validate_defined_ST_(self.validate_NmlId, self.segments, "segments")
        self.gds_check_cardinality_(self.segments, "segments", required=False)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.ion, "ion")
        self.gds_check_cardinality_(self.ion, "ion", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("ionChannel", node)
        if value is not None and "ionChannel" not in already_processed:
            already_processed.add("ionChannel")
            self.ion_channel = value
            self.validate_NmlId(self.ion_channel)  # validate type NmlId
        value = find_attr_value_("permeability", node)
        if value is not None and "permeability" not in already_processed:
            already_processed.add("permeability")
            self.permeability = value
            self.validate_Nml2Quantity_permeability(
                self.permeability
            )  # validate type Nml2Quantity_permeability
        value = find_attr_value_("segmentGroup", node)
        if value is not None and "segmentGroup" not in already_processed:
            already_processed.add("segmentGroup")
            self.segment_groups = value
            self.validate_NmlId(self.segment_groups)  # validate type NmlId
        value = find_attr_value_("segment", node)
        if value is not None and "segment" not in already_processed:
            already_processed.add("segment")
            self.segments = value
            self.validate_NmlId(self.segments)  # validate type NmlId
        value = find_attr_value_("ion", node)
        if value is not None and "ion" not in already_processed:
            already_processed.add("ion")
            self.ion = value
            self.validate_NmlId(self.ion)  # validate type NmlId
        super(ChannelDensityGHK, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ChannelDensityGHK, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class ChannelDensityGHK


class ChannelDensityNernst(Base):
    """ChannelDensityNernst -- Specifies a time varying conductance density, **gDensity,**  which is distributed on an area of the **cell,**  producing a current density **iDensity**  and whose reversal potential is calculated from the Nernst equation. Hard coded for Ca only! See https://github.com/OpenSourceBrain/ghk-nernst.
    \n
    :param condDensity:
    :type condDensity: conductanceDensity

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "ion_channel", "NmlId", 0, 0, {"use": "required", "name": "ion_channel"}
        ),
        MemberSpec_(
            "cond_density",
            "Nml2Quantity_conductanceDensity",
            0,
            1,
            {"use": "optional", "name": "cond_density"},
        ),
        MemberSpec_(
            "segment_groups",
            "NmlId",
            0,
            1,
            {"use": "optional", "name": "segment_groups"},
        ),
        MemberSpec_("segments", "NmlId", 0, 1, {"use": "optional", "name": "segments"}),
        MemberSpec_("ion", "NmlId", 0, 0, {"use": "required", "name": "ion"}),
        MemberSpec_(
            "variable_parameters",
            "VariableParameter",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "variableParameter",
                "type": "VariableParameter",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        ion_channel: "a NmlId (required)" = None,
        cond_density: "a Nml2Quantity_conductanceDensity (optional)" = None,
        segment_groups: "a NmlId (optional)" = "all",
        segments: "a NonNegativeInteger (optional)" = None,
        ion: "a NmlId (required)" = None,
        variable_parameters: "list of VariableParameter(s) (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ChannelDensityNernst"), self).__init__(
            id, extensiontype_, **kwargs_
        )
        self.ion_channel = _cast(None, ion_channel)
        self.ion_channel_nsprefix_ = None
        self.cond_density = _cast(None, cond_density)
        self.cond_density_nsprefix_ = None
        self.segment_groups = _cast(None, segment_groups)
        self.segment_groups_nsprefix_ = None
        self.segments = _cast(None, segments)
        self.segments_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        if variable_parameters is None:
            self.variable_parameters = []
        else:
            self.variable_parameters = variable_parameters
        self.variable_parameters_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityNernst
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityNernst.subclass:
            return ChannelDensityNernst.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityNernst(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_conductanceDensity(self, value):
        # Validate type Nml2Quantity_conductanceDensity, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductanceDensity_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductanceDensity_patterns_,
                    )
                )

    validate_Nml2Quantity_conductanceDensity_patterns_ = [
        [
            "^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S_per_m2|mS_per_cm2|S_per_cm2))$"
        ]
    ]

    def _hasContent(self):
        if self.variable_parameters or super(ChannelDensityNernst, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ChannelDensityNernst",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ChannelDensityNernst")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ChannelDensityNernst":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityNernst",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ChannelDensityNernst",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ChannelDensityNernst",
    ):
        super(ChannelDensityNernst, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityNernst",
        )
        if self.ion_channel is not None and "ion_channel" not in already_processed:
            already_processed.add("ion_channel")
            outfile.write(
                " ionChannel=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.ion_channel), input_name="ionChannel"
                        )
                    ),
                )
            )
        if self.cond_density is not None and "cond_density" not in already_processed:
            already_processed.add("cond_density")
            outfile.write(
                " condDensity=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.cond_density), input_name="condDensity"
                        )
                    ),
                )
            )
        if self.segment_groups != "all" and "segment_groups" not in already_processed:
            already_processed.add("segment_groups")
            outfile.write(
                " segmentGroup=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segment_groups), input_name="segmentGroup"
                        )
                    ),
                )
            )
        if self.segments is not None and "segments" not in already_processed:
            already_processed.add("segments")
            outfile.write(
                " segment=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segments), input_name="segment"
                        )
                    ),
                )
            )
        if self.ion is not None and "ion" not in already_processed:
            already_processed.add("ion")
            outfile.write(
                " ion=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.ion), input_name="ion")
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ChannelDensityNernst",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ChannelDensityNernst, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for variableParameter_ in self.variable_parameters:
            namespaceprefix_ = (
                self.variable_parameters_nsprefix_ + ":"
                if (UseCapturedNS_ and self.variable_parameters_nsprefix_)
                else ""
            )
            variableParameter_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="variableParameter",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.ion_channel, "ion_channel"
        )
        self.gds_check_cardinality_(self.ion_channel, "ion_channel", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductanceDensity,
            self.cond_density,
            "cond_density",
        )
        self.gds_check_cardinality_(self.cond_density, "cond_density", required=False)
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.segment_groups, "segment_groups"
        )
        self.gds_check_cardinality_(
            self.segment_groups, "segment_groups", required=False
        )
        self.gds_validate_defined_ST_(self.validate_NmlId, self.segments, "segments")
        self.gds_check_cardinality_(self.segments, "segments", required=False)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.ion, "ion")
        self.gds_check_cardinality_(self.ion, "ion", required=True)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.variable_parameters,
            "variable_parameters",
            min_occurs=0,
            max_occurs=9999999,
        )
        if recursive:
            for item in self.variable_parameters:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("ionChannel", node)
        if value is not None and "ionChannel" not in already_processed:
            already_processed.add("ionChannel")
            self.ion_channel = value
            self.validate_NmlId(self.ion_channel)  # validate type NmlId
        value = find_attr_value_("condDensity", node)
        if value is not None and "condDensity" not in already_processed:
            already_processed.add("condDensity")
            self.cond_density = value
            self.validate_Nml2Quantity_conductanceDensity(
                self.cond_density
            )  # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_("segmentGroup", node)
        if value is not None and "segmentGroup" not in already_processed:
            already_processed.add("segmentGroup")
            self.segment_groups = value
            self.validate_NmlId(self.segment_groups)  # validate type NmlId
        value = find_attr_value_("segment", node)
        if value is not None and "segment" not in already_processed:
            already_processed.add("segment")
            self.segments = value
            self.validate_NmlId(self.segments)  # validate type NmlId
        value = find_attr_value_("ion", node)
        if value is not None and "ion" not in already_processed:
            already_processed.add("ion")
            self.ion = value
            self.validate_NmlId(self.ion)  # validate type NmlId
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(ChannelDensityNernst, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "variableParameter":
            obj_ = VariableParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_parameters.append(obj_)
            obj_.original_tagname_ = "variableParameter"
        super(ChannelDensityNernst, self)._buildChildren(child_, node, nodeName_, True)


# end class ChannelDensityNernst


class ChannelDensity(Base):
    """ChannelDensity -- Specifies a time varying ohmic conductance density, **gDensity,**  which is distributed on an area of the **cell**  ( specified in  **membraneProperties**  ) with fixed reversal potential **erev**  producing a current density **iDensity**
    \n
    :param erev: The reversal potential of the current produced
    :type erev: voltage
    :param condDensity:
    :type condDensity: conductanceDensity

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "ion_channel", "NmlId", 0, 0, {"use": "required", "name": "ion_channel"}
        ),
        MemberSpec_(
            "cond_density",
            "Nml2Quantity_conductanceDensity",
            0,
            1,
            {"use": "optional", "name": "cond_density"},
        ),
        MemberSpec_(
            "erev", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "erev"}
        ),
        MemberSpec_(
            "segment_groups",
            "NmlId",
            0,
            1,
            {"use": "optional", "name": "segment_groups"},
        ),
        MemberSpec_(
            "segments",
            "NonNegativeInteger",
            0,
            1,
            {"use": "optional", "name": "segments"},
        ),
        MemberSpec_("ion", "NmlId", 0, 0, {"use": "required", "name": "ion"}),
        MemberSpec_(
            "variable_parameters",
            "VariableParameter",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "variableParameter",
                "type": "VariableParameter",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        ion_channel: "a NmlId (required)" = None,
        cond_density: "a Nml2Quantity_conductanceDensity (optional)" = None,
        erev: "a Nml2Quantity_voltage (required)" = None,
        segment_groups: "a NmlId (optional)" = "all",
        segments: "a NonNegativeInteger (optional)" = None,
        ion: "a NmlId (required)" = None,
        variable_parameters: "list of VariableParameter(s) (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ChannelDensity"), self).__init__(
            id, extensiontype_, **kwargs_
        )
        self.ion_channel = _cast(None, ion_channel)
        self.ion_channel_nsprefix_ = None
        self.cond_density = _cast(None, cond_density)
        self.cond_density_nsprefix_ = None
        self.erev = _cast(None, erev)
        self.erev_nsprefix_ = None
        self.segment_groups = _cast(None, segment_groups)
        self.segment_groups_nsprefix_ = None
        self.segments = _cast(int, segments)
        self.segments_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        if variable_parameters is None:
            self.variable_parameters = []
        else:
            self.variable_parameters = variable_parameters
        self.variable_parameters_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ChannelDensity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensity.subclass:
            return ChannelDensity.subclass(*args_, **kwargs_)
        else:
            return ChannelDensity(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_conductanceDensity(self, value):
        # Validate type Nml2Quantity_conductanceDensity, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductanceDensity_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductanceDensity_patterns_,
                    )
                )

    validate_Nml2Quantity_conductanceDensity_patterns_ = [
        [
            "^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S_per_m2|mS_per_cm2|S_per_cm2))$"
        ]
    ]

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def _hasContent(self):
        if self.variable_parameters or super(ChannelDensity, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ChannelDensity",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ChannelDensity")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ChannelDensity":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ChannelDensity"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ChannelDensity",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ChannelDensity",
    ):
        super(ChannelDensity, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ChannelDensity"
        )
        if self.ion_channel is not None and "ion_channel" not in already_processed:
            already_processed.add("ion_channel")
            outfile.write(
                " ionChannel=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.ion_channel), input_name="ionChannel"
                        )
                    ),
                )
            )
        if self.cond_density is not None and "cond_density" not in already_processed:
            already_processed.add("cond_density")
            outfile.write(
                " condDensity=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.cond_density), input_name="condDensity"
                        )
                    ),
                )
            )
        if self.erev is not None and "erev" not in already_processed:
            already_processed.add("erev")
            outfile.write(
                " erev=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.erev), input_name="erev"
                        )
                    ),
                )
            )
        if self.segment_groups != "all" and "segment_groups" not in already_processed:
            already_processed.add("segment_groups")
            outfile.write(
                " segmentGroup=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segment_groups), input_name="segmentGroup"
                        )
                    ),
                )
            )
        if self.segments is not None and "segments" not in already_processed:
            already_processed.add("segments")
            outfile.write(
                ' segment="%s"'
                % self.gds_format_integer(self.segments, input_name="segment")
            )
        if self.ion is not None and "ion" not in already_processed:
            already_processed.add("ion")
            outfile.write(
                " ion=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.ion), input_name="ion")
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ChannelDensity",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ChannelDensity, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for variableParameter_ in self.variable_parameters:
            namespaceprefix_ = (
                self.variable_parameters_nsprefix_ + ":"
                if (UseCapturedNS_ and self.variable_parameters_nsprefix_)
                else ""
            )
            variableParameter_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="variableParameter",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.ion_channel, "ion_channel"
        )
        self.gds_check_cardinality_(self.ion_channel, "ion_channel", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductanceDensity,
            self.cond_density,
            "cond_density",
        )
        self.gds_check_cardinality_(self.cond_density, "cond_density", required=False)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.erev, "erev"
        )
        self.gds_check_cardinality_(self.erev, "erev", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.segment_groups, "segment_groups"
        )
        self.gds_check_cardinality_(
            self.segment_groups, "segment_groups", required=False
        )
        self.gds_validate_defined_ST_(
            self.validate_NonNegativeInteger, self.segments, "segments"
        )
        self.gds_check_cardinality_(self.segments, "segments", required=False)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.ion, "ion")
        self.gds_check_cardinality_(self.ion, "ion", required=True)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.variable_parameters,
            "variable_parameters",
            min_occurs=0,
            max_occurs=9999999,
        )
        if recursive:
            for item in self.variable_parameters:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("ionChannel", node)
        if value is not None and "ionChannel" not in already_processed:
            already_processed.add("ionChannel")
            self.ion_channel = value
            self.validate_NmlId(self.ion_channel)  # validate type NmlId
        value = find_attr_value_("condDensity", node)
        if value is not None and "condDensity" not in already_processed:
            already_processed.add("condDensity")
            self.cond_density = value
            self.validate_Nml2Quantity_conductanceDensity(
                self.cond_density
            )  # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_("erev", node)
        if value is not None and "erev" not in already_processed:
            already_processed.add("erev")
            self.erev = value
            self.validate_Nml2Quantity_voltage(
                self.erev
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("segmentGroup", node)
        if value is not None and "segmentGroup" not in already_processed:
            already_processed.add("segmentGroup")
            self.segment_groups = value
            self.validate_NmlId(self.segment_groups)  # validate type NmlId
        value = find_attr_value_("segment", node)
        if value is not None and "segment" not in already_processed:
            already_processed.add("segment")
            self.segments = self.gds_parse_integer(value, node, "segment")
            if self.segments < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
            self.validate_NonNegativeInteger(
                self.segments
            )  # validate type NonNegativeInteger
        value = find_attr_value_("ion", node)
        if value is not None and "ion" not in already_processed:
            already_processed.add("ion")
            self.ion = value
            self.validate_NmlId(self.ion)  # validate type NmlId
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(ChannelDensity, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "variableParameter":
            obj_ = VariableParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_parameters.append(obj_)
            obj_.original_tagname_ = "variableParameter"
        super(ChannelDensity, self)._buildChildren(child_, node, nodeName_, True)


# end class ChannelDensity


class ChannelDensityNonUniformGHK(Base):
    """ChannelDensityNonUniformGHK -- Specifies a time varying conductance density, which is distributed on a region of the **cell,**  and whose current is calculated from the Goldman-Hodgkin-Katz equation. Hard coded for Ca only!. The conductance density of the channel is not uniform, but is set using the  **variableParameter** . Note, there is no dynamical description of this in LEMS yet, as this type only makes sense for multicompartmental cells. A ComponentType for this needs to be present to enable export of NeuroML 2 multicompartmental cells via LEMS/jNeuroML to NEURON"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "ion_channel", "NmlId", 0, 0, {"use": "required", "name": "ion_channel"}
        ),
        MemberSpec_("ion", "NmlId", 0, 0, {"use": "required", "name": "ion"}),
        MemberSpec_(
            "variable_parameters",
            "VariableParameter",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "variableParameter",
                "type": "VariableParameter",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        ion_channel: "a NmlId (required)" = None,
        ion: "a NmlId (required)" = None,
        variable_parameters: "list of VariableParameter(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ChannelDensityNonUniformGHK"), self).__init__(
            id, **kwargs_
        )
        self.ion_channel = _cast(None, ion_channel)
        self.ion_channel_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        if variable_parameters is None:
            self.variable_parameters = []
        else:
            self.variable_parameters = variable_parameters
        self.variable_parameters_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityNonUniformGHK
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityNonUniformGHK.subclass:
            return ChannelDensityNonUniformGHK.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityNonUniformGHK(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if (
            self.variable_parameters
            or super(ChannelDensityNonUniformGHK, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ChannelDensityNonUniformGHK",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ChannelDensityNonUniformGHK")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "ChannelDensityNonUniformGHK"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityNonUniformGHK",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ChannelDensityNonUniformGHK",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ChannelDensityNonUniformGHK",
    ):
        super(ChannelDensityNonUniformGHK, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityNonUniformGHK",
        )
        if self.ion_channel is not None and "ion_channel" not in already_processed:
            already_processed.add("ion_channel")
            outfile.write(
                " ionChannel=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.ion_channel), input_name="ionChannel"
                        )
                    ),
                )
            )
        if self.ion is not None and "ion" not in already_processed:
            already_processed.add("ion")
            outfile.write(
                " ion=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.ion), input_name="ion")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ChannelDensityNonUniformGHK",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ChannelDensityNonUniformGHK, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for variableParameter_ in self.variable_parameters:
            namespaceprefix_ = (
                self.variable_parameters_nsprefix_ + ":"
                if (UseCapturedNS_ and self.variable_parameters_nsprefix_)
                else ""
            )
            variableParameter_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="variableParameter",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.ion_channel, "ion_channel"
        )
        self.gds_check_cardinality_(self.ion_channel, "ion_channel", required=True)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.ion, "ion")
        self.gds_check_cardinality_(self.ion, "ion", required=True)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.variable_parameters,
            "variable_parameters",
            min_occurs=0,
            max_occurs=9999999,
        )
        if recursive:
            for item in self.variable_parameters:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("ionChannel", node)
        if value is not None and "ionChannel" not in already_processed:
            already_processed.add("ionChannel")
            self.ion_channel = value
            self.validate_NmlId(self.ion_channel)  # validate type NmlId
        value = find_attr_value_("ion", node)
        if value is not None and "ion" not in already_processed:
            already_processed.add("ion")
            self.ion = value
            self.validate_NmlId(self.ion)  # validate type NmlId
        super(ChannelDensityNonUniformGHK, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "variableParameter":
            obj_ = VariableParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_parameters.append(obj_)
            obj_.original_tagname_ = "variableParameter"
        super(ChannelDensityNonUniformGHK, self)._buildChildren(
            child_, node, nodeName_, True
        )


# end class ChannelDensityNonUniformGHK


class ChannelDensityNonUniformNernst(Base):
    """ChannelDensityNonUniformNernst -- Specifies a time varying conductance density, which is distributed on a region of the **cell,**  and whose reversal potential is calculated from the Nernst equation. Hard coded for Ca only!. The conductance density of the channel is not uniform, but is set using the  **variableParameter** . Note, there is no dynamical description of this in LEMS yet, as this type only makes sense for multicompartmental cells. A ComponentType for this needs to be present to enable export of NeuroML 2 multicompartmental cells via LEMS/jNeuroML to NEURON"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "ion_channel", "NmlId", 0, 0, {"use": "required", "name": "ion_channel"}
        ),
        MemberSpec_("ion", "NmlId", 0, 0, {"use": "required", "name": "ion"}),
        MemberSpec_(
            "variable_parameters",
            "VariableParameter",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "variableParameter",
                "type": "VariableParameter",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        ion_channel: "a NmlId (required)" = None,
        ion: "a NmlId (required)" = None,
        variable_parameters: "list of VariableParameter(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ChannelDensityNonUniformNernst"), self).__init__(
            id, **kwargs_
        )
        self.ion_channel = _cast(None, ion_channel)
        self.ion_channel_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        if variable_parameters is None:
            self.variable_parameters = []
        else:
            self.variable_parameters = variable_parameters
        self.variable_parameters_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityNonUniformNernst
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityNonUniformNernst.subclass:
            return ChannelDensityNonUniformNernst.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityNonUniformNernst(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if (
            self.variable_parameters
            or super(ChannelDensityNonUniformNernst, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ChannelDensityNonUniformNernst",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "ChannelDensityNonUniformNernst"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "ChannelDensityNonUniformNernst"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityNonUniformNernst",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ChannelDensityNonUniformNernst",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ChannelDensityNonUniformNernst",
    ):
        super(ChannelDensityNonUniformNernst, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityNonUniformNernst",
        )
        if self.ion_channel is not None and "ion_channel" not in already_processed:
            already_processed.add("ion_channel")
            outfile.write(
                " ionChannel=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.ion_channel), input_name="ionChannel"
                        )
                    ),
                )
            )
        if self.ion is not None and "ion" not in already_processed:
            already_processed.add("ion")
            outfile.write(
                " ion=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.ion), input_name="ion")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ChannelDensityNonUniformNernst",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ChannelDensityNonUniformNernst, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for variableParameter_ in self.variable_parameters:
            namespaceprefix_ = (
                self.variable_parameters_nsprefix_ + ":"
                if (UseCapturedNS_ and self.variable_parameters_nsprefix_)
                else ""
            )
            variableParameter_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="variableParameter",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.ion_channel, "ion_channel"
        )
        self.gds_check_cardinality_(self.ion_channel, "ion_channel", required=True)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.ion, "ion")
        self.gds_check_cardinality_(self.ion, "ion", required=True)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.variable_parameters,
            "variable_parameters",
            min_occurs=0,
            max_occurs=9999999,
        )
        if recursive:
            for item in self.variable_parameters:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("ionChannel", node)
        if value is not None and "ionChannel" not in already_processed:
            already_processed.add("ionChannel")
            self.ion_channel = value
            self.validate_NmlId(self.ion_channel)  # validate type NmlId
        value = find_attr_value_("ion", node)
        if value is not None and "ion" not in already_processed:
            already_processed.add("ion")
            self.ion = value
            self.validate_NmlId(self.ion)  # validate type NmlId
        super(ChannelDensityNonUniformNernst, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "variableParameter":
            obj_ = VariableParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_parameters.append(obj_)
            obj_.original_tagname_ = "variableParameter"
        super(ChannelDensityNonUniformNernst, self)._buildChildren(
            child_, node, nodeName_, True
        )


# end class ChannelDensityNonUniformNernst


class ChannelDensityNonUniform(Base):
    """ChannelDensityNonUniform -- Specifies a time varying ohmic conductance density, which is distributed on a region of the **cell.**  The conductance density of the channel is not uniform, but is set using the  **variableParameter** . Note, there is no dynamical description of this in LEMS yet, as this type only makes sense for multicompartmental cells. A ComponentType for this needs to be present to enable export of NeuroML 2 multicompartmental cells via LEMS/jNeuroML to NEURON
    \n
    :param erev: The reversal potential of the current produced
    :type erev: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "ion_channel", "NmlId", 0, 0, {"use": "required", "name": "ion_channel"}
        ),
        MemberSpec_(
            "erev", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "erev"}
        ),
        MemberSpec_("ion", "NmlId", 0, 0, {"use": "required", "name": "ion"}),
        MemberSpec_(
            "variable_parameters",
            "VariableParameter",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "variableParameter",
                "type": "VariableParameter",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        ion_channel: "a NmlId (required)" = None,
        erev: "a Nml2Quantity_voltage (required)" = None,
        ion: "a NmlId (required)" = None,
        variable_parameters: "list of VariableParameter(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ChannelDensityNonUniform"), self).__init__(id, **kwargs_)
        self.ion_channel = _cast(None, ion_channel)
        self.ion_channel_nsprefix_ = None
        self.erev = _cast(None, erev)
        self.erev_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        if variable_parameters is None:
            self.variable_parameters = []
        else:
            self.variable_parameters = variable_parameters
        self.variable_parameters_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityNonUniform
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityNonUniform.subclass:
            return ChannelDensityNonUniform.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityNonUniform(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def _hasContent(self):
        if (
            self.variable_parameters
            or super(ChannelDensityNonUniform, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ChannelDensityNonUniform",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ChannelDensityNonUniform")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ChannelDensityNonUniform":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityNonUniform",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ChannelDensityNonUniform",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ChannelDensityNonUniform",
    ):
        super(ChannelDensityNonUniform, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityNonUniform",
        )
        if self.ion_channel is not None and "ion_channel" not in already_processed:
            already_processed.add("ion_channel")
            outfile.write(
                " ionChannel=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.ion_channel), input_name="ionChannel"
                        )
                    ),
                )
            )
        if self.erev is not None and "erev" not in already_processed:
            already_processed.add("erev")
            outfile.write(
                " erev=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.erev), input_name="erev"
                        )
                    ),
                )
            )
        if self.ion is not None and "ion" not in already_processed:
            already_processed.add("ion")
            outfile.write(
                " ion=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.ion), input_name="ion")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ChannelDensityNonUniform",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ChannelDensityNonUniform, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for variableParameter_ in self.variable_parameters:
            namespaceprefix_ = (
                self.variable_parameters_nsprefix_ + ":"
                if (UseCapturedNS_ and self.variable_parameters_nsprefix_)
                else ""
            )
            variableParameter_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="variableParameter",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.ion_channel, "ion_channel"
        )
        self.gds_check_cardinality_(self.ion_channel, "ion_channel", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.erev, "erev"
        )
        self.gds_check_cardinality_(self.erev, "erev", required=True)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.ion, "ion")
        self.gds_check_cardinality_(self.ion, "ion", required=True)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.variable_parameters,
            "variable_parameters",
            min_occurs=0,
            max_occurs=9999999,
        )
        if recursive:
            for item in self.variable_parameters:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("ionChannel", node)
        if value is not None and "ionChannel" not in already_processed:
            already_processed.add("ionChannel")
            self.ion_channel = value
            self.validate_NmlId(self.ion_channel)  # validate type NmlId
        value = find_attr_value_("erev", node)
        if value is not None and "erev" not in already_processed:
            already_processed.add("erev")
            self.erev = value
            self.validate_Nml2Quantity_voltage(
                self.erev
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("ion", node)
        if value is not None and "ion" not in already_processed:
            already_processed.add("ion")
            self.ion = value
            self.validate_NmlId(self.ion)  # validate type NmlId
        super(ChannelDensityNonUniform, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "variableParameter":
            obj_ = VariableParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_parameters.append(obj_)
            obj_.original_tagname_ = "variableParameter"
        super(ChannelDensityNonUniform, self)._buildChildren(
            child_, node, nodeName_, True
        )


# end class ChannelDensityNonUniform


class ChannelPopulation(Base):
    """ChannelPopulation -- Population of a **number**  of ohmic ion channels. These each produce a conductance **channelg**  across a reversal potential **erev,**  giving a total current **i.**  Note that active membrane currents are more frequently specified as a density over an area of the  **cell**  using  **channelDensity**
    \n
    :param number: The number of channels present. This will be multiplied by the time varying conductance of the individual ion channel ( which extends  **baseIonChannel**  ) to produce the total conductance
    :type number: none
    :param erev: The reversal potential of the current produced
    :type erev: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "ion_channel", "NmlId", 0, 0, {"use": "required", "name": "ion_channel"}
        ),
        MemberSpec_(
            "number", "NonNegativeInteger", 0, 0, {"use": "required", "name": "number"}
        ),
        MemberSpec_(
            "erev", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "erev"}
        ),
        MemberSpec_(
            "segment_groups",
            "NmlId",
            0,
            1,
            {"use": "optional", "name": "segment_groups"},
        ),
        MemberSpec_(
            "segments",
            "NonNegativeInteger",
            0,
            1,
            {"use": "optional", "name": "segments"},
        ),
        MemberSpec_("ion", "NmlId", 0, 0, {"use": "required", "name": "ion"}),
        MemberSpec_(
            "variable_parameters",
            "VariableParameter",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "variableParameter",
                "type": "VariableParameter",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        ion_channel: "a NmlId (required)" = None,
        number: "a NonNegativeInteger (required)" = None,
        erev: "a Nml2Quantity_voltage (required)" = None,
        segment_groups: "a NmlId (optional)" = "all",
        segments: "a NonNegativeInteger (optional)" = None,
        ion: "a NmlId (required)" = None,
        variable_parameters: "list of VariableParameter(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ChannelPopulation"), self).__init__(id, **kwargs_)
        self.ion_channel = _cast(None, ion_channel)
        self.ion_channel_nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.erev = _cast(None, erev)
        self.erev_nsprefix_ = None
        self.segment_groups = _cast(None, segment_groups)
        self.segment_groups_nsprefix_ = None
        self.segments = _cast(int, segments)
        self.segments_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        if variable_parameters is None:
            self.variable_parameters = []
        else:
            self.variable_parameters = variable_parameters
        self.variable_parameters_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ChannelPopulation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelPopulation.subclass:
            return ChannelPopulation.subclass(*args_, **kwargs_)
        else:
            return ChannelPopulation(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def _hasContent(self):
        if self.variable_parameters or super(ChannelPopulation, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ChannelPopulation",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ChannelPopulation")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ChannelPopulation":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelPopulation",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ChannelPopulation",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ChannelPopulation",
    ):
        super(ChannelPopulation, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelPopulation",
        )
        if self.ion_channel is not None and "ion_channel" not in already_processed:
            already_processed.add("ion_channel")
            outfile.write(
                " ionChannel=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.ion_channel), input_name="ionChannel"
                        )
                    ),
                )
            )
        if self.number is not None and "number" not in already_processed:
            already_processed.add("number")
            outfile.write(
                ' number="%s"'
                % self.gds_format_integer(self.number, input_name="number")
            )
        if self.erev is not None and "erev" not in already_processed:
            already_processed.add("erev")
            outfile.write(
                " erev=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.erev), input_name="erev"
                        )
                    ),
                )
            )
        if self.segment_groups != "all" and "segment_groups" not in already_processed:
            already_processed.add("segment_groups")
            outfile.write(
                " segmentGroup=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segment_groups), input_name="segmentGroup"
                        )
                    ),
                )
            )
        if self.segments is not None and "segments" not in already_processed:
            already_processed.add("segments")
            outfile.write(
                ' segment="%s"'
                % self.gds_format_integer(self.segments, input_name="segment")
            )
        if self.ion is not None and "ion" not in already_processed:
            already_processed.add("ion")
            outfile.write(
                " ion=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.ion), input_name="ion")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ChannelPopulation",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ChannelPopulation, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for variableParameter_ in self.variable_parameters:
            namespaceprefix_ = (
                self.variable_parameters_nsprefix_ + ":"
                if (UseCapturedNS_ and self.variable_parameters_nsprefix_)
                else ""
            )
            variableParameter_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="variableParameter",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.ion_channel, "ion_channel"
        )
        self.gds_check_cardinality_(self.ion_channel, "ion_channel", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NonNegativeInteger, self.number, "number"
        )
        self.gds_check_cardinality_(self.number, "number", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.erev, "erev"
        )
        self.gds_check_cardinality_(self.erev, "erev", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.segment_groups, "segment_groups"
        )
        self.gds_check_cardinality_(
            self.segment_groups, "segment_groups", required=False
        )
        self.gds_validate_defined_ST_(
            self.validate_NonNegativeInteger, self.segments, "segments"
        )
        self.gds_check_cardinality_(self.segments, "segments", required=False)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.ion, "ion")
        self.gds_check_cardinality_(self.ion, "ion", required=True)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.variable_parameters,
            "variable_parameters",
            min_occurs=0,
            max_occurs=9999999,
        )
        if recursive:
            for item in self.variable_parameters:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("ionChannel", node)
        if value is not None and "ionChannel" not in already_processed:
            already_processed.add("ionChannel")
            self.ion_channel = value
            self.validate_NmlId(self.ion_channel)  # validate type NmlId
        value = find_attr_value_("number", node)
        if value is not None and "number" not in already_processed:
            already_processed.add("number")
            self.number = self.gds_parse_integer(value, node, "number")
            if self.number < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
            self.validate_NonNegativeInteger(
                self.number
            )  # validate type NonNegativeInteger
        value = find_attr_value_("erev", node)
        if value is not None and "erev" not in already_processed:
            already_processed.add("erev")
            self.erev = value
            self.validate_Nml2Quantity_voltage(
                self.erev
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("segmentGroup", node)
        if value is not None and "segmentGroup" not in already_processed:
            already_processed.add("segmentGroup")
            self.segment_groups = value
            self.validate_NmlId(self.segment_groups)  # validate type NmlId
        value = find_attr_value_("segment", node)
        if value is not None and "segment" not in already_processed:
            already_processed.add("segment")
            self.segments = self.gds_parse_integer(value, node, "segment")
            if self.segments < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
            self.validate_NonNegativeInteger(
                self.segments
            )  # validate type NonNegativeInteger
        value = find_attr_value_("ion", node)
        if value is not None and "ion" not in already_processed:
            already_processed.add("ion")
            self.ion = value
            self.validate_NmlId(self.ion)  # validate type NmlId
        super(ChannelPopulation, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "variableParameter":
            obj_ = VariableParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable_parameters.append(obj_)
            obj_.original_tagname_ = "variableParameter"
        super(ChannelPopulation, self)._buildChildren(child_, node, nodeName_, True)


# end class ChannelPopulation


class Resistivity(BaseWithoutId):
    """Resistivity -- The resistivity, or specific axial resistance, of the cytoplasm
    \n
    :param value:
    :type value: resistivity

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "value",
            "Nml2Quantity_resistivity",
            0,
            0,
            {"use": "required", "name": "value"},
        ),
        MemberSpec_(
            "segment_groups",
            "NmlId",
            0,
            1,
            {"use": "optional", "name": "segment_groups"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        value: "a Nml2Quantity_resistivity (required)" = None,
        segment_groups: "a NmlId (optional)" = "all",
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Resistivity"), self).__init__(**kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.segment_groups = _cast(None, segment_groups)
        self.segment_groups_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Resistivity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Resistivity.subclass:
            return Resistivity.subclass(*args_, **kwargs_)
        else:
            return Resistivity(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_resistivity(self, value):
        # Validate type Nml2Quantity_resistivity, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_resistivity_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_resistivity_patterns_,
                    )
                )

    validate_Nml2Quantity_resistivity_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(ohm_cm|kohm_cm|ohm_m))$"]
    ]

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if super(Resistivity, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Resistivity",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Resistivity")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Resistivity":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Resistivity"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Resistivity",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Resistivity",
    ):
        super(Resistivity, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Resistivity"
        )
        if self.value is not None and "value" not in already_processed:
            already_processed.add("value")
            outfile.write(
                " value=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.value), input_name="value"
                        )
                    ),
                )
            )
        if self.segment_groups != "all" and "segment_groups" not in already_processed:
            already_processed.add("segment_groups")
            outfile.write(
                " segmentGroup=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segment_groups), input_name="segmentGroup"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Resistivity",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Resistivity, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_resistivity, self.value, "value"
        )
        self.gds_check_cardinality_(self.value, "value", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.segment_groups, "segment_groups"
        )
        self.gds_check_cardinality_(
            self.segment_groups, "segment_groups", required=False
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("value", node)
        if value is not None and "value" not in already_processed:
            already_processed.add("value")
            self.value = value
            self.validate_Nml2Quantity_resistivity(
                self.value
            )  # validate type Nml2Quantity_resistivity
        value = find_attr_value_("segmentGroup", node)
        if value is not None and "segmentGroup" not in already_processed:
            already_processed.add("segmentGroup")
            self.segment_groups = value
            self.validate_NmlId(self.segment_groups)  # validate type NmlId
        super(Resistivity, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Resistivity, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class Resistivity


class InitMembPotential(BaseWithoutId):
    """InitMembPotential -- Explicitly set initial membrane potential for the cell
    \n
    :param value:
    :type value: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "value", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "value"}
        ),
        MemberSpec_(
            "segment_groups",
            "NmlId",
            0,
            1,
            {"use": "optional", "name": "segment_groups"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        value: "a Nml2Quantity_voltage (required)" = None,
        segment_groups: "a NmlId (optional)" = "all",
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("InitMembPotential"), self).__init__(**kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.segment_groups = _cast(None, segment_groups)
        self.segment_groups_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, InitMembPotential)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InitMembPotential.subclass:
            return InitMembPotential.subclass(*args_, **kwargs_)
        else:
            return InitMembPotential(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if super(InitMembPotential, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="InitMembPotential",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("InitMembPotential")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "InitMembPotential":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="InitMembPotential",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="InitMembPotential",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="InitMembPotential",
    ):
        super(InitMembPotential, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="InitMembPotential",
        )
        if self.value is not None and "value" not in already_processed:
            already_processed.add("value")
            outfile.write(
                " value=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.value), input_name="value"
                        )
                    ),
                )
            )
        if self.segment_groups != "all" and "segment_groups" not in already_processed:
            already_processed.add("segment_groups")
            outfile.write(
                " segmentGroup=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segment_groups), input_name="segmentGroup"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="InitMembPotential",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(InitMembPotential, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.value, "value"
        )
        self.gds_check_cardinality_(self.value, "value", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.segment_groups, "segment_groups"
        )
        self.gds_check_cardinality_(
            self.segment_groups, "segment_groups", required=False
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("value", node)
        if value is not None and "value" not in already_processed:
            already_processed.add("value")
            self.value = value
            self.validate_Nml2Quantity_voltage(
                self.value
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("segmentGroup", node)
        if value is not None and "segmentGroup" not in already_processed:
            already_processed.add("segmentGroup")
            self.segment_groups = value
            self.validate_NmlId(self.segment_groups)  # validate type NmlId
        super(InitMembPotential, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(InitMembPotential, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class InitMembPotential


class SpecificCapacitance(BaseWithoutId):
    """SpecificCapacitance -- Capacitance per unit area
    \n
    :param value:
    :type value: specificCapacitance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "value",
            "Nml2Quantity_specificCapacitance",
            0,
            0,
            {"use": "required", "name": "value"},
        ),
        MemberSpec_(
            "segment_groups",
            "NmlId",
            0,
            1,
            {"use": "optional", "name": "segment_groups"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        value: "a Nml2Quantity_specificCapacitance (required)" = None,
        segment_groups: "a NmlId (optional)" = "all",
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SpecificCapacitance"), self).__init__(**kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.segment_groups = _cast(None, segment_groups)
        self.segment_groups_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpecificCapacitance
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpecificCapacitance.subclass:
            return SpecificCapacitance.subclass(*args_, **kwargs_)
        else:
            return SpecificCapacitance(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_specificCapacitance(self, value):
        # Validate type Nml2Quantity_specificCapacitance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_specificCapacitance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_specificCapacitance_patterns_,
                    )
                )

    validate_Nml2Quantity_specificCapacitance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(F_per_m2|uF_per_cm2))$"]
    ]

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if super(SpecificCapacitance, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpecificCapacitance",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SpecificCapacitance")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SpecificCapacitance":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="SpecificCapacitance",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SpecificCapacitance",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SpecificCapacitance",
    ):
        super(SpecificCapacitance, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="SpecificCapacitance",
        )
        if self.value is not None and "value" not in already_processed:
            already_processed.add("value")
            outfile.write(
                " value=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.value), input_name="value"
                        )
                    ),
                )
            )
        if self.segment_groups != "all" and "segment_groups" not in already_processed:
            already_processed.add("segment_groups")
            outfile.write(
                " segmentGroup=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segment_groups), input_name="segmentGroup"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpecificCapacitance",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SpecificCapacitance, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_specificCapacitance, self.value, "value"
        )
        self.gds_check_cardinality_(self.value, "value", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.segment_groups, "segment_groups"
        )
        self.gds_check_cardinality_(
            self.segment_groups, "segment_groups", required=False
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("value", node)
        if value is not None and "value" not in already_processed:
            already_processed.add("value")
            self.value = value
            self.validate_Nml2Quantity_specificCapacitance(
                self.value
            )  # validate type Nml2Quantity_specificCapacitance
        value = find_attr_value_("segmentGroup", node)
        if value is not None and "segmentGroup" not in already_processed:
            already_processed.add("segmentGroup")
            self.segment_groups = value
            self.validate_NmlId(self.segment_groups)  # validate type NmlId
        super(SpecificCapacitance, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SpecificCapacitance, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class SpecificCapacitance


class SpikeThresh(BaseWithoutId):
    """SpikeThresh -- Membrane potential at which to emit a spiking event. Note, usually the spiking event will not be emitted again until the membrane potential has fallen below this value and rises again to cross it in a positive direction
    \n
    :param value:
    :type value: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "value", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "value"}
        ),
        MemberSpec_(
            "segment_groups",
            "NmlId",
            0,
            1,
            {"use": "optional", "name": "segment_groups"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        value: "a Nml2Quantity_voltage (required)" = None,
        segment_groups: "a NmlId (optional)" = "all",
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SpikeThresh"), self).__init__(**kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.segment_groups = _cast(None, segment_groups)
        self.segment_groups_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SpikeThresh)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeThresh.subclass:
            return SpikeThresh.subclass(*args_, **kwargs_)
        else:
            return SpikeThresh(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if super(SpikeThresh, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpikeThresh",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SpikeThresh")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SpikeThresh":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SpikeThresh"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SpikeThresh",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SpikeThresh",
    ):
        super(SpikeThresh, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SpikeThresh"
        )
        if self.value is not None and "value" not in already_processed:
            already_processed.add("value")
            outfile.write(
                " value=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.value), input_name="value"
                        )
                    ),
                )
            )
        if self.segment_groups != "all" and "segment_groups" not in already_processed:
            already_processed.add("segment_groups")
            outfile.write(
                " segmentGroup=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segment_groups), input_name="segmentGroup"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpikeThresh",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SpikeThresh, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.value, "value"
        )
        self.gds_check_cardinality_(self.value, "value", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.segment_groups, "segment_groups"
        )
        self.gds_check_cardinality_(
            self.segment_groups, "segment_groups", required=False
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("value", node)
        if value is not None and "value" not in already_processed:
            already_processed.add("value")
            self.value = value
            self.validate_Nml2Quantity_voltage(
                self.value
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("segmentGroup", node)
        if value is not None and "segmentGroup" not in already_processed:
            already_processed.add("segmentGroup")
            self.segment_groups = value
            self.validate_NmlId(self.segment_groups)  # validate type NmlId
        super(SpikeThresh, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SpikeThresh, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class SpikeThresh


class MembraneProperties(BaseWithoutId):
    """MembraneProperties -- Properties specific to the membrane, such as the **populations**  of channels, **channelDensities,**  **specificCapacitance,**  etc."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "channel_populations",
            "ChannelPopulation",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "channelPopulation",
                "type": "ChannelPopulation",
            },
            None,
        ),
        MemberSpec_(
            "channel_densities",
            "ChannelDensity",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "channelDensity",
                "type": "ChannelDensity",
            },
            None,
        ),
        MemberSpec_(
            "channel_density_v_shifts",
            "ChannelDensityVShift",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "channelDensityVShift",
                "type": "ChannelDensityVShift",
            },
            None,
        ),
        MemberSpec_(
            "channel_density_nernsts",
            "ChannelDensityNernst",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "channelDensityNernst",
                "type": "ChannelDensityNernst",
            },
            None,
        ),
        MemberSpec_(
            "channel_density_ghks",
            "ChannelDensityGHK",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "channelDensityGHK",
                "type": "ChannelDensityGHK",
            },
            None,
        ),
        MemberSpec_(
            "channel_density_ghk2s",
            "ChannelDensityGHK2",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "channelDensityGHK2",
                "type": "ChannelDensityGHK2",
            },
            None,
        ),
        MemberSpec_(
            "channel_density_non_uniforms",
            "ChannelDensityNonUniform",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "channelDensityNonUniform",
                "type": "ChannelDensityNonUniform",
            },
            None,
        ),
        MemberSpec_(
            "channel_density_non_uniform_nernsts",
            "ChannelDensityNonUniformNernst",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "channelDensityNonUniformNernst",
                "type": "ChannelDensityNonUniformNernst",
            },
            None,
        ),
        MemberSpec_(
            "channel_density_non_uniform_ghks",
            "ChannelDensityNonUniformGHK",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "channelDensityNonUniformGHK",
                "type": "ChannelDensityNonUniformGHK",
            },
            None,
        ),
        MemberSpec_(
            "spike_threshes",
            "SpikeThresh",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "spikeThresh",
                "type": "SpikeThresh",
            },
            None,
        ),
        MemberSpec_(
            "specific_capacitances",
            "SpecificCapacitance",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "specificCapacitance",
                "type": "SpecificCapacitance",
            },
            None,
        ),
        MemberSpec_(
            "init_memb_potentials",
            "InitMembPotential",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "initMembPotential",
                "type": "InitMembPotential",
            },
            None,
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        channel_populations: "list of ChannelPopulation(s) (optional)" = None,
        channel_densities: "list of ChannelDensity(s) (optional)" = None,
        channel_density_v_shifts: "list of ChannelDensityVShift(s) (optional)" = None,
        channel_density_nernsts: "list of ChannelDensityNernst(s) (optional)" = None,
        channel_density_ghks: "list of ChannelDensityGHK(s) (optional)" = None,
        channel_density_ghk2s: "list of ChannelDensityGHK2(s) (optional)" = None,
        channel_density_non_uniforms: "list of ChannelDensityNonUniform(s) (optional)" = None,
        channel_density_non_uniform_nernsts: "list of ChannelDensityNonUniformNernst(s) (optional)" = None,
        channel_density_non_uniform_ghks: "list of ChannelDensityNonUniformGHK(s) (optional)" = None,
        spike_threshes: "list of SpikeThresh(s) (optional)" = None,
        specific_capacitances: "list of SpecificCapacitance(s) (optional)" = None,
        init_memb_potentials: "list of InitMembPotential(s) (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("MembraneProperties"), self).__init__(
            extensiontype_, **kwargs_
        )
        if channel_populations is None:
            self.channel_populations = []
        else:
            self.channel_populations = channel_populations
        self.channel_populations_nsprefix_ = None
        if channel_densities is None:
            self.channel_densities = []
        else:
            self.channel_densities = channel_densities
        self.channel_densities_nsprefix_ = None
        if channel_density_v_shifts is None:
            self.channel_density_v_shifts = []
        else:
            self.channel_density_v_shifts = channel_density_v_shifts
        self.channel_density_v_shifts_nsprefix_ = None
        if channel_density_nernsts is None:
            self.channel_density_nernsts = []
        else:
            self.channel_density_nernsts = channel_density_nernsts
        self.channel_density_nernsts_nsprefix_ = None
        if channel_density_ghks is None:
            self.channel_density_ghks = []
        else:
            self.channel_density_ghks = channel_density_ghks
        self.channel_density_ghks_nsprefix_ = None
        if channel_density_ghk2s is None:
            self.channel_density_ghk2s = []
        else:
            self.channel_density_ghk2s = channel_density_ghk2s
        self.channel_density_ghk2s_nsprefix_ = None
        if channel_density_non_uniforms is None:
            self.channel_density_non_uniforms = []
        else:
            self.channel_density_non_uniforms = channel_density_non_uniforms
        self.channel_density_non_uniforms_nsprefix_ = None
        if channel_density_non_uniform_nernsts is None:
            self.channel_density_non_uniform_nernsts = []
        else:
            self.channel_density_non_uniform_nernsts = (
                channel_density_non_uniform_nernsts
            )
        self.channel_density_non_uniform_nernsts_nsprefix_ = None
        if channel_density_non_uniform_ghks is None:
            self.channel_density_non_uniform_ghks = []
        else:
            self.channel_density_non_uniform_ghks = channel_density_non_uniform_ghks
        self.channel_density_non_uniform_ghks_nsprefix_ = None
        if spike_threshes is None:
            self.spike_threshes = []
        else:
            self.spike_threshes = spike_threshes
        self.spike_threshes_nsprefix_ = None
        if specific_capacitances is None:
            self.specific_capacitances = []
        else:
            self.specific_capacitances = specific_capacitances
        self.specific_capacitances_nsprefix_ = None
        if init_memb_potentials is None:
            self.init_memb_potentials = []
        else:
            self.init_memb_potentials = init_memb_potentials
        self.init_memb_potentials_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MembraneProperties
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MembraneProperties.subclass:
            return MembraneProperties.subclass(*args_, **kwargs_)
        else:
            return MembraneProperties(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.channel_populations
            or self.channel_densities
            or self.channel_density_v_shifts
            or self.channel_density_nernsts
            or self.channel_density_ghks
            or self.channel_density_ghk2s
            or self.channel_density_non_uniforms
            or self.channel_density_non_uniform_nernsts
            or self.channel_density_non_uniform_ghks
            or self.spike_threshes
            or self.specific_capacitances
            or self.init_memb_potentials
            or super(MembraneProperties, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="MembraneProperties",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("MembraneProperties")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "MembraneProperties":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="MembraneProperties",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="MembraneProperties",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="MembraneProperties",
    ):
        super(MembraneProperties, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="MembraneProperties",
        )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="MembraneProperties",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(MembraneProperties, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for channelPopulation_ in self.channel_populations:
            namespaceprefix_ = (
                self.channel_populations_nsprefix_ + ":"
                if (UseCapturedNS_ and self.channel_populations_nsprefix_)
                else ""
            )
            channelPopulation_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="channelPopulation",
                pretty_print=pretty_print,
            )
        for channelDensity_ in self.channel_densities:
            namespaceprefix_ = (
                self.channel_densities_nsprefix_ + ":"
                if (UseCapturedNS_ and self.channel_densities_nsprefix_)
                else ""
            )
            channelDensity_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="channelDensity",
                pretty_print=pretty_print,
            )
        for channelDensityVShift_ in self.channel_density_v_shifts:
            namespaceprefix_ = (
                self.channel_density_v_shifts_nsprefix_ + ":"
                if (UseCapturedNS_ and self.channel_density_v_shifts_nsprefix_)
                else ""
            )
            channelDensityVShift_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="channelDensityVShift",
                pretty_print=pretty_print,
            )
        for channelDensityNernst_ in self.channel_density_nernsts:
            namespaceprefix_ = (
                self.channel_density_nernsts_nsprefix_ + ":"
                if (UseCapturedNS_ and self.channel_density_nernsts_nsprefix_)
                else ""
            )
            channelDensityNernst_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="channelDensityNernst",
                pretty_print=pretty_print,
            )
        for channelDensityGHK_ in self.channel_density_ghks:
            namespaceprefix_ = (
                self.channel_density_ghks_nsprefix_ + ":"
                if (UseCapturedNS_ and self.channel_density_ghks_nsprefix_)
                else ""
            )
            channelDensityGHK_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="channelDensityGHK",
                pretty_print=pretty_print,
            )
        for channelDensityGHK2_ in self.channel_density_ghk2s:
            namespaceprefix_ = (
                self.channel_density_ghk2s_nsprefix_ + ":"
                if (UseCapturedNS_ and self.channel_density_ghk2s_nsprefix_)
                else ""
            )
            channelDensityGHK2_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="channelDensityGHK2",
                pretty_print=pretty_print,
            )
        for channelDensityNonUniform_ in self.channel_density_non_uniforms:
            namespaceprefix_ = (
                self.channel_density_non_uniforms_nsprefix_ + ":"
                if (UseCapturedNS_ and self.channel_density_non_uniforms_nsprefix_)
                else ""
            )
            channelDensityNonUniform_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="channelDensityNonUniform",
                pretty_print=pretty_print,
            )
        for channelDensityNonUniformNernst_ in self.channel_density_non_uniform_nernsts:
            namespaceprefix_ = (
                self.channel_density_non_uniform_nernsts_nsprefix_ + ":"
                if (
                    UseCapturedNS_
                    and self.channel_density_non_uniform_nernsts_nsprefix_
                )
                else ""
            )
            channelDensityNonUniformNernst_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="channelDensityNonUniformNernst",
                pretty_print=pretty_print,
            )
        for channelDensityNonUniformGHK_ in self.channel_density_non_uniform_ghks:
            namespaceprefix_ = (
                self.channel_density_non_uniform_ghks_nsprefix_ + ":"
                if (UseCapturedNS_ and self.channel_density_non_uniform_ghks_nsprefix_)
                else ""
            )
            channelDensityNonUniformGHK_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="channelDensityNonUniformGHK",
                pretty_print=pretty_print,
            )
        for spikeThresh_ in self.spike_threshes:
            namespaceprefix_ = (
                self.spike_threshes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.spike_threshes_nsprefix_)
                else ""
            )
            spikeThresh_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="spikeThresh",
                pretty_print=pretty_print,
            )
        for specificCapacitance_ in self.specific_capacitances:
            namespaceprefix_ = (
                self.specific_capacitances_nsprefix_ + ":"
                if (UseCapturedNS_ and self.specific_capacitances_nsprefix_)
                else ""
            )
            specificCapacitance_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="specificCapacitance",
                pretty_print=pretty_print,
            )
        for initMembPotential_ in self.init_memb_potentials:
            namespaceprefix_ = (
                self.init_memb_potentials_nsprefix_ + ":"
                if (UseCapturedNS_ and self.init_memb_potentials_nsprefix_)
                else ""
            )
            initMembPotential_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="initMembPotential",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.channel_populations,
            "channel_populations",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.channel_densities,
            "channel_densities",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.channel_density_v_shifts,
            "channel_density_v_shifts",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.channel_density_nernsts,
            "channel_density_nernsts",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.channel_density_ghks,
            "channel_density_ghks",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.channel_density_ghk2s,
            "channel_density_ghk2s",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.channel_density_non_uniforms,
            "channel_density_non_uniforms",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.channel_density_non_uniform_nernsts,
            "channel_density_non_uniform_nernsts",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.channel_density_non_uniform_ghks,
            "channel_density_non_uniform_ghks",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.spike_threshes, "spike_threshes", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.specific_capacitances,
            "specific_capacitances",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.init_memb_potentials,
            "init_memb_potentials",
            min_occurs=0,
            max_occurs=9999999,
        )
        if recursive:
            for item in self.channel_populations:
                item.validate_(gds_collector, recursive=True)
            for item in self.channel_densities:
                item.validate_(gds_collector, recursive=True)
            for item in self.channel_density_v_shifts:
                item.validate_(gds_collector, recursive=True)
            for item in self.channel_density_nernsts:
                item.validate_(gds_collector, recursive=True)
            for item in self.channel_density_ghks:
                item.validate_(gds_collector, recursive=True)
            for item in self.channel_density_ghk2s:
                item.validate_(gds_collector, recursive=True)
            for item in self.channel_density_non_uniforms:
                item.validate_(gds_collector, recursive=True)
            for item in self.channel_density_non_uniform_nernsts:
                item.validate_(gds_collector, recursive=True)
            for item in self.channel_density_non_uniform_ghks:
                item.validate_(gds_collector, recursive=True)
            for item in self.spike_threshes:
                item.validate_(gds_collector, recursive=True)
            for item in self.specific_capacitances:
                item.validate_(gds_collector, recursive=True)
            for item in self.init_memb_potentials:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(MembraneProperties, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "channelPopulation":
            obj_ = ChannelPopulation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channel_populations.append(obj_)
            obj_.original_tagname_ = "channelPopulation"
        elif nodeName_ == "channelDensity":
            class_obj_ = self.get_class_obj_(child_, ChannelDensity)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channel_densities.append(obj_)
            obj_.original_tagname_ = "channelDensity"
        elif nodeName_ == "channelDensityVShift":
            obj_ = ChannelDensityVShift.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channel_density_v_shifts.append(obj_)
            obj_.original_tagname_ = "channelDensityVShift"
        elif nodeName_ == "channelDensityNernst":
            class_obj_ = self.get_class_obj_(child_, ChannelDensityNernst)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channel_density_nernsts.append(obj_)
            obj_.original_tagname_ = "channelDensityNernst"
        elif nodeName_ == "channelDensityGHK":
            obj_ = ChannelDensityGHK.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channel_density_ghks.append(obj_)
            obj_.original_tagname_ = "channelDensityGHK"
        elif nodeName_ == "channelDensityGHK2":
            obj_ = ChannelDensityGHK2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channel_density_ghk2s.append(obj_)
            obj_.original_tagname_ = "channelDensityGHK2"
        elif nodeName_ == "channelDensityNonUniform":
            obj_ = ChannelDensityNonUniform.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channel_density_non_uniforms.append(obj_)
            obj_.original_tagname_ = "channelDensityNonUniform"
        elif nodeName_ == "channelDensityNonUniformNernst":
            obj_ = ChannelDensityNonUniformNernst.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channel_density_non_uniform_nernsts.append(obj_)
            obj_.original_tagname_ = "channelDensityNonUniformNernst"
        elif nodeName_ == "channelDensityNonUniformGHK":
            obj_ = ChannelDensityNonUniformGHK.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channel_density_non_uniform_ghks.append(obj_)
            obj_.original_tagname_ = "channelDensityNonUniformGHK"
        elif nodeName_ == "spikeThresh":
            obj_ = SpikeThresh.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spike_threshes.append(obj_)
            obj_.original_tagname_ = "spikeThresh"
        elif nodeName_ == "specificCapacitance":
            obj_ = SpecificCapacitance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specific_capacitances.append(obj_)
            obj_.original_tagname_ = "specificCapacitance"
        elif nodeName_ == "initMembPotential":
            obj_ = InitMembPotential.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.init_memb_potentials.append(obj_)
            obj_.original_tagname_ = "initMembPotential"
        super(MembraneProperties, self)._buildChildren(child_, node, nodeName_, True)


# end class MembraneProperties


class BiophysicalProperties2CaPools(Standalone):
    """BiophysicalProperties2CaPools -- The biophysical properties of the  **cell** , including the  **membraneProperties2CaPools**  and the  **intracellularProperties2CaPools**  for a cell with two Ca pools"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "membrane_properties2_ca_pools",
            "MembraneProperties2CaPools",
            0,
            0,
            {
                "name": "membraneProperties2CaPools",
                "type": "MembraneProperties2CaPools",
            },
            None,
        ),
        MemberSpec_(
            "intracellular_properties2_ca_pools",
            "IntracellularProperties2CaPools",
            0,
            1,
            {
                "minOccurs": "0",
                "name": "intracellularProperties2CaPools",
                "type": "IntracellularProperties2CaPools",
            },
            None,
        ),
        MemberSpec_(
            "extracellular_properties",
            "ExtracellularProperties",
            0,
            1,
            {
                "minOccurs": "0",
                "name": "extracellularProperties",
                "type": "ExtracellularProperties",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        membrane_properties2_ca_pools: "a MembraneProperties2CaPools (required)" = None,
        intracellular_properties2_ca_pools: "a IntracellularProperties2CaPools (optional)" = None,
        extracellular_properties: "a ExtracellularProperties (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BiophysicalProperties2CaPools"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.membrane_properties2_ca_pools = membrane_properties2_ca_pools
        self.membrane_properties2_ca_pools_nsprefix_ = None
        self.intracellular_properties2_ca_pools = intracellular_properties2_ca_pools
        self.intracellular_properties2_ca_pools_nsprefix_ = None
        self.extracellular_properties = extracellular_properties
        self.extracellular_properties_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BiophysicalProperties2CaPools
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BiophysicalProperties2CaPools.subclass:
            return BiophysicalProperties2CaPools.subclass(*args_, **kwargs_)
        else:
            return BiophysicalProperties2CaPools(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.membrane_properties2_ca_pools is not None
            or self.intracellular_properties2_ca_pools is not None
            or self.extracellular_properties is not None
            or super(BiophysicalProperties2CaPools, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="BiophysicalProperties2CaPools",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BiophysicalProperties2CaPools")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "BiophysicalProperties2CaPools"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BiophysicalProperties2CaPools",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BiophysicalProperties2CaPools",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BiophysicalProperties2CaPools",
    ):
        super(BiophysicalProperties2CaPools, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BiophysicalProperties2CaPools",
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="BiophysicalProperties2CaPools",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BiophysicalProperties2CaPools, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.membrane_properties2_ca_pools is not None:
            namespaceprefix_ = (
                self.membrane_properties2_ca_pools_nsprefix_ + ":"
                if (UseCapturedNS_ and self.membrane_properties2_ca_pools_nsprefix_)
                else ""
            )
            self.membrane_properties2_ca_pools.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="membraneProperties2CaPools",
                pretty_print=pretty_print,
            )
        if self.intracellular_properties2_ca_pools is not None:
            namespaceprefix_ = (
                self.intracellular_properties2_ca_pools_nsprefix_ + ":"
                if (
                    UseCapturedNS_ and self.intracellular_properties2_ca_pools_nsprefix_
                )
                else ""
            )
            self.intracellular_properties2_ca_pools.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="intracellularProperties2CaPools",
                pretty_print=pretty_print,
            )
        if self.extracellular_properties is not None:
            namespaceprefix_ = (
                self.extracellular_properties_nsprefix_ + ":"
                if (UseCapturedNS_ and self.extracellular_properties_nsprefix_)
                else ""
            )
            self.extracellular_properties.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="extracellularProperties",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.membrane_properties2_ca_pools,
            "membrane_properties2_ca_pools",
            min_occurs=1,
            max_occurs=1,
        )
        self.gds_check_cardinality_(
            self.intracellular_properties2_ca_pools,
            "intracellular_properties2_ca_pools",
            min_occurs=0,
            max_occurs=1,
        )
        self.gds_check_cardinality_(
            self.extracellular_properties,
            "extracellular_properties",
            min_occurs=0,
            max_occurs=1,
        )
        if recursive:
            if self.membrane_properties2_ca_pools is not None:
                self.membrane_properties2_ca_pools.validate_(
                    gds_collector, recursive=True
                )
            if self.intracellular_properties2_ca_pools is not None:
                self.intracellular_properties2_ca_pools.validate_(
                    gds_collector, recursive=True
                )
            if self.extracellular_properties is not None:
                self.extracellular_properties.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(BiophysicalProperties2CaPools, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "membraneProperties2CaPools":
            obj_ = MembraneProperties2CaPools.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.membrane_properties2_ca_pools = obj_
            obj_.original_tagname_ = "membraneProperties2CaPools"
        elif nodeName_ == "intracellularProperties2CaPools":
            obj_ = IntracellularProperties2CaPools.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intracellular_properties2_ca_pools = obj_
            obj_.original_tagname_ = "intracellularProperties2CaPools"
        elif nodeName_ == "extracellularProperties":
            obj_ = ExtracellularProperties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extracellular_properties = obj_
            obj_.original_tagname_ = "extracellularProperties"
        super(BiophysicalProperties2CaPools, self)._buildChildren(
            child_, node, nodeName_, True
        )


# end class BiophysicalProperties2CaPools


class BiophysicalProperties(Standalone):
    """BiophysicalProperties -- The biophysical properties of the  **cell** , including the  **membraneProperties**  and the  **intracellularProperties**"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "membrane_properties",
            "MembraneProperties",
            0,
            0,
            {"name": "membraneProperties", "type": "MembraneProperties"},
            None,
        ),
        MemberSpec_(
            "intracellular_properties",
            "IntracellularProperties",
            0,
            1,
            {
                "minOccurs": "0",
                "name": "intracellularProperties",
                "type": "IntracellularProperties",
            },
            None,
        ),
        MemberSpec_(
            "extracellular_properties",
            "ExtracellularProperties",
            0,
            1,
            {
                "minOccurs": "0",
                "name": "extracellularProperties",
                "type": "ExtracellularProperties",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        membrane_properties: "a MembraneProperties (required)" = None,
        intracellular_properties: "a IntracellularProperties (optional)" = None,
        extracellular_properties: "a ExtracellularProperties (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BiophysicalProperties"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.membrane_properties = membrane_properties
        self.membrane_properties_nsprefix_ = None
        self.intracellular_properties = intracellular_properties
        self.intracellular_properties_nsprefix_ = None
        self.extracellular_properties = extracellular_properties
        self.extracellular_properties_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BiophysicalProperties
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BiophysicalProperties.subclass:
            return BiophysicalProperties.subclass(*args_, **kwargs_)
        else:
            return BiophysicalProperties(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.membrane_properties is not None
            or self.intracellular_properties is not None
            or self.extracellular_properties is not None
            or super(BiophysicalProperties, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="BiophysicalProperties",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BiophysicalProperties")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BiophysicalProperties":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BiophysicalProperties",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BiophysicalProperties",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BiophysicalProperties",
    ):
        super(BiophysicalProperties, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BiophysicalProperties",
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="BiophysicalProperties",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BiophysicalProperties, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.membrane_properties is not None:
            namespaceprefix_ = (
                self.membrane_properties_nsprefix_ + ":"
                if (UseCapturedNS_ and self.membrane_properties_nsprefix_)
                else ""
            )
            self.membrane_properties.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="membraneProperties",
                pretty_print=pretty_print,
            )
        if self.intracellular_properties is not None:
            namespaceprefix_ = (
                self.intracellular_properties_nsprefix_ + ":"
                if (UseCapturedNS_ and self.intracellular_properties_nsprefix_)
                else ""
            )
            self.intracellular_properties.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="intracellularProperties",
                pretty_print=pretty_print,
            )
        if self.extracellular_properties is not None:
            namespaceprefix_ = (
                self.extracellular_properties_nsprefix_ + ":"
                if (UseCapturedNS_ and self.extracellular_properties_nsprefix_)
                else ""
            )
            self.extracellular_properties.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="extracellularProperties",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.membrane_properties, "membrane_properties", min_occurs=1, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.intracellular_properties,
            "intracellular_properties",
            min_occurs=0,
            max_occurs=1,
        )
        self.gds_check_cardinality_(
            self.extracellular_properties,
            "extracellular_properties",
            min_occurs=0,
            max_occurs=1,
        )
        if recursive:
            if self.membrane_properties is not None:
                self.membrane_properties.validate_(gds_collector, recursive=True)
            if self.intracellular_properties is not None:
                self.intracellular_properties.validate_(gds_collector, recursive=True)
            if self.extracellular_properties is not None:
                self.extracellular_properties.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(BiophysicalProperties, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "membraneProperties":
            class_obj_ = self.get_class_obj_(child_, MembraneProperties)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.membrane_properties = obj_
            obj_.original_tagname_ = "membraneProperties"
        elif nodeName_ == "intracellularProperties":
            class_obj_ = self.get_class_obj_(child_, IntracellularProperties)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intracellular_properties = obj_
            obj_.original_tagname_ = "intracellularProperties"
        elif nodeName_ == "extracellularProperties":
            obj_ = ExtracellularProperties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extracellular_properties = obj_
            obj_.original_tagname_ = "extracellularProperties"
        super(BiophysicalProperties, self)._buildChildren(child_, node, nodeName_, True)


# end class BiophysicalProperties


class SegmentEndPoint(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "segments",
            "NonNegativeInteger",
            0,
            0,
            {"use": "required", "name": "segments"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        segments: "a NonNegativeInteger (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SegmentEndPoint"), self).__init__(**kwargs_)
        self.segments = _cast(int, segments)
        self.segments_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SegmentEndPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SegmentEndPoint.subclass:
            return SegmentEndPoint.subclass(*args_, **kwargs_)
        else:
            return SegmentEndPoint(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def _hasContent(self):
        if super(SegmentEndPoint, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SegmentEndPoint",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SegmentEndPoint")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SegmentEndPoint":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SegmentEndPoint"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SegmentEndPoint",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SegmentEndPoint",
    ):
        super(SegmentEndPoint, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SegmentEndPoint"
        )
        if self.segments is not None and "segments" not in already_processed:
            already_processed.add("segments")
            outfile.write(
                ' segment="%s"'
                % self.gds_format_integer(self.segments, input_name="segment")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SegmentEndPoint",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SegmentEndPoint, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NonNegativeInteger, self.segments, "segments"
        )
        self.gds_check_cardinality_(self.segments, "segments", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("segment", node)
        if value is not None and "segment" not in already_processed:
            already_processed.add("segment")
            self.segments = self.gds_parse_integer(value, node, "segment")
            if self.segments < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
            self.validate_NonNegativeInteger(
                self.segments
            )  # validate type NonNegativeInteger
        super(SegmentEndPoint, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SegmentEndPoint, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class SegmentEndPoint


class SubTree(BaseWithoutId):
    """SubTree -- Include all the  **segment** s distal to that specified by  **from**  in the  **segmentGroup**"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "from_",
            "SegmentEndPoint",
            0,
            1,
            {"minOccurs": "0", "name": "from", "type": "SegmentEndPoint"},
            3,
        ),
        MemberSpec_(
            "to",
            "SegmentEndPoint",
            0,
            1,
            {"minOccurs": "0", "name": "to", "type": "SegmentEndPoint"},
            3,
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        from_: "a SegmentEndPoint (optional)" = None,
        to: "a SegmentEndPoint (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SubTree"), self).__init__(**kwargs_)
        self.from_ = from_
        self.from__nsprefix_ = None
        self.to = to
        self.to_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SubTree)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubTree.subclass:
            return SubTree.subclass(*args_, **kwargs_)
        else:
            return SubTree(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.from_ is not None
            or self.to is not None
            or super(SubTree, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="SubTree",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SubTree")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SubTree":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SubTree"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SubTree",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="SubTree"
    ):
        super(SubTree, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SubTree"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="SubTree",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SubTree, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.from_ is not None:
            namespaceprefix_ = (
                self.from__nsprefix_ + ":"
                if (UseCapturedNS_ and self.from__nsprefix_)
                else ""
            )
            self.from_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="from",
                pretty_print=pretty_print,
            )
        if self.to is not None:
            namespaceprefix_ = (
                self.to_nsprefix_ + ":"
                if (UseCapturedNS_ and self.to_nsprefix_)
                else ""
            )
            self.to.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="to",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        # cardinality check omitted for choice item from_
        # self.gds_check_cardinality_(self.from_, 'from_', min_occurs=0, max_occurs=1)
        # cardinality check omitted for choice item to
        # self.gds_check_cardinality_(self.to, 'to', min_occurs=0, max_occurs=1)
        if recursive:
            if self.from_ is not None:
                self.from_.validate_(gds_collector, recursive=True)
            if self.to is not None:
                self.to.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(SubTree, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "from":
            obj_ = SegmentEndPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.from_ = obj_
            obj_.original_tagname_ = "from"
        elif nodeName_ == "to":
            obj_ = SegmentEndPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.to = obj_
            obj_.original_tagname_ = "to"
        super(SubTree, self)._buildChildren(child_, node, nodeName_, True)


# end class SubTree


class Path(BaseWithoutId):
    """Path -- Include all the  **segment** s between those specified by  **from**  and  **to** , inclusive"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "from_",
            "SegmentEndPoint",
            0,
            1,
            {"minOccurs": "0", "name": "from", "type": "SegmentEndPoint"},
            None,
        ),
        MemberSpec_(
            "to",
            "SegmentEndPoint",
            0,
            1,
            {"minOccurs": "0", "name": "to", "type": "SegmentEndPoint"},
            None,
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        from_: "a SegmentEndPoint (optional)" = None,
        to: "a SegmentEndPoint (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Path"), self).__init__(**kwargs_)
        self.from_ = from_
        self.from__nsprefix_ = None
        self.to = to
        self.to_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Path)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Path.subclass:
            return Path.subclass(*args_, **kwargs_)
        else:
            return Path(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.from_ is not None
            or self.to is not None
            or super(Path, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Path",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Path")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Path":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Path"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Path",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Path"
    ):
        super(Path, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Path"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Path",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Path, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.from_ is not None:
            namespaceprefix_ = (
                self.from__nsprefix_ + ":"
                if (UseCapturedNS_ and self.from__nsprefix_)
                else ""
            )
            self.from_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="from",
                pretty_print=pretty_print,
            )
        if self.to is not None:
            namespaceprefix_ = (
                self.to_nsprefix_ + ":"
                if (UseCapturedNS_ and self.to_nsprefix_)
                else ""
            )
            self.to.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="to",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(self.from_, "from_", min_occurs=0, max_occurs=1)
        self.gds_check_cardinality_(self.to, "to", min_occurs=0, max_occurs=1)
        if recursive:
            if self.from_ is not None:
                self.from_.validate_(gds_collector, recursive=True)
            if self.to is not None:
                self.to.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(Path, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "from":
            obj_ = SegmentEndPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.from_ = obj_
            obj_.original_tagname_ = "from"
        elif nodeName_ == "to":
            obj_ = SegmentEndPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.to = obj_
            obj_.original_tagname_ = "to"
        super(Path, self)._buildChildren(child_, node, nodeName_, True)


# end class Path


class Include(BaseWithoutId):
    """Include -- Include all members of another  **segmentGroup**  in this group"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "segment_groups",
            "NmlId",
            0,
            0,
            {"use": "required", "name": "segment_groups"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        segment_groups: "a NmlId (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Include"), self).__init__(**kwargs_)
        self.segment_groups = _cast(None, segment_groups)
        self.segment_groups_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Include)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Include.subclass:
            return Include.subclass(*args_, **kwargs_)
        else:
            return Include(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if super(Include, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Include",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Include")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Include":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Include"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Include",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Include"
    ):
        super(Include, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Include"
        )
        if (
            self.segment_groups is not None
            and "segment_groups" not in already_processed
        ):
            already_processed.add("segment_groups")
            outfile.write(
                " segmentGroup=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.segment_groups), input_name="segmentGroup"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Include",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Include, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.segment_groups, "segment_groups"
        )
        self.gds_check_cardinality_(
            self.segment_groups, "segment_groups", required=True
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("segmentGroup", node)
        if value is not None and "segmentGroup" not in already_processed:
            already_processed.add("segmentGroup")
            self.segment_groups = value
            self.validate_NmlId(self.segment_groups)  # validate type NmlId
        super(Include, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Include, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class Include


class Member(BaseWithoutId):
    """Member -- A single identified **segment**  which is part of the  **segmentGroup**"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "segments",
            "NonNegativeInteger",
            0,
            0,
            {"use": "required", "name": "segments"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        segments: "a NonNegativeInteger (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Member"), self).__init__(**kwargs_)
        self.segments = _cast(int, segments)
        self.segments_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Member)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Member.subclass:
            return Member.subclass(*args_, **kwargs_)
        else:
            return Member(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def _hasContent(self):
        if super(Member, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Member",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Member")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Member":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Member"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Member",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Member"
    ):
        super(Member, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Member"
        )
        if self.segments is not None and "segments" not in already_processed:
            already_processed.add("segments")
            outfile.write(
                ' segment="%s"'
                % self.gds_format_integer(self.segments, input_name="segment")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Member",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Member, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NonNegativeInteger, self.segments, "segments"
        )
        self.gds_check_cardinality_(self.segments, "segments", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("segment", node)
        if value is not None and "segment" not in already_processed:
            already_processed.add("segment")
            self.segments = self.gds_parse_integer(value, node, "segment")
            if self.segments < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
            self.validate_NonNegativeInteger(
                self.segments
            )  # validate type NonNegativeInteger
        super(Member, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Member, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class Member


class DistalDetails(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "normalization_end",
            "xs:double",
            0,
            0,
            {"use": "required", "name": "normalization_end"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        normalization_end: "a double (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("DistalDetails"), self).__init__(**kwargs_)
        self.normalization_end = _cast(float, normalization_end)
        self.normalization_end_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, DistalDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DistalDetails.subclass:
            return DistalDetails.subclass(*args_, **kwargs_)
        else:
            return DistalDetails(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(DistalDetails, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DistalDetails",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("DistalDetails")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "DistalDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="DistalDetails"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="DistalDetails",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="DistalDetails",
    ):
        super(DistalDetails, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="DistalDetails"
        )
        if (
            self.normalization_end is not None
            and "normalization_end" not in already_processed
        ):
            already_processed.add("normalization_end")
            outfile.write(
                ' normalizationEnd="%s"'
                % self.gds_format_double(
                    self.normalization_end, input_name="normalizationEnd"
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DistalDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(DistalDetails, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(
            self.gds_validate_double, self.normalization_end, "normalization_end"
        )
        self.gds_check_cardinality_(
            self.normalization_end, "normalization_end", required=True
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("normalizationEnd", node)
        if value is not None and "normalizationEnd" not in already_processed:
            already_processed.add("normalizationEnd")
            value = self.gds_parse_double(value, node, "normalizationEnd")
            self.normalization_end = value
        super(DistalDetails, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(DistalDetails, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class DistalDetails


class ProximalDetails(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "translation_start",
            "xs:double",
            0,
            0,
            {"use": "required", "name": "translation_start"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        translation_start: "a double (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ProximalDetails"), self).__init__(**kwargs_)
        self.translation_start = _cast(float, translation_start)
        self.translation_start_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ProximalDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProximalDetails.subclass:
            return ProximalDetails.subclass(*args_, **kwargs_)
        else:
            return ProximalDetails(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(ProximalDetails, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ProximalDetails",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ProximalDetails")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ProximalDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ProximalDetails"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ProximalDetails",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ProximalDetails",
    ):
        super(ProximalDetails, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ProximalDetails"
        )
        if (
            self.translation_start is not None
            and "translation_start" not in already_processed
        ):
            already_processed.add("translation_start")
            outfile.write(
                ' translationStart="%s"'
                % self.gds_format_double(
                    self.translation_start, input_name="translationStart"
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ProximalDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ProximalDetails, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(
            self.gds_validate_double, self.translation_start, "translation_start"
        )
        self.gds_check_cardinality_(
            self.translation_start, "translation_start", required=True
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("translationStart", node)
        if value is not None and "translationStart" not in already_processed:
            already_processed.add("translationStart")
            value = self.gds_parse_double(value, node, "translationStart")
            self.translation_start = value
        super(ProximalDetails, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ProximalDetails, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class ProximalDetails


class InhomogeneousParameter(Base):
    """InhomogeneousParameter -- An inhomogeneous parameter specified across the  **segmentGroup**  ( see  **variableParameter**  for usage )."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "variable", "xs:string", 0, 0, {"use": "required", "name": "variable"}
        ),
        MemberSpec_("metric", "Metric", 0, 0, {"use": "required", "name": "metric"}),
        MemberSpec_(
            "proximal",
            "ProximalDetails",
            0,
            1,
            {"minOccurs": "0", "name": "proximal", "type": "ProximalDetails"},
            None,
        ),
        MemberSpec_(
            "distal",
            "DistalDetails",
            0,
            1,
            {"minOccurs": "0", "name": "distal", "type": "DistalDetails"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        variable: "a string (required)" = None,
        metric: "a Metric (required)" = None,
        proximal: "a ProximalDetails (optional)" = None,
        distal: "a DistalDetails (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("InhomogeneousParameter"), self).__init__(id, **kwargs_)
        self.variable = _cast(None, variable)
        self.variable_nsprefix_ = None
        self.metric = _cast(None, metric)
        self.metric_nsprefix_ = None
        self.proximal = proximal
        self.proximal_nsprefix_ = None
        self.distal = distal
        self.distal_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InhomogeneousParameter
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InhomogeneousParameter.subclass:
            return InhomogeneousParameter.subclass(*args_, **kwargs_)
        else:
            return InhomogeneousParameter(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Metric(self, value):
        # Validate type Metric, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = ["Path Length from root"]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on Metric'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False

    def _hasContent(self):
        if (
            self.proximal is not None
            or self.distal is not None
            or super(InhomogeneousParameter, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="InhomogeneousParameter",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("InhomogeneousParameter")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "InhomogeneousParameter":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="InhomogeneousParameter",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="InhomogeneousParameter",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="InhomogeneousParameter",
    ):
        super(InhomogeneousParameter, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="InhomogeneousParameter",
        )
        if self.variable is not None and "variable" not in already_processed:
            already_processed.add("variable")
            outfile.write(
                " variable=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.variable), input_name="variable"
                        )
                    ),
                )
            )
        if self.metric is not None and "metric" not in already_processed:
            already_processed.add("metric")
            outfile.write(
                " metric=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.metric), input_name="metric"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="InhomogeneousParameter",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(InhomogeneousParameter, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.proximal is not None:
            namespaceprefix_ = (
                self.proximal_nsprefix_ + ":"
                if (UseCapturedNS_ and self.proximal_nsprefix_)
                else ""
            )
            self.proximal.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="proximal",
                pretty_print=pretty_print,
            )
        if self.distal is not None:
            namespaceprefix_ = (
                self.distal_nsprefix_ + ":"
                if (UseCapturedNS_ and self.distal_nsprefix_)
                else ""
            )
            self.distal.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="distal",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.variable, "variable"
        )
        self.gds_check_cardinality_(self.variable, "variable", required=True)
        self.gds_validate_defined_ST_(self.validate_Metric, self.metric, "metric")
        self.gds_check_cardinality_(self.metric, "metric", required=True)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.proximal, "proximal", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(self.distal, "distal", min_occurs=0, max_occurs=1)
        if recursive:
            if self.proximal is not None:
                self.proximal.validate_(gds_collector, recursive=True)
            if self.distal is not None:
                self.distal.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("variable", node)
        if value is not None and "variable" not in already_processed:
            already_processed.add("variable")
            self.variable = value
        value = find_attr_value_("metric", node)
        if value is not None and "metric" not in already_processed:
            already_processed.add("metric")
            self.metric = value
            self.validate_Metric(self.metric)  # validate type Metric
        super(InhomogeneousParameter, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "proximal":
            obj_ = ProximalDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.proximal = obj_
            obj_.original_tagname_ = "proximal"
        elif nodeName_ == "distal":
            obj_ = DistalDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distal = obj_
            obj_.original_tagname_ = "distal"
        super(InhomogeneousParameter, self)._buildChildren(
            child_, node, nodeName_, True
        )


# end class InhomogeneousParameter


class SegmentGroup(Base):
    """SegmentGroup -- A method to describe a group of  **segment** s in a  **morphology** , e. g. soma_group, dendrite_group, axon_group. While a name is useful to describe the group, the **neuroLexId**  attribute can be used to explicitly specify the meaning of the group, e. g. sao1044911821 for 'Neuronal Cell Body', sao1211023249 for 'Dendrite'. The  **segment** s in this group can be specified as: a list of individual  **member**  segments; a  **path** , all of the segments along which should be included; a  **subTree**  of the  **cell**  to include; other segmentGroups to  **include**  ( so all segments from those get included here ). An  **inhomogeneousParameter**  can be defined on the region of the cell specified by this group ( see  **variableParameter**  for usage )."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "neuro_lex_id",
            "NeuroLexId",
            0,
            1,
            {"use": "optional", "name": "neuro_lex_id"},
        ),
        MemberSpec_(
            "notes",
            ["Notes", "xs:string"],
            0,
            1,
            {"minOccurs": "0", "name": "notes", "type": "xs:string"},
            None,
        ),
        MemberSpec_(
            "properties",
            "Property",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "property",
                "type": "Property",
            },
            None,
        ),
        MemberSpec_(
            "annotation",
            "Annotation",
            0,
            1,
            {"minOccurs": "0", "name": "annotation", "type": "Annotation"},
            None,
        ),
        MemberSpec_(
            "members",
            "Member",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "member",
                "type": "Member",
            },
            None,
        ),
        MemberSpec_(
            "includes",
            "Include",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "include",
                "type": "Include",
            },
            None,
        ),
        MemberSpec_(
            "paths",
            "Path",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "path",
                "type": "Path",
            },
            None,
        ),
        MemberSpec_(
            "sub_trees",
            "SubTree",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "subTree",
                "type": "SubTree",
            },
            None,
        ),
        MemberSpec_(
            "inhomogeneous_parameters",
            "InhomogeneousParameter",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "inhomogeneousParameter",
                "type": "InhomogeneousParameter",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        members: "list of Member(s) (optional)" = None,
        includes: "list of Include(s) (optional)" = None,
        paths: "list of Path(s) (optional)" = None,
        sub_trees: "list of SubTree(s) (optional)" = None,
        inhomogeneous_parameters: "list of InhomogeneousParameter(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SegmentGroup"), self).__init__(id, **kwargs_)
        self.neuro_lex_id = _cast(None, neuro_lex_id)
        self.neuro_lex_id_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        if properties is None:
            self.properties = []
        else:
            self.properties = properties
        self.properties_nsprefix_ = None
        self.annotation = annotation
        self.annotation_nsprefix_ = None
        if members is None:
            self.members = []
        else:
            self.members = members
        self.members_nsprefix_ = None
        if includes is None:
            self.includes = []
        else:
            self.includes = includes
        self.includes_nsprefix_ = None
        if paths is None:
            self.paths = []
        else:
            self.paths = paths
        self.paths_nsprefix_ = None
        if sub_trees is None:
            self.sub_trees = []
        else:
            self.sub_trees = sub_trees
        self.sub_trees_nsprefix_ = None
        if inhomogeneous_parameters is None:
            self.inhomogeneous_parameters = []
        else:
            self.inhomogeneous_parameters = inhomogeneous_parameters
        self.inhomogeneous_parameters_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SegmentGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SegmentGroup.subclass:
            return SegmentGroup.subclass(*args_, **kwargs_)
        else:
            return SegmentGroup(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_NeuroLexId(self, value):
        # Validate type NeuroLexId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NeuroLexId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NeuroLexId_patterns_,
                    )
                )

    validate_NeuroLexId_patterns_ = [["^([a-zA-Z0-9_:]*)$"]]

    def _hasContent(self):
        if (
            self.notes is not None
            or self.properties
            or self.annotation is not None
            or self.members
            or self.includes
            or self.paths
            or self.sub_trees
            or self.inhomogeneous_parameters
            or super(SegmentGroup, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="SegmentGroup",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SegmentGroup")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SegmentGroup":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SegmentGroup"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SegmentGroup",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SegmentGroup",
    ):
        super(SegmentGroup, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SegmentGroup"
        )
        if self.neuro_lex_id is not None and "neuro_lex_id" not in already_processed:
            already_processed.add("neuro_lex_id")
            outfile.write(
                " neuroLexId=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.neuro_lex_id), input_name="neuroLexId"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="SegmentGroup",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SegmentGroup, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.notes is not None:
            namespaceprefix_ = (
                self.notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%snotes>%s</%snotes>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.notes), input_name="notes"
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        for property_ in self.properties:
            namespaceprefix_ = (
                self.properties_nsprefix_ + ":"
                if (UseCapturedNS_ and self.properties_nsprefix_)
                else ""
            )
            property_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="property",
                pretty_print=pretty_print,
            )
        if self.annotation is not None:
            namespaceprefix_ = (
                self.annotation_nsprefix_ + ":"
                if (UseCapturedNS_ and self.annotation_nsprefix_)
                else ""
            )
            self.annotation.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="annotation",
                pretty_print=pretty_print,
            )
        for member_ in self.members:
            namespaceprefix_ = (
                self.members_nsprefix_ + ":"
                if (UseCapturedNS_ and self.members_nsprefix_)
                else ""
            )
            member_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="member",
                pretty_print=pretty_print,
            )
        for include_ in self.includes:
            namespaceprefix_ = (
                self.includes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.includes_nsprefix_)
                else ""
            )
            include_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="include",
                pretty_print=pretty_print,
            )
        for path_ in self.paths:
            namespaceprefix_ = (
                self.paths_nsprefix_ + ":"
                if (UseCapturedNS_ and self.paths_nsprefix_)
                else ""
            )
            path_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="path",
                pretty_print=pretty_print,
            )
        for subTree_ in self.sub_trees:
            namespaceprefix_ = (
                self.sub_trees_nsprefix_ + ":"
                if (UseCapturedNS_ and self.sub_trees_nsprefix_)
                else ""
            )
            subTree_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="subTree",
                pretty_print=pretty_print,
            )
        for inhomogeneousParameter_ in self.inhomogeneous_parameters:
            namespaceprefix_ = (
                self.inhomogeneous_parameters_nsprefix_ + ":"
                if (UseCapturedNS_ and self.inhomogeneous_parameters_nsprefix_)
                else ""
            )
            inhomogeneousParameter_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="inhomogeneousParameter",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NeuroLexId, self.neuro_lex_id, "neuro_lex_id"
        )
        self.gds_check_cardinality_(self.neuro_lex_id, "neuro_lex_id", required=False)
        # validate simple type children
        self.gds_validate_defined_ST_(self.validate_Notes, self.notes, "notes")
        self.gds_check_cardinality_(self.notes, "notes", min_occurs=0, max_occurs=1)
        # validate complex type children
        self.gds_check_cardinality_(
            self.properties, "properties", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.annotation, "annotation", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.members, "members", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.includes, "includes", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.paths, "paths", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.sub_trees, "sub_trees", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.inhomogeneous_parameters,
            "inhomogeneous_parameters",
            min_occurs=0,
            max_occurs=9999999,
        )
        if recursive:
            for item in self.properties:
                item.validate_(gds_collector, recursive=True)
            if self.annotation is not None:
                self.annotation.validate_(gds_collector, recursive=True)
            for item in self.members:
                item.validate_(gds_collector, recursive=True)
            for item in self.includes:
                item.validate_(gds_collector, recursive=True)
            for item in self.paths:
                item.validate_(gds_collector, recursive=True)
            for item in self.sub_trees:
                item.validate_(gds_collector, recursive=True)
            for item in self.inhomogeneous_parameters:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("neuroLexId", node)
        if value is not None and "neuroLexId" not in already_processed:
            already_processed.add("neuroLexId")
            self.neuro_lex_id = value
            self.validate_NeuroLexId(self.neuro_lex_id)  # validate type NeuroLexId
        super(SegmentGroup, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "notes":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "notes")
            value_ = self.gds_validate_string(value_, node, "notes")
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == "property":
            obj_ = Property.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.properties.append(obj_)
            obj_.original_tagname_ = "property"
        elif nodeName_ == "annotation":
            obj_ = Annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = "annotation"
        elif nodeName_ == "member":
            obj_ = Member.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.members.append(obj_)
            obj_.original_tagname_ = "member"
        elif nodeName_ == "include":
            obj_ = Include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.includes.append(obj_)
            obj_.original_tagname_ = "include"
        elif nodeName_ == "path":
            obj_ = Path.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.paths.append(obj_)
            obj_.original_tagname_ = "path"
        elif nodeName_ == "subTree":
            obj_ = SubTree.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sub_trees.append(obj_)
            obj_.original_tagname_ = "subTree"
        elif nodeName_ == "inhomogeneousParameter":
            obj_ = InhomogeneousParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inhomogeneous_parameters.append(obj_)
            obj_.original_tagname_ = "inhomogeneousParameter"
        super(SegmentGroup, self)._buildChildren(child_, node, nodeName_, True)

    def __str__(self):
        return (
            "SegmentGroup: "
            + str(self.id)
            + ", "
            + str(len(self.members))
            + " member(s), "
            + str(len(self.includes))
            + " included group(s)"
        )

    def __repr__(self):
        return str(self)


# end class SegmentGroup


class Point3DWithDiam(BaseWithoutId):
    """Point3DWithDiam -- Base type for ComponentTypes which specify an ( **x,**  **y,**  **z**  ) coordinate along with a **diameter.**  Note: no dimension used in the attributes for these coordinates! These are assumed to have dimension micrometer ( 10^-6 m ). This is due to micrometers being the default option for the majority of neuronal morphology formats, and dimensions are omitted here to facilitate reading and writing of morphologies in NeuroML.
    \n
    :param x: x coordinate of the point. Note: no dimension used, see description of  **point3DWithDiam**  for details.
    :type x: none
    :param y: y coordinate of the ppoint. Note: no dimension used, see description of  **point3DWithDiam**  for details.
    :type y: none
    :param z: z coordinate of the ppoint. Note: no dimension used, see description of  **point3DWithDiam**  for details.
    :type z: none
    :param diameter: Diameter of the ppoint. Note: no dimension used, see description of  **point3DWithDiam**  for details.
    :type diameter: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("x", "xs:double", 0, 0, {"use": "required", "name": "x"}),
        MemberSpec_("y", "xs:double", 0, 0, {"use": "required", "name": "y"}),
        MemberSpec_("z", "xs:double", 0, 0, {"use": "required", "name": "z"}),
        MemberSpec_(
            "diameter",
            "DoubleGreaterThanZero",
            0,
            0,
            {"use": "required", "name": "diameter"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        x: "a double (required)" = None,
        y: "a double (required)" = None,
        z: "a double (required)" = None,
        diameter: "a DoubleGreaterThanZero (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Point3DWithDiam"), self).__init__(**kwargs_)
        self.x = _cast(float, x)
        self.x_nsprefix_ = None
        self.y = _cast(float, y)
        self.y_nsprefix_ = None
        self.z = _cast(float, z)
        self.z_nsprefix_ = None
        self.diameter = _cast(float, diameter)
        self.diameter_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Point3DWithDiam)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Point3DWithDiam.subclass:
            return Point3DWithDiam.subclass(*args_, **kwargs_)
        else:
            return Point3DWithDiam(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_DoubleGreaterThanZero(self, value):
        # Validate type DoubleGreaterThanZero, a restriction on xs:double.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value <= 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on DoubleGreaterThanZero'
                    % {"value": value, "lineno": lineno}
                )
                result = False

    def _hasContent(self):
        if super(Point3DWithDiam, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Point3DWithDiam",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Point3DWithDiam")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Point3DWithDiam":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Point3DWithDiam"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Point3DWithDiam",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Point3DWithDiam",
    ):
        super(Point3DWithDiam, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Point3DWithDiam"
        )
        if self.x is not None and "x" not in already_processed:
            already_processed.add("x")
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name="x"))
        if self.y is not None and "y" not in already_processed:
            already_processed.add("y")
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name="y"))
        if self.z is not None and "z" not in already_processed:
            already_processed.add("z")
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name="z"))
        if self.diameter is not None and "diameter" not in already_processed:
            already_processed.add("diameter")
            outfile.write(
                ' diameter="%s"'
                % self.gds_format_double(self.diameter, input_name="diameter")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Point3DWithDiam",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Point3DWithDiam, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_double, self.x, "x")
        self.gds_check_cardinality_(self.x, "x", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_double, self.y, "y")
        self.gds_check_cardinality_(self.y, "y", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_double, self.z, "z")
        self.gds_check_cardinality_(self.z, "z", required=True)
        self.gds_validate_defined_ST_(
            self.validate_DoubleGreaterThanZero, self.diameter, "diameter"
        )
        self.gds_check_cardinality_(self.diameter, "diameter", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("x", node)
        if value is not None and "x" not in already_processed:
            already_processed.add("x")
            value = self.gds_parse_double(value, node, "x")
            self.x = value
        value = find_attr_value_("y", node)
        if value is not None and "y" not in already_processed:
            already_processed.add("y")
            value = self.gds_parse_double(value, node, "y")
            self.y = value
        value = find_attr_value_("z", node)
        if value is not None and "z" not in already_processed:
            already_processed.add("z")
            value = self.gds_parse_double(value, node, "z")
            self.z = value
        value = find_attr_value_("diameter", node)
        if value is not None and "diameter" not in already_processed:
            already_processed.add("diameter")
            value = self.gds_parse_double(value, node, "diameter")
            self.diameter = value
            self.validate_DoubleGreaterThanZero(
                self.diameter
            )  # validate type DoubleGreaterThanZero
        super(Point3DWithDiam, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Point3DWithDiam, self)._buildChildren(child_, node, nodeName_, True)
        pass

    def __str__(self):
        return (
            "("
            + str(self.x)
            + ", "
            + str(self.y)
            + ", "
            + str(self.z)
            + "), diam "
            + str(self.diameter)
            + "um"
        )

    def __repr__(self):
        return str(self)

    def distance_to(self, other_3d_point):
        """Find the distance between this point and another.

        :param other_3d_point: other 3D point to calculate distance to
        :type other_3d_point: Point3DWithDiam
        :returns: distance between the two points
        :rtype: float
        """
        a_x = self.x
        a_y = self.y
        a_z = self.z

        b_x = other_3d_point.x
        b_y = other_3d_point.y
        b_z = other_3d_point.z

        distance = ((a_x - b_x) ** 2 + (a_y - b_y) ** 2 + (a_z - b_z) ** 2) ** (0.5)
        return distance


# end class Point3DWithDiam


class SegmentParent(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "segments",
            "NonNegativeInteger",
            0,
            0,
            {"use": "required", "name": "segments"},
        ),
        MemberSpec_(
            "fraction_along",
            "ZeroToOne",
            0,
            1,
            {"use": "optional", "name": "fraction_along"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        segments: "a NonNegativeInteger (required)" = None,
        fraction_along: "a ZeroToOne (optional)" = "1",
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SegmentParent"), self).__init__(**kwargs_)
        self.segments = _cast(int, segments)
        self.segments_nsprefix_ = None
        self.fraction_along = _cast(float, fraction_along)
        self.fraction_along_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SegmentParent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SegmentParent.subclass:
            return SegmentParent.subclass(*args_, **kwargs_)
        else:
            return SegmentParent(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def validate_ZeroToOne(self, value):
        # Validate type ZeroToOne, a restriction on xs:float.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ZeroToOne'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ZeroToOne'
                    % {"value": value, "lineno": lineno}
                )
                result = False

    def _hasContent(self):
        if super(SegmentParent, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SegmentParent",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SegmentParent")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SegmentParent":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SegmentParent"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SegmentParent",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SegmentParent",
    ):
        super(SegmentParent, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SegmentParent"
        )
        if self.segments is not None and "segments" not in already_processed:
            already_processed.add("segments")
            outfile.write(
                ' segment="%s"'
                % self.gds_format_integer(self.segments, input_name="segment")
            )
        if self.fraction_along != 1 and "fraction_along" not in already_processed:
            already_processed.add("fraction_along")
            outfile.write(
                ' fractionAlong="%s"'
                % self.gds_format_float(self.fraction_along, input_name="fractionAlong")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SegmentParent",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SegmentParent, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NonNegativeInteger, self.segments, "segments"
        )
        self.gds_check_cardinality_(self.segments, "segments", required=True)
        self.gds_validate_defined_ST_(
            self.validate_ZeroToOne, self.fraction_along, "fraction_along"
        )
        self.gds_check_cardinality_(
            self.fraction_along, "fraction_along", required=False
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("segment", node)
        if value is not None and "segment" not in already_processed:
            already_processed.add("segment")
            self.segments = self.gds_parse_integer(value, node, "segment")
            if self.segments < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
            self.validate_NonNegativeInteger(
                self.segments
            )  # validate type NonNegativeInteger
        value = find_attr_value_("fractionAlong", node)
        if value is not None and "fractionAlong" not in already_processed:
            already_processed.add("fractionAlong")
            value = self.gds_parse_float(value, node, "fractionAlong")
            self.fraction_along = value
            self.validate_ZeroToOne(self.fraction_along)  # validate type ZeroToOne
        super(SegmentParent, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SegmentParent, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class SegmentParent


class Segment(BaseNonNegativeIntegerId):
    """Segment -- A segment defines the smallest unit within a possibly branching structure (  **morphology**  ), such as a dendrite or axon. Its **id**  should be a nonnegative integer ( usually soma/root = 0 ). Its end points are given by the  **proximal**  and  **distal**  points. The  **proximal**  point can be omitted, usually because it is the same as a point on the  **parent**  segment, see  **proximal**  for details.  **parent**  specifies the parent segment. The first segment of a  **cell**  ( with no  **parent**  ) usually represents the soma. The shape is normally a cylinder ( radii of the  **proximal**  and  **distal**  equal, but positions different ) or a conical frustum ( radii and positions different ). If the x, y, x positions of the  **proximal**  and  **distal**  are equal, the segment can be interpreted as a sphere, and in this case the radii of these points must be equal. NOTE: LEMS does not yet support multicompartmental modelling, so the Dynamics here is only appropriate for single compartment modelling."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("name", "xs:string", 0, 1, {"use": "optional", "name": "name"}),
        MemberSpec_(
            "neuro_lex_id",
            "NeuroLexId",
            0,
            1,
            {"use": "optional", "name": "neuro_lex_id"},
        ),
        MemberSpec_(
            "parent",
            "SegmentParent",
            0,
            1,
            {"minOccurs": "0", "name": "parent", "type": "SegmentParent"},
            None,
        ),
        MemberSpec_(
            "proximal",
            "Point3DWithDiam",
            0,
            1,
            {"minOccurs": "0", "name": "proximal", "type": "Point3DWithDiam"},
            None,
        ),
        MemberSpec_(
            "distal",
            "Point3DWithDiam",
            0,
            0,
            {"minOccurs": "1", "name": "distal", "type": "Point3DWithDiam"},
            None,
        ),
    ]
    subclass = None
    superclass = BaseNonNegativeIntegerId

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        name: "a string (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        parent: "a SegmentParent (optional)" = None,
        proximal: "a Point3DWithDiam (optional)" = None,
        distal: "a Point3DWithDiam (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Segment"), self).__init__(id, **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.neuro_lex_id = _cast(None, neuro_lex_id)
        self.neuro_lex_id_nsprefix_ = None
        self.parent = parent
        self.parent_nsprefix_ = None
        self.proximal = proximal
        self.proximal_nsprefix_ = None
        self.distal = distal
        self.distal_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Segment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Segment.subclass:
            return Segment.subclass(*args_, **kwargs_)
        else:
            return Segment(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NeuroLexId(self, value):
        # Validate type NeuroLexId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NeuroLexId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NeuroLexId_patterns_,
                    )
                )

    validate_NeuroLexId_patterns_ = [["^([a-zA-Z0-9_:]*)$"]]

    def _hasContent(self):
        if (
            self.parent is not None
            or self.proximal is not None
            or self.distal is not None
            or super(Segment, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Segment",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Segment")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Segment":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Segment"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Segment",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Segment"
    ):
        super(Segment, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Segment"
        )
        if self.name is not None and "name" not in already_processed:
            already_processed.add("name")
            outfile.write(
                " name=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.name), input_name="name"
                        )
                    ),
                )
            )
        if self.neuro_lex_id is not None and "neuro_lex_id" not in already_processed:
            already_processed.add("neuro_lex_id")
            outfile.write(
                " neuroLexId=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.neuro_lex_id), input_name="neuroLexId"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Segment",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Segment, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.parent is not None:
            namespaceprefix_ = (
                self.parent_nsprefix_ + ":"
                if (UseCapturedNS_ and self.parent_nsprefix_)
                else ""
            )
            self.parent.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="parent",
                pretty_print=pretty_print,
            )
        if self.proximal is not None:
            namespaceprefix_ = (
                self.proximal_nsprefix_ + ":"
                if (UseCapturedNS_ and self.proximal_nsprefix_)
                else ""
            )
            self.proximal.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="proximal",
                pretty_print=pretty_print,
            )
        if self.distal is not None:
            namespaceprefix_ = (
                self.distal_nsprefix_ + ":"
                if (UseCapturedNS_ and self.distal_nsprefix_)
                else ""
            )
            self.distal.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="distal",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.name, "name")
        self.gds_check_cardinality_(self.name, "name", required=False)
        self.gds_validate_defined_ST_(
            self.validate_NeuroLexId, self.neuro_lex_id, "neuro_lex_id"
        )
        self.gds_check_cardinality_(self.neuro_lex_id, "neuro_lex_id", required=False)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(self.parent, "parent", min_occurs=0, max_occurs=1)
        self.gds_check_cardinality_(
            self.proximal, "proximal", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(self.distal, "distal", min_occurs=1, max_occurs=1)
        if recursive:
            if self.parent is not None:
                self.parent.validate_(gds_collector, recursive=True)
            if self.proximal is not None:
                self.proximal.validate_(gds_collector, recursive=True)
            if self.distal is not None:
                self.distal.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("name", node)
        if value is not None and "name" not in already_processed:
            already_processed.add("name")
            self.name = value
        value = find_attr_value_("neuroLexId", node)
        if value is not None and "neuroLexId" not in already_processed:
            already_processed.add("neuroLexId")
            self.neuro_lex_id = value
            self.validate_NeuroLexId(self.neuro_lex_id)  # validate type NeuroLexId
        super(Segment, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "parent":
            obj_ = SegmentParent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parent = obj_
            obj_.original_tagname_ = "parent"
        elif nodeName_ == "proximal":
            obj_ = Point3DWithDiam.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.proximal = obj_
            obj_.original_tagname_ = "proximal"
        elif nodeName_ == "distal":
            obj_ = Point3DWithDiam.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distal = obj_
            obj_.original_tagname_ = "distal"
        super(Segment, self)._buildChildren(child_, node, nodeName_, True)

    @property
    def length(self):
        """Get the length of the segment.

        :returns: length of the segment
        :rtype: float
        """

        if self.proximal == None:
            raise Exception(
                "Cannot get length of segment "
                + str(self.id)
                + " using the length property, since no proximal point is set on it (the proximal point comes from the parent segment). Use the method get_segment_length(segment_id) on the cell instead."
            )

        prox_x = self.proximal.x
        prox_y = self.proximal.y
        prox_z = self.proximal.z

        dist_x = self.distal.x
        dist_y = self.distal.y
        dist_z = self.distal.z

        length = (
            (prox_x - dist_x) ** 2 + (prox_y - dist_y) ** 2 + (prox_z - dist_z) ** 2
        ) ** (0.5)

        return length

    def __str__(self):
        return (
            "<Segment|"
            + str(self.id)
            + ("|" + self.name if self.name is not None else "")
            + ">"
        )

    def __repr__(self):
        return str(self)

    @property
    def volume(self):
        """Get the volume of the segment.

        :returns: volume of segment
        :rtype: float
        """
        if self.proximal == None:
            raise Exception(
                "Cannot get volume of segment "
                + str(self.id)
                + " using the volume property, since no proximal point is set on it (the proximal point comes from the parent segment). Use the method get_segment_volume(segment_id) on the cell instead."
            )

        prox_rad = self.proximal.diameter / 2.0
        dist_rad = self.distal.diameter / 2.0

        if (
            self.proximal.x == self.distal.x
            and self.proximal.y == self.distal.y
            and self.proximal.z == self.distal.z
        ):
            if prox_rad != dist_rad:
                raise Exception(
                    "Cannot get volume of segment "
                    + str(self.id)
                    + ". The (x,y,z) coordinates of the proximal and distal points match (i.e. it is a sphere), but the diameters of these points are different, making the volume calculation ambiguous."
                )

            return 4.0 / 3 * pi * prox_rad**3

        length = self.length

        volume = (
            (pi / 3) * length * (prox_rad**2 + dist_rad**2 + prox_rad * dist_rad)
        )

        return volume

    @property
    def surface_area(self):
        """Get the surface area of the segment.

        :returns: surface area of segment
        :rtype: float
        """
        if self.proximal == None:
            raise Exception(
                "Cannot get surface area of segment "
                + str(self.id)
                + " using the surface_area property, since no proximal point is set on it (the proximal point comes from the parent segment). Use the method get_segment_surface_area(segment_id) on the cell instead."
            )

        prox_rad = self.proximal.diameter / 2.0
        dist_rad = self.distal.diameter / 2.0

        if (
            self.proximal.x == self.distal.x
            and self.proximal.y == self.distal.y
            and self.proximal.z == self.distal.z
        ):
            if prox_rad != dist_rad:
                raise Exception(
                    "Cannot get surface area of segment "
                    + str(self.id)
                    + ". The (x,y,z) coordinates of the proximal and distal points match (i.e. it is a sphere), but the diameters of these points are different, making the surface area calculation ambiguous."
                )

            return 4.0 * pi * prox_rad**2

        length = self.length

        surface_area = (
            pi * (prox_rad + dist_rad) * sqrt((prox_rad - dist_rad) ** 2 + length**2)
        )

        return surface_area

    # end class Segment


class Morphology(Standalone):
    """Morphology -- The collection of  **segment** s which specify the 3D structure of the cell, along with a number of  **segmentGroup** s"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "segments",
            "Segment",
            1,
            0,
            {"maxOccurs": "unbounded", "name": "segment", "type": "Segment"},
            None,
        ),
        MemberSpec_(
            "segment_groups",
            "SegmentGroup",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "segmentGroup",
                "type": "SegmentGroup",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        segments: "list of Segment(s) (required)" = None,
        segment_groups: "list of SegmentGroup(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Morphology"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        if segments is None:
            self.segments = []
        else:
            self.segments = segments
        self.segments_nsprefix_ = None
        if segment_groups is None:
            self.segment_groups = []
        else:
            self.segment_groups = segment_groups
        self.segment_groups_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Morphology)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Morphology.subclass:
            return Morphology.subclass(*args_, **kwargs_)
        else:
            return Morphology(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.segments
            or self.segment_groups
            or super(Morphology, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Morphology",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Morphology")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Morphology":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Morphology"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Morphology",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Morphology"
    ):
        super(Morphology, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Morphology"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Morphology",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Morphology, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for segment_ in self.segments:
            namespaceprefix_ = (
                self.segments_nsprefix_ + ":"
                if (UseCapturedNS_ and self.segments_nsprefix_)
                else ""
            )
            segment_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="segment",
                pretty_print=pretty_print,
            )
        for segmentGroup_ in self.segment_groups:
            namespaceprefix_ = (
                self.segment_groups_nsprefix_ + ":"
                if (UseCapturedNS_ and self.segment_groups_nsprefix_)
                else ""
            )
            segmentGroup_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="segmentGroup",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.segments, "segments", min_occurs=1, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.segment_groups, "segment_groups", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.segments:
                item.validate_(gds_collector, recursive=True)
            for item in self.segment_groups:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(Morphology, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "segment":
            obj_ = Segment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.segments.append(obj_)
            obj_.original_tagname_ = "segment"
        elif nodeName_ == "segmentGroup":
            obj_ = SegmentGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.segment_groups.append(obj_)
            obj_.original_tagname_ = "segmentGroup"
        super(Morphology, self)._buildChildren(child_, node, nodeName_, True)

    @property
    def num_segments(self):
        """Get the number of segments included in this cell morphology.

        :returns: number of segments
        :rtype: int
        """
        return len(self.segments)


# end class Morphology


class BaseCell(Standalone):
    """BaseCell -- Base type of any cell ( e. g. point neuron like  **izhikevich2007Cell** , or a morphologically detailed  **Cell**  with  **segment** s ) which can be used in a  **population**"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "neuro_lex_id",
            "NeuroLexId",
            0,
            1,
            {"use": "optional", "name": "neuro_lex_id"},
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BaseCell"), self).__init__(
            id, metaid, notes, properties, annotation, extensiontype_, **kwargs_
        )
        self.neuro_lex_id = _cast(None, neuro_lex_id)
        self.neuro_lex_id_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BaseCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseCell.subclass:
            return BaseCell.subclass(*args_, **kwargs_)
        else:
            return BaseCell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NeuroLexId(self, value):
        # Validate type NeuroLexId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NeuroLexId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NeuroLexId_patterns_,
                    )
                )

    validate_NeuroLexId_patterns_ = [["^([a-zA-Z0-9_:]*)$"]]

    def _hasContent(self):
        if super(BaseCell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseCell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BaseCell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BaseCell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="BaseCell"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BaseCell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="BaseCell"
    ):
        super(BaseCell, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="BaseCell"
        )
        if self.neuro_lex_id is not None and "neuro_lex_id" not in already_processed:
            already_processed.add("neuro_lex_id")
            outfile.write(
                " neuroLexId=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.neuro_lex_id), input_name="neuroLexId"
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseCell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BaseCell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NeuroLexId, self.neuro_lex_id, "neuro_lex_id"
        )
        self.gds_check_cardinality_(self.neuro_lex_id, "neuro_lex_id", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("neuroLexId", node)
        if value is not None and "neuroLexId" not in already_processed:
            already_processed.add("neuroLexId")
            self.neuro_lex_id = value
            self.validate_NeuroLexId(self.neuro_lex_id)  # validate type NeuroLexId
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(BaseCell, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BaseCell, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class BaseCell


class PlasticityMechanism(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "type", "PlasticityTypes", 0, 0, {"use": "required", "name": "type"}
        ),
        MemberSpec_(
            "init_release_prob",
            "ZeroToOne",
            0,
            0,
            {"use": "required", "name": "init_release_prob"},
        ),
        MemberSpec_(
            "tau_rec", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "tau_rec"}
        ),
        MemberSpec_(
            "tau_fac", "Nml2Quantity_time", 0, 1, {"use": "optional", "name": "tau_fac"}
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        type: "a PlasticityTypes (required)" = None,
        init_release_prob: "a ZeroToOne (required)" = None,
        tau_rec: "a Nml2Quantity_time (required)" = None,
        tau_fac: "a Nml2Quantity_time (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("PlasticityMechanism"), self).__init__(**kwargs_)
        self.type = _cast(None, type)
        self.type_nsprefix_ = None
        self.init_release_prob = _cast(float, init_release_prob)
        self.init_release_prob_nsprefix_ = None
        self.tau_rec = _cast(None, tau_rec)
        self.tau_rec_nsprefix_ = None
        self.tau_fac = _cast(None, tau_fac)
        self.tau_fac_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlasticityMechanism
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlasticityMechanism.subclass:
            return PlasticityMechanism.subclass(*args_, **kwargs_)
        else:
            return PlasticityMechanism(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_PlasticityTypes(self, value):
        # Validate type PlasticityTypes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "tsodyksMarkramDepMechanism",
                "tsodyksMarkramDepFacMechanism",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PlasticityTypes'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False

    def validate_ZeroToOne(self, value):
        # Validate type ZeroToOne, a restriction on xs:float.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ZeroToOne'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ZeroToOne'
                    % {"value": value, "lineno": lineno}
                )
                result = False

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(PlasticityMechanism, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="PlasticityMechanism",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("PlasticityMechanism")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "PlasticityMechanism":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="PlasticityMechanism",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="PlasticityMechanism",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="PlasticityMechanism",
    ):
        super(PlasticityMechanism, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="PlasticityMechanism",
        )
        if self.type is not None and "type" not in already_processed:
            already_processed.add("type")
            outfile.write(
                " type=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.type), input_name="type"
                        )
                    ),
                )
            )
        if (
            self.init_release_prob is not None
            and "init_release_prob" not in already_processed
        ):
            already_processed.add("init_release_prob")
            outfile.write(
                ' initReleaseProb="%s"'
                % self.gds_format_float(
                    self.init_release_prob, input_name="initReleaseProb"
                )
            )
        if self.tau_rec is not None and "tau_rec" not in already_processed:
            already_processed.add("tau_rec")
            outfile.write(
                " tauRec=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.tau_rec), input_name="tauRec"
                        )
                    ),
                )
            )
        if self.tau_fac is not None and "tau_fac" not in already_processed:
            already_processed.add("tau_fac")
            outfile.write(
                " tauFac=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.tau_fac), input_name="tauFac"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="PlasticityMechanism",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(PlasticityMechanism, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_PlasticityTypes, self.type, "type")
        self.gds_check_cardinality_(self.type, "type", required=True)
        self.gds_validate_defined_ST_(
            self.validate_ZeroToOne, self.init_release_prob, "init_release_prob"
        )
        self.gds_check_cardinality_(
            self.init_release_prob, "init_release_prob", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.tau_rec, "tau_rec"
        )
        self.gds_check_cardinality_(self.tau_rec, "tau_rec", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.tau_fac, "tau_fac"
        )
        self.gds_check_cardinality_(self.tau_fac, "tau_fac", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type = value
            self.validate_PlasticityTypes(self.type)  # validate type PlasticityTypes
        value = find_attr_value_("initReleaseProb", node)
        if value is not None and "initReleaseProb" not in already_processed:
            already_processed.add("initReleaseProb")
            value = self.gds_parse_float(value, node, "initReleaseProb")
            self.init_release_prob = value
            self.validate_ZeroToOne(self.init_release_prob)  # validate type ZeroToOne
        value = find_attr_value_("tauRec", node)
        if value is not None and "tauRec" not in already_processed:
            already_processed.add("tauRec")
            self.tau_rec = value
            self.validate_Nml2Quantity_time(
                self.tau_rec
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("tauFac", node)
        if value is not None and "tauFac" not in already_processed:
            already_processed.add("tauFac")
            self.tau_fac = value
            self.validate_Nml2Quantity_time(
                self.tau_fac
            )  # validate type Nml2Quantity_time
        super(PlasticityMechanism, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(PlasticityMechanism, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class PlasticityMechanism


class BlockMechanism(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("type", "BlockTypes", 0, 0, {"use": "required", "name": "type"}),
        MemberSpec_("species", "NmlId", 0, 0, {"use": "required", "name": "species"}),
        MemberSpec_(
            "block_concentration",
            "Nml2Quantity_concentration",
            0,
            0,
            {"use": "required", "name": "block_concentration"},
        ),
        MemberSpec_(
            "scaling_conc",
            "Nml2Quantity_concentration",
            0,
            0,
            {"use": "required", "name": "scaling_conc"},
        ),
        MemberSpec_(
            "scaling_volt",
            "Nml2Quantity_voltage",
            0,
            0,
            {"use": "required", "name": "scaling_volt"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        type: "a BlockTypes (required)" = None,
        species: "a NmlId (required)" = None,
        block_concentration: "a Nml2Quantity_concentration (required)" = None,
        scaling_conc: "a Nml2Quantity_concentration (required)" = None,
        scaling_volt: "a Nml2Quantity_voltage (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BlockMechanism"), self).__init__(**kwargs_)
        self.type = _cast(None, type)
        self.type_nsprefix_ = None
        self.species = _cast(None, species)
        self.species_nsprefix_ = None
        self.block_concentration = _cast(None, block_concentration)
        self.block_concentration_nsprefix_ = None
        self.scaling_conc = _cast(None, scaling_conc)
        self.scaling_conc_nsprefix_ = None
        self.scaling_volt = _cast(None, scaling_volt)
        self.scaling_volt_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BlockMechanism)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockMechanism.subclass:
            return BlockMechanism.subclass(*args_, **kwargs_)
        else:
            return BlockMechanism(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_BlockTypes(self, value):
        # Validate type BlockTypes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = ["voltageConcDepBlockMechanism"]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BlockTypes'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_concentration(self, value):
        # Validate type Nml2Quantity_concentration, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_concentration_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_concentration_patterns_,
                    )
                )

    validate_Nml2Quantity_concentration_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(mol_per_m3|mol_per_cm3|M|mM))$"]
    ]

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def _hasContent(self):
        if super(BlockMechanism, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BlockMechanism",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BlockMechanism")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BlockMechanism":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="BlockMechanism"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BlockMechanism",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BlockMechanism",
    ):
        super(BlockMechanism, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="BlockMechanism"
        )
        if self.type is not None and "type" not in already_processed:
            already_processed.add("type")
            outfile.write(
                " type=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.type), input_name="type"
                        )
                    ),
                )
            )
        if self.species is not None and "species" not in already_processed:
            already_processed.add("species")
            outfile.write(
                " species=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.species), input_name="species"
                        )
                    ),
                )
            )
        if (
            self.block_concentration is not None
            and "block_concentration" not in already_processed
        ):
            already_processed.add("block_concentration")
            outfile.write(
                " blockConcentration=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.block_concentration),
                            input_name="blockConcentration",
                        )
                    ),
                )
            )
        if self.scaling_conc is not None and "scaling_conc" not in already_processed:
            already_processed.add("scaling_conc")
            outfile.write(
                " scalingConc=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.scaling_conc), input_name="scalingConc"
                        )
                    ),
                )
            )
        if self.scaling_volt is not None and "scaling_volt" not in already_processed:
            already_processed.add("scaling_volt")
            outfile.write(
                " scalingVolt=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.scaling_volt), input_name="scalingVolt"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BlockMechanism",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BlockMechanism, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_BlockTypes, self.type, "type")
        self.gds_check_cardinality_(self.type, "type", required=True)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.species, "species")
        self.gds_check_cardinality_(self.species, "species", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_concentration,
            self.block_concentration,
            "block_concentration",
        )
        self.gds_check_cardinality_(
            self.block_concentration, "block_concentration", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_concentration, self.scaling_conc, "scaling_conc"
        )
        self.gds_check_cardinality_(self.scaling_conc, "scaling_conc", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.scaling_volt, "scaling_volt"
        )
        self.gds_check_cardinality_(self.scaling_volt, "scaling_volt", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type = value
            self.validate_BlockTypes(self.type)  # validate type BlockTypes
        value = find_attr_value_("species", node)
        if value is not None and "species" not in already_processed:
            already_processed.add("species")
            self.species = value
            self.validate_NmlId(self.species)  # validate type NmlId
        value = find_attr_value_("blockConcentration", node)
        if value is not None and "blockConcentration" not in already_processed:
            already_processed.add("blockConcentration")
            self.block_concentration = value
            self.validate_Nml2Quantity_concentration(
                self.block_concentration
            )  # validate type Nml2Quantity_concentration
        value = find_attr_value_("scalingConc", node)
        if value is not None and "scalingConc" not in already_processed:
            already_processed.add("scalingConc")
            self.scaling_conc = value
            self.validate_Nml2Quantity_concentration(
                self.scaling_conc
            )  # validate type Nml2Quantity_concentration
        value = find_attr_value_("scalingVolt", node)
        if value is not None and "scalingVolt" not in already_processed:
            already_processed.add("scalingVolt")
            self.scaling_volt = value
            self.validate_Nml2Quantity_voltage(
                self.scaling_volt
            )  # validate type Nml2Quantity_voltage
        super(BlockMechanism, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BlockMechanism, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class BlockMechanism


class BaseSynapse(Standalone):
    """BaseSynapse -- Base type for all synapses, i. e. ComponentTypes which produce a current ( dimension current ) and change Dynamics in response to an incoming event. cno_0000009"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "neuro_lex_id",
            "NeuroLexId",
            0,
            1,
            {"use": "optional", "name": "neuro_lex_id"},
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BaseSynapse"), self).__init__(
            id, metaid, notes, properties, annotation, extensiontype_, **kwargs_
        )
        self.neuro_lex_id = _cast(None, neuro_lex_id)
        self.neuro_lex_id_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BaseSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseSynapse.subclass:
            return BaseSynapse.subclass(*args_, **kwargs_)
        else:
            return BaseSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NeuroLexId(self, value):
        # Validate type NeuroLexId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NeuroLexId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NeuroLexId_patterns_,
                    )
                )

    validate_NeuroLexId_patterns_ = [["^([a-zA-Z0-9_:]*)$"]]

    def _hasContent(self):
        if super(BaseSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BaseSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BaseSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="BaseSynapse"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BaseSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BaseSynapse",
    ):
        super(BaseSynapse, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="BaseSynapse"
        )
        if self.neuro_lex_id is not None and "neuro_lex_id" not in already_processed:
            already_processed.add("neuro_lex_id")
            outfile.write(
                " neuroLexId=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.neuro_lex_id), input_name="neuroLexId"
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BaseSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NeuroLexId, self.neuro_lex_id, "neuro_lex_id"
        )
        self.gds_check_cardinality_(self.neuro_lex_id, "neuro_lex_id", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("neuroLexId", node)
        if value is not None and "neuroLexId" not in already_processed:
            already_processed.add("neuroLexId")
            self.neuro_lex_id = value
            self.validate_NeuroLexId(self.neuro_lex_id)  # validate type NeuroLexId
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(BaseSynapse, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BaseSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class BaseSynapse


class FixedFactorConcentrationModel(Standalone):
    """FixedFactorConcentrationModel -- Model of buffering of concentration of an ion ( currently hard coded to be calcium, due to requirement for **iCa**  ) which has a baseline level **restingConc**  and tends to this value with time course **decayConstant.**  A fixed factor **rho**  is used to scale the incoming current *independently of the size of the compartment* to produce a concentration change.
    \n
    :param restingConc:
    :type restingConc: concentration
    :param decayConstant:
    :type decayConstant: time
    :param rho:
    :type rho: rho_factor

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("ion", "NmlId", 0, 0, {"use": "required", "name": "ion"}),
        MemberSpec_(
            "resting_conc",
            "Nml2Quantity_concentration",
            0,
            0,
            {"use": "required", "name": "resting_conc"},
        ),
        MemberSpec_(
            "decay_constant",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "decay_constant"},
        ),
        MemberSpec_(
            "rho", "Nml2Quantity_rhoFactor", 0, 0, {"use": "required", "name": "rho"}
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        ion: "a NmlId (required)" = None,
        resting_conc: "a Nml2Quantity_concentration (required)" = None,
        decay_constant: "a Nml2Quantity_time (required)" = None,
        rho: "a Nml2Quantity_rhoFactor (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("FixedFactorConcentrationModel"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        self.resting_conc = _cast(None, resting_conc)
        self.resting_conc_nsprefix_ = None
        self.decay_constant = _cast(None, decay_constant)
        self.decay_constant_nsprefix_ = None
        self.rho = _cast(None, rho)
        self.rho_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FixedFactorConcentrationModel
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FixedFactorConcentrationModel.subclass:
            return FixedFactorConcentrationModel.subclass(*args_, **kwargs_)
        else:
            return FixedFactorConcentrationModel(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_concentration(self, value):
        # Validate type Nml2Quantity_concentration, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_concentration_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_concentration_patterns_,
                    )
                )

    validate_Nml2Quantity_concentration_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(mol_per_m3|mol_per_cm3|M|mM))$"]
    ]

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_rhoFactor(self, value):
        # Validate type Nml2Quantity_rhoFactor, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_rhoFactor_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_rhoFactor_patterns_,
                    )
                )

    validate_Nml2Quantity_rhoFactor_patterns_ = [
        [
            "^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(mol_per_m_per_A_per_s|mol_per_cm_per_uA_per_ms))$"
        ]
    ]

    def _hasContent(self):
        if super(FixedFactorConcentrationModel, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="FixedFactorConcentrationModel",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("FixedFactorConcentrationModel")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "FixedFactorConcentrationModel"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="FixedFactorConcentrationModel",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="FixedFactorConcentrationModel",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="FixedFactorConcentrationModel",
    ):
        super(FixedFactorConcentrationModel, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="FixedFactorConcentrationModel",
        )
        if self.ion is not None and "ion" not in already_processed:
            already_processed.add("ion")
            outfile.write(
                " ion=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.ion), input_name="ion")
                    ),
                )
            )
        if self.resting_conc is not None and "resting_conc" not in already_processed:
            already_processed.add("resting_conc")
            outfile.write(
                " restingConc=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.resting_conc), input_name="restingConc"
                        )
                    ),
                )
            )
        if (
            self.decay_constant is not None
            and "decay_constant" not in already_processed
        ):
            already_processed.add("decay_constant")
            outfile.write(
                " decayConstant=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.decay_constant),
                            input_name="decayConstant",
                        )
                    ),
                )
            )
        if self.rho is not None and "rho" not in already_processed:
            already_processed.add("rho")
            outfile.write(
                " rho=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.rho), input_name="rho")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="FixedFactorConcentrationModel",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(FixedFactorConcentrationModel, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.ion, "ion")
        self.gds_check_cardinality_(self.ion, "ion", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_concentration, self.resting_conc, "resting_conc"
        )
        self.gds_check_cardinality_(self.resting_conc, "resting_conc", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.decay_constant, "decay_constant"
        )
        self.gds_check_cardinality_(
            self.decay_constant, "decay_constant", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_rhoFactor, self.rho, "rho"
        )
        self.gds_check_cardinality_(self.rho, "rho", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("ion", node)
        if value is not None and "ion" not in already_processed:
            already_processed.add("ion")
            self.ion = value
            self.validate_NmlId(self.ion)  # validate type NmlId
        value = find_attr_value_("restingConc", node)
        if value is not None and "restingConc" not in already_processed:
            already_processed.add("restingConc")
            self.resting_conc = value
            self.validate_Nml2Quantity_concentration(
                self.resting_conc
            )  # validate type Nml2Quantity_concentration
        value = find_attr_value_("decayConstant", node)
        if value is not None and "decayConstant" not in already_processed:
            already_processed.add("decayConstant")
            self.decay_constant = value
            self.validate_Nml2Quantity_time(
                self.decay_constant
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("rho", node)
        if value is not None and "rho" not in already_processed:
            already_processed.add("rho")
            self.rho = value
            self.validate_Nml2Quantity_rhoFactor(
                self.rho
            )  # validate type Nml2Quantity_rhoFactor
        super(FixedFactorConcentrationModel, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(FixedFactorConcentrationModel, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class FixedFactorConcentrationModel


class DecayingPoolConcentrationModel(Standalone):
    """DecayingPoolConcentrationModel -- Model of an intracellular buffering mechanism for **ion**  ( currently hard Coded to be calcium, due to requirement for **iCa**  ) which has a baseline level **restingConc**  and tends to this value with time course **decayConstant.**  The ion is assumed to occupy a shell inside the membrane of thickness **shellThickness.**
    \n
    :param restingConc:
    :type restingConc: concentration
    :param decayConstant:
    :type decayConstant: time
    :param shellThickness:
    :type shellThickness: length

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("ion", "NmlId", 0, 0, {"use": "required", "name": "ion"}),
        MemberSpec_(
            "resting_conc",
            "Nml2Quantity_concentration",
            0,
            0,
            {"use": "required", "name": "resting_conc"},
        ),
        MemberSpec_(
            "decay_constant",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "decay_constant"},
        ),
        MemberSpec_(
            "shell_thickness",
            "Nml2Quantity_length",
            0,
            0,
            {"use": "required", "name": "shell_thickness"},
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        ion: "a NmlId (required)" = None,
        resting_conc: "a Nml2Quantity_concentration (required)" = None,
        decay_constant: "a Nml2Quantity_time (required)" = None,
        shell_thickness: "a Nml2Quantity_length (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("DecayingPoolConcentrationModel"), self).__init__(
            id, metaid, notes, properties, annotation, extensiontype_, **kwargs_
        )
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        self.resting_conc = _cast(None, resting_conc)
        self.resting_conc_nsprefix_ = None
        self.decay_constant = _cast(None, decay_constant)
        self.decay_constant_nsprefix_ = None
        self.shell_thickness = _cast(None, shell_thickness)
        self.shell_thickness_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DecayingPoolConcentrationModel
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DecayingPoolConcentrationModel.subclass:
            return DecayingPoolConcentrationModel.subclass(*args_, **kwargs_)
        else:
            return DecayingPoolConcentrationModel(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_concentration(self, value):
        # Validate type Nml2Quantity_concentration, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_concentration_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_concentration_patterns_,
                    )
                )

    validate_Nml2Quantity_concentration_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(mol_per_m3|mol_per_cm3|M|mM))$"]
    ]

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_length(self, value):
        # Validate type Nml2Quantity_length, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_length_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_length_patterns_,
                    )
                )

    validate_Nml2Quantity_length_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(m|cm|um))$"]
    ]

    def _hasContent(self):
        if super(DecayingPoolConcentrationModel, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DecayingPoolConcentrationModel",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "DecayingPoolConcentrationModel"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "DecayingPoolConcentrationModel"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="DecayingPoolConcentrationModel",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="DecayingPoolConcentrationModel",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="DecayingPoolConcentrationModel",
    ):
        super(DecayingPoolConcentrationModel, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="DecayingPoolConcentrationModel",
        )
        if self.ion is not None and "ion" not in already_processed:
            already_processed.add("ion")
            outfile.write(
                " ion=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.ion), input_name="ion")
                    ),
                )
            )
        if self.resting_conc is not None and "resting_conc" not in already_processed:
            already_processed.add("resting_conc")
            outfile.write(
                " restingConc=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.resting_conc), input_name="restingConc"
                        )
                    ),
                )
            )
        if (
            self.decay_constant is not None
            and "decay_constant" not in already_processed
        ):
            already_processed.add("decay_constant")
            outfile.write(
                " decayConstant=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.decay_constant),
                            input_name="decayConstant",
                        )
                    ),
                )
            )
        if (
            self.shell_thickness is not None
            and "shell_thickness" not in already_processed
        ):
            already_processed.add("shell_thickness")
            outfile.write(
                " shellThickness=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.shell_thickness),
                            input_name="shellThickness",
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DecayingPoolConcentrationModel",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(DecayingPoolConcentrationModel, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.ion, "ion")
        self.gds_check_cardinality_(self.ion, "ion", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_concentration, self.resting_conc, "resting_conc"
        )
        self.gds_check_cardinality_(self.resting_conc, "resting_conc", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.decay_constant, "decay_constant"
        )
        self.gds_check_cardinality_(
            self.decay_constant, "decay_constant", required=True
        )
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_length, self.shell_thickness, "shell_thickness"
        )
        self.gds_check_cardinality_(
            self.shell_thickness, "shell_thickness", required=True
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("ion", node)
        if value is not None and "ion" not in already_processed:
            already_processed.add("ion")
            self.ion = value
            self.validate_NmlId(self.ion)  # validate type NmlId
        value = find_attr_value_("restingConc", node)
        if value is not None and "restingConc" not in already_processed:
            already_processed.add("restingConc")
            self.resting_conc = value
            self.validate_Nml2Quantity_concentration(
                self.resting_conc
            )  # validate type Nml2Quantity_concentration
        value = find_attr_value_("decayConstant", node)
        if value is not None and "decayConstant" not in already_processed:
            already_processed.add("decayConstant")
            self.decay_constant = value
            self.validate_Nml2Quantity_time(
                self.decay_constant
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("shellThickness", node)
        if value is not None and "shellThickness" not in already_processed:
            already_processed.add("shellThickness")
            self.shell_thickness = value
            self.validate_Nml2Quantity_length(
                self.shell_thickness
            )  # validate type Nml2Quantity_length
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(DecayingPoolConcentrationModel, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(DecayingPoolConcentrationModel, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class DecayingPoolConcentrationModel


class HHTime(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("type", "NmlId", 0, 0, {"use": "required", "name": "type"}),
        MemberSpec_(
            "rate", "Nml2Quantity_time", 0, 1, {"use": "optional", "name": "rate"}
        ),
        MemberSpec_(
            "midpoint",
            "Nml2Quantity_voltage",
            0,
            1,
            {"use": "optional", "name": "midpoint"},
        ),
        MemberSpec_(
            "scale", "Nml2Quantity_voltage", 0, 1, {"use": "optional", "name": "scale"}
        ),
        MemberSpec_(
            "tau", "Nml2Quantity_time", 0, 1, {"use": "optional", "name": "tau"}
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        type: "a NmlId (required)" = None,
        rate: "a Nml2Quantity_time (optional)" = None,
        midpoint: "a Nml2Quantity_voltage (optional)" = None,
        scale: "a Nml2Quantity_voltage (optional)" = None,
        tau: "a Nml2Quantity_time (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("HHTime"), self).__init__(**kwargs_)
        self.type = _cast(None, type)
        self.type_nsprefix_ = None
        self.rate = _cast(None, rate)
        self.rate_nsprefix_ = None
        self.midpoint = _cast(None, midpoint)
        self.midpoint_nsprefix_ = None
        self.scale = _cast(None, scale)
        self.scale_nsprefix_ = None
        self.tau = _cast(None, tau)
        self.tau_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, HHTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HHTime.subclass:
            return HHTime.subclass(*args_, **kwargs_)
        else:
            return HHTime(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def _hasContent(self):
        if super(HHTime, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="HHTime",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("HHTime")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "HHTime":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="HHTime"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="HHTime",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="HHTime"
    ):
        super(HHTime, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="HHTime"
        )
        if self.type is not None and "type" not in already_processed:
            already_processed.add("type")
            outfile.write(
                " type=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.type), input_name="type"
                        )
                    ),
                )
            )
        if self.rate is not None and "rate" not in already_processed:
            already_processed.add("rate")
            outfile.write(
                " rate=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.rate), input_name="rate"
                        )
                    ),
                )
            )
        if self.midpoint is not None and "midpoint" not in already_processed:
            already_processed.add("midpoint")
            outfile.write(
                " midpoint=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.midpoint), input_name="midpoint"
                        )
                    ),
                )
            )
        if self.scale is not None and "scale" not in already_processed:
            already_processed.add("scale")
            outfile.write(
                " scale=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.scale), input_name="scale"
                        )
                    ),
                )
            )
        if self.tau is not None and "tau" not in already_processed:
            already_processed.add("tau")
            outfile.write(
                " tau=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.tau), input_name="tau")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="HHTime",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(HHTime, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.type, "type")
        self.gds_check_cardinality_(self.type, "type", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.rate, "rate"
        )
        self.gds_check_cardinality_(self.rate, "rate", required=False)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.midpoint, "midpoint"
        )
        self.gds_check_cardinality_(self.midpoint, "midpoint", required=False)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.scale, "scale"
        )
        self.gds_check_cardinality_(self.scale, "scale", required=False)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_time, self.tau, "tau")
        self.gds_check_cardinality_(self.tau, "tau", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type = value
            self.validate_NmlId(self.type)  # validate type NmlId
        value = find_attr_value_("rate", node)
        if value is not None and "rate" not in already_processed:
            already_processed.add("rate")
            self.rate = value
            self.validate_Nml2Quantity_time(
                self.rate
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("midpoint", node)
        if value is not None and "midpoint" not in already_processed:
            already_processed.add("midpoint")
            self.midpoint = value
            self.validate_Nml2Quantity_voltage(
                self.midpoint
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("scale", node)
        if value is not None and "scale" not in already_processed:
            already_processed.add("scale")
            self.scale = value
            self.validate_Nml2Quantity_voltage(
                self.scale
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("tau", node)
        if value is not None and "tau" not in already_processed:
            already_processed.add("tau")
            self.tau = value
            self.validate_Nml2Quantity_time(self.tau)  # validate type Nml2Quantity_time
        super(HHTime, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(HHTime, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class HHTime


class HHVariable(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("type", "NmlId", 0, 0, {"use": "required", "name": "type"}),
        MemberSpec_("rate", "xs:float", 0, 1, {"use": "optional", "name": "rate"}),
        MemberSpec_(
            "midpoint",
            "Nml2Quantity_voltage",
            0,
            1,
            {"use": "optional", "name": "midpoint"},
        ),
        MemberSpec_(
            "scale", "Nml2Quantity_voltage", 0, 1, {"use": "optional", "name": "scale"}
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        type: "a NmlId (required)" = None,
        rate: "a float (optional)" = None,
        midpoint: "a Nml2Quantity_voltage (optional)" = None,
        scale: "a Nml2Quantity_voltage (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("HHVariable"), self).__init__(**kwargs_)
        self.type = _cast(None, type)
        self.type_nsprefix_ = None
        self.rate = _cast(float, rate)
        self.rate_nsprefix_ = None
        self.midpoint = _cast(None, midpoint)
        self.midpoint_nsprefix_ = None
        self.scale = _cast(None, scale)
        self.scale_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, HHVariable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HHVariable.subclass:
            return HHVariable.subclass(*args_, **kwargs_)
        else:
            return HHVariable(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def _hasContent(self):
        if super(HHVariable, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="HHVariable",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("HHVariable")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "HHVariable":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="HHVariable"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="HHVariable",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="HHVariable"
    ):
        super(HHVariable, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="HHVariable"
        )
        if self.type is not None and "type" not in already_processed:
            already_processed.add("type")
            outfile.write(
                " type=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.type), input_name="type"
                        )
                    ),
                )
            )
        if self.rate is not None and "rate" not in already_processed:
            already_processed.add("rate")
            outfile.write(
                ' rate="%s"' % self.gds_format_float(self.rate, input_name="rate")
            )
        if self.midpoint is not None and "midpoint" not in already_processed:
            already_processed.add("midpoint")
            outfile.write(
                " midpoint=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.midpoint), input_name="midpoint"
                        )
                    ),
                )
            )
        if self.scale is not None and "scale" not in already_processed:
            already_processed.add("scale")
            outfile.write(
                " scale=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.scale), input_name="scale"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="HHVariable",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(HHVariable, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.type, "type")
        self.gds_check_cardinality_(self.type, "type", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.rate, "rate")
        self.gds_check_cardinality_(self.rate, "rate", required=False)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.midpoint, "midpoint"
        )
        self.gds_check_cardinality_(self.midpoint, "midpoint", required=False)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.scale, "scale"
        )
        self.gds_check_cardinality_(self.scale, "scale", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type = value
            self.validate_NmlId(self.type)  # validate type NmlId
        value = find_attr_value_("rate", node)
        if value is not None and "rate" not in already_processed:
            already_processed.add("rate")
            value = self.gds_parse_float(value, node, "rate")
            self.rate = value
        value = find_attr_value_("midpoint", node)
        if value is not None and "midpoint" not in already_processed:
            already_processed.add("midpoint")
            self.midpoint = value
            self.validate_Nml2Quantity_voltage(
                self.midpoint
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("scale", node)
        if value is not None and "scale" not in already_processed:
            already_processed.add("scale")
            self.scale = value
            self.validate_Nml2Quantity_voltage(
                self.scale
            )  # validate type Nml2Quantity_voltage
        super(HHVariable, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(HHVariable, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class HHVariable


class HHRate(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("type", "NmlId", 0, 0, {"use": "required", "name": "type"}),
        MemberSpec_(
            "rate", "Nml2Quantity_pertime", 0, 1, {"use": "optional", "name": "rate"}
        ),
        MemberSpec_(
            "midpoint",
            "Nml2Quantity_voltage",
            0,
            1,
            {"use": "optional", "name": "midpoint"},
        ),
        MemberSpec_(
            "scale", "Nml2Quantity_voltage", 0, 1, {"use": "optional", "name": "scale"}
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        type: "a NmlId (required)" = None,
        rate: "a Nml2Quantity_pertime (optional)" = None,
        midpoint: "a Nml2Quantity_voltage (optional)" = None,
        scale: "a Nml2Quantity_voltage (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("HHRate"), self).__init__(**kwargs_)
        self.type = _cast(None, type)
        self.type_nsprefix_ = None
        self.rate = _cast(None, rate)
        self.rate_nsprefix_ = None
        self.midpoint = _cast(None, midpoint)
        self.midpoint_nsprefix_ = None
        self.scale = _cast(None, scale)
        self.scale_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, HHRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HHRate.subclass:
            return HHRate.subclass(*args_, **kwargs_)
        else:
            return HHRate(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_pertime_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_pertime_patterns_,
                    )
                )

    validate_Nml2Quantity_pertime_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$"]
    ]

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def _hasContent(self):
        if super(HHRate, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="HHRate",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("HHRate")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "HHRate":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="HHRate"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="HHRate",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="HHRate"
    ):
        super(HHRate, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="HHRate"
        )
        if self.type is not None and "type" not in already_processed:
            already_processed.add("type")
            outfile.write(
                " type=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.type), input_name="type"
                        )
                    ),
                )
            )
        if self.rate is not None and "rate" not in already_processed:
            already_processed.add("rate")
            outfile.write(
                " rate=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.rate), input_name="rate"
                        )
                    ),
                )
            )
        if self.midpoint is not None and "midpoint" not in already_processed:
            already_processed.add("midpoint")
            outfile.write(
                " midpoint=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.midpoint), input_name="midpoint"
                        )
                    ),
                )
            )
        if self.scale is not None and "scale" not in already_processed:
            already_processed.add("scale")
            outfile.write(
                " scale=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.scale), input_name="scale"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="HHRate",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(HHRate, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.type, "type")
        self.gds_check_cardinality_(self.type, "type", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_pertime, self.rate, "rate"
        )
        self.gds_check_cardinality_(self.rate, "rate", required=False)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.midpoint, "midpoint"
        )
        self.gds_check_cardinality_(self.midpoint, "midpoint", required=False)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.scale, "scale"
        )
        self.gds_check_cardinality_(self.scale, "scale", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type = value
            self.validate_NmlId(self.type)  # validate type NmlId
        value = find_attr_value_("rate", node)
        if value is not None and "rate" not in already_processed:
            already_processed.add("rate")
            self.rate = value
            self.validate_Nml2Quantity_pertime(
                self.rate
            )  # validate type Nml2Quantity_pertime
        value = find_attr_value_("midpoint", node)
        if value is not None and "midpoint" not in already_processed:
            already_processed.add("midpoint")
            self.midpoint = value
            self.validate_Nml2Quantity_voltage(
                self.midpoint
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("scale", node)
        if value is not None and "scale" not in already_processed:
            already_processed.add("scale")
            self.scale = value
            self.validate_Nml2Quantity_voltage(
                self.scale
            )  # validate type Nml2Quantity_voltage
        super(HHRate, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(HHRate, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class HHRate


class GateFractionalSubgate(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "fractional_conductance",
            "Nml2Quantity_none",
            0,
            0,
            {"use": "required", "name": "fractional_conductance"},
        ),
        MemberSpec_(
            "notes",
            ["Notes", "xs:string"],
            0,
            1,
            {"minOccurs": "0", "name": "notes", "type": "xs:string"},
            None,
        ),
        MemberSpec_(
            "q10_settings",
            "Q10Settings",
            0,
            1,
            {"minOccurs": "0", "name": "q10Settings", "type": "Q10Settings"},
            None,
        ),
        MemberSpec_(
            "steady_state",
            "HHVariable",
            0,
            0,
            {"minOccurs": "1", "name": "steadyState", "type": "HHVariable"},
            None,
        ),
        MemberSpec_(
            "time_course",
            "HHTime",
            0,
            0,
            {"minOccurs": "1", "name": "timeCourse", "type": "HHTime"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        fractional_conductance: "a Nml2Quantity_none (required)" = None,
        notes: "a string (optional)" = None,
        q10_settings: "a Q10Settings (optional)" = None,
        steady_state: "a HHVariable (required)" = None,
        time_course: "a HHTime (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("GateFractionalSubgate"), self).__init__(id, **kwargs_)
        self.fractional_conductance = _cast(None, fractional_conductance)
        self.fractional_conductance_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10_settings = q10_settings
        self.q10_settings_nsprefix_ = None
        self.steady_state = steady_state
        self.steady_state_nsprefix_ = None
        self.time_course = time_course
        self.time_course_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GateFractionalSubgate
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateFractionalSubgate.subclass:
            return GateFractionalSubgate.subclass(*args_, **kwargs_)
        else:
            return GateFractionalSubgate(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_none_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_none_patterns_,
                    )
                )

    validate_Nml2Quantity_none_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$"]
    ]

    def _hasContent(self):
        if (
            self.notes is not None
            or self.q10_settings is not None
            or self.steady_state is not None
            or self.time_course is not None
            or super(GateFractionalSubgate, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateFractionalSubgate",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GateFractionalSubgate")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GateFractionalSubgate":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GateFractionalSubgate",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GateFractionalSubgate",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GateFractionalSubgate",
    ):
        super(GateFractionalSubgate, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GateFractionalSubgate",
        )
        if (
            self.fractional_conductance is not None
            and "fractional_conductance" not in already_processed
        ):
            already_processed.add("fractional_conductance")
            outfile.write(
                " fractionalConductance=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.fractional_conductance),
                            input_name="fractionalConductance",
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateFractionalSubgate",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(GateFractionalSubgate, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.notes is not None:
            namespaceprefix_ = (
                self.notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%snotes>%s</%snotes>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.notes), input_name="notes"
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.q10_settings is not None:
            namespaceprefix_ = (
                self.q10_settings_nsprefix_ + ":"
                if (UseCapturedNS_ and self.q10_settings_nsprefix_)
                else ""
            )
            self.q10_settings.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="q10Settings",
                pretty_print=pretty_print,
            )
        if self.steady_state is not None:
            namespaceprefix_ = (
                self.steady_state_nsprefix_ + ":"
                if (UseCapturedNS_ and self.steady_state_nsprefix_)
                else ""
            )
            self.steady_state.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="steadyState",
                pretty_print=pretty_print,
            )
        if self.time_course is not None:
            namespaceprefix_ = (
                self.time_course_nsprefix_ + ":"
                if (UseCapturedNS_ and self.time_course_nsprefix_)
                else ""
            )
            self.time_course.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="timeCourse",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_none,
            self.fractional_conductance,
            "fractional_conductance",
        )
        self.gds_check_cardinality_(
            self.fractional_conductance, "fractional_conductance", required=True
        )
        # validate simple type children
        self.gds_validate_defined_ST_(self.validate_Notes, self.notes, "notes")
        self.gds_check_cardinality_(self.notes, "notes", min_occurs=0, max_occurs=1)
        # validate complex type children
        self.gds_check_cardinality_(
            self.q10_settings, "q10_settings", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.steady_state, "steady_state", min_occurs=1, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.time_course, "time_course", min_occurs=1, max_occurs=1
        )
        if recursive:
            if self.q10_settings is not None:
                self.q10_settings.validate_(gds_collector, recursive=True)
            if self.steady_state is not None:
                self.steady_state.validate_(gds_collector, recursive=True)
            if self.time_course is not None:
                self.time_course.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("fractionalConductance", node)
        if value is not None and "fractionalConductance" not in already_processed:
            already_processed.add("fractionalConductance")
            self.fractional_conductance = value
            self.validate_Nml2Quantity_none(
                self.fractional_conductance
            )  # validate type Nml2Quantity_none
        super(GateFractionalSubgate, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "notes":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "notes")
            value_ = self.gds_validate_string(value_, node, "notes")
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == "q10Settings":
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10_settings = obj_
            obj_.original_tagname_ = "q10Settings"
        elif nodeName_ == "steadyState":
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steady_state = obj_
            obj_.original_tagname_ = "steadyState"
        elif nodeName_ == "timeCourse":
            obj_ = HHTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_course = obj_
            obj_.original_tagname_ = "timeCourse"
        super(GateFractionalSubgate, self)._buildChildren(child_, node, nodeName_, True)


# end class GateFractionalSubgate


class GateFractional(Base):
    """GateFractional -- Gate composed of subgates contributing with fractional conductance
    \n
    :param instances:
    :type instances: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "instances",
            "PositiveInteger",
            0,
            0,
            {"use": "required", "name": "instances"},
        ),
        MemberSpec_(
            "notes",
            ["Notes", "xs:string"],
            0,
            1,
            {"minOccurs": "0", "name": "notes", "type": "xs:string"},
            None,
        ),
        MemberSpec_(
            "q10_settings",
            "Q10Settings",
            0,
            1,
            {"minOccurs": "0", "name": "q10Settings", "type": "Q10Settings"},
            None,
        ),
        MemberSpec_(
            "sub_gates",
            "GateFractionalSubgate",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "1",
                "name": "subGate",
                "type": "GateFractionalSubgate",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        instances: "a PositiveInteger (required)" = None,
        notes: "a string (optional)" = None,
        q10_settings: "a Q10Settings (optional)" = None,
        sub_gates: "list of GateFractionalSubgate(s) (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("GateFractional"), self).__init__(id, **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10_settings = q10_settings
        self.q10_settings_nsprefix_ = None
        if sub_gates is None:
            self.sub_gates = []
        else:
            self.sub_gates = sub_gates
        self.sub_gates_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GateFractional)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateFractional.subclass:
            return GateFractional.subclass(*args_, **kwargs_)
        else:
            return GateFractional(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def _hasContent(self):
        if (
            self.notes is not None
            or self.q10_settings is not None
            or self.sub_gates
            or super(GateFractional, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateFractional",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GateFractional")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GateFractional":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GateFractional"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GateFractional",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GateFractional",
    ):
        super(GateFractional, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GateFractional"
        )
        if self.instances is not None and "instances" not in already_processed:
            already_processed.add("instances")
            outfile.write(
                ' instances="%s"'
                % self.gds_format_integer(self.instances, input_name="instances")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateFractional",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(GateFractional, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.notes is not None:
            namespaceprefix_ = (
                self.notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%snotes>%s</%snotes>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.notes), input_name="notes"
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.q10_settings is not None:
            namespaceprefix_ = (
                self.q10_settings_nsprefix_ + ":"
                if (UseCapturedNS_ and self.q10_settings_nsprefix_)
                else ""
            )
            self.q10_settings.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="q10Settings",
                pretty_print=pretty_print,
            )
        for subGate_ in self.sub_gates:
            namespaceprefix_ = (
                self.sub_gates_nsprefix_ + ":"
                if (UseCapturedNS_ and self.sub_gates_nsprefix_)
                else ""
            )
            subGate_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="subGate",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_PositiveInteger, self.instances, "instances"
        )
        self.gds_check_cardinality_(self.instances, "instances", required=True)
        # validate simple type children
        self.gds_validate_defined_ST_(self.validate_Notes, self.notes, "notes")
        self.gds_check_cardinality_(self.notes, "notes", min_occurs=0, max_occurs=1)
        # validate complex type children
        self.gds_check_cardinality_(
            self.q10_settings, "q10_settings", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.sub_gates, "sub_gates", min_occurs=1, max_occurs=9999999
        )
        if recursive:
            if self.q10_settings is not None:
                self.q10_settings.validate_(gds_collector, recursive=True)
            for item in self.sub_gates:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("instances", node)
        if value is not None and "instances" not in already_processed:
            already_processed.add("instances")
            self.instances = self.gds_parse_integer(value, node, "instances")
            if self.instances <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")
            self.validate_PositiveInteger(
                self.instances
            )  # validate type PositiveInteger
        super(GateFractional, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "notes":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "notes")
            value_ = self.gds_validate_string(value_, node, "notes")
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == "q10Settings":
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10_settings = obj_
            obj_.original_tagname_ = "q10Settings"
        elif nodeName_ == "subGate":
            obj_ = GateFractionalSubgate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sub_gates.append(obj_)
            obj_.original_tagname_ = "subGate"
        super(GateFractional, self)._buildChildren(child_, node, nodeName_, True)


# end class GateFractional


class GateHHInstantaneous(Base):
    """GateHHInstantaneous -- Gate which follows the general Hodgkin Huxley formalism but is instantaneous, so tau = 0 and gate follows exactly inf value
    \n
    :param instances:
    :type instances: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "instances",
            "PositiveInteger",
            0,
            0,
            {"use": "required", "name": "instances"},
        ),
        MemberSpec_(
            "notes",
            ["Notes", "xs:string"],
            0,
            1,
            {"minOccurs": "0", "name": "notes", "type": "xs:string"},
            None,
        ),
        MemberSpec_(
            "steady_state",
            "HHVariable",
            0,
            0,
            {"minOccurs": "1", "name": "steadyState", "type": "HHVariable"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        instances: "a PositiveInteger (required)" = None,
        notes: "a string (optional)" = None,
        steady_state: "a HHVariable (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("GateHHInstantaneous"), self).__init__(id, **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.steady_state = steady_state
        self.steady_state_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GateHHInstantaneous
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHInstantaneous.subclass:
            return GateHHInstantaneous.subclass(*args_, **kwargs_)
        else:
            return GateHHInstantaneous(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def _hasContent(self):
        if (
            self.notes is not None
            or self.steady_state is not None
            or super(GateHHInstantaneous, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHInstantaneous",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GateHHInstantaneous")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GateHHInstantaneous":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GateHHInstantaneous",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GateHHInstantaneous",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GateHHInstantaneous",
    ):
        super(GateHHInstantaneous, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GateHHInstantaneous",
        )
        if self.instances is not None and "instances" not in already_processed:
            already_processed.add("instances")
            outfile.write(
                ' instances="%s"'
                % self.gds_format_integer(self.instances, input_name="instances")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHInstantaneous",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(GateHHInstantaneous, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.notes is not None:
            namespaceprefix_ = (
                self.notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%snotes>%s</%snotes>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.notes), input_name="notes"
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.steady_state is not None:
            namespaceprefix_ = (
                self.steady_state_nsprefix_ + ":"
                if (UseCapturedNS_ and self.steady_state_nsprefix_)
                else ""
            )
            self.steady_state.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="steadyState",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_PositiveInteger, self.instances, "instances"
        )
        self.gds_check_cardinality_(self.instances, "instances", required=True)
        # validate simple type children
        self.gds_validate_defined_ST_(self.validate_Notes, self.notes, "notes")
        self.gds_check_cardinality_(self.notes, "notes", min_occurs=0, max_occurs=1)
        # validate complex type children
        self.gds_check_cardinality_(
            self.steady_state, "steady_state", min_occurs=1, max_occurs=1
        )
        if recursive:
            if self.steady_state is not None:
                self.steady_state.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("instances", node)
        if value is not None and "instances" not in already_processed:
            already_processed.add("instances")
            self.instances = self.gds_parse_integer(value, node, "instances")
            if self.instances <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")
            self.validate_PositiveInteger(
                self.instances
            )  # validate type PositiveInteger
        super(GateHHInstantaneous, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "notes":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "notes")
            value_ = self.gds_validate_string(value_, node, "notes")
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == "steadyState":
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steady_state = obj_
            obj_.original_tagname_ = "steadyState"
        super(GateHHInstantaneous, self)._buildChildren(child_, node, nodeName_, True)


# end class GateHHInstantaneous


class GateHHRatesInf(Base):
    """GateHHRatesInf -- Gate which follows the general Hodgkin Huxley formalism
    \n
    :param instances:
    :type instances: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "instances",
            "PositiveInteger",
            0,
            0,
            {"use": "required", "name": "instances"},
        ),
        MemberSpec_(
            "notes",
            ["Notes", "xs:string"],
            0,
            1,
            {"minOccurs": "0", "name": "notes", "type": "xs:string"},
            None,
        ),
        MemberSpec_(
            "q10_settings",
            "Q10Settings",
            0,
            1,
            {"minOccurs": "0", "name": "q10Settings", "type": "Q10Settings"},
            None,
        ),
        MemberSpec_(
            "forward_rate",
            "HHRate",
            0,
            0,
            {"minOccurs": "1", "name": "forwardRate", "type": "HHRate"},
            None,
        ),
        MemberSpec_(
            "reverse_rate",
            "HHRate",
            0,
            0,
            {"minOccurs": "1", "name": "reverseRate", "type": "HHRate"},
            None,
        ),
        MemberSpec_(
            "steady_state",
            "HHVariable",
            0,
            0,
            {"minOccurs": "1", "name": "steadyState", "type": "HHVariable"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        instances: "a PositiveInteger (required)" = None,
        notes: "a string (optional)" = None,
        q10_settings: "a Q10Settings (optional)" = None,
        forward_rate: "a HHRate (required)" = None,
        reverse_rate: "a HHRate (required)" = None,
        steady_state: "a HHVariable (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("GateHHRatesInf"), self).__init__(id, **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10_settings = q10_settings
        self.q10_settings_nsprefix_ = None
        self.forward_rate = forward_rate
        self.forward_rate_nsprefix_ = None
        self.reverse_rate = reverse_rate
        self.reverse_rate_nsprefix_ = None
        self.steady_state = steady_state
        self.steady_state_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GateHHRatesInf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHRatesInf.subclass:
            return GateHHRatesInf.subclass(*args_, **kwargs_)
        else:
            return GateHHRatesInf(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def _hasContent(self):
        if (
            self.notes is not None
            or self.q10_settings is not None
            or self.forward_rate is not None
            or self.reverse_rate is not None
            or self.steady_state is not None
            or super(GateHHRatesInf, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHRatesInf",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GateHHRatesInf")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GateHHRatesInf":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GateHHRatesInf"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GateHHRatesInf",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GateHHRatesInf",
    ):
        super(GateHHRatesInf, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GateHHRatesInf"
        )
        if self.instances is not None and "instances" not in already_processed:
            already_processed.add("instances")
            outfile.write(
                ' instances="%s"'
                % self.gds_format_integer(self.instances, input_name="instances")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHRatesInf",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(GateHHRatesInf, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.notes is not None:
            namespaceprefix_ = (
                self.notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%snotes>%s</%snotes>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.notes), input_name="notes"
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.q10_settings is not None:
            namespaceprefix_ = (
                self.q10_settings_nsprefix_ + ":"
                if (UseCapturedNS_ and self.q10_settings_nsprefix_)
                else ""
            )
            self.q10_settings.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="q10Settings",
                pretty_print=pretty_print,
            )
        if self.forward_rate is not None:
            namespaceprefix_ = (
                self.forward_rate_nsprefix_ + ":"
                if (UseCapturedNS_ and self.forward_rate_nsprefix_)
                else ""
            )
            self.forward_rate.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="forwardRate",
                pretty_print=pretty_print,
            )
        if self.reverse_rate is not None:
            namespaceprefix_ = (
                self.reverse_rate_nsprefix_ + ":"
                if (UseCapturedNS_ and self.reverse_rate_nsprefix_)
                else ""
            )
            self.reverse_rate.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="reverseRate",
                pretty_print=pretty_print,
            )
        if self.steady_state is not None:
            namespaceprefix_ = (
                self.steady_state_nsprefix_ + ":"
                if (UseCapturedNS_ and self.steady_state_nsprefix_)
                else ""
            )
            self.steady_state.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="steadyState",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_PositiveInteger, self.instances, "instances"
        )
        self.gds_check_cardinality_(self.instances, "instances", required=True)
        # validate simple type children
        self.gds_validate_defined_ST_(self.validate_Notes, self.notes, "notes")
        self.gds_check_cardinality_(self.notes, "notes", min_occurs=0, max_occurs=1)
        # validate complex type children
        self.gds_check_cardinality_(
            self.q10_settings, "q10_settings", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.forward_rate, "forward_rate", min_occurs=1, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.reverse_rate, "reverse_rate", min_occurs=1, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.steady_state, "steady_state", min_occurs=1, max_occurs=1
        )
        if recursive:
            if self.q10_settings is not None:
                self.q10_settings.validate_(gds_collector, recursive=True)
            if self.forward_rate is not None:
                self.forward_rate.validate_(gds_collector, recursive=True)
            if self.reverse_rate is not None:
                self.reverse_rate.validate_(gds_collector, recursive=True)
            if self.steady_state is not None:
                self.steady_state.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("instances", node)
        if value is not None and "instances" not in already_processed:
            already_processed.add("instances")
            self.instances = self.gds_parse_integer(value, node, "instances")
            if self.instances <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")
            self.validate_PositiveInteger(
                self.instances
            )  # validate type PositiveInteger
        super(GateHHRatesInf, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "notes":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "notes")
            value_ = self.gds_validate_string(value_, node, "notes")
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == "q10Settings":
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10_settings = obj_
            obj_.original_tagname_ = "q10Settings"
        elif nodeName_ == "forwardRate":
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forward_rate = obj_
            obj_.original_tagname_ = "forwardRate"
        elif nodeName_ == "reverseRate":
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reverse_rate = obj_
            obj_.original_tagname_ = "reverseRate"
        elif nodeName_ == "steadyState":
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steady_state = obj_
            obj_.original_tagname_ = "steadyState"
        super(GateHHRatesInf, self)._buildChildren(child_, node, nodeName_, True)


# end class GateHHRatesInf


class GateHHRatesTau(Base):
    """GateHHRatesTau -- Gate which follows the general Hodgkin Huxley formalism
    \n
    :param instances:
    :type instances: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "instances",
            "PositiveInteger",
            0,
            0,
            {"use": "required", "name": "instances"},
        ),
        MemberSpec_(
            "notes",
            ["Notes", "xs:string"],
            0,
            1,
            {"minOccurs": "0", "name": "notes", "type": "xs:string"},
            None,
        ),
        MemberSpec_(
            "q10_settings",
            "Q10Settings",
            0,
            1,
            {"minOccurs": "0", "name": "q10Settings", "type": "Q10Settings"},
            None,
        ),
        MemberSpec_(
            "forward_rate",
            "HHRate",
            0,
            0,
            {"minOccurs": "1", "name": "forwardRate", "type": "HHRate"},
            None,
        ),
        MemberSpec_(
            "reverse_rate",
            "HHRate",
            0,
            0,
            {"minOccurs": "1", "name": "reverseRate", "type": "HHRate"},
            None,
        ),
        MemberSpec_(
            "time_course",
            "HHTime",
            0,
            0,
            {"minOccurs": "1", "name": "timeCourse", "type": "HHTime"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        instances: "a PositiveInteger (required)" = None,
        notes: "a string (optional)" = None,
        q10_settings: "a Q10Settings (optional)" = None,
        forward_rate: "a HHRate (required)" = None,
        reverse_rate: "a HHRate (required)" = None,
        time_course: "a HHTime (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("GateHHRatesTau"), self).__init__(id, **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10_settings = q10_settings
        self.q10_settings_nsprefix_ = None
        self.forward_rate = forward_rate
        self.forward_rate_nsprefix_ = None
        self.reverse_rate = reverse_rate
        self.reverse_rate_nsprefix_ = None
        self.time_course = time_course
        self.time_course_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GateHHRatesTau)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHRatesTau.subclass:
            return GateHHRatesTau.subclass(*args_, **kwargs_)
        else:
            return GateHHRatesTau(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def _hasContent(self):
        if (
            self.notes is not None
            or self.q10_settings is not None
            or self.forward_rate is not None
            or self.reverse_rate is not None
            or self.time_course is not None
            or super(GateHHRatesTau, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHRatesTau",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GateHHRatesTau")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GateHHRatesTau":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GateHHRatesTau"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GateHHRatesTau",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GateHHRatesTau",
    ):
        super(GateHHRatesTau, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GateHHRatesTau"
        )
        if self.instances is not None and "instances" not in already_processed:
            already_processed.add("instances")
            outfile.write(
                ' instances="%s"'
                % self.gds_format_integer(self.instances, input_name="instances")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHRatesTau",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(GateHHRatesTau, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.notes is not None:
            namespaceprefix_ = (
                self.notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%snotes>%s</%snotes>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.notes), input_name="notes"
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.q10_settings is not None:
            namespaceprefix_ = (
                self.q10_settings_nsprefix_ + ":"
                if (UseCapturedNS_ and self.q10_settings_nsprefix_)
                else ""
            )
            self.q10_settings.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="q10Settings",
                pretty_print=pretty_print,
            )
        if self.forward_rate is not None:
            namespaceprefix_ = (
                self.forward_rate_nsprefix_ + ":"
                if (UseCapturedNS_ and self.forward_rate_nsprefix_)
                else ""
            )
            self.forward_rate.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="forwardRate",
                pretty_print=pretty_print,
            )
        if self.reverse_rate is not None:
            namespaceprefix_ = (
                self.reverse_rate_nsprefix_ + ":"
                if (UseCapturedNS_ and self.reverse_rate_nsprefix_)
                else ""
            )
            self.reverse_rate.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="reverseRate",
                pretty_print=pretty_print,
            )
        if self.time_course is not None:
            namespaceprefix_ = (
                self.time_course_nsprefix_ + ":"
                if (UseCapturedNS_ and self.time_course_nsprefix_)
                else ""
            )
            self.time_course.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="timeCourse",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_PositiveInteger, self.instances, "instances"
        )
        self.gds_check_cardinality_(self.instances, "instances", required=True)
        # validate simple type children
        self.gds_validate_defined_ST_(self.validate_Notes, self.notes, "notes")
        self.gds_check_cardinality_(self.notes, "notes", min_occurs=0, max_occurs=1)
        # validate complex type children
        self.gds_check_cardinality_(
            self.q10_settings, "q10_settings", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.forward_rate, "forward_rate", min_occurs=1, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.reverse_rate, "reverse_rate", min_occurs=1, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.time_course, "time_course", min_occurs=1, max_occurs=1
        )
        if recursive:
            if self.q10_settings is not None:
                self.q10_settings.validate_(gds_collector, recursive=True)
            if self.forward_rate is not None:
                self.forward_rate.validate_(gds_collector, recursive=True)
            if self.reverse_rate is not None:
                self.reverse_rate.validate_(gds_collector, recursive=True)
            if self.time_course is not None:
                self.time_course.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("instances", node)
        if value is not None and "instances" not in already_processed:
            already_processed.add("instances")
            self.instances = self.gds_parse_integer(value, node, "instances")
            if self.instances <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")
            self.validate_PositiveInteger(
                self.instances
            )  # validate type PositiveInteger
        super(GateHHRatesTau, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "notes":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "notes")
            value_ = self.gds_validate_string(value_, node, "notes")
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == "q10Settings":
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10_settings = obj_
            obj_.original_tagname_ = "q10Settings"
        elif nodeName_ == "forwardRate":
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forward_rate = obj_
            obj_.original_tagname_ = "forwardRate"
        elif nodeName_ == "reverseRate":
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reverse_rate = obj_
            obj_.original_tagname_ = "reverseRate"
        elif nodeName_ == "timeCourse":
            obj_ = HHTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_course = obj_
            obj_.original_tagname_ = "timeCourse"
        super(GateHHRatesTau, self)._buildChildren(child_, node, nodeName_, True)


# end class GateHHRatesTau


class GateHHRatesTauInf(Base):
    """GateHHRatesTauInf -- Gate which follows the general Hodgkin Huxley formalism
    \n
    :param instances:
    :type instances: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "instances",
            "PositiveInteger",
            0,
            0,
            {"use": "required", "name": "instances"},
        ),
        MemberSpec_(
            "notes",
            ["Notes", "xs:string"],
            0,
            1,
            {"minOccurs": "0", "name": "notes", "type": "xs:string"},
            None,
        ),
        MemberSpec_(
            "q10_settings",
            "Q10Settings",
            0,
            1,
            {"minOccurs": "0", "name": "q10Settings", "type": "Q10Settings"},
            None,
        ),
        MemberSpec_(
            "forward_rate",
            "HHRate",
            0,
            0,
            {"minOccurs": "1", "name": "forwardRate", "type": "HHRate"},
            None,
        ),
        MemberSpec_(
            "reverse_rate",
            "HHRate",
            0,
            0,
            {"minOccurs": "1", "name": "reverseRate", "type": "HHRate"},
            None,
        ),
        MemberSpec_(
            "time_course",
            "HHTime",
            0,
            0,
            {"minOccurs": "1", "name": "timeCourse", "type": "HHTime"},
            None,
        ),
        MemberSpec_(
            "steady_state",
            "HHVariable",
            0,
            0,
            {"minOccurs": "1", "name": "steadyState", "type": "HHVariable"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        instances: "a PositiveInteger (required)" = None,
        notes: "a string (optional)" = None,
        q10_settings: "a Q10Settings (optional)" = None,
        forward_rate: "a HHRate (required)" = None,
        reverse_rate: "a HHRate (required)" = None,
        time_course: "a HHTime (required)" = None,
        steady_state: "a HHVariable (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("GateHHRatesTauInf"), self).__init__(id, **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10_settings = q10_settings
        self.q10_settings_nsprefix_ = None
        self.forward_rate = forward_rate
        self.forward_rate_nsprefix_ = None
        self.reverse_rate = reverse_rate
        self.reverse_rate_nsprefix_ = None
        self.time_course = time_course
        self.time_course_nsprefix_ = None
        self.steady_state = steady_state
        self.steady_state_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GateHHRatesTauInf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHRatesTauInf.subclass:
            return GateHHRatesTauInf.subclass(*args_, **kwargs_)
        else:
            return GateHHRatesTauInf(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def _hasContent(self):
        if (
            self.notes is not None
            or self.q10_settings is not None
            or self.forward_rate is not None
            or self.reverse_rate is not None
            or self.time_course is not None
            or self.steady_state is not None
            or super(GateHHRatesTauInf, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHRatesTauInf",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GateHHRatesTauInf")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GateHHRatesTauInf":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GateHHRatesTauInf",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GateHHRatesTauInf",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GateHHRatesTauInf",
    ):
        super(GateHHRatesTauInf, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GateHHRatesTauInf",
        )
        if self.instances is not None and "instances" not in already_processed:
            already_processed.add("instances")
            outfile.write(
                ' instances="%s"'
                % self.gds_format_integer(self.instances, input_name="instances")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHRatesTauInf",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(GateHHRatesTauInf, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.notes is not None:
            namespaceprefix_ = (
                self.notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%snotes>%s</%snotes>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.notes), input_name="notes"
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.q10_settings is not None:
            namespaceprefix_ = (
                self.q10_settings_nsprefix_ + ":"
                if (UseCapturedNS_ and self.q10_settings_nsprefix_)
                else ""
            )
            self.q10_settings.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="q10Settings",
                pretty_print=pretty_print,
            )
        if self.forward_rate is not None:
            namespaceprefix_ = (
                self.forward_rate_nsprefix_ + ":"
                if (UseCapturedNS_ and self.forward_rate_nsprefix_)
                else ""
            )
            self.forward_rate.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="forwardRate",
                pretty_print=pretty_print,
            )
        if self.reverse_rate is not None:
            namespaceprefix_ = (
                self.reverse_rate_nsprefix_ + ":"
                if (UseCapturedNS_ and self.reverse_rate_nsprefix_)
                else ""
            )
            self.reverse_rate.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="reverseRate",
                pretty_print=pretty_print,
            )
        if self.time_course is not None:
            namespaceprefix_ = (
                self.time_course_nsprefix_ + ":"
                if (UseCapturedNS_ and self.time_course_nsprefix_)
                else ""
            )
            self.time_course.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="timeCourse",
                pretty_print=pretty_print,
            )
        if self.steady_state is not None:
            namespaceprefix_ = (
                self.steady_state_nsprefix_ + ":"
                if (UseCapturedNS_ and self.steady_state_nsprefix_)
                else ""
            )
            self.steady_state.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="steadyState",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_PositiveInteger, self.instances, "instances"
        )
        self.gds_check_cardinality_(self.instances, "instances", required=True)
        # validate simple type children
        self.gds_validate_defined_ST_(self.validate_Notes, self.notes, "notes")
        self.gds_check_cardinality_(self.notes, "notes", min_occurs=0, max_occurs=1)
        # validate complex type children
        self.gds_check_cardinality_(
            self.q10_settings, "q10_settings", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.forward_rate, "forward_rate", min_occurs=1, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.reverse_rate, "reverse_rate", min_occurs=1, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.time_course, "time_course", min_occurs=1, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.steady_state, "steady_state", min_occurs=1, max_occurs=1
        )
        if recursive:
            if self.q10_settings is not None:
                self.q10_settings.validate_(gds_collector, recursive=True)
            if self.forward_rate is not None:
                self.forward_rate.validate_(gds_collector, recursive=True)
            if self.reverse_rate is not None:
                self.reverse_rate.validate_(gds_collector, recursive=True)
            if self.time_course is not None:
                self.time_course.validate_(gds_collector, recursive=True)
            if self.steady_state is not None:
                self.steady_state.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("instances", node)
        if value is not None and "instances" not in already_processed:
            already_processed.add("instances")
            self.instances = self.gds_parse_integer(value, node, "instances")
            if self.instances <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")
            self.validate_PositiveInteger(
                self.instances
            )  # validate type PositiveInteger
        super(GateHHRatesTauInf, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "notes":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "notes")
            value_ = self.gds_validate_string(value_, node, "notes")
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == "q10Settings":
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10_settings = obj_
            obj_.original_tagname_ = "q10Settings"
        elif nodeName_ == "forwardRate":
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forward_rate = obj_
            obj_.original_tagname_ = "forwardRate"
        elif nodeName_ == "reverseRate":
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reverse_rate = obj_
            obj_.original_tagname_ = "reverseRate"
        elif nodeName_ == "timeCourse":
            obj_ = HHTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_course = obj_
            obj_.original_tagname_ = "timeCourse"
        elif nodeName_ == "steadyState":
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steady_state = obj_
            obj_.original_tagname_ = "steadyState"
        super(GateHHRatesTauInf, self)._buildChildren(child_, node, nodeName_, True)


# end class GateHHRatesTauInf


class GateHHTauInf(Base):
    """GateHHTauInf -- Gate which follows the general Hodgkin Huxley formalism
    \n
    :param instances:
    :type instances: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "instances",
            "PositiveInteger",
            0,
            0,
            {"use": "required", "name": "instances"},
        ),
        MemberSpec_(
            "notes",
            ["Notes", "xs:string"],
            0,
            1,
            {"minOccurs": "0", "name": "notes", "type": "xs:string"},
            None,
        ),
        MemberSpec_(
            "q10_settings",
            "Q10Settings",
            0,
            1,
            {"minOccurs": "0", "name": "q10Settings", "type": "Q10Settings"},
            None,
        ),
        MemberSpec_(
            "time_course",
            "HHTime",
            0,
            0,
            {"minOccurs": "1", "name": "timeCourse", "type": "HHTime"},
            None,
        ),
        MemberSpec_(
            "steady_state",
            "HHVariable",
            0,
            0,
            {"minOccurs": "1", "name": "steadyState", "type": "HHVariable"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        instances: "a PositiveInteger (required)" = None,
        notes: "a string (optional)" = None,
        q10_settings: "a Q10Settings (optional)" = None,
        time_course: "a HHTime (required)" = None,
        steady_state: "a HHVariable (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("GateHHTauInf"), self).__init__(id, **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10_settings = q10_settings
        self.q10_settings_nsprefix_ = None
        self.time_course = time_course
        self.time_course_nsprefix_ = None
        self.steady_state = steady_state
        self.steady_state_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GateHHTauInf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHTauInf.subclass:
            return GateHHTauInf.subclass(*args_, **kwargs_)
        else:
            return GateHHTauInf(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def _hasContent(self):
        if (
            self.notes is not None
            or self.q10_settings is not None
            or self.time_course is not None
            or self.steady_state is not None
            or super(GateHHTauInf, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHTauInf",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GateHHTauInf")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GateHHTauInf":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GateHHTauInf"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GateHHTauInf",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GateHHTauInf",
    ):
        super(GateHHTauInf, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GateHHTauInf"
        )
        if self.instances is not None and "instances" not in already_processed:
            already_processed.add("instances")
            outfile.write(
                ' instances="%s"'
                % self.gds_format_integer(self.instances, input_name="instances")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHTauInf",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(GateHHTauInf, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.notes is not None:
            namespaceprefix_ = (
                self.notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%snotes>%s</%snotes>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.notes), input_name="notes"
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.q10_settings is not None:
            namespaceprefix_ = (
                self.q10_settings_nsprefix_ + ":"
                if (UseCapturedNS_ and self.q10_settings_nsprefix_)
                else ""
            )
            self.q10_settings.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="q10Settings",
                pretty_print=pretty_print,
            )
        if self.time_course is not None:
            namespaceprefix_ = (
                self.time_course_nsprefix_ + ":"
                if (UseCapturedNS_ and self.time_course_nsprefix_)
                else ""
            )
            self.time_course.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="timeCourse",
                pretty_print=pretty_print,
            )
        if self.steady_state is not None:
            namespaceprefix_ = (
                self.steady_state_nsprefix_ + ":"
                if (UseCapturedNS_ and self.steady_state_nsprefix_)
                else ""
            )
            self.steady_state.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="steadyState",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_PositiveInteger, self.instances, "instances"
        )
        self.gds_check_cardinality_(self.instances, "instances", required=True)
        # validate simple type children
        self.gds_validate_defined_ST_(self.validate_Notes, self.notes, "notes")
        self.gds_check_cardinality_(self.notes, "notes", min_occurs=0, max_occurs=1)
        # validate complex type children
        self.gds_check_cardinality_(
            self.q10_settings, "q10_settings", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.time_course, "time_course", min_occurs=1, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.steady_state, "steady_state", min_occurs=1, max_occurs=1
        )
        if recursive:
            if self.q10_settings is not None:
                self.q10_settings.validate_(gds_collector, recursive=True)
            if self.time_course is not None:
                self.time_course.validate_(gds_collector, recursive=True)
            if self.steady_state is not None:
                self.steady_state.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("instances", node)
        if value is not None and "instances" not in already_processed:
            already_processed.add("instances")
            self.instances = self.gds_parse_integer(value, node, "instances")
            if self.instances <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")
            self.validate_PositiveInteger(
                self.instances
            )  # validate type PositiveInteger
        super(GateHHTauInf, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "notes":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "notes")
            value_ = self.gds_validate_string(value_, node, "notes")
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == "q10Settings":
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10_settings = obj_
            obj_.original_tagname_ = "q10Settings"
        elif nodeName_ == "timeCourse":
            obj_ = HHTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_course = obj_
            obj_.original_tagname_ = "timeCourse"
        elif nodeName_ == "steadyState":
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steady_state = obj_
            obj_.original_tagname_ = "steadyState"
        super(GateHHTauInf, self)._buildChildren(child_, node, nodeName_, True)


# end class GateHHTauInf


class GateHHRates(Base):
    """GateHHRates -- Gate which follows the general Hodgkin Huxley formalism
    \n
    :param instances:
    :type instances: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "instances",
            "PositiveInteger",
            0,
            0,
            {"use": "required", "name": "instances"},
        ),
        MemberSpec_(
            "notes",
            ["Notes", "xs:string"],
            0,
            1,
            {"minOccurs": "0", "name": "notes", "type": "xs:string"},
            None,
        ),
        MemberSpec_(
            "q10_settings",
            "Q10Settings",
            0,
            1,
            {"minOccurs": "0", "name": "q10Settings", "type": "Q10Settings"},
            None,
        ),
        MemberSpec_(
            "forward_rate",
            "HHRate",
            0,
            0,
            {"minOccurs": "1", "name": "forwardRate", "type": "HHRate"},
            None,
        ),
        MemberSpec_(
            "reverse_rate",
            "HHRate",
            0,
            0,
            {"minOccurs": "1", "name": "reverseRate", "type": "HHRate"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        instances: "a PositiveInteger (required)" = None,
        notes: "a string (optional)" = None,
        q10_settings: "a Q10Settings (optional)" = None,
        forward_rate: "a HHRate (required)" = None,
        reverse_rate: "a HHRate (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("GateHHRates"), self).__init__(id, **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10_settings = q10_settings
        self.q10_settings_nsprefix_ = None
        self.forward_rate = forward_rate
        self.forward_rate_nsprefix_ = None
        self.reverse_rate = reverse_rate
        self.reverse_rate_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GateHHRates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHRates.subclass:
            return GateHHRates.subclass(*args_, **kwargs_)
        else:
            return GateHHRates(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def _hasContent(self):
        if (
            self.notes is not None
            or self.q10_settings is not None
            or self.forward_rate is not None
            or self.reverse_rate is not None
            or super(GateHHRates, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHRates",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GateHHRates")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GateHHRates":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GateHHRates"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GateHHRates",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GateHHRates",
    ):
        super(GateHHRates, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GateHHRates"
        )
        if self.instances is not None and "instances" not in already_processed:
            already_processed.add("instances")
            outfile.write(
                ' instances="%s"'
                % self.gds_format_integer(self.instances, input_name="instances")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHRates",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(GateHHRates, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.notes is not None:
            namespaceprefix_ = (
                self.notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%snotes>%s</%snotes>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.notes), input_name="notes"
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.q10_settings is not None:
            namespaceprefix_ = (
                self.q10_settings_nsprefix_ + ":"
                if (UseCapturedNS_ and self.q10_settings_nsprefix_)
                else ""
            )
            self.q10_settings.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="q10Settings",
                pretty_print=pretty_print,
            )
        if self.forward_rate is not None:
            namespaceprefix_ = (
                self.forward_rate_nsprefix_ + ":"
                if (UseCapturedNS_ and self.forward_rate_nsprefix_)
                else ""
            )
            self.forward_rate.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="forwardRate",
                pretty_print=pretty_print,
            )
        if self.reverse_rate is not None:
            namespaceprefix_ = (
                self.reverse_rate_nsprefix_ + ":"
                if (UseCapturedNS_ and self.reverse_rate_nsprefix_)
                else ""
            )
            self.reverse_rate.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="reverseRate",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_PositiveInteger, self.instances, "instances"
        )
        self.gds_check_cardinality_(self.instances, "instances", required=True)
        # validate simple type children
        self.gds_validate_defined_ST_(self.validate_Notes, self.notes, "notes")
        self.gds_check_cardinality_(self.notes, "notes", min_occurs=0, max_occurs=1)
        # validate complex type children
        self.gds_check_cardinality_(
            self.q10_settings, "q10_settings", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.forward_rate, "forward_rate", min_occurs=1, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.reverse_rate, "reverse_rate", min_occurs=1, max_occurs=1
        )
        if recursive:
            if self.q10_settings is not None:
                self.q10_settings.validate_(gds_collector, recursive=True)
            if self.forward_rate is not None:
                self.forward_rate.validate_(gds_collector, recursive=True)
            if self.reverse_rate is not None:
                self.reverse_rate.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("instances", node)
        if value is not None and "instances" not in already_processed:
            already_processed.add("instances")
            self.instances = self.gds_parse_integer(value, node, "instances")
            if self.instances <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")
            self.validate_PositiveInteger(
                self.instances
            )  # validate type PositiveInteger
        super(GateHHRates, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "notes":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "notes")
            value_ = self.gds_validate_string(value_, node, "notes")
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == "q10Settings":
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10_settings = obj_
            obj_.original_tagname_ = "q10Settings"
        elif nodeName_ == "forwardRate":
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forward_rate = obj_
            obj_.original_tagname_ = "forwardRate"
        elif nodeName_ == "reverseRate":
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reverse_rate = obj_
            obj_.original_tagname_ = "reverseRate"
        super(GateHHRates, self)._buildChildren(child_, node, nodeName_, True)


# end class GateHHRates


class GateHHUndetermined(Base):
    """GateHHUndetermined -- Note all sub elements for gateHHrates, gateHHratesTau, gateFractional etc. allowed here. Which are valid should be constrained by what type is set"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "instances",
            "PositiveInteger",
            0,
            0,
            {"use": "required", "name": "instances"},
        ),
        MemberSpec_("type", "gateTypes", 0, 0, {"use": "required", "name": "type"}),
        MemberSpec_(
            "notes",
            ["Notes", "xs:string"],
            0,
            1,
            {"minOccurs": "0", "name": "notes", "type": "xs:string"},
            None,
        ),
        MemberSpec_(
            "q10_settings",
            "Q10Settings",
            0,
            1,
            {"minOccurs": "0", "name": "q10Settings", "type": "Q10Settings"},
            None,
        ),
        MemberSpec_(
            "forward_rate",
            "HHRate",
            0,
            1,
            {"minOccurs": "0", "name": "forwardRate", "type": "HHRate"},
            None,
        ),
        MemberSpec_(
            "reverse_rate",
            "HHRate",
            0,
            1,
            {"minOccurs": "0", "name": "reverseRate", "type": "HHRate"},
            None,
        ),
        MemberSpec_(
            "time_course",
            "HHTime",
            0,
            1,
            {"minOccurs": "0", "name": "timeCourse", "type": "HHTime"},
            None,
        ),
        MemberSpec_(
            "steady_state",
            "HHVariable",
            0,
            1,
            {"minOccurs": "0", "name": "steadyState", "type": "HHVariable"},
            None,
        ),
        MemberSpec_(
            "sub_gates",
            "GateFractionalSubgate",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "subGate",
                "type": "GateFractionalSubgate",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        instances: "a PositiveInteger (required)" = None,
        type: "a gateTypes (required)" = None,
        notes: "a string (optional)" = None,
        q10_settings: "a Q10Settings (optional)" = None,
        forward_rate: "a HHRate (optional)" = None,
        reverse_rate: "a HHRate (optional)" = None,
        time_course: "a HHTime (optional)" = None,
        steady_state: "a HHVariable (optional)" = None,
        sub_gates: "list of GateFractionalSubgate(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("GateHHUndetermined"), self).__init__(id, **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.type = _cast(None, type)
        self.type_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10_settings = q10_settings
        self.q10_settings_nsprefix_ = None
        self.forward_rate = forward_rate
        self.forward_rate_nsprefix_ = None
        self.reverse_rate = reverse_rate
        self.reverse_rate_nsprefix_ = None
        self.time_course = time_course
        self.time_course_nsprefix_ = None
        self.steady_state = steady_state
        self.steady_state_nsprefix_ = None
        if sub_gates is None:
            self.sub_gates = []
        else:
            self.sub_gates = sub_gates
        self.sub_gates_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GateHHUndetermined
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHUndetermined.subclass:
            return GateHHUndetermined.subclass(*args_, **kwargs_)
        else:
            return GateHHUndetermined(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def validate_gateTypes(self, value):
        # Validate type gateTypes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = [
                "gateHHrates",
                "gateHHratesTau",
                "gateHHtauInf",
                "gateHHratesInf",
                "gateHHratesTauInf",
                "gateHHInstantaneous",
                "gateKS",
                "gateFractional",
            ]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on gateTypes'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False

    def _hasContent(self):
        if (
            self.notes is not None
            or self.q10_settings is not None
            or self.forward_rate is not None
            or self.reverse_rate is not None
            or self.time_course is not None
            or self.steady_state is not None
            or self.sub_gates
            or super(GateHHUndetermined, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHUndetermined",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GateHHUndetermined")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GateHHUndetermined":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GateHHUndetermined",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GateHHUndetermined",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GateHHUndetermined",
    ):
        super(GateHHUndetermined, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="GateHHUndetermined",
        )
        if self.instances is not None and "instances" not in already_processed:
            already_processed.add("instances")
            outfile.write(
                ' instances="%s"'
                % self.gds_format_integer(self.instances, input_name="instances")
            )
        if self.type is not None and "type" not in already_processed:
            already_processed.add("type")
            outfile.write(
                " type=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.type), input_name="type"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateHHUndetermined",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(GateHHUndetermined, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.notes is not None:
            namespaceprefix_ = (
                self.notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%snotes>%s</%snotes>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.notes), input_name="notes"
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.q10_settings is not None:
            namespaceprefix_ = (
                self.q10_settings_nsprefix_ + ":"
                if (UseCapturedNS_ and self.q10_settings_nsprefix_)
                else ""
            )
            self.q10_settings.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="q10Settings",
                pretty_print=pretty_print,
            )
        if self.forward_rate is not None:
            namespaceprefix_ = (
                self.forward_rate_nsprefix_ + ":"
                if (UseCapturedNS_ and self.forward_rate_nsprefix_)
                else ""
            )
            self.forward_rate.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="forwardRate",
                pretty_print=pretty_print,
            )
        if self.reverse_rate is not None:
            namespaceprefix_ = (
                self.reverse_rate_nsprefix_ + ":"
                if (UseCapturedNS_ and self.reverse_rate_nsprefix_)
                else ""
            )
            self.reverse_rate.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="reverseRate",
                pretty_print=pretty_print,
            )
        if self.time_course is not None:
            namespaceprefix_ = (
                self.time_course_nsprefix_ + ":"
                if (UseCapturedNS_ and self.time_course_nsprefix_)
                else ""
            )
            self.time_course.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="timeCourse",
                pretty_print=pretty_print,
            )
        if self.steady_state is not None:
            namespaceprefix_ = (
                self.steady_state_nsprefix_ + ":"
                if (UseCapturedNS_ and self.steady_state_nsprefix_)
                else ""
            )
            self.steady_state.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="steadyState",
                pretty_print=pretty_print,
            )
        for subGate_ in self.sub_gates:
            namespaceprefix_ = (
                self.sub_gates_nsprefix_ + ":"
                if (UseCapturedNS_ and self.sub_gates_nsprefix_)
                else ""
            )
            subGate_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="subGate",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_PositiveInteger, self.instances, "instances"
        )
        self.gds_check_cardinality_(self.instances, "instances", required=True)
        self.gds_validate_defined_ST_(self.validate_gateTypes, self.type, "type")
        self.gds_check_cardinality_(self.type, "type", required=True)
        # validate simple type children
        self.gds_validate_defined_ST_(self.validate_Notes, self.notes, "notes")
        self.gds_check_cardinality_(self.notes, "notes", min_occurs=0, max_occurs=1)
        # validate complex type children
        self.gds_check_cardinality_(
            self.q10_settings, "q10_settings", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.forward_rate, "forward_rate", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.reverse_rate, "reverse_rate", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.time_course, "time_course", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.steady_state, "steady_state", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.sub_gates, "sub_gates", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            if self.q10_settings is not None:
                self.q10_settings.validate_(gds_collector, recursive=True)
            if self.forward_rate is not None:
                self.forward_rate.validate_(gds_collector, recursive=True)
            if self.reverse_rate is not None:
                self.reverse_rate.validate_(gds_collector, recursive=True)
            if self.time_course is not None:
                self.time_course.validate_(gds_collector, recursive=True)
            if self.steady_state is not None:
                self.steady_state.validate_(gds_collector, recursive=True)
            for item in self.sub_gates:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("instances", node)
        if value is not None and "instances" not in already_processed:
            already_processed.add("instances")
            self.instances = self.gds_parse_integer(value, node, "instances")
            if self.instances <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")
            self.validate_PositiveInteger(
                self.instances
            )  # validate type PositiveInteger
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type = value
            self.validate_gateTypes(self.type)  # validate type gateTypes
        super(GateHHUndetermined, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "notes":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "notes")
            value_ = self.gds_validate_string(value_, node, "notes")
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == "q10Settings":
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10_settings = obj_
            obj_.original_tagname_ = "q10Settings"
        elif nodeName_ == "forwardRate":
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forward_rate = obj_
            obj_.original_tagname_ = "forwardRate"
        elif nodeName_ == "reverseRate":
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reverse_rate = obj_
            obj_.original_tagname_ = "reverseRate"
        elif nodeName_ == "timeCourse":
            obj_ = HHTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_course = obj_
            obj_.original_tagname_ = "timeCourse"
        elif nodeName_ == "steadyState":
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steady_state = obj_
            obj_.original_tagname_ = "steadyState"
        elif nodeName_ == "subGate":
            obj_ = GateFractionalSubgate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sub_gates.append(obj_)
            obj_.original_tagname_ = "subGate"
        super(GateHHUndetermined, self)._buildChildren(child_, node, nodeName_, True)


# end class GateHHUndetermined


class GateKS(Base):
    """GateKS -- A gate which consists of multiple  **KSState** s and  **KSTransition** s giving the rates of transition between them
    \n
    :param instances:
    :type instances: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "instances",
            "PositiveInteger",
            0,
            0,
            {"use": "required", "name": "instances"},
        ),
        MemberSpec_(
            "notes",
            ["Notes", "xs:string"],
            0,
            1,
            {"minOccurs": "0", "name": "notes", "type": "xs:string"},
            None,
        ),
        MemberSpec_(
            "q10_settings",
            "Q10Settings",
            0,
            1,
            {"minOccurs": "0", "name": "q10Settings", "type": "Q10Settings"},
            None,
        ),
        MemberSpec_(
            "closed_states",
            "ClosedState",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "1",
                "name": "closedState",
                "type": "ClosedState",
            },
            None,
        ),
        MemberSpec_(
            "open_states",
            "OpenState",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "1",
                "name": "openState",
                "type": "OpenState",
            },
            None,
        ),
        MemberSpec_(
            "forward_transition",
            "ForwardTransition",
            1,
            0,
            {"name": "forwardTransition", "type": "ForwardTransition"},
            2,
        ),
        MemberSpec_(
            "reverse_transition",
            "ReverseTransition",
            1,
            0,
            {"name": "reverseTransition", "type": "ReverseTransition"},
            2,
        ),
        MemberSpec_(
            "tau_inf_transition",
            "TauInfTransition",
            1,
            0,
            {"name": "tauInfTransition", "type": "TauInfTransition"},
            2,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        instances: "a PositiveInteger (required)" = None,
        notes: "a string (optional)" = None,
        q10_settings: "a Q10Settings (optional)" = None,
        closed_states: "list of ClosedState(s) (required)" = None,
        open_states: "list of OpenState(s) (required)" = None,
        forward_transition: "list of ForwardTransition(s) (required)" = None,
        reverse_transition: "list of ReverseTransition(s) (required)" = None,
        tau_inf_transition: "list of TauInfTransition(s) (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("GateKS"), self).__init__(id, **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10_settings = q10_settings
        self.q10_settings_nsprefix_ = None
        if closed_states is None:
            self.closed_states = []
        else:
            self.closed_states = closed_states
        self.closed_states_nsprefix_ = None
        if open_states is None:
            self.open_states = []
        else:
            self.open_states = open_states
        self.open_states_nsprefix_ = None
        if forward_transition is None:
            self.forward_transition = []
        else:
            self.forward_transition = forward_transition
        self.forward_transition_nsprefix_ = None
        if reverse_transition is None:
            self.reverse_transition = []
        else:
            self.reverse_transition = reverse_transition
        self.reverse_transition_nsprefix_ = None
        if tau_inf_transition is None:
            self.tau_inf_transition = []
        else:
            self.tau_inf_transition = tau_inf_transition
        self.tau_inf_transition_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GateKS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateKS.subclass:
            return GateKS.subclass(*args_, **kwargs_)
        else:
            return GateKS(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass
        return result

    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def _hasContent(self):
        if (
            self.notes is not None
            or self.q10_settings is not None
            or self.closed_states
            or self.open_states
            or self.forward_transition
            or self.reverse_transition
            or self.tau_inf_transition
            or super(GateKS, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateKS",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GateKS")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GateKS":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GateKS"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GateKS",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="GateKS"
    ):
        super(GateKS, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GateKS"
        )
        if self.instances is not None and "instances" not in already_processed:
            already_processed.add("instances")
            outfile.write(
                ' instances="%s"'
                % self.gds_format_integer(self.instances, input_name="instances")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="GateKS",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(GateKS, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.notes is not None:
            namespaceprefix_ = (
                self.notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%snotes>%s</%snotes>%s"
                % (
                    namespaceprefix_,
                    self.gds_encode(
                        self.gds_format_string(
                            quote_xml(self.notes), input_name="notes"
                        )
                    ),
                    namespaceprefix_,
                    eol_,
                )
            )
        if self.q10_settings is not None:
            namespaceprefix_ = (
                self.q10_settings_nsprefix_ + ":"
                if (UseCapturedNS_ and self.q10_settings_nsprefix_)
                else ""
            )
            self.q10_settings.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="q10Settings",
                pretty_print=pretty_print,
            )
        for closedState_ in self.closed_states:
            namespaceprefix_ = (
                self.closed_states_nsprefix_ + ":"
                if (UseCapturedNS_ and self.closed_states_nsprefix_)
                else ""
            )
            closedState_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="closedState",
                pretty_print=pretty_print,
            )
        for openState_ in self.open_states:
            namespaceprefix_ = (
                self.open_states_nsprefix_ + ":"
                if (UseCapturedNS_ and self.open_states_nsprefix_)
                else ""
            )
            openState_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="openState",
                pretty_print=pretty_print,
            )
        for forwardTransition_ in self.forward_transition:
            namespaceprefix_ = (
                self.forward_transition_nsprefix_ + ":"
                if (UseCapturedNS_ and self.forward_transition_nsprefix_)
                else ""
            )
            forwardTransition_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="forwardTransition",
                pretty_print=pretty_print,
            )
        for reverseTransition_ in self.reverse_transition:
            namespaceprefix_ = (
                self.reverse_transition_nsprefix_ + ":"
                if (UseCapturedNS_ and self.reverse_transition_nsprefix_)
                else ""
            )
            reverseTransition_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="reverseTransition",
                pretty_print=pretty_print,
            )
        for tauInfTransition_ in self.tau_inf_transition:
            namespaceprefix_ = (
                self.tau_inf_transition_nsprefix_ + ":"
                if (UseCapturedNS_ and self.tau_inf_transition_nsprefix_)
                else ""
            )
            tauInfTransition_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="tauInfTransition",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_PositiveInteger, self.instances, "instances"
        )
        self.gds_check_cardinality_(self.instances, "instances", required=True)
        # validate simple type children
        self.gds_validate_defined_ST_(self.validate_Notes, self.notes, "notes")
        self.gds_check_cardinality_(self.notes, "notes", min_occurs=0, max_occurs=1)
        # validate complex type children
        self.gds_check_cardinality_(
            self.q10_settings, "q10_settings", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.closed_states, "closed_states", min_occurs=1, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.open_states, "open_states", min_occurs=1, max_occurs=9999999
        )
        # cardinality check omitted for choice item forward_transition
        # self.gds_check_cardinality_(self.forward_transition, 'forward_transition', min_occurs=1, max_occurs=9999999)
        # cardinality check omitted for choice item reverse_transition
        # self.gds_check_cardinality_(self.reverse_transition, 'reverse_transition', min_occurs=1, max_occurs=9999999)
        # cardinality check omitted for choice item tau_inf_transition
        # self.gds_check_cardinality_(self.tau_inf_transition, 'tau_inf_transition', min_occurs=1, max_occurs=9999999)
        if recursive:
            if self.q10_settings is not None:
                self.q10_settings.validate_(gds_collector, recursive=True)
            for item in self.closed_states:
                item.validate_(gds_collector, recursive=True)
            for item in self.open_states:
                item.validate_(gds_collector, recursive=True)
            for item in self.forward_transition:
                item.validate_(gds_collector, recursive=True)
            for item in self.reverse_transition:
                item.validate_(gds_collector, recursive=True)
            for item in self.tau_inf_transition:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("instances", node)
        if value is not None and "instances" not in already_processed:
            already_processed.add("instances")
            self.instances = self.gds_parse_integer(value, node, "instances")
            if self.instances <= 0:
                raise_parse_error(node, "Invalid PositiveInteger")
            self.validate_PositiveInteger(
                self.instances
            )  # validate type PositiveInteger
        super(GateKS, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "notes":
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, "notes")
            value_ = self.gds_validate_string(value_, node, "notes")
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == "q10Settings":
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10_settings = obj_
            obj_.original_tagname_ = "q10Settings"
        elif nodeName_ == "closedState":
            obj_ = ClosedState.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.closed_states.append(obj_)
            obj_.original_tagname_ = "closedState"
        elif nodeName_ == "openState":
            obj_ = OpenState.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.open_states.append(obj_)
            obj_.original_tagname_ = "openState"
        elif nodeName_ == "forwardTransition":
            obj_ = ForwardTransition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forward_transition.append(obj_)
            obj_.original_tagname_ = "forwardTransition"
        elif nodeName_ == "reverseTransition":
            obj_ = ReverseTransition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reverse_transition.append(obj_)
            obj_.original_tagname_ = "reverseTransition"
        elif nodeName_ == "tauInfTransition":
            obj_ = TauInfTransition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tau_inf_transition.append(obj_)
            obj_.original_tagname_ = "tauInfTransition"
        super(GateKS, self)._buildChildren(child_, node, nodeName_, True)


# end class GateKS


class TauInfTransition(Base):
    """TauInfTransition -- KS Transition specified in terms of time constant  **tau**  and steady state  **inf**"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("from_", "NmlId", 0, 0, {"use": "required", "name": "from_"}),
        MemberSpec_("to", "NmlId", 0, 0, {"use": "required", "name": "to"}),
        MemberSpec_(
            "steady_state",
            "HHVariable",
            0,
            0,
            {"name": "steadyState", "type": "HHVariable"},
            None,
        ),
        MemberSpec_(
            "time_course",
            "HHTime",
            0,
            0,
            {"name": "timeCourse", "type": "HHTime"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        from_: "a NmlId (required)" = None,
        to: "a NmlId (required)" = None,
        steady_state: "a HHVariable (required)" = None,
        time_course: "a HHTime (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("TauInfTransition"), self).__init__(id, **kwargs_)
        self.from_ = _cast(None, from_)
        self.from__nsprefix_ = None
        self.to = _cast(None, to)
        self.to_nsprefix_ = None
        self.steady_state = steady_state
        self.steady_state_nsprefix_ = None
        self.time_course = time_course
        self.time_course_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, TauInfTransition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TauInfTransition.subclass:
            return TauInfTransition.subclass(*args_, **kwargs_)
        else:
            return TauInfTransition(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if (
            self.steady_state is not None
            or self.time_course is not None
            or super(TauInfTransition, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="TauInfTransition",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("TauInfTransition")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "TauInfTransition":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="TauInfTransition",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="TauInfTransition",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="TauInfTransition",
    ):
        super(TauInfTransition, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="TauInfTransition",
        )
        if self.from_ is not None and "from_" not in already_processed:
            already_processed.add("from_")
            outfile.write(
                " from=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.from_), input_name="from"
                        )
                    ),
                )
            )
        if self.to is not None and "to" not in already_processed:
            already_processed.add("to")
            outfile.write(
                " to=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.to), input_name="to")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="TauInfTransition",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(TauInfTransition, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.steady_state is not None:
            namespaceprefix_ = (
                self.steady_state_nsprefix_ + ":"
                if (UseCapturedNS_ and self.steady_state_nsprefix_)
                else ""
            )
            self.steady_state.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="steadyState",
                pretty_print=pretty_print,
            )
        if self.time_course is not None:
            namespaceprefix_ = (
                self.time_course_nsprefix_ + ":"
                if (UseCapturedNS_ and self.time_course_nsprefix_)
                else ""
            )
            self.time_course.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="timeCourse",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.from_, "from_")
        self.gds_check_cardinality_(self.from_, "from_", required=True)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.to, "to")
        self.gds_check_cardinality_(self.to, "to", required=True)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.steady_state, "steady_state", min_occurs=1, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.time_course, "time_course", min_occurs=1, max_occurs=1
        )
        if recursive:
            if self.steady_state is not None:
                self.steady_state.validate_(gds_collector, recursive=True)
            if self.time_course is not None:
                self.time_course.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("from", node)
        if value is not None and "from" not in already_processed:
            already_processed.add("from")
            self.from_ = value
            self.validate_NmlId(self.from_)  # validate type NmlId
        value = find_attr_value_("to", node)
        if value is not None and "to" not in already_processed:
            already_processed.add("to")
            self.to = value
            self.validate_NmlId(self.to)  # validate type NmlId
        super(TauInfTransition, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "steadyState":
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steady_state = obj_
            obj_.original_tagname_ = "steadyState"
        elif nodeName_ == "timeCourse":
            obj_ = HHTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.time_course = obj_
            obj_.original_tagname_ = "timeCourse"
        super(TauInfTransition, self)._buildChildren(child_, node, nodeName_, True)


# end class TauInfTransition


class ReverseTransition(Base):
    """ReverseTransition -- A reverse only  **KSTransition**  for a  **gateKS**  which specifies a **rate**  ( type  **baseHHRate**  ) which follows one of the standard Hodgkin Huxley forms ( e. g.  **HHExpRate** ,  **HHSigmoidRate** ,  **HHExpLinearRate**"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("from_", "NmlId", 0, 0, {"use": "required", "name": "from_"}),
        MemberSpec_("to", "NmlId", 0, 0, {"use": "required", "name": "to"}),
        MemberSpec_(
            "__ANY__",
            "__ANY__",
            1,
            1,
            {"maxOccurs": "unbounded", "minOccurs": "0", "processContents": "skip"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        from_: "a NmlId (required)" = None,
        to: "a NmlId (required)" = None,
        anytypeobjs_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ReverseTransition"), self).__init__(id, **kwargs_)
        self.from_ = _cast(None, from_)
        self.from__nsprefix_ = None
        self.to = _cast(None, to)
        self.to_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ReverseTransition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReverseTransition.subclass:
            return ReverseTransition.subclass(*args_, **kwargs_)
        else:
            return ReverseTransition(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if self.anytypeobjs_ or super(ReverseTransition, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ReverseTransition",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ReverseTransition")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ReverseTransition":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ReverseTransition",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ReverseTransition",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ReverseTransition",
    ):
        super(ReverseTransition, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ReverseTransition",
        )
        if self.from_ is not None and "from_" not in already_processed:
            already_processed.add("from_")
            outfile.write(
                " from=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.from_), input_name="from"
                        )
                    ),
                )
            )
        if self.to is not None and "to" not in already_processed:
            already_processed.add("to")
            outfile.write(
                " to=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.to), input_name="to")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ReverseTransition",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ReverseTransition, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write("\n")

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.from_, "from_")
        self.gds_check_cardinality_(self.from_, "from_", required=True)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.to, "to")
        self.gds_check_cardinality_(self.to, "to", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("from", node)
        if value is not None and "from" not in already_processed:
            already_processed.add("from")
            self.from_ = value
            self.validate_NmlId(self.from_)  # validate type NmlId
        value = find_attr_value_("to", node)
        if value is not None and "to" not in already_processed:
            already_processed.add("to")
            self.to = value
            self.validate_NmlId(self.to)  # validate type NmlId
        super(ReverseTransition, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        content_ = self.gds_build_any(child_, "ReverseTransition")
        self.anytypeobjs_.append(content_)
        super(ReverseTransition, self)._buildChildren(child_, node, nodeName_, True)


# end class ReverseTransition


class ForwardTransition(Base):
    """ForwardTransition -- A forward only  **KSTransition**  for a  **gateKS**  which specifies a **rate**  ( type  **baseHHRate**  ) which follows one of the standard Hodgkin Huxley forms ( e. g.  **HHExpRate** ,  **HHSigmoidRate** ,  **HHExpLinearRate**"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("from_", "NmlId", 0, 0, {"use": "required", "name": "from_"}),
        MemberSpec_("to", "NmlId", 0, 0, {"use": "required", "name": "to"}),
        MemberSpec_(
            "__ANY__",
            "__ANY__",
            1,
            1,
            {"maxOccurs": "unbounded", "minOccurs": "0", "processContents": "skip"},
            None,
        ),
    ]
    subclass = None
    superclass = Base

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        from_: "a NmlId (required)" = None,
        to: "a NmlId (required)" = None,
        anytypeobjs_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ForwardTransition"), self).__init__(id, **kwargs_)
        self.from_ = _cast(None, from_)
        self.from__nsprefix_ = None
        self.to = _cast(None, to)
        self.to_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ForwardTransition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForwardTransition.subclass:
            return ForwardTransition.subclass(*args_, **kwargs_)
        else:
            return ForwardTransition(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if self.anytypeobjs_ or super(ForwardTransition, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ForwardTransition",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ForwardTransition")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ForwardTransition":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ForwardTransition",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ForwardTransition",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ForwardTransition",
    ):
        super(ForwardTransition, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ForwardTransition",
        )
        if self.from_ is not None and "from_" not in already_processed:
            already_processed.add("from_")
            outfile.write(
                " from=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.from_), input_name="from"
                        )
                    ),
                )
            )
        if self.to is not None and "to" not in already_processed:
            already_processed.add("to")
            outfile.write(
                " to=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.to), input_name="to")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ForwardTransition",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ForwardTransition, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write("\n")

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.from_, "from_")
        self.gds_check_cardinality_(self.from_, "from_", required=True)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.to, "to")
        self.gds_check_cardinality_(self.to, "to", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("from", node)
        if value is not None and "from" not in already_processed:
            already_processed.add("from")
            self.from_ = value
            self.validate_NmlId(self.from_)  # validate type NmlId
        value = find_attr_value_("to", node)
        if value is not None and "to" not in already_processed:
            already_processed.add("to")
            self.to = value
            self.validate_NmlId(self.to)  # validate type NmlId
        super(ForwardTransition, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        content_ = self.gds_build_any(child_, "ForwardTransition")
        self.anytypeobjs_.append(content_)
        super(ForwardTransition, self)._buildChildren(child_, node, nodeName_, True)


# end class ForwardTransition


class OpenState(Base):
    """OpenState -- A  **KSState**  with **relativeConductance**  of 1
    \n
    :param relativeConductance:
    :type relativeConductance: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = Base

    def __init__(self, id: "a NmlId (required)" = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("OpenState"), self).__init__(id, **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, OpenState)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenState.subclass:
            return OpenState.subclass(*args_, **kwargs_)
        else:
            return OpenState(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(OpenState, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="OpenState",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("OpenState")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "OpenState":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="OpenState"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="OpenState",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="OpenState"
    ):
        super(OpenState, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="OpenState"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="OpenState",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(OpenState, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(OpenState, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(OpenState, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class OpenState


class ClosedState(Base):
    """ClosedState -- A  **KSState**  with **relativeConductance**  of 0
    \n
    :param relativeConductance:
    :type relativeConductance: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = Base

    def __init__(self, id: "a NmlId (required)" = None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ClosedState"), self).__init__(id, **kwargs_)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ClosedState)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClosedState.subclass:
            return ClosedState.subclass(*args_, **kwargs_)
        else:
            return ClosedState(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(ClosedState, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ClosedState",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ClosedState")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ClosedState":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ClosedState"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ClosedState",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ClosedState",
    ):
        super(ClosedState, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ClosedState"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ClosedState",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ClosedState, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(ClosedState, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ClosedState, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class ClosedState


class Q10ConductanceScaling(BaseWithoutId):
    """Q10ConductanceScaling -- A value for the conductance scaling which varies as a standard function of the difference between the current temperature, **temperature,**  and the temperature at which the conductance was originally determined, **experimentalTemp**
    \n
    :param q10Factor:
    :type q10Factor: none
    :param experimentalTemp:
    :type experimentalTemp: temperature

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "q10_factor",
            "Nml2Quantity_none",
            0,
            0,
            {"use": "required", "name": "q10_factor"},
        ),
        MemberSpec_(
            "experimental_temp",
            "Nml2Quantity_temperature",
            0,
            0,
            {"use": "required", "name": "experimental_temp"},
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        q10_factor: "a Nml2Quantity_none (required)" = None,
        experimental_temp: "a Nml2Quantity_temperature (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Q10ConductanceScaling"), self).__init__(**kwargs_)
        self.q10_factor = _cast(None, q10_factor)
        self.q10_factor_nsprefix_ = None
        self.experimental_temp = _cast(None, experimental_temp)
        self.experimental_temp_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Q10ConductanceScaling
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Q10ConductanceScaling.subclass:
            return Q10ConductanceScaling.subclass(*args_, **kwargs_)
        else:
            return Q10ConductanceScaling(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_none_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_none_patterns_,
                    )
                )

    validate_Nml2Quantity_none_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$"]
    ]

    def validate_Nml2Quantity_temperature(self, value):
        # Validate type Nml2Quantity_temperature, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_temperature_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_temperature_patterns_,
                    )
                )

    validate_Nml2Quantity_temperature_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(degC))$"]
    ]

    def _hasContent(self):
        if super(Q10ConductanceScaling, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Q10ConductanceScaling",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Q10ConductanceScaling")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Q10ConductanceScaling":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="Q10ConductanceScaling",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Q10ConductanceScaling",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Q10ConductanceScaling",
    ):
        super(Q10ConductanceScaling, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="Q10ConductanceScaling",
        )
        if self.q10_factor is not None and "q10_factor" not in already_processed:
            already_processed.add("q10_factor")
            outfile.write(
                " q10Factor=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.q10_factor), input_name="q10Factor"
                        )
                    ),
                )
            )
        if (
            self.experimental_temp is not None
            and "experimental_temp" not in already_processed
        ):
            already_processed.add("experimental_temp")
            outfile.write(
                " experimentalTemp=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.experimental_temp),
                            input_name="experimentalTemp",
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Q10ConductanceScaling",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Q10ConductanceScaling, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_none, self.q10_factor, "q10_factor"
        )
        self.gds_check_cardinality_(self.q10_factor, "q10_factor", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_temperature,
            self.experimental_temp,
            "experimental_temp",
        )
        self.gds_check_cardinality_(
            self.experimental_temp, "experimental_temp", required=True
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("q10Factor", node)
        if value is not None and "q10Factor" not in already_processed:
            already_processed.add("q10Factor")
            self.q10_factor = value
            self.validate_Nml2Quantity_none(
                self.q10_factor
            )  # validate type Nml2Quantity_none
        value = find_attr_value_("experimentalTemp", node)
        if value is not None and "experimentalTemp" not in already_processed:
            already_processed.add("experimentalTemp")
            self.experimental_temp = value
            self.validate_Nml2Quantity_temperature(
                self.experimental_temp
            )  # validate type Nml2Quantity_temperature
        super(Q10ConductanceScaling, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Q10ConductanceScaling, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class Q10ConductanceScaling


class IonChannelKS(Standalone):
    """A kinetic scheme based ion channel with multiple  **gateKS** s, each of which consists of multiple  **KSState** s and  **KSTransition** s giving the rates of transition between them
    IonChannelKS -- A kinetic scheme based ion channel with multiple  **gateKS** s, each of which consists of multiple  **KSState** s and  **KSTransition** s giving the rates of transition between them
    \n
    :param conductance:
    :type conductance: conductance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("species", "NmlId", 0, 1, {"use": "optional", "name": "species"}),
        MemberSpec_(
            "conductance",
            "Nml2Quantity_conductance",
            0,
            1,
            {"use": "optional", "name": "conductance"},
        ),
        MemberSpec_(
            "neuro_lex_id",
            "NeuroLexId",
            0,
            1,
            {"use": "optional", "name": "neuro_lex_id"},
        ),
        MemberSpec_(
            "gate_kses",
            "GateKS",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "gateKS",
                "type": "GateKS",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        species: "a NmlId (optional)" = None,
        conductance: "a Nml2Quantity_conductance (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        gate_kses: "list of GateKS(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IonChannelKS"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        self.species = _cast(None, species)
        self.species_nsprefix_ = None
        self.conductance = _cast(None, conductance)
        self.conductance_nsprefix_ = None
        self.neuro_lex_id = _cast(None, neuro_lex_id)
        self.neuro_lex_id_nsprefix_ = None
        if gate_kses is None:
            self.gate_kses = []
        else:
            self.gate_kses = gate_kses
        self.gate_kses_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IonChannelKS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IonChannelKS.subclass:
            return IonChannelKS.subclass(*args_, **kwargs_)
        else:
            return IonChannelKS(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductance_patterns_,
                    )
                )

    validate_Nml2Quantity_conductance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$"]
    ]

    def validate_NeuroLexId(self, value):
        # Validate type NeuroLexId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NeuroLexId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NeuroLexId_patterns_,
                    )
                )

    validate_NeuroLexId_patterns_ = [["^([a-zA-Z0-9_:]*)$"]]

    def _hasContent(self):
        if self.gate_kses or super(IonChannelKS, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="IonChannelKS",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IonChannelKS")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IonChannelKS":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IonChannelKS"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IonChannelKS",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="IonChannelKS",
    ):
        super(IonChannelKS, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IonChannelKS"
        )
        if self.species is not None and "species" not in already_processed:
            already_processed.add("species")
            outfile.write(
                " species=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.species), input_name="species"
                        )
                    ),
                )
            )
        if self.conductance is not None and "conductance" not in already_processed:
            already_processed.add("conductance")
            outfile.write(
                " conductance=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.conductance), input_name="conductance"
                        )
                    ),
                )
            )
        if self.neuro_lex_id is not None and "neuro_lex_id" not in already_processed:
            already_processed.add("neuro_lex_id")
            outfile.write(
                " neuroLexId=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.neuro_lex_id), input_name="neuroLexId"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="IonChannelKS",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IonChannelKS, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for gateKS_ in self.gate_kses:
            namespaceprefix_ = (
                self.gate_kses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.gate_kses_nsprefix_)
                else ""
            )
            gateKS_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="gateKS",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.species, "species")
        self.gds_check_cardinality_(self.species, "species", required=False)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductance, self.conductance, "conductance"
        )
        self.gds_check_cardinality_(self.conductance, "conductance", required=False)
        self.gds_validate_defined_ST_(
            self.validate_NeuroLexId, self.neuro_lex_id, "neuro_lex_id"
        )
        self.gds_check_cardinality_(self.neuro_lex_id, "neuro_lex_id", required=False)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.gate_kses, "gate_kses", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.gate_kses:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("species", node)
        if value is not None and "species" not in already_processed:
            already_processed.add("species")
            self.species = value
            self.validate_NmlId(self.species)  # validate type NmlId
        value = find_attr_value_("conductance", node)
        if value is not None and "conductance" not in already_processed:
            already_processed.add("conductance")
            self.conductance = value
            self.validate_Nml2Quantity_conductance(
                self.conductance
            )  # validate type Nml2Quantity_conductance
        value = find_attr_value_("neuroLexId", node)
        if value is not None and "neuroLexId" not in already_processed:
            already_processed.add("neuroLexId")
            self.neuro_lex_id = value
            self.validate_NeuroLexId(self.neuro_lex_id)  # validate type NeuroLexId
        super(IonChannelKS, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "gateKS":
            obj_ = GateKS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gate_kses.append(obj_)
            obj_.original_tagname_ = "gateKS"
        super(IonChannelKS, self)._buildChildren(child_, node, nodeName_, True)


# end class IonChannelKS


class IonChannelScalable(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "neuro_lex_id",
            "NeuroLexId",
            0,
            1,
            {"use": "optional", "name": "neuro_lex_id"},
        ),
        MemberSpec_(
            "q10_conductance_scalings",
            "Q10ConductanceScaling",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "q10ConductanceScaling",
                "type": "Q10ConductanceScaling",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        q10_conductance_scalings: "list of Q10ConductanceScaling(s) (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IonChannelScalable"), self).__init__(
            id, metaid, notes, properties, annotation, extensiontype_, **kwargs_
        )
        self.neuro_lex_id = _cast(None, neuro_lex_id)
        self.neuro_lex_id_nsprefix_ = None
        if q10_conductance_scalings is None:
            self.q10_conductance_scalings = []
        else:
            self.q10_conductance_scalings = q10_conductance_scalings
        self.q10_conductance_scalings_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IonChannelScalable
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IonChannelScalable.subclass:
            return IonChannelScalable.subclass(*args_, **kwargs_)
        else:
            return IonChannelScalable(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NeuroLexId(self, value):
        # Validate type NeuroLexId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NeuroLexId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NeuroLexId_patterns_,
                    )
                )

    validate_NeuroLexId_patterns_ = [["^([a-zA-Z0-9_:]*)$"]]

    def _hasContent(self):
        if (
            self.q10_conductance_scalings
            or super(IonChannelScalable, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="IonChannelScalable",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IonChannelScalable")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IonChannelScalable":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="IonChannelScalable",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IonChannelScalable",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="IonChannelScalable",
    ):
        super(IonChannelScalable, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="IonChannelScalable",
        )
        if self.neuro_lex_id is not None and "neuro_lex_id" not in already_processed:
            already_processed.add("neuro_lex_id")
            outfile.write(
                " neuroLexId=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.neuro_lex_id), input_name="neuroLexId"
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="IonChannelScalable",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IonChannelScalable, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for q10ConductanceScaling_ in self.q10_conductance_scalings:
            namespaceprefix_ = (
                self.q10_conductance_scalings_nsprefix_ + ":"
                if (UseCapturedNS_ and self.q10_conductance_scalings_nsprefix_)
                else ""
            )
            q10ConductanceScaling_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="q10ConductanceScaling",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NeuroLexId, self.neuro_lex_id, "neuro_lex_id"
        )
        self.gds_check_cardinality_(self.neuro_lex_id, "neuro_lex_id", required=False)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.q10_conductance_scalings,
            "q10_conductance_scalings",
            min_occurs=0,
            max_occurs=9999999,
        )
        if recursive:
            for item in self.q10_conductance_scalings:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("neuroLexId", node)
        if value is not None and "neuroLexId" not in already_processed:
            already_processed.add("neuroLexId")
            self.neuro_lex_id = value
            self.validate_NeuroLexId(self.neuro_lex_id)  # validate type NeuroLexId
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(IonChannelScalable, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "q10ConductanceScaling":
            obj_ = Q10ConductanceScaling.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10_conductance_scalings.append(obj_)
            obj_.original_tagname_ = "q10ConductanceScaling"
        super(IonChannelScalable, self)._buildChildren(child_, node, nodeName_, True)


# end class IonChannelScalable


class NeuroMLDocument(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "includes",
            "IncludeType",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "include",
                "type": "IncludeType",
            },
            None,
        ),
        MemberSpec_(
            "extracellular_properties",
            "ExtracellularProperties",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "extracellularProperties",
                "type": "ExtracellularProperties",
            },
            None,
        ),
        MemberSpec_(
            "intracellular_properties",
            "IntracellularProperties",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "intracellularProperties",
                "type": "IntracellularProperties",
            },
            None,
        ),
        MemberSpec_(
            "morphology",
            "Morphology",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "morphology",
                "type": "Morphology",
            },
            None,
        ),
        MemberSpec_(
            "ion_channel",
            "IonChannel",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "ionChannel",
                "type": "IonChannel",
            },
            None,
        ),
        MemberSpec_(
            "ion_channel_hhs",
            "IonChannelHH",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "ionChannelHH",
                "type": "IonChannelHH",
            },
            None,
        ),
        MemberSpec_(
            "ion_channel_v_shifts",
            "IonChannelVShift",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "ionChannelVShift",
                "type": "IonChannelVShift",
            },
            None,
        ),
        MemberSpec_(
            "ion_channel_kses",
            "IonChannelKS",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "ionChannelKS",
                "type": "IonChannelKS",
            },
            None,
        ),
        MemberSpec_(
            "decaying_pool_concentration_models",
            "DecayingPoolConcentrationModel",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "decayingPoolConcentrationModel",
                "type": "DecayingPoolConcentrationModel",
            },
            None,
        ),
        MemberSpec_(
            "fixed_factor_concentration_models",
            "FixedFactorConcentrationModel",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "fixedFactorConcentrationModel",
                "type": "FixedFactorConcentrationModel",
            },
            None,
        ),
        MemberSpec_(
            "alpha_current_synapses",
            "AlphaCurrentSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "alphaCurrentSynapse",
                "type": "AlphaCurrentSynapse",
            },
            None,
        ),
        MemberSpec_(
            "alpha_synapses",
            "AlphaSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "alphaSynapse",
                "type": "AlphaSynapse",
            },
            None,
        ),
        MemberSpec_(
            "exp_one_synapses",
            "ExpOneSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "expOneSynapse",
                "type": "ExpOneSynapse",
            },
            None,
        ),
        MemberSpec_(
            "exp_two_synapses",
            "ExpTwoSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "expTwoSynapse",
                "type": "ExpTwoSynapse",
            },
            None,
        ),
        MemberSpec_(
            "exp_three_synapses",
            "ExpThreeSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "expThreeSynapse",
                "type": "ExpThreeSynapse",
            },
            None,
        ),
        MemberSpec_(
            "blocking_plastic_synapses",
            "BlockingPlasticSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "blockingPlasticSynapse",
                "type": "BlockingPlasticSynapse",
            },
            None,
        ),
        MemberSpec_(
            "double_synapses",
            "DoubleSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "doubleSynapse",
                "type": "DoubleSynapse",
            },
            None,
        ),
        MemberSpec_(
            "gap_junctions",
            "GapJunction",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "gapJunction",
                "type": "GapJunction",
            },
            None,
        ),
        MemberSpec_(
            "silent_synapses",
            "SilentSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "silentSynapse",
                "type": "SilentSynapse",
            },
            None,
        ),
        MemberSpec_(
            "linear_graded_synapses",
            "LinearGradedSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "linearGradedSynapse",
                "type": "LinearGradedSynapse",
            },
            None,
        ),
        MemberSpec_(
            "graded_synapses",
            "GradedSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "gradedSynapse",
                "type": "GradedSynapse",
            },
            None,
        ),
        MemberSpec_(
            "biophysical_properties",
            "BiophysicalProperties",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "biophysicalProperties",
                "type": "BiophysicalProperties",
            },
            None,
        ),
        MemberSpec_(
            "cells",
            "Cell",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "cell",
                "type": "Cell",
            },
            None,
        ),
        MemberSpec_(
            "cell2_ca_poolses",
            "Cell2CaPools",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "cell2CaPools",
                "type": "Cell2CaPools",
            },
            None,
        ),
        MemberSpec_(
            "base_cells",
            "BaseCell",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "baseCell",
                "type": "BaseCell",
            },
            None,
        ),
        MemberSpec_(
            "iaf_tau_cells",
            "IafTauCell",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "iafTauCell",
                "type": "IafTauCell",
            },
            None,
        ),
        MemberSpec_(
            "iaf_tau_ref_cells",
            "IafTauRefCell",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "iafTauRefCell",
                "type": "IafTauRefCell",
            },
            None,
        ),
        MemberSpec_(
            "iaf_cells",
            "IafCell",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "iafCell",
                "type": "IafCell",
            },
            None,
        ),
        MemberSpec_(
            "iaf_ref_cells",
            "IafRefCell",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "iafRefCell",
                "type": "IafRefCell",
            },
            None,
        ),
        MemberSpec_(
            "izhikevich_cells",
            "IzhikevichCell",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "izhikevichCell",
                "type": "IzhikevichCell",
            },
            None,
        ),
        MemberSpec_(
            "izhikevich2007_cells",
            "Izhikevich2007Cell",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "izhikevich2007Cell",
                "type": "Izhikevich2007Cell",
            },
            None,
        ),
        MemberSpec_(
            "ad_ex_ia_f_cells",
            "AdExIaFCell",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "adExIaFCell",
                "type": "AdExIaFCell",
            },
            None,
        ),
        MemberSpec_(
            "fitz_hugh_nagumo_cells",
            "FitzHughNagumoCell",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "fitzHughNagumoCell",
                "type": "FitzHughNagumoCell",
            },
            None,
        ),
        MemberSpec_(
            "fitz_hugh_nagumo1969_cells",
            "FitzHughNagumo1969Cell",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "fitzHughNagumo1969Cell",
                "type": "FitzHughNagumo1969Cell",
            },
            None,
        ),
        MemberSpec_(
            "pinsky_rinzel_ca3_cells",
            "PinskyRinzelCA3Cell",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "pinskyRinzelCA3Cell",
                "type": "PinskyRinzelCA3Cell",
            },
            None,
        ),
        MemberSpec_(
            "pulse_generators",
            "PulseGenerator",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "pulseGenerator",
                "type": "PulseGenerator",
            },
            None,
        ),
        MemberSpec_(
            "pulse_generator_dls",
            "PulseGeneratorDL",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "pulseGeneratorDL",
                "type": "PulseGeneratorDL",
            },
            None,
        ),
        MemberSpec_(
            "sine_generators",
            "SineGenerator",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "sineGenerator",
                "type": "SineGenerator",
            },
            None,
        ),
        MemberSpec_(
            "sine_generator_dls",
            "SineGeneratorDL",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "sineGeneratorDL",
                "type": "SineGeneratorDL",
            },
            None,
        ),
        MemberSpec_(
            "ramp_generators",
            "RampGenerator",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "rampGenerator",
                "type": "RampGenerator",
            },
            None,
        ),
        MemberSpec_(
            "ramp_generator_dls",
            "RampGeneratorDL",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "rampGeneratorDL",
                "type": "RampGeneratorDL",
            },
            None,
        ),
        MemberSpec_(
            "compound_inputs",
            "CompoundInput",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "compoundInput",
                "type": "CompoundInput",
            },
            None,
        ),
        MemberSpec_(
            "compound_input_dls",
            "CompoundInputDL",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "compoundInputDL",
                "type": "CompoundInputDL",
            },
            None,
        ),
        MemberSpec_(
            "voltage_clamps",
            "VoltageClamp",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "voltageClamp",
                "type": "VoltageClamp",
            },
            None,
        ),
        MemberSpec_(
            "voltage_clamp_triples",
            "VoltageClampTriple",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "voltageClampTriple",
                "type": "VoltageClampTriple",
            },
            None,
        ),
        MemberSpec_(
            "spike_arrays",
            "SpikeArray",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "spikeArray",
                "type": "SpikeArray",
            },
            None,
        ),
        MemberSpec_(
            "timed_synaptic_inputs",
            "TimedSynapticInput",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "timedSynapticInput",
                "type": "TimedSynapticInput",
            },
            None,
        ),
        MemberSpec_(
            "spike_generators",
            "SpikeGenerator",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "spikeGenerator",
                "type": "SpikeGenerator",
            },
            None,
        ),
        MemberSpec_(
            "spike_generator_randoms",
            "SpikeGeneratorRandom",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "spikeGeneratorRandom",
                "type": "SpikeGeneratorRandom",
            },
            None,
        ),
        MemberSpec_(
            "spike_generator_poissons",
            "SpikeGeneratorPoisson",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "spikeGeneratorPoisson",
                "type": "SpikeGeneratorPoisson",
            },
            None,
        ),
        MemberSpec_(
            "spike_generator_ref_poissons",
            "SpikeGeneratorRefPoisson",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "spikeGeneratorRefPoisson",
                "type": "SpikeGeneratorRefPoisson",
            },
            None,
        ),
        MemberSpec_(
            "poisson_firing_synapses",
            "PoissonFiringSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "poissonFiringSynapse",
                "type": "PoissonFiringSynapse",
            },
            None,
        ),
        MemberSpec_(
            "transient_poisson_firing_synapses",
            "TransientPoissonFiringSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "transientPoissonFiringSynapse",
                "type": "TransientPoissonFiringSynapse",
            },
            None,
        ),
        MemberSpec_(
            "IF_curr_alpha",
            "IF_curr_alpha",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "IF_curr_alpha",
                "type": "IF_curr_alpha",
            },
            None,
        ),
        MemberSpec_(
            "IF_curr_exp",
            "IF_curr_exp",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "IF_curr_exp",
                "type": "IF_curr_exp",
            },
            None,
        ),
        MemberSpec_(
            "IF_cond_alpha",
            "IF_cond_alpha",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "IF_cond_alpha",
                "type": "IF_cond_alpha",
            },
            None,
        ),
        MemberSpec_(
            "IF_cond_exp",
            "IF_cond_exp",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "IF_cond_exp",
                "type": "IF_cond_exp",
            },
            None,
        ),
        MemberSpec_(
            "EIF_cond_exp_isfa_ista",
            "EIF_cond_exp_isfa_ista",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "EIF_cond_exp_isfa_ista",
                "type": "EIF_cond_exp_isfa_ista",
            },
            None,
        ),
        MemberSpec_(
            "EIF_cond_alpha_isfa_ista",
            "EIF_cond_alpha_isfa_ista",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "EIF_cond_alpha_isfa_ista",
                "type": "EIF_cond_alpha_isfa_ista",
            },
            None,
        ),
        MemberSpec_(
            "HH_cond_exp",
            "HH_cond_exp",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "HH_cond_exp",
                "type": "HH_cond_exp",
            },
            None,
        ),
        MemberSpec_(
            "exp_cond_synapses",
            "ExpCondSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "expCondSynapse",
                "type": "ExpCondSynapse",
            },
            None,
        ),
        MemberSpec_(
            "alpha_cond_synapses",
            "AlphaCondSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "alphaCondSynapse",
                "type": "AlphaCondSynapse",
            },
            None,
        ),
        MemberSpec_(
            "exp_curr_synapses",
            "ExpCurrSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "expCurrSynapse",
                "type": "ExpCurrSynapse",
            },
            None,
        ),
        MemberSpec_(
            "alpha_curr_synapses",
            "AlphaCurrSynapse",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "alphaCurrSynapse",
                "type": "AlphaCurrSynapse",
            },
            None,
        ),
        MemberSpec_(
            "SpikeSourcePoisson",
            "SpikeSourcePoisson",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "SpikeSourcePoisson",
                "type": "SpikeSourcePoisson",
            },
            None,
        ),
        MemberSpec_(
            "networks",
            "Network",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "network",
                "type": "Network",
            },
            None,
        ),
        MemberSpec_(
            "ComponentType",
            "ComponentType",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "ComponentType",
                "type": "ComponentType",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Standalone

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        includes: "list of IncludeType(s) (optional)" = None,
        extracellular_properties: "list of ExtracellularProperties(s) (optional)" = None,
        intracellular_properties: "list of IntracellularProperties(s) (optional)" = None,
        morphology: "list of Morphology(s) (optional)" = None,
        ion_channel: "list of IonChannel(s) (optional)" = None,
        ion_channel_hhs: "list of IonChannelHH(s) (optional)" = None,
        ion_channel_v_shifts: "list of IonChannelVShift(s) (optional)" = None,
        ion_channel_kses: "list of IonChannelKS(s) (optional)" = None,
        decaying_pool_concentration_models: "list of DecayingPoolConcentrationModel(s) (optional)" = None,
        fixed_factor_concentration_models: "list of FixedFactorConcentrationModel(s) (optional)" = None,
        alpha_current_synapses: "list of AlphaCurrentSynapse(s) (optional)" = None,
        alpha_synapses: "list of AlphaSynapse(s) (optional)" = None,
        exp_one_synapses: "list of ExpOneSynapse(s) (optional)" = None,
        exp_two_synapses: "list of ExpTwoSynapse(s) (optional)" = None,
        exp_three_synapses: "list of ExpThreeSynapse(s) (optional)" = None,
        blocking_plastic_synapses: "list of BlockingPlasticSynapse(s) (optional)" = None,
        double_synapses: "list of DoubleSynapse(s) (optional)" = None,
        gap_junctions: "list of GapJunction(s) (optional)" = None,
        silent_synapses: "list of SilentSynapse(s) (optional)" = None,
        linear_graded_synapses: "list of LinearGradedSynapse(s) (optional)" = None,
        graded_synapses: "list of GradedSynapse(s) (optional)" = None,
        biophysical_properties: "list of BiophysicalProperties(s) (optional)" = None,
        cells: "list of Cell(s) (optional)" = None,
        cell2_ca_poolses: "list of Cell2CaPools(s) (optional)" = None,
        base_cells: "list of BaseCell(s) (optional)" = None,
        iaf_tau_cells: "list of IafTauCell(s) (optional)" = None,
        iaf_tau_ref_cells: "list of IafTauRefCell(s) (optional)" = None,
        iaf_cells: "list of IafCell(s) (optional)" = None,
        iaf_ref_cells: "list of IafRefCell(s) (optional)" = None,
        izhikevich_cells: "list of IzhikevichCell(s) (optional)" = None,
        izhikevich2007_cells: "list of Izhikevich2007Cell(s) (optional)" = None,
        ad_ex_ia_f_cells: "list of AdExIaFCell(s) (optional)" = None,
        fitz_hugh_nagumo_cells: "list of FitzHughNagumoCell(s) (optional)" = None,
        fitz_hugh_nagumo1969_cells: "list of FitzHughNagumo1969Cell(s) (optional)" = None,
        pinsky_rinzel_ca3_cells: "list of PinskyRinzelCA3Cell(s) (optional)" = None,
        pulse_generators: "list of PulseGenerator(s) (optional)" = None,
        pulse_generator_dls: "list of PulseGeneratorDL(s) (optional)" = None,
        sine_generators: "list of SineGenerator(s) (optional)" = None,
        sine_generator_dls: "list of SineGeneratorDL(s) (optional)" = None,
        ramp_generators: "list of RampGenerator(s) (optional)" = None,
        ramp_generator_dls: "list of RampGeneratorDL(s) (optional)" = None,
        compound_inputs: "list of CompoundInput(s) (optional)" = None,
        compound_input_dls: "list of CompoundInputDL(s) (optional)" = None,
        voltage_clamps: "list of VoltageClamp(s) (optional)" = None,
        voltage_clamp_triples: "list of VoltageClampTriple(s) (optional)" = None,
        spike_arrays: "list of SpikeArray(s) (optional)" = None,
        timed_synaptic_inputs: "list of TimedSynapticInput(s) (optional)" = None,
        spike_generators: "list of SpikeGenerator(s) (optional)" = None,
        spike_generator_randoms: "list of SpikeGeneratorRandom(s) (optional)" = None,
        spike_generator_poissons: "list of SpikeGeneratorPoisson(s) (optional)" = None,
        spike_generator_ref_poissons: "list of SpikeGeneratorRefPoisson(s) (optional)" = None,
        poisson_firing_synapses: "list of PoissonFiringSynapse(s) (optional)" = None,
        transient_poisson_firing_synapses: "list of TransientPoissonFiringSynapse(s) (optional)" = None,
        IF_curr_alpha: "list of IF_curr_alpha(s) (optional)" = None,
        IF_curr_exp: "list of IF_curr_exp(s) (optional)" = None,
        IF_cond_alpha: "list of IF_cond_alpha(s) (optional)" = None,
        IF_cond_exp: "list of IF_cond_exp(s) (optional)" = None,
        EIF_cond_exp_isfa_ista: "list of EIF_cond_exp_isfa_ista(s) (optional)" = None,
        EIF_cond_alpha_isfa_ista: "list of EIF_cond_alpha_isfa_ista(s) (optional)" = None,
        HH_cond_exp: "list of HH_cond_exp(s) (optional)" = None,
        exp_cond_synapses: "list of ExpCondSynapse(s) (optional)" = None,
        alpha_cond_synapses: "list of AlphaCondSynapse(s) (optional)" = None,
        exp_curr_synapses: "list of ExpCurrSynapse(s) (optional)" = None,
        alpha_curr_synapses: "list of AlphaCurrSynapse(s) (optional)" = None,
        SpikeSourcePoisson: "list of SpikeSourcePoisson(s) (optional)" = None,
        networks: "list of Network(s) (optional)" = None,
        ComponentType: "list of ComponentType(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("NeuroMLDocument"), self).__init__(
            id, metaid, notes, properties, annotation, **kwargs_
        )
        if includes is None:
            self.includes = []
        else:
            self.includes = includes
        self.includes_nsprefix_ = None
        if extracellular_properties is None:
            self.extracellular_properties = []
        else:
            self.extracellular_properties = extracellular_properties
        self.extracellular_properties_nsprefix_ = None
        if intracellular_properties is None:
            self.intracellular_properties = []
        else:
            self.intracellular_properties = intracellular_properties
        self.intracellular_properties_nsprefix_ = None
        if morphology is None:
            self.morphology = []
        else:
            self.morphology = morphology
        self.morphology_nsprefix_ = None
        if ion_channel is None:
            self.ion_channel = []
        else:
            self.ion_channel = ion_channel
        self.ion_channel_nsprefix_ = None
        if ion_channel_hhs is None:
            self.ion_channel_hhs = []
        else:
            self.ion_channel_hhs = ion_channel_hhs
        self.ion_channel_hhs_nsprefix_ = None
        if ion_channel_v_shifts is None:
            self.ion_channel_v_shifts = []
        else:
            self.ion_channel_v_shifts = ion_channel_v_shifts
        self.ion_channel_v_shifts_nsprefix_ = None
        if ion_channel_kses is None:
            self.ion_channel_kses = []
        else:
            self.ion_channel_kses = ion_channel_kses
        self.ion_channel_kses_nsprefix_ = None
        if decaying_pool_concentration_models is None:
            self.decaying_pool_concentration_models = []
        else:
            self.decaying_pool_concentration_models = decaying_pool_concentration_models
        self.decaying_pool_concentration_models_nsprefix_ = None
        if fixed_factor_concentration_models is None:
            self.fixed_factor_concentration_models = []
        else:
            self.fixed_factor_concentration_models = fixed_factor_concentration_models
        self.fixed_factor_concentration_models_nsprefix_ = None
        if alpha_current_synapses is None:
            self.alpha_current_synapses = []
        else:
            self.alpha_current_synapses = alpha_current_synapses
        self.alpha_current_synapses_nsprefix_ = None
        if alpha_synapses is None:
            self.alpha_synapses = []
        else:
            self.alpha_synapses = alpha_synapses
        self.alpha_synapses_nsprefix_ = None
        if exp_one_synapses is None:
            self.exp_one_synapses = []
        else:
            self.exp_one_synapses = exp_one_synapses
        self.exp_one_synapses_nsprefix_ = None
        if exp_two_synapses is None:
            self.exp_two_synapses = []
        else:
            self.exp_two_synapses = exp_two_synapses
        self.exp_two_synapses_nsprefix_ = None
        if exp_three_synapses is None:
            self.exp_three_synapses = []
        else:
            self.exp_three_synapses = exp_three_synapses
        self.exp_three_synapses_nsprefix_ = None
        if blocking_plastic_synapses is None:
            self.blocking_plastic_synapses = []
        else:
            self.blocking_plastic_synapses = blocking_plastic_synapses
        self.blocking_plastic_synapses_nsprefix_ = None
        if double_synapses is None:
            self.double_synapses = []
        else:
            self.double_synapses = double_synapses
        self.double_synapses_nsprefix_ = None
        if gap_junctions is None:
            self.gap_junctions = []
        else:
            self.gap_junctions = gap_junctions
        self.gap_junctions_nsprefix_ = None
        if silent_synapses is None:
            self.silent_synapses = []
        else:
            self.silent_synapses = silent_synapses
        self.silent_synapses_nsprefix_ = None
        if linear_graded_synapses is None:
            self.linear_graded_synapses = []
        else:
            self.linear_graded_synapses = linear_graded_synapses
        self.linear_graded_synapses_nsprefix_ = None
        if graded_synapses is None:
            self.graded_synapses = []
        else:
            self.graded_synapses = graded_synapses
        self.graded_synapses_nsprefix_ = None
        if biophysical_properties is None:
            self.biophysical_properties = []
        else:
            self.biophysical_properties = biophysical_properties
        self.biophysical_properties_nsprefix_ = None
        if cells is None:
            self.cells = []
        else:
            self.cells = cells
        self.cells_nsprefix_ = None
        if cell2_ca_poolses is None:
            self.cell2_ca_poolses = []
        else:
            self.cell2_ca_poolses = cell2_ca_poolses
        self.cell2_ca_poolses_nsprefix_ = None
        if base_cells is None:
            self.base_cells = []
        else:
            self.base_cells = base_cells
        self.base_cells_nsprefix_ = None
        if iaf_tau_cells is None:
            self.iaf_tau_cells = []
        else:
            self.iaf_tau_cells = iaf_tau_cells
        self.iaf_tau_cells_nsprefix_ = None
        if iaf_tau_ref_cells is None:
            self.iaf_tau_ref_cells = []
        else:
            self.iaf_tau_ref_cells = iaf_tau_ref_cells
        self.iaf_tau_ref_cells_nsprefix_ = None
        if iaf_cells is None:
            self.iaf_cells = []
        else:
            self.iaf_cells = iaf_cells
        self.iaf_cells_nsprefix_ = None
        if iaf_ref_cells is None:
            self.iaf_ref_cells = []
        else:
            self.iaf_ref_cells = iaf_ref_cells
        self.iaf_ref_cells_nsprefix_ = None
        if izhikevich_cells is None:
            self.izhikevich_cells = []
        else:
            self.izhikevich_cells = izhikevich_cells
        self.izhikevich_cells_nsprefix_ = None
        if izhikevich2007_cells is None:
            self.izhikevich2007_cells = []
        else:
            self.izhikevich2007_cells = izhikevich2007_cells
        self.izhikevich2007_cells_nsprefix_ = None
        if ad_ex_ia_f_cells is None:
            self.ad_ex_ia_f_cells = []
        else:
            self.ad_ex_ia_f_cells = ad_ex_ia_f_cells
        self.ad_ex_ia_f_cells_nsprefix_ = None
        if fitz_hugh_nagumo_cells is None:
            self.fitz_hugh_nagumo_cells = []
        else:
            self.fitz_hugh_nagumo_cells = fitz_hugh_nagumo_cells
        self.fitz_hugh_nagumo_cells_nsprefix_ = None
        if fitz_hugh_nagumo1969_cells is None:
            self.fitz_hugh_nagumo1969_cells = []
        else:
            self.fitz_hugh_nagumo1969_cells = fitz_hugh_nagumo1969_cells
        self.fitz_hugh_nagumo1969_cells_nsprefix_ = None
        if pinsky_rinzel_ca3_cells is None:
            self.pinsky_rinzel_ca3_cells = []
        else:
            self.pinsky_rinzel_ca3_cells = pinsky_rinzel_ca3_cells
        self.pinsky_rinzel_ca3_cells_nsprefix_ = None
        if pulse_generators is None:
            self.pulse_generators = []
        else:
            self.pulse_generators = pulse_generators
        self.pulse_generators_nsprefix_ = None
        if pulse_generator_dls is None:
            self.pulse_generator_dls = []
        else:
            self.pulse_generator_dls = pulse_generator_dls
        self.pulse_generator_dls_nsprefix_ = None
        if sine_generators is None:
            self.sine_generators = []
        else:
            self.sine_generators = sine_generators
        self.sine_generators_nsprefix_ = None
        if sine_generator_dls is None:
            self.sine_generator_dls = []
        else:
            self.sine_generator_dls = sine_generator_dls
        self.sine_generator_dls_nsprefix_ = None
        if ramp_generators is None:
            self.ramp_generators = []
        else:
            self.ramp_generators = ramp_generators
        self.ramp_generators_nsprefix_ = None
        if ramp_generator_dls is None:
            self.ramp_generator_dls = []
        else:
            self.ramp_generator_dls = ramp_generator_dls
        self.ramp_generator_dls_nsprefix_ = None
        if compound_inputs is None:
            self.compound_inputs = []
        else:
            self.compound_inputs = compound_inputs
        self.compound_inputs_nsprefix_ = None
        if compound_input_dls is None:
            self.compound_input_dls = []
        else:
            self.compound_input_dls = compound_input_dls
        self.compound_input_dls_nsprefix_ = None
        if voltage_clamps is None:
            self.voltage_clamps = []
        else:
            self.voltage_clamps = voltage_clamps
        self.voltage_clamps_nsprefix_ = None
        if voltage_clamp_triples is None:
            self.voltage_clamp_triples = []
        else:
            self.voltage_clamp_triples = voltage_clamp_triples
        self.voltage_clamp_triples_nsprefix_ = None
        if spike_arrays is None:
            self.spike_arrays = []
        else:
            self.spike_arrays = spike_arrays
        self.spike_arrays_nsprefix_ = None
        if timed_synaptic_inputs is None:
            self.timed_synaptic_inputs = []
        else:
            self.timed_synaptic_inputs = timed_synaptic_inputs
        self.timed_synaptic_inputs_nsprefix_ = None
        if spike_generators is None:
            self.spike_generators = []
        else:
            self.spike_generators = spike_generators
        self.spike_generators_nsprefix_ = None
        if spike_generator_randoms is None:
            self.spike_generator_randoms = []
        else:
            self.spike_generator_randoms = spike_generator_randoms
        self.spike_generator_randoms_nsprefix_ = None
        if spike_generator_poissons is None:
            self.spike_generator_poissons = []
        else:
            self.spike_generator_poissons = spike_generator_poissons
        self.spike_generator_poissons_nsprefix_ = None
        if spike_generator_ref_poissons is None:
            self.spike_generator_ref_poissons = []
        else:
            self.spike_generator_ref_poissons = spike_generator_ref_poissons
        self.spike_generator_ref_poissons_nsprefix_ = None
        if poisson_firing_synapses is None:
            self.poisson_firing_synapses = []
        else:
            self.poisson_firing_synapses = poisson_firing_synapses
        self.poisson_firing_synapses_nsprefix_ = None
        if transient_poisson_firing_synapses is None:
            self.transient_poisson_firing_synapses = []
        else:
            self.transient_poisson_firing_synapses = transient_poisson_firing_synapses
        self.transient_poisson_firing_synapses_nsprefix_ = None
        if IF_curr_alpha is None:
            self.IF_curr_alpha = []
        else:
            self.IF_curr_alpha = IF_curr_alpha
        self.IF_curr_alpha_nsprefix_ = None
        if IF_curr_exp is None:
            self.IF_curr_exp = []
        else:
            self.IF_curr_exp = IF_curr_exp
        self.IF_curr_exp_nsprefix_ = None
        if IF_cond_alpha is None:
            self.IF_cond_alpha = []
        else:
            self.IF_cond_alpha = IF_cond_alpha
        self.IF_cond_alpha_nsprefix_ = None
        if IF_cond_exp is None:
            self.IF_cond_exp = []
        else:
            self.IF_cond_exp = IF_cond_exp
        self.IF_cond_exp_nsprefix_ = None
        if EIF_cond_exp_isfa_ista is None:
            self.EIF_cond_exp_isfa_ista = []
        else:
            self.EIF_cond_exp_isfa_ista = EIF_cond_exp_isfa_ista
        self.EIF_cond_exp_isfa_ista_nsprefix_ = None
        if EIF_cond_alpha_isfa_ista is None:
            self.EIF_cond_alpha_isfa_ista = []
        else:
            self.EIF_cond_alpha_isfa_ista = EIF_cond_alpha_isfa_ista
        self.EIF_cond_alpha_isfa_ista_nsprefix_ = None
        if HH_cond_exp is None:
            self.HH_cond_exp = []
        else:
            self.HH_cond_exp = HH_cond_exp
        self.HH_cond_exp_nsprefix_ = None
        if exp_cond_synapses is None:
            self.exp_cond_synapses = []
        else:
            self.exp_cond_synapses = exp_cond_synapses
        self.exp_cond_synapses_nsprefix_ = None
        if alpha_cond_synapses is None:
            self.alpha_cond_synapses = []
        else:
            self.alpha_cond_synapses = alpha_cond_synapses
        self.alpha_cond_synapses_nsprefix_ = None
        if exp_curr_synapses is None:
            self.exp_curr_synapses = []
        else:
            self.exp_curr_synapses = exp_curr_synapses
        self.exp_curr_synapses_nsprefix_ = None
        if alpha_curr_synapses is None:
            self.alpha_curr_synapses = []
        else:
            self.alpha_curr_synapses = alpha_curr_synapses
        self.alpha_curr_synapses_nsprefix_ = None
        if SpikeSourcePoisson is None:
            self.SpikeSourcePoisson = []
        else:
            self.SpikeSourcePoisson = SpikeSourcePoisson
        self.SpikeSourcePoisson_nsprefix_ = None
        if networks is None:
            self.networks = []
        else:
            self.networks = networks
        self.networks_nsprefix_ = None
        if ComponentType is None:
            self.ComponentType = []
        else:
            self.ComponentType = ComponentType
        self.ComponentType_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, NeuroMLDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuroMLDocument.subclass:
            return NeuroMLDocument.subclass(*args_, **kwargs_)
        else:
            return NeuroMLDocument(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.includes
            or self.extracellular_properties
            or self.intracellular_properties
            or self.morphology
            or self.ion_channel
            or self.ion_channel_hhs
            or self.ion_channel_v_shifts
            or self.ion_channel_kses
            or self.decaying_pool_concentration_models
            or self.fixed_factor_concentration_models
            or self.alpha_current_synapses
            or self.alpha_synapses
            or self.exp_one_synapses
            or self.exp_two_synapses
            or self.exp_three_synapses
            or self.blocking_plastic_synapses
            or self.double_synapses
            or self.gap_junctions
            or self.silent_synapses
            or self.linear_graded_synapses
            or self.graded_synapses
            or self.biophysical_properties
            or self.cells
            or self.cell2_ca_poolses
            or self.base_cells
            or self.iaf_tau_cells
            or self.iaf_tau_ref_cells
            or self.iaf_cells
            or self.iaf_ref_cells
            or self.izhikevich_cells
            or self.izhikevich2007_cells
            or self.ad_ex_ia_f_cells
            or self.fitz_hugh_nagumo_cells
            or self.fitz_hugh_nagumo1969_cells
            or self.pinsky_rinzel_ca3_cells
            or self.pulse_generators
            or self.pulse_generator_dls
            or self.sine_generators
            or self.sine_generator_dls
            or self.ramp_generators
            or self.ramp_generator_dls
            or self.compound_inputs
            or self.compound_input_dls
            or self.voltage_clamps
            or self.voltage_clamp_triples
            or self.spike_arrays
            or self.timed_synaptic_inputs
            or self.spike_generators
            or self.spike_generator_randoms
            or self.spike_generator_poissons
            or self.spike_generator_ref_poissons
            or self.poisson_firing_synapses
            or self.transient_poisson_firing_synapses
            or self.IF_curr_alpha
            or self.IF_curr_exp
            or self.IF_cond_alpha
            or self.IF_cond_exp
            or self.EIF_cond_exp_isfa_ista
            or self.EIF_cond_alpha_isfa_ista
            or self.HH_cond_exp
            or self.exp_cond_synapses
            or self.alpha_cond_synapses
            or self.exp_curr_synapses
            or self.alpha_curr_synapses
            or self.SpikeSourcePoisson
            or self.networks
            or self.ComponentType
            or super(NeuroMLDocument, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="NeuroMLDocument",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("NeuroMLDocument")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "NeuroMLDocument":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="NeuroMLDocument"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="NeuroMLDocument",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="NeuroMLDocument",
    ):
        super(NeuroMLDocument, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="NeuroMLDocument"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="NeuroMLDocument",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(NeuroMLDocument, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for include_ in self.includes:
            namespaceprefix_ = (
                self.includes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.includes_nsprefix_)
                else ""
            )
            include_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="include",
                pretty_print=pretty_print,
            )
        for extracellularProperties_ in self.extracellular_properties:
            namespaceprefix_ = (
                self.extracellular_properties_nsprefix_ + ":"
                if (UseCapturedNS_ and self.extracellular_properties_nsprefix_)
                else ""
            )
            extracellularProperties_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="extracellularProperties",
                pretty_print=pretty_print,
            )
        for intracellularProperties_ in self.intracellular_properties:
            namespaceprefix_ = (
                self.intracellular_properties_nsprefix_ + ":"
                if (UseCapturedNS_ and self.intracellular_properties_nsprefix_)
                else ""
            )
            intracellularProperties_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="intracellularProperties",
                pretty_print=pretty_print,
            )
        for morphology_ in self.morphology:
            namespaceprefix_ = (
                self.morphology_nsprefix_ + ":"
                if (UseCapturedNS_ and self.morphology_nsprefix_)
                else ""
            )
            morphology_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="morphology",
                pretty_print=pretty_print,
            )
        for ionChannel_ in self.ion_channel:
            namespaceprefix_ = (
                self.ion_channel_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ion_channel_nsprefix_)
                else ""
            )
            ionChannel_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ionChannel",
                pretty_print=pretty_print,
            )
        for ionChannelHH_ in self.ion_channel_hhs:
            namespaceprefix_ = (
                self.ion_channel_hhs_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ion_channel_hhs_nsprefix_)
                else ""
            )
            ionChannelHH_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ionChannelHH",
                pretty_print=pretty_print,
            )
        for ionChannelVShift_ in self.ion_channel_v_shifts:
            namespaceprefix_ = (
                self.ion_channel_v_shifts_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ion_channel_v_shifts_nsprefix_)
                else ""
            )
            ionChannelVShift_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ionChannelVShift",
                pretty_print=pretty_print,
            )
        for ionChannelKS_ in self.ion_channel_kses:
            namespaceprefix_ = (
                self.ion_channel_kses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ion_channel_kses_nsprefix_)
                else ""
            )
            ionChannelKS_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ionChannelKS",
                pretty_print=pretty_print,
            )
        for decayingPoolConcentrationModel_ in self.decaying_pool_concentration_models:
            namespaceprefix_ = (
                self.decaying_pool_concentration_models_nsprefix_ + ":"
                if (
                    UseCapturedNS_ and self.decaying_pool_concentration_models_nsprefix_
                )
                else ""
            )
            decayingPoolConcentrationModel_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="decayingPoolConcentrationModel",
                pretty_print=pretty_print,
            )
        for fixedFactorConcentrationModel_ in self.fixed_factor_concentration_models:
            namespaceprefix_ = (
                self.fixed_factor_concentration_models_nsprefix_ + ":"
                if (UseCapturedNS_ and self.fixed_factor_concentration_models_nsprefix_)
                else ""
            )
            fixedFactorConcentrationModel_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="fixedFactorConcentrationModel",
                pretty_print=pretty_print,
            )
        for alphaCurrentSynapse_ in self.alpha_current_synapses:
            namespaceprefix_ = (
                self.alpha_current_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.alpha_current_synapses_nsprefix_)
                else ""
            )
            alphaCurrentSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="alphaCurrentSynapse",
                pretty_print=pretty_print,
            )
        for alphaSynapse_ in self.alpha_synapses:
            namespaceprefix_ = (
                self.alpha_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.alpha_synapses_nsprefix_)
                else ""
            )
            alphaSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="alphaSynapse",
                pretty_print=pretty_print,
            )
        for expOneSynapse_ in self.exp_one_synapses:
            namespaceprefix_ = (
                self.exp_one_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.exp_one_synapses_nsprefix_)
                else ""
            )
            expOneSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="expOneSynapse",
                pretty_print=pretty_print,
            )
        for expTwoSynapse_ in self.exp_two_synapses:
            namespaceprefix_ = (
                self.exp_two_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.exp_two_synapses_nsprefix_)
                else ""
            )
            expTwoSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="expTwoSynapse",
                pretty_print=pretty_print,
            )
        for expThreeSynapse_ in self.exp_three_synapses:
            namespaceprefix_ = (
                self.exp_three_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.exp_three_synapses_nsprefix_)
                else ""
            )
            expThreeSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="expThreeSynapse",
                pretty_print=pretty_print,
            )
        for blockingPlasticSynapse_ in self.blocking_plastic_synapses:
            namespaceprefix_ = (
                self.blocking_plastic_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.blocking_plastic_synapses_nsprefix_)
                else ""
            )
            blockingPlasticSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="blockingPlasticSynapse",
                pretty_print=pretty_print,
            )
        for doubleSynapse_ in self.double_synapses:
            namespaceprefix_ = (
                self.double_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.double_synapses_nsprefix_)
                else ""
            )
            doubleSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="doubleSynapse",
                pretty_print=pretty_print,
            )
        for gapJunction_ in self.gap_junctions:
            namespaceprefix_ = (
                self.gap_junctions_nsprefix_ + ":"
                if (UseCapturedNS_ and self.gap_junctions_nsprefix_)
                else ""
            )
            gapJunction_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="gapJunction",
                pretty_print=pretty_print,
            )
        for silentSynapse_ in self.silent_synapses:
            namespaceprefix_ = (
                self.silent_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.silent_synapses_nsprefix_)
                else ""
            )
            silentSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="silentSynapse",
                pretty_print=pretty_print,
            )
        for linearGradedSynapse_ in self.linear_graded_synapses:
            namespaceprefix_ = (
                self.linear_graded_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.linear_graded_synapses_nsprefix_)
                else ""
            )
            linearGradedSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="linearGradedSynapse",
                pretty_print=pretty_print,
            )
        for gradedSynapse_ in self.graded_synapses:
            namespaceprefix_ = (
                self.graded_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.graded_synapses_nsprefix_)
                else ""
            )
            gradedSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="gradedSynapse",
                pretty_print=pretty_print,
            )
        for biophysicalProperties_ in self.biophysical_properties:
            namespaceprefix_ = (
                self.biophysical_properties_nsprefix_ + ":"
                if (UseCapturedNS_ and self.biophysical_properties_nsprefix_)
                else ""
            )
            biophysicalProperties_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="biophysicalProperties",
                pretty_print=pretty_print,
            )
        for cell_ in self.cells:
            namespaceprefix_ = (
                self.cells_nsprefix_ + ":"
                if (UseCapturedNS_ and self.cells_nsprefix_)
                else ""
            )
            cell_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="cell",
                pretty_print=pretty_print,
            )
        for cell2CaPools_ in self.cell2_ca_poolses:
            namespaceprefix_ = (
                self.cell2_ca_poolses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.cell2_ca_poolses_nsprefix_)
                else ""
            )
            cell2CaPools_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="cell2CaPools",
                pretty_print=pretty_print,
            )
        for baseCell_ in self.base_cells:
            namespaceprefix_ = (
                self.base_cells_nsprefix_ + ":"
                if (UseCapturedNS_ and self.base_cells_nsprefix_)
                else ""
            )
            baseCell_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="baseCell",
                pretty_print=pretty_print,
            )
        for iafTauCell_ in self.iaf_tau_cells:
            namespaceprefix_ = (
                self.iaf_tau_cells_nsprefix_ + ":"
                if (UseCapturedNS_ and self.iaf_tau_cells_nsprefix_)
                else ""
            )
            iafTauCell_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="iafTauCell",
                pretty_print=pretty_print,
            )
        for iafTauRefCell_ in self.iaf_tau_ref_cells:
            namespaceprefix_ = (
                self.iaf_tau_ref_cells_nsprefix_ + ":"
                if (UseCapturedNS_ and self.iaf_tau_ref_cells_nsprefix_)
                else ""
            )
            iafTauRefCell_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="iafTauRefCell",
                pretty_print=pretty_print,
            )
        for iafCell_ in self.iaf_cells:
            namespaceprefix_ = (
                self.iaf_cells_nsprefix_ + ":"
                if (UseCapturedNS_ and self.iaf_cells_nsprefix_)
                else ""
            )
            iafCell_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="iafCell",
                pretty_print=pretty_print,
            )
        for iafRefCell_ in self.iaf_ref_cells:
            namespaceprefix_ = (
                self.iaf_ref_cells_nsprefix_ + ":"
                if (UseCapturedNS_ and self.iaf_ref_cells_nsprefix_)
                else ""
            )
            iafRefCell_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="iafRefCell",
                pretty_print=pretty_print,
            )
        for izhikevichCell_ in self.izhikevich_cells:
            namespaceprefix_ = (
                self.izhikevich_cells_nsprefix_ + ":"
                if (UseCapturedNS_ and self.izhikevich_cells_nsprefix_)
                else ""
            )
            izhikevichCell_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="izhikevichCell",
                pretty_print=pretty_print,
            )
        for izhikevich2007Cell_ in self.izhikevich2007_cells:
            namespaceprefix_ = (
                self.izhikevich2007_cells_nsprefix_ + ":"
                if (UseCapturedNS_ and self.izhikevich2007_cells_nsprefix_)
                else ""
            )
            izhikevich2007Cell_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="izhikevich2007Cell",
                pretty_print=pretty_print,
            )
        for adExIaFCell_ in self.ad_ex_ia_f_cells:
            namespaceprefix_ = (
                self.ad_ex_ia_f_cells_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ad_ex_ia_f_cells_nsprefix_)
                else ""
            )
            adExIaFCell_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="adExIaFCell",
                pretty_print=pretty_print,
            )
        for fitzHughNagumoCell_ in self.fitz_hugh_nagumo_cells:
            namespaceprefix_ = (
                self.fitz_hugh_nagumo_cells_nsprefix_ + ":"
                if (UseCapturedNS_ and self.fitz_hugh_nagumo_cells_nsprefix_)
                else ""
            )
            fitzHughNagumoCell_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="fitzHughNagumoCell",
                pretty_print=pretty_print,
            )
        for fitzHughNagumo1969Cell_ in self.fitz_hugh_nagumo1969_cells:
            namespaceprefix_ = (
                self.fitz_hugh_nagumo1969_cells_nsprefix_ + ":"
                if (UseCapturedNS_ and self.fitz_hugh_nagumo1969_cells_nsprefix_)
                else ""
            )
            fitzHughNagumo1969Cell_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="fitzHughNagumo1969Cell",
                pretty_print=pretty_print,
            )
        for pinskyRinzelCA3Cell_ in self.pinsky_rinzel_ca3_cells:
            namespaceprefix_ = (
                self.pinsky_rinzel_ca3_cells_nsprefix_ + ":"
                if (UseCapturedNS_ and self.pinsky_rinzel_ca3_cells_nsprefix_)
                else ""
            )
            pinskyRinzelCA3Cell_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="pinskyRinzelCA3Cell",
                pretty_print=pretty_print,
            )
        for pulseGenerator_ in self.pulse_generators:
            namespaceprefix_ = (
                self.pulse_generators_nsprefix_ + ":"
                if (UseCapturedNS_ and self.pulse_generators_nsprefix_)
                else ""
            )
            pulseGenerator_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="pulseGenerator",
                pretty_print=pretty_print,
            )
        for pulseGeneratorDL_ in self.pulse_generator_dls:
            namespaceprefix_ = (
                self.pulse_generator_dls_nsprefix_ + ":"
                if (UseCapturedNS_ and self.pulse_generator_dls_nsprefix_)
                else ""
            )
            pulseGeneratorDL_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="pulseGeneratorDL",
                pretty_print=pretty_print,
            )
        for sineGenerator_ in self.sine_generators:
            namespaceprefix_ = (
                self.sine_generators_nsprefix_ + ":"
                if (UseCapturedNS_ and self.sine_generators_nsprefix_)
                else ""
            )
            sineGenerator_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="sineGenerator",
                pretty_print=pretty_print,
            )
        for sineGeneratorDL_ in self.sine_generator_dls:
            namespaceprefix_ = (
                self.sine_generator_dls_nsprefix_ + ":"
                if (UseCapturedNS_ and self.sine_generator_dls_nsprefix_)
                else ""
            )
            sineGeneratorDL_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="sineGeneratorDL",
                pretty_print=pretty_print,
            )
        for rampGenerator_ in self.ramp_generators:
            namespaceprefix_ = (
                self.ramp_generators_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ramp_generators_nsprefix_)
                else ""
            )
            rampGenerator_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="rampGenerator",
                pretty_print=pretty_print,
            )
        for rampGeneratorDL_ in self.ramp_generator_dls:
            namespaceprefix_ = (
                self.ramp_generator_dls_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ramp_generator_dls_nsprefix_)
                else ""
            )
            rampGeneratorDL_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="rampGeneratorDL",
                pretty_print=pretty_print,
            )
        for compoundInput_ in self.compound_inputs:
            namespaceprefix_ = (
                self.compound_inputs_nsprefix_ + ":"
                if (UseCapturedNS_ and self.compound_inputs_nsprefix_)
                else ""
            )
            compoundInput_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="compoundInput",
                pretty_print=pretty_print,
            )
        for compoundInputDL_ in self.compound_input_dls:
            namespaceprefix_ = (
                self.compound_input_dls_nsprefix_ + ":"
                if (UseCapturedNS_ and self.compound_input_dls_nsprefix_)
                else ""
            )
            compoundInputDL_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="compoundInputDL",
                pretty_print=pretty_print,
            )
        for voltageClamp_ in self.voltage_clamps:
            namespaceprefix_ = (
                self.voltage_clamps_nsprefix_ + ":"
                if (UseCapturedNS_ and self.voltage_clamps_nsprefix_)
                else ""
            )
            voltageClamp_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="voltageClamp",
                pretty_print=pretty_print,
            )
        for voltageClampTriple_ in self.voltage_clamp_triples:
            namespaceprefix_ = (
                self.voltage_clamp_triples_nsprefix_ + ":"
                if (UseCapturedNS_ and self.voltage_clamp_triples_nsprefix_)
                else ""
            )
            voltageClampTriple_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="voltageClampTriple",
                pretty_print=pretty_print,
            )
        for spikeArray_ in self.spike_arrays:
            namespaceprefix_ = (
                self.spike_arrays_nsprefix_ + ":"
                if (UseCapturedNS_ and self.spike_arrays_nsprefix_)
                else ""
            )
            spikeArray_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="spikeArray",
                pretty_print=pretty_print,
            )
        for timedSynapticInput_ in self.timed_synaptic_inputs:
            namespaceprefix_ = (
                self.timed_synaptic_inputs_nsprefix_ + ":"
                if (UseCapturedNS_ and self.timed_synaptic_inputs_nsprefix_)
                else ""
            )
            timedSynapticInput_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="timedSynapticInput",
                pretty_print=pretty_print,
            )
        for spikeGenerator_ in self.spike_generators:
            namespaceprefix_ = (
                self.spike_generators_nsprefix_ + ":"
                if (UseCapturedNS_ and self.spike_generators_nsprefix_)
                else ""
            )
            spikeGenerator_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="spikeGenerator",
                pretty_print=pretty_print,
            )
        for spikeGeneratorRandom_ in self.spike_generator_randoms:
            namespaceprefix_ = (
                self.spike_generator_randoms_nsprefix_ + ":"
                if (UseCapturedNS_ and self.spike_generator_randoms_nsprefix_)
                else ""
            )
            spikeGeneratorRandom_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="spikeGeneratorRandom",
                pretty_print=pretty_print,
            )
        for spikeGeneratorPoisson_ in self.spike_generator_poissons:
            namespaceprefix_ = (
                self.spike_generator_poissons_nsprefix_ + ":"
                if (UseCapturedNS_ and self.spike_generator_poissons_nsprefix_)
                else ""
            )
            spikeGeneratorPoisson_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="spikeGeneratorPoisson",
                pretty_print=pretty_print,
            )
        for spikeGeneratorRefPoisson_ in self.spike_generator_ref_poissons:
            namespaceprefix_ = (
                self.spike_generator_ref_poissons_nsprefix_ + ":"
                if (UseCapturedNS_ and self.spike_generator_ref_poissons_nsprefix_)
                else ""
            )
            spikeGeneratorRefPoisson_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="spikeGeneratorRefPoisson",
                pretty_print=pretty_print,
            )
        for poissonFiringSynapse_ in self.poisson_firing_synapses:
            namespaceprefix_ = (
                self.poisson_firing_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.poisson_firing_synapses_nsprefix_)
                else ""
            )
            poissonFiringSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="poissonFiringSynapse",
                pretty_print=pretty_print,
            )
        for transientPoissonFiringSynapse_ in self.transient_poisson_firing_synapses:
            namespaceprefix_ = (
                self.transient_poisson_firing_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.transient_poisson_firing_synapses_nsprefix_)
                else ""
            )
            transientPoissonFiringSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="transientPoissonFiringSynapse",
                pretty_print=pretty_print,
            )
        for IF_curr_alpha_ in self.IF_curr_alpha:
            namespaceprefix_ = (
                self.IF_curr_alpha_nsprefix_ + ":"
                if (UseCapturedNS_ and self.IF_curr_alpha_nsprefix_)
                else ""
            )
            IF_curr_alpha_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="IF_curr_alpha",
                pretty_print=pretty_print,
            )
        for IF_curr_exp_ in self.IF_curr_exp:
            namespaceprefix_ = (
                self.IF_curr_exp_nsprefix_ + ":"
                if (UseCapturedNS_ and self.IF_curr_exp_nsprefix_)
                else ""
            )
            IF_curr_exp_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="IF_curr_exp",
                pretty_print=pretty_print,
            )
        for IF_cond_alpha_ in self.IF_cond_alpha:
            namespaceprefix_ = (
                self.IF_cond_alpha_nsprefix_ + ":"
                if (UseCapturedNS_ and self.IF_cond_alpha_nsprefix_)
                else ""
            )
            IF_cond_alpha_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="IF_cond_alpha",
                pretty_print=pretty_print,
            )
        for IF_cond_exp_ in self.IF_cond_exp:
            namespaceprefix_ = (
                self.IF_cond_exp_nsprefix_ + ":"
                if (UseCapturedNS_ and self.IF_cond_exp_nsprefix_)
                else ""
            )
            IF_cond_exp_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="IF_cond_exp",
                pretty_print=pretty_print,
            )
        for EIF_cond_exp_isfa_ista_ in self.EIF_cond_exp_isfa_ista:
            namespaceprefix_ = (
                self.EIF_cond_exp_isfa_ista_nsprefix_ + ":"
                if (UseCapturedNS_ and self.EIF_cond_exp_isfa_ista_nsprefix_)
                else ""
            )
            EIF_cond_exp_isfa_ista_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="EIF_cond_exp_isfa_ista",
                pretty_print=pretty_print,
            )
        for EIF_cond_alpha_isfa_ista_ in self.EIF_cond_alpha_isfa_ista:
            namespaceprefix_ = (
                self.EIF_cond_alpha_isfa_ista_nsprefix_ + ":"
                if (UseCapturedNS_ and self.EIF_cond_alpha_isfa_ista_nsprefix_)
                else ""
            )
            EIF_cond_alpha_isfa_ista_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="EIF_cond_alpha_isfa_ista",
                pretty_print=pretty_print,
            )
        for HH_cond_exp_ in self.HH_cond_exp:
            namespaceprefix_ = (
                self.HH_cond_exp_nsprefix_ + ":"
                if (UseCapturedNS_ and self.HH_cond_exp_nsprefix_)
                else ""
            )
            HH_cond_exp_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="HH_cond_exp",
                pretty_print=pretty_print,
            )
        for expCondSynapse_ in self.exp_cond_synapses:
            namespaceprefix_ = (
                self.exp_cond_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.exp_cond_synapses_nsprefix_)
                else ""
            )
            expCondSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="expCondSynapse",
                pretty_print=pretty_print,
            )
        for alphaCondSynapse_ in self.alpha_cond_synapses:
            namespaceprefix_ = (
                self.alpha_cond_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.alpha_cond_synapses_nsprefix_)
                else ""
            )
            alphaCondSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="alphaCondSynapse",
                pretty_print=pretty_print,
            )
        for expCurrSynapse_ in self.exp_curr_synapses:
            namespaceprefix_ = (
                self.exp_curr_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.exp_curr_synapses_nsprefix_)
                else ""
            )
            expCurrSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="expCurrSynapse",
                pretty_print=pretty_print,
            )
        for alphaCurrSynapse_ in self.alpha_curr_synapses:
            namespaceprefix_ = (
                self.alpha_curr_synapses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.alpha_curr_synapses_nsprefix_)
                else ""
            )
            alphaCurrSynapse_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="alphaCurrSynapse",
                pretty_print=pretty_print,
            )
        for SpikeSourcePoisson_ in self.SpikeSourcePoisson:
            namespaceprefix_ = (
                self.SpikeSourcePoisson_nsprefix_ + ":"
                if (UseCapturedNS_ and self.SpikeSourcePoisson_nsprefix_)
                else ""
            )
            SpikeSourcePoisson_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="SpikeSourcePoisson",
                pretty_print=pretty_print,
            )
        for network_ in self.networks:
            namespaceprefix_ = (
                self.networks_nsprefix_ + ":"
                if (UseCapturedNS_ and self.networks_nsprefix_)
                else ""
            )
            network_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="network",
                pretty_print=pretty_print,
            )
        for ComponentType_ in self.ComponentType:
            namespaceprefix_ = (
                self.ComponentType_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ComponentType_nsprefix_)
                else ""
            )
            ComponentType_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="ComponentType",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.includes, "includes", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.extracellular_properties,
            "extracellular_properties",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.intracellular_properties,
            "intracellular_properties",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.morphology, "morphology", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.ion_channel, "ion_channel", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.ion_channel_hhs, "ion_channel_hhs", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.ion_channel_v_shifts,
            "ion_channel_v_shifts",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.ion_channel_kses, "ion_channel_kses", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.decaying_pool_concentration_models,
            "decaying_pool_concentration_models",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.fixed_factor_concentration_models,
            "fixed_factor_concentration_models",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.alpha_current_synapses,
            "alpha_current_synapses",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.alpha_synapses, "alpha_synapses", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.exp_one_synapses, "exp_one_synapses", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.exp_two_synapses, "exp_two_synapses", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.exp_three_synapses,
            "exp_three_synapses",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.blocking_plastic_synapses,
            "blocking_plastic_synapses",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.double_synapses, "double_synapses", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.gap_junctions, "gap_junctions", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.silent_synapses, "silent_synapses", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.linear_graded_synapses,
            "linear_graded_synapses",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.graded_synapses, "graded_synapses", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.biophysical_properties,
            "biophysical_properties",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.cells, "cells", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.cell2_ca_poolses, "cell2_ca_poolses", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.base_cells, "base_cells", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.iaf_tau_cells, "iaf_tau_cells", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.iaf_tau_ref_cells,
            "iaf_tau_ref_cells",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.iaf_cells, "iaf_cells", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.iaf_ref_cells, "iaf_ref_cells", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.izhikevich_cells, "izhikevich_cells", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.izhikevich2007_cells,
            "izhikevich2007_cells",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.ad_ex_ia_f_cells, "ad_ex_ia_f_cells", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.fitz_hugh_nagumo_cells,
            "fitz_hugh_nagumo_cells",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.fitz_hugh_nagumo1969_cells,
            "fitz_hugh_nagumo1969_cells",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.pinsky_rinzel_ca3_cells,
            "pinsky_rinzel_ca3_cells",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.pulse_generators, "pulse_generators", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.pulse_generator_dls,
            "pulse_generator_dls",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.sine_generators, "sine_generators", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.sine_generator_dls,
            "sine_generator_dls",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.ramp_generators, "ramp_generators", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.ramp_generator_dls,
            "ramp_generator_dls",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.compound_inputs, "compound_inputs", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.compound_input_dls,
            "compound_input_dls",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.voltage_clamps, "voltage_clamps", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.voltage_clamp_triples,
            "voltage_clamp_triples",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.spike_arrays, "spike_arrays", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.timed_synaptic_inputs,
            "timed_synaptic_inputs",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.spike_generators, "spike_generators", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.spike_generator_randoms,
            "spike_generator_randoms",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.spike_generator_poissons,
            "spike_generator_poissons",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.spike_generator_ref_poissons,
            "spike_generator_ref_poissons",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.poisson_firing_synapses,
            "poisson_firing_synapses",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.transient_poisson_firing_synapses,
            "transient_poisson_firing_synapses",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.IF_curr_alpha, "IF_curr_alpha", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.IF_curr_exp, "IF_curr_exp", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.IF_cond_alpha, "IF_cond_alpha", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.IF_cond_exp, "IF_cond_exp", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.EIF_cond_exp_isfa_ista,
            "EIF_cond_exp_isfa_ista",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.EIF_cond_alpha_isfa_ista,
            "EIF_cond_alpha_isfa_ista",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.HH_cond_exp, "HH_cond_exp", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.exp_cond_synapses,
            "exp_cond_synapses",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.alpha_cond_synapses,
            "alpha_cond_synapses",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.exp_curr_synapses,
            "exp_curr_synapses",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.alpha_curr_synapses,
            "alpha_curr_synapses",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.SpikeSourcePoisson,
            "SpikeSourcePoisson",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.networks, "networks", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.ComponentType, "ComponentType", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.includes:
                item.validate_(gds_collector, recursive=True)
            for item in self.extracellular_properties:
                item.validate_(gds_collector, recursive=True)
            for item in self.intracellular_properties:
                item.validate_(gds_collector, recursive=True)
            for item in self.morphology:
                item.validate_(gds_collector, recursive=True)
            for item in self.ion_channel:
                item.validate_(gds_collector, recursive=True)
            for item in self.ion_channel_hhs:
                item.validate_(gds_collector, recursive=True)
            for item in self.ion_channel_v_shifts:
                item.validate_(gds_collector, recursive=True)
            for item in self.ion_channel_kses:
                item.validate_(gds_collector, recursive=True)
            for item in self.decaying_pool_concentration_models:
                item.validate_(gds_collector, recursive=True)
            for item in self.fixed_factor_concentration_models:
                item.validate_(gds_collector, recursive=True)
            for item in self.alpha_current_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.alpha_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.exp_one_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.exp_two_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.exp_three_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.blocking_plastic_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.double_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.gap_junctions:
                item.validate_(gds_collector, recursive=True)
            for item in self.silent_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.linear_graded_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.graded_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.biophysical_properties:
                item.validate_(gds_collector, recursive=True)
            for item in self.cells:
                item.validate_(gds_collector, recursive=True)
            for item in self.cell2_ca_poolses:
                item.validate_(gds_collector, recursive=True)
            for item in self.base_cells:
                item.validate_(gds_collector, recursive=True)
            for item in self.iaf_tau_cells:
                item.validate_(gds_collector, recursive=True)
            for item in self.iaf_tau_ref_cells:
                item.validate_(gds_collector, recursive=True)
            for item in self.iaf_cells:
                item.validate_(gds_collector, recursive=True)
            for item in self.iaf_ref_cells:
                item.validate_(gds_collector, recursive=True)
            for item in self.izhikevich_cells:
                item.validate_(gds_collector, recursive=True)
            for item in self.izhikevich2007_cells:
                item.validate_(gds_collector, recursive=True)
            for item in self.ad_ex_ia_f_cells:
                item.validate_(gds_collector, recursive=True)
            for item in self.fitz_hugh_nagumo_cells:
                item.validate_(gds_collector, recursive=True)
            for item in self.fitz_hugh_nagumo1969_cells:
                item.validate_(gds_collector, recursive=True)
            for item in self.pinsky_rinzel_ca3_cells:
                item.validate_(gds_collector, recursive=True)
            for item in self.pulse_generators:
                item.validate_(gds_collector, recursive=True)
            for item in self.pulse_generator_dls:
                item.validate_(gds_collector, recursive=True)
            for item in self.sine_generators:
                item.validate_(gds_collector, recursive=True)
            for item in self.sine_generator_dls:
                item.validate_(gds_collector, recursive=True)
            for item in self.ramp_generators:
                item.validate_(gds_collector, recursive=True)
            for item in self.ramp_generator_dls:
                item.validate_(gds_collector, recursive=True)
            for item in self.compound_inputs:
                item.validate_(gds_collector, recursive=True)
            for item in self.compound_input_dls:
                item.validate_(gds_collector, recursive=True)
            for item in self.voltage_clamps:
                item.validate_(gds_collector, recursive=True)
            for item in self.voltage_clamp_triples:
                item.validate_(gds_collector, recursive=True)
            for item in self.spike_arrays:
                item.validate_(gds_collector, recursive=True)
            for item in self.timed_synaptic_inputs:
                item.validate_(gds_collector, recursive=True)
            for item in self.spike_generators:
                item.validate_(gds_collector, recursive=True)
            for item in self.spike_generator_randoms:
                item.validate_(gds_collector, recursive=True)
            for item in self.spike_generator_poissons:
                item.validate_(gds_collector, recursive=True)
            for item in self.spike_generator_ref_poissons:
                item.validate_(gds_collector, recursive=True)
            for item in self.poisson_firing_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.transient_poisson_firing_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.IF_curr_alpha:
                item.validate_(gds_collector, recursive=True)
            for item in self.IF_curr_exp:
                item.validate_(gds_collector, recursive=True)
            for item in self.IF_cond_alpha:
                item.validate_(gds_collector, recursive=True)
            for item in self.IF_cond_exp:
                item.validate_(gds_collector, recursive=True)
            for item in self.EIF_cond_exp_isfa_ista:
                item.validate_(gds_collector, recursive=True)
            for item in self.EIF_cond_alpha_isfa_ista:
                item.validate_(gds_collector, recursive=True)
            for item in self.HH_cond_exp:
                item.validate_(gds_collector, recursive=True)
            for item in self.exp_cond_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.alpha_cond_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.exp_curr_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.alpha_curr_synapses:
                item.validate_(gds_collector, recursive=True)
            for item in self.SpikeSourcePoisson:
                item.validate_(gds_collector, recursive=True)
            for item in self.networks:
                item.validate_(gds_collector, recursive=True)
            for item in self.ComponentType:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(NeuroMLDocument, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "include":
            obj_ = IncludeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.includes.append(obj_)
            obj_.original_tagname_ = "include"
        elif nodeName_ == "extracellularProperties":
            obj_ = ExtracellularProperties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extracellular_properties.append(obj_)
            obj_.original_tagname_ = "extracellularProperties"
        elif nodeName_ == "intracellularProperties":
            class_obj_ = self.get_class_obj_(child_, IntracellularProperties)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intracellular_properties.append(obj_)
            obj_.original_tagname_ = "intracellularProperties"
        elif nodeName_ == "morphology":
            obj_ = Morphology.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.morphology.append(obj_)
            obj_.original_tagname_ = "morphology"
        elif nodeName_ == "ionChannel":
            class_obj_ = self.get_class_obj_(child_, IonChannel)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ion_channel.append(obj_)
            obj_.original_tagname_ = "ionChannel"
        elif nodeName_ == "ionChannelHH":
            obj_ = IonChannelHH.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ion_channel_hhs.append(obj_)
            obj_.original_tagname_ = "ionChannelHH"
        elif nodeName_ == "ionChannelVShift":
            obj_ = IonChannelVShift.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ion_channel_v_shifts.append(obj_)
            obj_.original_tagname_ = "ionChannelVShift"
        elif nodeName_ == "ionChannelKS":
            obj_ = IonChannelKS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ion_channel_kses.append(obj_)
            obj_.original_tagname_ = "ionChannelKS"
        elif nodeName_ == "decayingPoolConcentrationModel":
            class_obj_ = self.get_class_obj_(child_, DecayingPoolConcentrationModel)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.decaying_pool_concentration_models.append(obj_)
            obj_.original_tagname_ = "decayingPoolConcentrationModel"
        elif nodeName_ == "fixedFactorConcentrationModel":
            obj_ = FixedFactorConcentrationModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fixed_factor_concentration_models.append(obj_)
            obj_.original_tagname_ = "fixedFactorConcentrationModel"
        elif nodeName_ == "alphaCurrentSynapse":
            obj_ = AlphaCurrentSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alpha_current_synapses.append(obj_)
            obj_.original_tagname_ = "alphaCurrentSynapse"
        elif nodeName_ == "alphaSynapse":
            obj_ = AlphaSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alpha_synapses.append(obj_)
            obj_.original_tagname_ = "alphaSynapse"
        elif nodeName_ == "expOneSynapse":
            obj_ = ExpOneSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exp_one_synapses.append(obj_)
            obj_.original_tagname_ = "expOneSynapse"
        elif nodeName_ == "expTwoSynapse":
            class_obj_ = self.get_class_obj_(child_, ExpTwoSynapse)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exp_two_synapses.append(obj_)
            obj_.original_tagname_ = "expTwoSynapse"
        elif nodeName_ == "expThreeSynapse":
            obj_ = ExpThreeSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exp_three_synapses.append(obj_)
            obj_.original_tagname_ = "expThreeSynapse"
        elif nodeName_ == "blockingPlasticSynapse":
            obj_ = BlockingPlasticSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.blocking_plastic_synapses.append(obj_)
            obj_.original_tagname_ = "blockingPlasticSynapse"
        elif nodeName_ == "doubleSynapse":
            obj_ = DoubleSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.double_synapses.append(obj_)
            obj_.original_tagname_ = "doubleSynapse"
        elif nodeName_ == "gapJunction":
            obj_ = GapJunction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gap_junctions.append(obj_)
            obj_.original_tagname_ = "gapJunction"
        elif nodeName_ == "silentSynapse":
            obj_ = SilentSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.silent_synapses.append(obj_)
            obj_.original_tagname_ = "silentSynapse"
        elif nodeName_ == "linearGradedSynapse":
            obj_ = LinearGradedSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.linear_graded_synapses.append(obj_)
            obj_.original_tagname_ = "linearGradedSynapse"
        elif nodeName_ == "gradedSynapse":
            obj_ = GradedSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.graded_synapses.append(obj_)
            obj_.original_tagname_ = "gradedSynapse"
        elif nodeName_ == "biophysicalProperties":
            obj_ = BiophysicalProperties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.biophysical_properties.append(obj_)
            obj_.original_tagname_ = "biophysicalProperties"
        elif nodeName_ == "cell":
            class_obj_ = self.get_class_obj_(child_, Cell)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cells.append(obj_)
            obj_.original_tagname_ = "cell"
        elif nodeName_ == "cell2CaPools":
            obj_ = Cell2CaPools.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cell2_ca_poolses.append(obj_)
            obj_.original_tagname_ = "cell2CaPools"
        elif nodeName_ == "baseCell":
            class_obj_ = self.get_class_obj_(child_, BaseCell)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.base_cells.append(obj_)
            obj_.original_tagname_ = "baseCell"
        elif nodeName_ == "iafTauCell":
            class_obj_ = self.get_class_obj_(child_, IafTauCell)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iaf_tau_cells.append(obj_)
            obj_.original_tagname_ = "iafTauCell"
        elif nodeName_ == "iafTauRefCell":
            obj_ = IafTauRefCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iaf_tau_ref_cells.append(obj_)
            obj_.original_tagname_ = "iafTauRefCell"
        elif nodeName_ == "iafCell":
            class_obj_ = self.get_class_obj_(child_, IafCell)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iaf_cells.append(obj_)
            obj_.original_tagname_ = "iafCell"
        elif nodeName_ == "iafRefCell":
            obj_ = IafRefCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iaf_ref_cells.append(obj_)
            obj_.original_tagname_ = "iafRefCell"
        elif nodeName_ == "izhikevichCell":
            obj_ = IzhikevichCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.izhikevich_cells.append(obj_)
            obj_.original_tagname_ = "izhikevichCell"
        elif nodeName_ == "izhikevich2007Cell":
            obj_ = Izhikevich2007Cell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.izhikevich2007_cells.append(obj_)
            obj_.original_tagname_ = "izhikevich2007Cell"
        elif nodeName_ == "adExIaFCell":
            obj_ = AdExIaFCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ad_ex_ia_f_cells.append(obj_)
            obj_.original_tagname_ = "adExIaFCell"
        elif nodeName_ == "fitzHughNagumoCell":
            obj_ = FitzHughNagumoCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fitz_hugh_nagumo_cells.append(obj_)
            obj_.original_tagname_ = "fitzHughNagumoCell"
        elif nodeName_ == "fitzHughNagumo1969Cell":
            obj_ = FitzHughNagumo1969Cell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fitz_hugh_nagumo1969_cells.append(obj_)
            obj_.original_tagname_ = "fitzHughNagumo1969Cell"
        elif nodeName_ == "pinskyRinzelCA3Cell":
            obj_ = PinskyRinzelCA3Cell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pinsky_rinzel_ca3_cells.append(obj_)
            obj_.original_tagname_ = "pinskyRinzelCA3Cell"
        elif nodeName_ == "pulseGenerator":
            obj_ = PulseGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pulse_generators.append(obj_)
            obj_.original_tagname_ = "pulseGenerator"
        elif nodeName_ == "pulseGeneratorDL":
            obj_ = PulseGeneratorDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pulse_generator_dls.append(obj_)
            obj_.original_tagname_ = "pulseGeneratorDL"
        elif nodeName_ == "sineGenerator":
            obj_ = SineGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sine_generators.append(obj_)
            obj_.original_tagname_ = "sineGenerator"
        elif nodeName_ == "sineGeneratorDL":
            obj_ = SineGeneratorDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sine_generator_dls.append(obj_)
            obj_.original_tagname_ = "sineGeneratorDL"
        elif nodeName_ == "rampGenerator":
            obj_ = RampGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ramp_generators.append(obj_)
            obj_.original_tagname_ = "rampGenerator"
        elif nodeName_ == "rampGeneratorDL":
            obj_ = RampGeneratorDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ramp_generator_dls.append(obj_)
            obj_.original_tagname_ = "rampGeneratorDL"
        elif nodeName_ == "compoundInput":
            obj_ = CompoundInput.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.compound_inputs.append(obj_)
            obj_.original_tagname_ = "compoundInput"
        elif nodeName_ == "compoundInputDL":
            obj_ = CompoundInputDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.compound_input_dls.append(obj_)
            obj_.original_tagname_ = "compoundInputDL"
        elif nodeName_ == "voltageClamp":
            obj_ = VoltageClamp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.voltage_clamps.append(obj_)
            obj_.original_tagname_ = "voltageClamp"
        elif nodeName_ == "voltageClampTriple":
            obj_ = VoltageClampTriple.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.voltage_clamp_triples.append(obj_)
            obj_.original_tagname_ = "voltageClampTriple"
        elif nodeName_ == "spikeArray":
            obj_ = SpikeArray.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spike_arrays.append(obj_)
            obj_.original_tagname_ = "spikeArray"
        elif nodeName_ == "timedSynapticInput":
            obj_ = TimedSynapticInput.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timed_synaptic_inputs.append(obj_)
            obj_.original_tagname_ = "timedSynapticInput"
        elif nodeName_ == "spikeGenerator":
            obj_ = SpikeGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spike_generators.append(obj_)
            obj_.original_tagname_ = "spikeGenerator"
        elif nodeName_ == "spikeGeneratorRandom":
            obj_ = SpikeGeneratorRandom.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spike_generator_randoms.append(obj_)
            obj_.original_tagname_ = "spikeGeneratorRandom"
        elif nodeName_ == "spikeGeneratorPoisson":
            class_obj_ = self.get_class_obj_(child_, SpikeGeneratorPoisson)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spike_generator_poissons.append(obj_)
            obj_.original_tagname_ = "spikeGeneratorPoisson"
        elif nodeName_ == "spikeGeneratorRefPoisson":
            obj_ = SpikeGeneratorRefPoisson.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spike_generator_ref_poissons.append(obj_)
            obj_.original_tagname_ = "spikeGeneratorRefPoisson"
        elif nodeName_ == "poissonFiringSynapse":
            obj_ = PoissonFiringSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.poisson_firing_synapses.append(obj_)
            obj_.original_tagname_ = "poissonFiringSynapse"
        elif nodeName_ == "transientPoissonFiringSynapse":
            obj_ = TransientPoissonFiringSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transient_poisson_firing_synapses.append(obj_)
            obj_.original_tagname_ = "transientPoissonFiringSynapse"
        elif nodeName_ == "IF_curr_alpha":
            obj_ = IF_curr_alpha.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IF_curr_alpha.append(obj_)
            obj_.original_tagname_ = "IF_curr_alpha"
        elif nodeName_ == "IF_curr_exp":
            obj_ = IF_curr_exp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IF_curr_exp.append(obj_)
            obj_.original_tagname_ = "IF_curr_exp"
        elif nodeName_ == "IF_cond_alpha":
            obj_ = IF_cond_alpha.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IF_cond_alpha.append(obj_)
            obj_.original_tagname_ = "IF_cond_alpha"
        elif nodeName_ == "IF_cond_exp":
            obj_ = IF_cond_exp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IF_cond_exp.append(obj_)
            obj_.original_tagname_ = "IF_cond_exp"
        elif nodeName_ == "EIF_cond_exp_isfa_ista":
            class_obj_ = self.get_class_obj_(child_, EIF_cond_exp_isfa_ista)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EIF_cond_exp_isfa_ista.append(obj_)
            obj_.original_tagname_ = "EIF_cond_exp_isfa_ista"
        elif nodeName_ == "EIF_cond_alpha_isfa_ista":
            obj_ = EIF_cond_alpha_isfa_ista.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EIF_cond_alpha_isfa_ista.append(obj_)
            obj_.original_tagname_ = "EIF_cond_alpha_isfa_ista"
        elif nodeName_ == "HH_cond_exp":
            obj_ = HH_cond_exp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HH_cond_exp.append(obj_)
            obj_.original_tagname_ = "HH_cond_exp"
        elif nodeName_ == "expCondSynapse":
            obj_ = ExpCondSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exp_cond_synapses.append(obj_)
            obj_.original_tagname_ = "expCondSynapse"
        elif nodeName_ == "alphaCondSynapse":
            obj_ = AlphaCondSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alpha_cond_synapses.append(obj_)
            obj_.original_tagname_ = "alphaCondSynapse"
        elif nodeName_ == "expCurrSynapse":
            obj_ = ExpCurrSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exp_curr_synapses.append(obj_)
            obj_.original_tagname_ = "expCurrSynapse"
        elif nodeName_ == "alphaCurrSynapse":
            obj_ = AlphaCurrSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alpha_curr_synapses.append(obj_)
            obj_.original_tagname_ = "alphaCurrSynapse"
        elif nodeName_ == "SpikeSourcePoisson":
            obj_ = SpikeSourcePoisson.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SpikeSourcePoisson.append(obj_)
            obj_.original_tagname_ = "SpikeSourcePoisson"
        elif nodeName_ == "network":
            obj_ = Network.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.networks.append(obj_)
            obj_.original_tagname_ = "network"
        elif nodeName_ == "ComponentType":
            obj_ = ComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ComponentType.append(obj_)
            obj_.original_tagname_ = "ComponentType"
        super(NeuroMLDocument, self)._buildChildren(child_, node, nodeName_, True)

    def summary(self, show_includes=True, show_non_network=True):
        """Get a pretty-printed summary of the complete NeuroMLDocument.

        This includes information on the various Components included in the
        NeuroMLDocument: networks, cells, projections, synapses, and so on.
        """

        info = "*******************************************************\n"
        info += "* NeuroMLDocument: " + self.id + "\n*\n"
        post = ""
        membs = inspect.getmembers(self)
        for memb in membs:
            if (
                isinstance(memb[1], list)
                and len(memb[1]) > 0
                and not memb[0].endswith("_")
                and not memb[0] == "networks"
            ):
                if (memb[0] == "includes" and show_includes) or (
                    not memb[0] == "includes" and show_non_network
                ):
                    post = "*\n"
                    info += "*  " + str(memb[1][0].__class__.__name__) + ": "
                    listed = []
                    for entry in memb[1]:
                        if hasattr(entry, "id"):
                            listed.append(str(entry.id))
                        elif hasattr(entry, "name"):
                            listed.append(str(entry.name))
                        elif hasattr(entry, "href"):
                            listed.append(str(entry.href))
                        elif hasattr(entry, "tag"):
                            listed.append(str(entry.tag) + " = " + str(entry.value))
                    info += str(sorted(listed)) + "\n"
        info += post

        for network in self.networks:
            info += "*  Network: " + network.id
            if network.temperature:
                info += " (temperature: " + network.temperature + ")"
            info += "\n*\n"
            tot_pop = 0
            tot_cells = 0
            pop_info = ""
            for pop in sorted(network.populations, key=lambda x: x.id):
                pop_info += "*     " + str(pop) + "\n"
                tot_pop += 1
                tot_cells += pop.get_size()
                if len(pop.instances) > 0:
                    loc = pop.instances[0].location
                    pop_info += "*       Locations: [" + str(loc) + ", ...]\n"
                if len(pop.properties) > 0:
                    pop_info += "*       Properties: "
                    for p in pop.properties:
                        pop_info += str(p.tag) + "=" + str(p.value) + "; "
                    pop_info += "\n"

            info += (
                "*   "
                + str(tot_cells)
                + " cells in "
                + str(tot_pop)
                + " populations \n"
                + pop_info
                + "*\n"
            )

            tot_proj = 0
            tot_conns = 0

            proj_info = ""
            for proj in sorted(network.projections, key=lambda x: x.id):
                proj_info += "*     " + str(proj) + "\n"
                tot_proj += 1
                tot_conns += len(proj.connections)
                tot_conns += len(proj.connection_wds)
                if len(proj.connections) > 0:
                    proj_info += (
                        "*       "
                        + str(len(proj.connections))
                        + " connections: [("
                        + str(proj.connections[0])
                        + "), ...]\n"
                    )
                if len(proj.connection_wds) > 0:
                    proj_info += (
                        "*       "
                        + str(len(proj.connection_wds))
                        + " connections (wd): [("
                        + str(proj.connection_wds[0])
                        + "), ...]\n"
                    )

            for proj in sorted(network.electrical_projections, key=lambda x: x.id):
                proj_info += (
                    "*     Electrical projection: "
                    + proj.id
                    + " from "
                    + proj.presynaptic_population
                    + " to "
                    + proj.postsynaptic_population
                    + "\n"
                )
                tot_proj += 1
                tot_conns += len(proj.electrical_connections)
                tot_conns += len(proj.electrical_connection_instances)
                tot_conns += len(proj.electrical_connection_instance_ws)
                if len(proj.electrical_connections) > 0:
                    proj_info += (
                        "*       "
                        + str(len(proj.electrical_connections))
                        + " connections: [("
                        + str(proj.electrical_connections[0])
                        + "), ...]\n"
                    )
                if len(proj.electrical_connection_instances) > 0:
                    proj_info += (
                        "*       "
                        + str(len(proj.electrical_connection_instances))
                        + " connections: [("
                        + str(proj.electrical_connection_instances[0])
                        + "), ...]\n"
                    )
                if len(proj.electrical_connection_instance_ws) > 0:
                    proj_info += (
                        "*       "
                        + str(len(proj.electrical_connection_instance_ws))
                        + " connections: [("
                        + str(proj.electrical_connection_instance_ws[0])
                        + "), ...]\n"
                    )

            for proj in sorted(network.continuous_projections, key=lambda x: x.id):
                proj_info += (
                    "*     Continuous projection: "
                    + proj.id
                    + " from "
                    + proj.presynaptic_population
                    + " to "
                    + proj.postsynaptic_population
                    + "\n"
                )
                tot_proj += 1
                tot_conns += len(proj.continuous_connections)
                tot_conns += len(proj.continuous_connection_instances)
                tot_conns += len(proj.continuous_connection_instance_ws)
                if len(proj.continuous_connections) > 0:
                    proj_info += (
                        "*       "
                        + str(len(proj.continuous_connections))
                        + " connections: [("
                        + str(proj.continuous_connections[0])
                        + "), ...]\n"
                    )
                if len(proj.continuous_connection_instances) > 0:
                    proj_info += (
                        "*       "
                        + str(len(proj.continuous_connection_instances))
                        + " connections: [("
                        + str(proj.continuous_connection_instances[0])
                        + "), ...]\n"
                    )
                if len(proj.continuous_connection_instance_ws) > 0:
                    proj_info += (
                        "*       "
                        + str(len(proj.continuous_connection_instance_ws))
                        + " connections (w): [("
                        + str(proj.continuous_connection_instance_ws[0])
                        + "), ...]\n"
                    )

            info += (
                "*   "
                + str(tot_conns)
                + " connections in "
                + str(tot_proj)
                + " projections \n"
                + proj_info
                + "*\n"
            )

            if len(network.synaptic_connections) > 0:
                info += (
                    "*   "
                    + str(len(network.synaptic_connections))
                    + " explicit synaptic connections (outside of projections)\n"
                )
                for sc in network.synaptic_connections:
                    info += "*     " + str(sc) + "\n"
                info += "*\n"

            tot_input_lists = 0
            tot_inputs = 0
            input_info = ""
            for il in sorted(network.input_lists, key=lambda x: x.id):
                input_info += "*     " + str(il) + "\n"
                tot_input_lists += 1
                if len(il.input) > 0:
                    input_info += (
                        "*       "
                        + str(len(il.input))
                        + " inputs: [("
                        + str(il.input[0])
                        + "), ...]\n"
                    )
                    tot_inputs += len(il.input)
                if len(il.input_ws) > 0:
                    input_info += (
                        "*       "
                        + str(len(il.input_ws))
                        + " inputs: [("
                        + str(il.input_ws[0])
                        + "), ...]\n"
                    )
                    tot_inputs += len(il.input_ws)

            info += (
                "*   "
                + str(tot_inputs)
                + " inputs in "
                + str(tot_input_lists)
                + " input lists \n"
                + input_info
                + "*\n"
            )

            if len(network.explicit_inputs) > 0:
                info += (
                    "*   "
                    + str(len(network.explicit_inputs))
                    + " explicit inputs (outside of input lists)\n"
                )
                for el in network.explicit_inputs:
                    info += "*     " + str(el) + "\n"
                info += "*\n"

        info += "*******************************************************"

        return info

    warn_count = 0

    def get_by_id(self, id):
        """Get a component by specifying its ID.

        :param id: id of Component to get
        :type id: str
        :returns: Component with given ID or None if no Component with provided ID was found
        """
        if len(id) == 0:
            callframe = inspect.getouterframes(inspect.currentframe(), 2)
            print(
                "Method: " + callframe[1][3] + " is asking for an element with no id..."
            )

            return None
        all_ids = []
        for ms in self.member_data_items_:
            mlist = getattr(self, ms.get_name())
            # TODO: debug why this is required
            if mlist is None:
                continue
            for m in mlist:
                if hasattr(m, "id"):
                    if m.id == id:
                        return m
                    else:
                        all_ids.append(m.id)
        if self.warn_count < 10:
            neuroml.print_(
                "Id "
                + id
                + " not found in <neuroml> element. All ids: "
                + str(sorted(all_ids))
            )
            self.warn_count += 1
        elif self.warn_count == 10:
            neuroml.print_(" - Suppressing further warnings about id not found...")
        return None

    def append(self, element):
        """Append an element

        :param element: element to append
        :type element: Object
        """
        self.add(element)

    # end class NeuroMLDocument


class NamedDimensionalVariable(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("name", "xs:string", 0, 0, {"use": "required", "name": "name"}),
        MemberSpec_(
            "dimension", "xs:string", 0, 0, {"use": "required", "name": "dimension"}
        ),
        MemberSpec_(
            "description", "xs:string", 0, 1, {"use": "optional", "name": "description"}
        ),
        MemberSpec_(
            "exposure", "xs:string", 0, 1, {"use": "optional", "name": "exposure"}
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        name: "a string (required)" = None,
        dimension: "a string (required)" = None,
        description: "a string (optional)" = None,
        exposure: "a string (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("NamedDimensionalVariable"), self).__init__(
            extensiontype_, **kwargs_
        )
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.dimension = _cast(None, dimension)
        self.dimension_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.exposure = _cast(None, exposure)
        self.exposure_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamedDimensionalVariable
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamedDimensionalVariable.subclass:
            return NamedDimensionalVariable.subclass(*args_, **kwargs_)
        else:
            return NamedDimensionalVariable(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(NamedDimensionalVariable, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="NamedDimensionalVariable",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("NamedDimensionalVariable")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "NamedDimensionalVariable":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="NamedDimensionalVariable",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="NamedDimensionalVariable",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="NamedDimensionalVariable",
    ):
        super(NamedDimensionalVariable, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="NamedDimensionalVariable",
        )
        if self.name is not None and "name" not in already_processed:
            already_processed.add("name")
            outfile.write(
                " name=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.name), input_name="name"
                        )
                    ),
                )
            )
        if self.dimension is not None and "dimension" not in already_processed:
            already_processed.add("dimension")
            outfile.write(
                " dimension=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.dimension), input_name="dimension"
                        )
                    ),
                )
            )
        if self.description is not None and "description" not in already_processed:
            already_processed.add("description")
            outfile.write(
                " description=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.description), input_name="description"
                        )
                    ),
                )
            )
        if self.exposure is not None and "exposure" not in already_processed:
            already_processed.add("exposure")
            outfile.write(
                " exposure=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.exposure), input_name="exposure"
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="NamedDimensionalVariable",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(NamedDimensionalVariable, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.name, "name")
        self.gds_check_cardinality_(self.name, "name", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.dimension, "dimension"
        )
        self.gds_check_cardinality_(self.dimension, "dimension", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.description, "description"
        )
        self.gds_check_cardinality_(self.description, "description", required=False)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.exposure, "exposure"
        )
        self.gds_check_cardinality_(self.exposure, "exposure", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("name", node)
        if value is not None and "name" not in already_processed:
            already_processed.add("name")
            self.name = value
        value = find_attr_value_("dimension", node)
        if value is not None and "dimension" not in already_processed:
            already_processed.add("dimension")
            self.dimension = value
        value = find_attr_value_("description", node)
        if value is not None and "description" not in already_processed:
            already_processed.add("description")
            self.description = value
        value = find_attr_value_("exposure", node)
        if value is not None and "exposure" not in already_processed:
            already_processed.add("exposure")
            self.exposure = value
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(NamedDimensionalVariable, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(NamedDimensionalVariable, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class NamedDimensionalVariable


class NamedDimensionalType(BaseWithoutId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("name", "xs:string", 0, 0, {"use": "required", "name": "name"}),
        MemberSpec_(
            "dimension", "xs:string", 0, 0, {"use": "required", "name": "dimension"}
        ),
        MemberSpec_(
            "description", "xs:string", 0, 1, {"use": "optional", "name": "description"}
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        name: "a string (required)" = None,
        dimension: "a string (required)" = None,
        description: "a string (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("NamedDimensionalType"), self).__init__(
            extensiontype_, **kwargs_
        )
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.dimension = _cast(None, dimension)
        self.dimension_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamedDimensionalType
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamedDimensionalType.subclass:
            return NamedDimensionalType.subclass(*args_, **kwargs_)
        else:
            return NamedDimensionalType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(NamedDimensionalType, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="NamedDimensionalType",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("NamedDimensionalType")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "NamedDimensionalType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="NamedDimensionalType",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="NamedDimensionalType",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="NamedDimensionalType",
    ):
        super(NamedDimensionalType, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="NamedDimensionalType",
        )
        if self.name is not None and "name" not in already_processed:
            already_processed.add("name")
            outfile.write(
                " name=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.name), input_name="name"
                        )
                    ),
                )
            )
        if self.dimension is not None and "dimension" not in already_processed:
            already_processed.add("dimension")
            outfile.write(
                " dimension=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.dimension), input_name="dimension"
                        )
                    ),
                )
            )
        if self.description is not None and "description" not in already_processed:
            already_processed.add("description")
            outfile.write(
                " description=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.description), input_name="description"
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="NamedDimensionalType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(NamedDimensionalType, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.name, "name")
        self.gds_check_cardinality_(self.name, "name", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.dimension, "dimension"
        )
        self.gds_check_cardinality_(self.dimension, "dimension", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.description, "description"
        )
        self.gds_check_cardinality_(self.description, "description", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("name", node)
        if value is not None and "name" not in already_processed:
            already_processed.add("name")
            self.name = value
        value = find_attr_value_("dimension", node)
        if value is not None and "dimension" not in already_processed:
            already_processed.add("dimension")
            self.dimension = value
        value = find_attr_value_("description", node)
        if value is not None and "description" not in already_processed:
            already_processed.add("description")
            self.description = value
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(NamedDimensionalType, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(NamedDimensionalType, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class NamedDimensionalType


class Exposure(BaseWithoutId):
    """Exposure -- LEMS Exposure (ComponentType property)"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("name", "xs:string", 0, 0, {"use": "required", "name": "name"}),
        MemberSpec_(
            "dimension", "xs:string", 0, 0, {"use": "required", "name": "dimension"}
        ),
        MemberSpec_(
            "description", "xs:string", 0, 1, {"use": "optional", "name": "description"}
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        name: "a string (required)" = None,
        dimension: "a string (required)" = None,
        description: "a string (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Exposure"), self).__init__(**kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.dimension = _cast(None, dimension)
        self.dimension_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Exposure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Exposure.subclass:
            return Exposure.subclass(*args_, **kwargs_)
        else:
            return Exposure(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(Exposure, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Exposure",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Exposure")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Exposure":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Exposure"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Exposure",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Exposure"
    ):
        super(Exposure, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Exposure"
        )
        if self.name is not None and "name" not in already_processed:
            already_processed.add("name")
            outfile.write(
                " name=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.name), input_name="name"
                        )
                    ),
                )
            )
        if self.dimension is not None and "dimension" not in already_processed:
            already_processed.add("dimension")
            outfile.write(
                " dimension=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.dimension), input_name="dimension"
                        )
                    ),
                )
            )
        if self.description is not None and "description" not in already_processed:
            already_processed.add("description")
            outfile.write(
                " description=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.description), input_name="description"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Exposure",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Exposure, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.name, "name")
        self.gds_check_cardinality_(self.name, "name", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.dimension, "dimension"
        )
        self.gds_check_cardinality_(self.dimension, "dimension", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.description, "description"
        )
        self.gds_check_cardinality_(self.description, "description", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("name", node)
        if value is not None and "name" not in already_processed:
            already_processed.add("name")
            self.name = value
        value = find_attr_value_("dimension", node)
        if value is not None and "dimension" not in already_processed:
            already_processed.add("dimension")
            self.dimension = value
        value = find_attr_value_("description", node)
        if value is not None and "description" not in already_processed:
            already_processed.add("description")
            self.description = value
        super(Exposure, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Exposure, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class Exposure


class Constant(BaseWithoutId):
    """Constant -- LEMS ComponentType for Constant."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("name", "xs:string", 0, 0, {"use": "required", "name": "name"}),
        MemberSpec_(
            "dimension", "xs:string", 0, 0, {"use": "required", "name": "dimension"}
        ),
        MemberSpec_(
            "value", "Nml2Quantity", 0, 0, {"use": "required", "name": "value"}
        ),
        MemberSpec_(
            "description", "xs:string", 0, 1, {"use": "optional", "name": "description"}
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        name: "a string (required)" = None,
        dimension: "a string (required)" = None,
        value: "a Nml2Quantity (required)" = None,
        description: "a string (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Constant"), self).__init__(**kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.dimension = _cast(None, dimension)
        self.dimension_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Constant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Constant.subclass:
            return Constant.subclass(*args_, **kwargs_)
        else:
            return Constant(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity(self, value):
        # Validate type Nml2Quantity, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_patterns_,
                    )
                )

    validate_Nml2Quantity_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*([_a-zA-Z0-9])*)$"]
    ]

    def _hasContent(self):
        if super(Constant, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Constant",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Constant")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Constant":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Constant"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Constant",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Constant"
    ):
        super(Constant, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Constant"
        )
        if self.name is not None and "name" not in already_processed:
            already_processed.add("name")
            outfile.write(
                " name=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.name), input_name="name"
                        )
                    ),
                )
            )
        if self.dimension is not None and "dimension" not in already_processed:
            already_processed.add("dimension")
            outfile.write(
                " dimension=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.dimension), input_name="dimension"
                        )
                    ),
                )
            )
        if self.value is not None and "value" not in already_processed:
            already_processed.add("value")
            outfile.write(
                " value=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.value), input_name="value"
                        )
                    ),
                )
            )
        if self.description is not None and "description" not in already_processed:
            already_processed.add("description")
            outfile.write(
                " description=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.description), input_name="description"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Constant",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Constant, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.name, "name")
        self.gds_check_cardinality_(self.name, "name", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.dimension, "dimension"
        )
        self.gds_check_cardinality_(self.dimension, "dimension", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity, self.value, "value")
        self.gds_check_cardinality_(self.value, "value", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.description, "description"
        )
        self.gds_check_cardinality_(self.description, "description", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("name", node)
        if value is not None and "name" not in already_processed:
            already_processed.add("name")
            self.name = value
        value = find_attr_value_("dimension", node)
        if value is not None and "dimension" not in already_processed:
            already_processed.add("dimension")
            self.dimension = value
        value = find_attr_value_("value", node)
        if value is not None and "value" not in already_processed:
            already_processed.add("value")
            self.value = value
            self.validate_Nml2Quantity(self.value)  # validate type Nml2Quantity
        value = find_attr_value_("description", node)
        if value is not None and "description" not in already_processed:
            already_processed.add("description")
            self.description = value
        super(Constant, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Constant, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class Constant


class Annotation(BaseWithoutId):
    """Annotation -- A structured annotation containing metadata, specifically RDF or  **property**  elements"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "__ANY__",
            "__ANY__",
            1,
            1,
            {"maxOccurs": "unbounded", "minOccurs": "0", "processContents": "skip"},
            None,
        ),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Annotation"), self).__init__(**kwargs_)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Annotation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Annotation.subclass:
            return Annotation.subclass(*args_, **kwargs_)
        else:
            return Annotation(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if self.anytypeobjs_ or super(Annotation, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Annotation",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Annotation")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Annotation":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Annotation"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Annotation",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Annotation"
    ):
        super(Annotation, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Annotation"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Annotation",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Annotation, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write("\n")

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(Annotation, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        content_ = self.gds_build_any(child_, "Annotation")
        self.anytypeobjs_.append(content_)
        super(Annotation, self)._buildChildren(child_, node, nodeName_, True)


# end class Annotation


class Property(BaseWithoutId):
    """Property -- A property ( a **tag**  and **value**  pair ), which can be on any  **baseStandalone**  either as a direct child, or within an  **Annotation** . Generally something which helps the visual display or facilitates simulation of a Component, but is not a core physiological property. Common examples include: **numberInternalDivisions,**  equivalent of nseg in NEURON; **radius,**  for a radius to use in graphical displays for abstract cells ( i. e. without defined morphologies ); **color,**  the color to use for a  **Population**  or  **populationList**  of cells; **recommended_dt_ms,**  the recommended timestep to use for simulating a  **Network** , **recommended_duration_ms**  the recommended duration to use when running a  **Network**"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("tag", "xs:string", 0, 0, {"use": "required", "name": "tag"}),
        MemberSpec_("value", "xs:string", 0, 0, {"use": "required", "name": "value"}),
    ]
    subclass = None
    superclass = BaseWithoutId

    def __init__(
        self,
        tag: "a string (required)" = None,
        value: "a string (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Property"), self).__init__(**kwargs_)
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Property)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Property.subclass:
            return Property.subclass(*args_, **kwargs_)
        else:
            return Property(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(Property, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Property",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Property")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Property":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Property"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Property",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Property"
    ):
        super(Property, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Property"
        )
        if self.tag is not None and "tag" not in already_processed:
            already_processed.add("tag")
            outfile.write(
                " tag=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.tag), input_name="tag")
                    ),
                )
            )
        if self.value is not None and "value" not in already_processed:
            already_processed.add("value")
            outfile.write(
                " value=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.value), input_name="value"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Property",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Property, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.tag, "tag")
        self.gds_check_cardinality_(self.tag, "tag", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.value, "value")
        self.gds_check_cardinality_(self.value, "value", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("tag", node)
        if value is not None and "tag" not in already_processed:
            already_processed.add("tag")
            self.tag = value
        value = find_attr_value_("value", node)
        if value is not None and "value" not in already_processed:
            already_processed.add("value")
            self.value = value
        super(Property, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Property, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class Property


class BasePynnSynapse(BaseSynapse):
    """BasePynnSynapse -- Base type for all PyNN synapses. Note, the current **I**  produced is dimensionless, but it requires a membrane potential **v**  with dimension voltage
    \n
    :param tau_syn:
    :type tau_syn: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "tau_syn", "xs:float", 0, 0, {"use": "required", "name": "tau_syn"}
        ),
    ]
    subclass = None
    superclass = BaseSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        tau_syn: "a float (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BasePynnSynapse"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            extensiontype_,
            **kwargs_,
        )
        self.tau_syn = _cast(float, tau_syn)
        self.tau_syn_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, BasePynnSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasePynnSynapse.subclass:
            return BasePynnSynapse.subclass(*args_, **kwargs_)
        else:
            return BasePynnSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(BasePynnSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BasePynnSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BasePynnSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BasePynnSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="BasePynnSynapse"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BasePynnSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BasePynnSynapse",
    ):
        super(BasePynnSynapse, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="BasePynnSynapse"
        )
        if self.tau_syn is not None and "tau_syn" not in already_processed:
            already_processed.add("tau_syn")
            outfile.write(
                ' tau_syn="%s"'
                % self.gds_format_float(self.tau_syn, input_name="tau_syn")
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BasePynnSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BasePynnSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.tau_syn, "tau_syn")
        self.gds_check_cardinality_(self.tau_syn, "tau_syn", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("tau_syn", node)
        if value is not None and "tau_syn" not in already_processed:
            already_processed.add("tau_syn")
            value = self.gds_parse_float(value, node, "tau_syn")
            self.tau_syn = value
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(BasePynnSynapse, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BasePynnSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class BasePynnSynapse


class basePyNNCell(BaseCell):
    """basePyNNCell -- Base type of any PyNN standard cell model. Note: membrane potential **v**  has dimensions voltage, but all other parameters are dimensionless. This is to facilitate translation to and from PyNN scripts in Python, where these parameters have implicit units, see http://neuralensemble.org/trac/PyNN/wiki/StandardModels
    \n
    :param cm:
    :type cm: none
    :param i_offset:
    :type i_offset: none
    :param tau_syn_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_E: none
    :param tau_syn_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_I: none
    :param v_init:
    :type v_init: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("cm", "xs:float", 0, 0, {"use": "required", "name": "cm"}),
        MemberSpec_(
            "i_offset", "xs:float", 0, 0, {"use": "required", "name": "i_offset"}
        ),
        MemberSpec_(
            "tau_syn_E", "xs:float", 0, 0, {"use": "required", "name": "tau_syn_E"}
        ),
        MemberSpec_(
            "tau_syn_I", "xs:float", 0, 0, {"use": "required", "name": "tau_syn_I"}
        ),
        MemberSpec_("v_init", "xs:float", 0, 0, {"use": "required", "name": "v_init"}),
    ]
    subclass = None
    superclass = BaseCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        cm: "a float (required)" = None,
        i_offset: "a float (required)" = None,
        tau_syn_E: "a float (required)" = None,
        tau_syn_I: "a float (required)" = None,
        v_init: "a float (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("basePyNNCell"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            extensiontype_,
            **kwargs_,
        )
        self.cm = _cast(float, cm)
        self.cm_nsprefix_ = None
        self.i_offset = _cast(float, i_offset)
        self.i_offset_nsprefix_ = None
        self.tau_syn_E = _cast(float, tau_syn_E)
        self.tau_syn_E_nsprefix_ = None
        self.tau_syn_I = _cast(float, tau_syn_I)
        self.tau_syn_I_nsprefix_ = None
        self.v_init = _cast(float, v_init)
        self.v_init_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, basePyNNCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basePyNNCell.subclass:
            return basePyNNCell.subclass(*args_, **kwargs_)
        else:
            return basePyNNCell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(basePyNNCell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="basePyNNCell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("basePyNNCell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "basePyNNCell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="basePyNNCell"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="basePyNNCell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="basePyNNCell",
    ):
        super(basePyNNCell, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="basePyNNCell"
        )
        if self.cm is not None and "cm" not in already_processed:
            already_processed.add("cm")
            outfile.write(' cm="%s"' % self.gds_format_float(self.cm, input_name="cm"))
        if self.i_offset is not None and "i_offset" not in already_processed:
            already_processed.add("i_offset")
            outfile.write(
                ' i_offset="%s"'
                % self.gds_format_float(self.i_offset, input_name="i_offset")
            )
        if self.tau_syn_E is not None and "tau_syn_E" not in already_processed:
            already_processed.add("tau_syn_E")
            outfile.write(
                ' tau_syn_E="%s"'
                % self.gds_format_float(self.tau_syn_E, input_name="tau_syn_E")
            )
        if self.tau_syn_I is not None and "tau_syn_I" not in already_processed:
            already_processed.add("tau_syn_I")
            outfile.write(
                ' tau_syn_I="%s"'
                % self.gds_format_float(self.tau_syn_I, input_name="tau_syn_I")
            )
        if self.v_init is not None and "v_init" not in already_processed:
            already_processed.add("v_init")
            outfile.write(
                ' v_init="%s"' % self.gds_format_float(self.v_init, input_name="v_init")
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="basePyNNCell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(basePyNNCell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.cm, "cm")
        self.gds_check_cardinality_(self.cm, "cm", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_float, self.i_offset, "i_offset"
        )
        self.gds_check_cardinality_(self.i_offset, "i_offset", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_float, self.tau_syn_E, "tau_syn_E"
        )
        self.gds_check_cardinality_(self.tau_syn_E, "tau_syn_E", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_float, self.tau_syn_I, "tau_syn_I"
        )
        self.gds_check_cardinality_(self.tau_syn_I, "tau_syn_I", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.v_init, "v_init")
        self.gds_check_cardinality_(self.v_init, "v_init", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("cm", node)
        if value is not None and "cm" not in already_processed:
            already_processed.add("cm")
            value = self.gds_parse_float(value, node, "cm")
            self.cm = value
        value = find_attr_value_("i_offset", node)
        if value is not None and "i_offset" not in already_processed:
            already_processed.add("i_offset")
            value = self.gds_parse_float(value, node, "i_offset")
            self.i_offset = value
        value = find_attr_value_("tau_syn_E", node)
        if value is not None and "tau_syn_E" not in already_processed:
            already_processed.add("tau_syn_E")
            value = self.gds_parse_float(value, node, "tau_syn_E")
            self.tau_syn_E = value
        value = find_attr_value_("tau_syn_I", node)
        if value is not None and "tau_syn_I" not in already_processed:
            already_processed.add("tau_syn_I")
            value = self.gds_parse_float(value, node, "tau_syn_I")
            self.tau_syn_I = value
        value = find_attr_value_("v_init", node)
        if value is not None and "v_init" not in already_processed:
            already_processed.add("v_init")
            value = self.gds_parse_float(value, node, "v_init")
            self.v_init = value
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(basePyNNCell, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(basePyNNCell, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class basePyNNCell


class InputW(Input):
    """InputW -- Specifies input lists. Can set **weight**  to scale individual inputs.
    \n
    :param weight:
    :type weight: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("weight", "xs:float", 0, 0, {"use": "required", "name": "weight"}),
    ]
    subclass = None
    superclass = Input

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        target: "a string (required)" = None,
        destination: "a NmlId (required)" = None,
        segment_id: "a NonNegativeInteger (optional)" = None,
        fraction_along: "a ZeroToOne (optional)" = None,
        weight: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("InputW"), self).__init__(
            id, target, destination, segment_id, fraction_along, **kwargs_
        )
        self.weight = _cast(float, weight)
        self.weight_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, InputW)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InputW.subclass:
            return InputW.subclass(*args_, **kwargs_)
        else:
            return InputW(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(InputW, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="InputW",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("InputW")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "InputW":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="InputW"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="InputW",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="InputW"
    ):
        super(InputW, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="InputW"
        )
        if self.weight is not None and "weight" not in already_processed:
            already_processed.add("weight")
            outfile.write(
                ' weight="%s"' % self.gds_format_float(self.weight, input_name="weight")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="InputW",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(InputW, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.weight, "weight")
        self.gds_check_cardinality_(self.weight, "weight", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("weight", node)
        if value is not None and "weight" not in already_processed:
            already_processed.add("weight")
            value = self.gds_parse_float(value, node, "weight")
            self.weight = value
        super(InputW, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(InputW, self)._buildChildren(child_, node, nodeName_, True)
        pass

    def get_weight(self):
        """Get weight.

        If weight is not set, the default value of 1.0 is returned.
        """

        return float(self.weight) if self.weight != None else 1.0

    def __str__(self):
        return (
            "Input (weight) "
            + str(self.id)
            + ": "
            + str(self.get_target_cell_id())
            + ":"
            + str(self.get_segment_id())
            + "("
            + "%.6f" % self.get_fraction_along()
            + "), weight: "
            + "%.6f" % self.get_weight()
        )

    # end class InputW


class ContinuousProjection(BaseProjection):
    """ContinuousProjection -- A projection between **presynapticPopulation**  and **postsynapticPopulation**  through components **preComponent**  at the start and **postComponent**  at the end of a  **continuousConnection**  or  **continuousConnectionInstance** . Can be used for analog synapses."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "continuous_connections",
            "ContinuousConnection",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "continuousConnection",
                "type": "ContinuousConnection",
            },
            None,
        ),
        MemberSpec_(
            "continuous_connection_instances",
            "ContinuousConnectionInstance",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "continuousConnectionInstance",
                "type": "ContinuousConnectionInstance",
            },
            None,
        ),
        MemberSpec_(
            "continuous_connection_instance_ws",
            "ContinuousConnectionInstanceW",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "continuousConnectionInstanceW",
                "type": "ContinuousConnectionInstanceW",
            },
            None,
        ),
    ]
    subclass = None
    superclass = BaseProjection

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        presynaptic_population: "a NmlId (required)" = None,
        postsynaptic_population: "a NmlId (required)" = None,
        continuous_connections: "list of ContinuousConnection(s) (optional)" = None,
        continuous_connection_instances: "list of ContinuousConnectionInstance(s) (optional)" = None,
        continuous_connection_instance_ws: "list of ContinuousConnectionInstanceW(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ContinuousProjection"), self).__init__(
            id, presynaptic_population, postsynaptic_population, **kwargs_
        )
        if continuous_connections is None:
            self.continuous_connections = []
        else:
            self.continuous_connections = continuous_connections
        self.continuous_connections_nsprefix_ = None
        if continuous_connection_instances is None:
            self.continuous_connection_instances = []
        else:
            self.continuous_connection_instances = continuous_connection_instances
        self.continuous_connection_instances_nsprefix_ = None
        if continuous_connection_instance_ws is None:
            self.continuous_connection_instance_ws = []
        else:
            self.continuous_connection_instance_ws = continuous_connection_instance_ws
        self.continuous_connection_instance_ws_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContinuousProjection
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContinuousProjection.subclass:
            return ContinuousProjection.subclass(*args_, **kwargs_)
        else:
            return ContinuousProjection(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.continuous_connections
            or self.continuous_connection_instances
            or self.continuous_connection_instance_ws
            or super(ContinuousProjection, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ContinuousProjection",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ContinuousProjection")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ContinuousProjection":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ContinuousProjection",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ContinuousProjection",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ContinuousProjection",
    ):
        super(ContinuousProjection, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ContinuousProjection",
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ContinuousProjection",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ContinuousProjection, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for continuousConnection_ in self.continuous_connections:
            namespaceprefix_ = (
                self.continuous_connections_nsprefix_ + ":"
                if (UseCapturedNS_ and self.continuous_connections_nsprefix_)
                else ""
            )
            continuousConnection_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="continuousConnection",
                pretty_print=pretty_print,
            )
        for continuousConnectionInstance_ in self.continuous_connection_instances:
            namespaceprefix_ = (
                self.continuous_connection_instances_nsprefix_ + ":"
                if (UseCapturedNS_ and self.continuous_connection_instances_nsprefix_)
                else ""
            )
            continuousConnectionInstance_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="continuousConnectionInstance",
                pretty_print=pretty_print,
            )
        for continuousConnectionInstanceW_ in self.continuous_connection_instance_ws:
            namespaceprefix_ = (
                self.continuous_connection_instance_ws_nsprefix_ + ":"
                if (UseCapturedNS_ and self.continuous_connection_instance_ws_nsprefix_)
                else ""
            )
            continuousConnectionInstanceW_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="continuousConnectionInstanceW",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.continuous_connections,
            "continuous_connections",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.continuous_connection_instances,
            "continuous_connection_instances",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.continuous_connection_instance_ws,
            "continuous_connection_instance_ws",
            min_occurs=0,
            max_occurs=9999999,
        )
        if recursive:
            for item in self.continuous_connections:
                item.validate_(gds_collector, recursive=True)
            for item in self.continuous_connection_instances:
                item.validate_(gds_collector, recursive=True)
            for item in self.continuous_connection_instance_ws:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(ContinuousProjection, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "continuousConnection":
            class_obj_ = self.get_class_obj_(child_, ContinuousConnection)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.continuous_connections.append(obj_)
            obj_.original_tagname_ = "continuousConnection"
        elif nodeName_ == "continuousConnectionInstance":
            class_obj_ = self.get_class_obj_(child_, ContinuousConnectionInstance)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.continuous_connection_instances.append(obj_)
            obj_.original_tagname_ = "continuousConnectionInstance"
        elif nodeName_ == "continuousConnectionInstanceW":
            obj_ = ContinuousConnectionInstanceW.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.continuous_connection_instance_ws.append(obj_)
            obj_.original_tagname_ = "continuousConnectionInstanceW"
        super(ContinuousProjection, self)._buildChildren(child_, node, nodeName_, True)

    def exportHdf5(self, h5file, h5Group):
        """Export to HDF5 file."""
        # print("Exporting ContinuousProjection: "+str(self.id)+" as HDF5")

        projGroup = h5file.create_group(h5Group, "projection_" + self.id)
        projGroup._f_setattr("id", self.id)
        projGroup._f_setattr("type", "continuousProjection")
        projGroup._f_setattr("presynapticPopulation", self.presynaptic_population)
        projGroup._f_setattr("postsynapticPopulation", self.postsynaptic_population)

        pre_comp = (
            self.continuous_connections[0].pre_component
            if len(self.continuous_connections) > 0
            else self.continuous_connection_instances[0].pre_component
            if len(self.continuous_connection_instances) > 0
            else self.continuous_connection_instance_ws[0].pre_component
        )
        projGroup._f_setattr("preComponent", pre_comp)
        post_comp = (
            self.continuous_connections[0].post_component
            if len(self.continuous_connections) > 0
            else self.continuous_connection_instances[0].post_component
            if len(self.continuous_connection_instances) > 0
            else self.continuous_connection_instance_ws[0].post_component
        )
        projGroup._f_setattr("postComponent", post_comp)

        cols = 7
        extra_cols = {}

        num_tot = (
            len(self.continuous_connections)
            + len(self.continuous_connection_instances)
            + len(self.continuous_connection_instance_ws)
        )

        if len(self.continuous_connection_instance_ws) > 0:
            extra_cols["column_" + str(cols)] = "weight"
            cols += 1

        # print("Exporting "+str(num_tot)+" continuous connections")
        a = numpy.zeros([num_tot, cols], numpy.float32)

        count = 0

        # TODO: optimise for single compartment cells, i.e. where no pre_segment/post_fraction_along etc.
        for connection in self.continuous_connections:
            a[count, 0] = connection.id
            a[count, 1] = connection.get_pre_cell_id()
            a[count, 2] = connection.get_post_cell_id()
            a[count, 3] = connection.pre_segment
            a[count, 4] = connection.post_segment
            a[count, 5] = connection.pre_fraction_along
            a[count, 6] = connection.post_fraction_along
            count = count + 1

        for connection in self.continuous_connection_instances:
            a[count, 0] = connection.id
            a[count, 1] = connection.get_pre_cell_id()
            a[count, 2] = connection.get_post_cell_id()
            a[count, 3] = connection.pre_segment
            a[count, 4] = connection.post_segment
            a[count, 5] = connection.pre_fraction_along
            a[count, 6] = connection.post_fraction_along
            count = count + 1

        for connection in self.continuous_connection_instance_ws:
            a[count, 0] = connection.id
            a[count, 1] = connection.get_pre_cell_id()
            a[count, 2] = connection.get_post_cell_id()
            a[count, 3] = connection.pre_segment
            a[count, 4] = connection.post_segment
            a[count, 5] = connection.pre_fraction_along
            a[count, 6] = connection.post_fraction_along
            a[count, 7] = connection.weight
            count = count + 1

        array = h5file.create_carray(
            projGroup, self.id, obj=a, title="Connections of cells in " + self.id
        )

        array._f_setattr("column_0", "id")
        array._f_setattr("column_1", "pre_cell_id")
        array._f_setattr("column_2", "post_cell_id")
        array._f_setattr("column_3", "pre_segment_id")
        array._f_setattr("column_4", "post_segment_id")
        array._f_setattr("column_5", "pre_fraction_along")
        array._f_setattr("column_6", "post_fraction_along")
        for k in extra_cols:
            array._f_setattr(k, extra_cols[k])

    # end class ContinuousProjection


class ElectricalProjection(BaseProjection):
    """ElectricalProjection -- A projection between **presynapticPopulation**  to another **postsynapticPopulation**  through gap junctions."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "electrical_connections",
            "ElectricalConnection",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "electricalConnection",
                "type": "ElectricalConnection",
            },
            None,
        ),
        MemberSpec_(
            "electrical_connection_instances",
            "ElectricalConnectionInstance",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "electricalConnectionInstance",
                "type": "ElectricalConnectionInstance",
            },
            None,
        ),
        MemberSpec_(
            "electrical_connection_instance_ws",
            "ElectricalConnectionInstanceW",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "electricalConnectionInstanceW",
                "type": "ElectricalConnectionInstanceW",
            },
            None,
        ),
    ]
    subclass = None
    superclass = BaseProjection

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        presynaptic_population: "a NmlId (required)" = None,
        postsynaptic_population: "a NmlId (required)" = None,
        electrical_connections: "list of ElectricalConnection(s) (optional)" = None,
        electrical_connection_instances: "list of ElectricalConnectionInstance(s) (optional)" = None,
        electrical_connection_instance_ws: "list of ElectricalConnectionInstanceW(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ElectricalProjection"), self).__init__(
            id, presynaptic_population, postsynaptic_population, **kwargs_
        )
        if electrical_connections is None:
            self.electrical_connections = []
        else:
            self.electrical_connections = electrical_connections
        self.electrical_connections_nsprefix_ = None
        if electrical_connection_instances is None:
            self.electrical_connection_instances = []
        else:
            self.electrical_connection_instances = electrical_connection_instances
        self.electrical_connection_instances_nsprefix_ = None
        if electrical_connection_instance_ws is None:
            self.electrical_connection_instance_ws = []
        else:
            self.electrical_connection_instance_ws = electrical_connection_instance_ws
        self.electrical_connection_instance_ws_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricalProjection
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricalProjection.subclass:
            return ElectricalProjection.subclass(*args_, **kwargs_)
        else:
            return ElectricalProjection(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.electrical_connections
            or self.electrical_connection_instances
            or self.electrical_connection_instance_ws
            or super(ElectricalProjection, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ElectricalProjection",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ElectricalProjection")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ElectricalProjection":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ElectricalProjection",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ElectricalProjection",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ElectricalProjection",
    ):
        super(ElectricalProjection, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ElectricalProjection",
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ElectricalProjection",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ElectricalProjection, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for electricalConnection_ in self.electrical_connections:
            namespaceprefix_ = (
                self.electrical_connections_nsprefix_ + ":"
                if (UseCapturedNS_ and self.electrical_connections_nsprefix_)
                else ""
            )
            electricalConnection_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="electricalConnection",
                pretty_print=pretty_print,
            )
        for electricalConnectionInstance_ in self.electrical_connection_instances:
            namespaceprefix_ = (
                self.electrical_connection_instances_nsprefix_ + ":"
                if (UseCapturedNS_ and self.electrical_connection_instances_nsprefix_)
                else ""
            )
            electricalConnectionInstance_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="electricalConnectionInstance",
                pretty_print=pretty_print,
            )
        for electricalConnectionInstanceW_ in self.electrical_connection_instance_ws:
            namespaceprefix_ = (
                self.electrical_connection_instance_ws_nsprefix_ + ":"
                if (UseCapturedNS_ and self.electrical_connection_instance_ws_nsprefix_)
                else ""
            )
            electricalConnectionInstanceW_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="electricalConnectionInstanceW",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.electrical_connections,
            "electrical_connections",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.electrical_connection_instances,
            "electrical_connection_instances",
            min_occurs=0,
            max_occurs=9999999,
        )
        self.gds_check_cardinality_(
            self.electrical_connection_instance_ws,
            "electrical_connection_instance_ws",
            min_occurs=0,
            max_occurs=9999999,
        )
        if recursive:
            for item in self.electrical_connections:
                item.validate_(gds_collector, recursive=True)
            for item in self.electrical_connection_instances:
                item.validate_(gds_collector, recursive=True)
            for item in self.electrical_connection_instance_ws:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(ElectricalProjection, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "electricalConnection":
            class_obj_ = self.get_class_obj_(child_, ElectricalConnection)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.electrical_connections.append(obj_)
            obj_.original_tagname_ = "electricalConnection"
        elif nodeName_ == "electricalConnectionInstance":
            class_obj_ = self.get_class_obj_(child_, ElectricalConnectionInstance)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.electrical_connection_instances.append(obj_)
            obj_.original_tagname_ = "electricalConnectionInstance"
        elif nodeName_ == "electricalConnectionInstanceW":
            obj_ = ElectricalConnectionInstanceW.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.electrical_connection_instance_ws.append(obj_)
            obj_.original_tagname_ = "electricalConnectionInstanceW"
        super(ElectricalProjection, self)._buildChildren(child_, node, nodeName_, True)

    def exportHdf5(self, h5file, h5Group):
        """Export to HDF5 file."""
        # print("Exporting ElectricalProjection: "+str(self.id)+" as HDF5")

        projGroup = h5file.create_group(h5Group, "projection_" + self.id)
        projGroup._f_setattr("id", self.id)
        projGroup._f_setattr("type", "electricalProjection")
        projGroup._f_setattr("presynapticPopulation", self.presynaptic_population)
        projGroup._f_setattr("postsynapticPopulation", self.postsynaptic_population)

        syn = (
            self.electrical_connections[0].synapse
            if len(self.electrical_connections) > 0
            else self.electrical_connection_instances[0].synapse
            if len(self.electrical_connection_instances) > 0
            else self.electrical_connection_instance_ws[0].synapse
        )
        projGroup._f_setattr("synapse", syn)

        cols = 7
        extra_cols = {}

        num_tot = (
            len(self.electrical_connections)
            + len(self.electrical_connection_instances)
            + len(self.electrical_connection_instance_ws)
        )
        if len(self.electrical_connection_instance_ws) > 0:
            extra_cols["column_" + str(cols)] = "weight"
            cols += 1

        # print("Exporting "+str(num_tot)+" electrical connections")
        a = numpy.zeros([num_tot, cols], numpy.float32)

        count = 0

        # TODO: optimise for single compartment cells, i.e. where no pre_segment/post_fraction_along etc.
        for connection in self.electrical_connections:
            a[count, 0] = connection.id
            a[count, 1] = connection.get_pre_cell_id()
            a[count, 2] = connection.get_post_cell_id()
            a[count, 3] = connection.pre_segment
            a[count, 4] = connection.post_segment
            a[count, 5] = connection.pre_fraction_along
            a[count, 6] = connection.post_fraction_along
            count = count + 1

        for connection in self.electrical_connection_instances:
            a[count, 0] = connection.id
            a[count, 1] = connection.get_pre_cell_id()
            a[count, 2] = connection.get_post_cell_id()
            a[count, 3] = connection.pre_segment
            a[count, 4] = connection.post_segment
            a[count, 5] = connection.pre_fraction_along
            a[count, 6] = connection.post_fraction_along
            count = count + 1

        for connection in self.electrical_connection_instance_ws:
            a[count, 0] = connection.id
            a[count, 1] = connection.get_pre_cell_id()
            a[count, 2] = connection.get_post_cell_id()
            a[count, 3] = connection.pre_segment
            a[count, 4] = connection.post_segment
            a[count, 5] = connection.pre_fraction_along
            a[count, 6] = connection.post_fraction_along
            a[count, 7] = connection.get_weight()
            count = count + 1

        array = h5file.create_carray(
            projGroup, self.id, obj=a, title="Connections of cells in " + self.id
        )

        array._f_setattr("column_0", "id")
        array._f_setattr("column_1", "pre_cell_id")
        array._f_setattr("column_2", "post_cell_id")
        array._f_setattr("column_3", "pre_segment_id")
        array._f_setattr("column_4", "post_segment_id")
        array._f_setattr("column_5", "pre_fraction_along")
        array._f_setattr("column_6", "post_fraction_along")

        for col in extra_cols.keys():
            array._f_setattr(col, extra_cols[col])

    # end class ElectricalProjection


class BaseConnectionNewFormat(BaseConnection):
    """BaseConnectionNewFormat -- Base of all synaptic connections with preCell, postSegment, etc.
    See BaseConnectionOldFormat

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "pre_cell", "xs:string", 0, 0, {"use": "required", "name": "pre_cell"}
        ),
        MemberSpec_(
            "pre_segment",
            "NonNegativeInteger",
            0,
            1,
            {"use": "optional", "name": "pre_segment"},
        ),
        MemberSpec_(
            "pre_fraction_along",
            "ZeroToOne",
            0,
            1,
            {"use": "optional", "name": "pre_fraction_along"},
        ),
        MemberSpec_(
            "post_cell", "xs:string", 0, 0, {"use": "required", "name": "post_cell"}
        ),
        MemberSpec_(
            "post_segment",
            "NonNegativeInteger",
            0,
            1,
            {"use": "optional", "name": "post_segment"},
        ),
        MemberSpec_(
            "post_fraction_along",
            "ZeroToOne",
            0,
            1,
            {"use": "optional", "name": "post_fraction_along"},
        ),
    ]
    subclass = None
    superclass = BaseConnection

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        pre_cell: "a string (required)" = None,
        pre_segment: "a NonNegativeInteger (optional)" = "0",
        pre_fraction_along: "a ZeroToOne (optional)" = "0.5",
        post_cell: "a string (required)" = None,
        post_segment: "a NonNegativeInteger (optional)" = "0",
        post_fraction_along: "a ZeroToOne (optional)" = "0.5",
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BaseConnectionNewFormat"), self).__init__(
            id, neuro_lex_id, extensiontype_, **kwargs_
        )
        self.pre_cell = _cast(None, pre_cell)
        self.pre_cell_nsprefix_ = None
        self.pre_segment = _cast(int, pre_segment)
        self.pre_segment_nsprefix_ = None
        self.pre_fraction_along = _cast(float, pre_fraction_along)
        self.pre_fraction_along_nsprefix_ = None
        self.post_cell = _cast(None, post_cell)
        self.post_cell_nsprefix_ = None
        self.post_segment = _cast(int, post_segment)
        self.post_segment_nsprefix_ = None
        self.post_fraction_along = _cast(float, post_fraction_along)
        self.post_fraction_along_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseConnectionNewFormat
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseConnectionNewFormat.subclass:
            return BaseConnectionNewFormat.subclass(*args_, **kwargs_)
        else:
            return BaseConnectionNewFormat(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def validate_ZeroToOne(self, value):
        # Validate type ZeroToOne, a restriction on xs:float.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ZeroToOne'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ZeroToOne'
                    % {"value": value, "lineno": lineno}
                )
                result = False

    def _hasContent(self):
        if super(BaseConnectionNewFormat, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseConnectionNewFormat",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BaseConnectionNewFormat")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BaseConnectionNewFormat":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseConnectionNewFormat",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BaseConnectionNewFormat",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BaseConnectionNewFormat",
    ):
        super(BaseConnectionNewFormat, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseConnectionNewFormat",
        )
        if self.pre_cell is not None and "pre_cell" not in already_processed:
            already_processed.add("pre_cell")
            outfile.write(
                " preCell=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.pre_cell), input_name="preCell"
                        )
                    ),
                )
            )
        if self.pre_segment != 0 and "pre_segment" not in already_processed:
            already_processed.add("pre_segment")
            outfile.write(
                ' preSegment="%s"'
                % self.gds_format_integer(self.pre_segment, input_name="preSegment")
            )
        if (
            self.pre_fraction_along != 0.5
            and "pre_fraction_along" not in already_processed
        ):
            already_processed.add("pre_fraction_along")
            outfile.write(
                ' preFractionAlong="%s"'
                % self.gds_format_float(
                    self.pre_fraction_along, input_name="preFractionAlong"
                )
            )
        if self.post_cell is not None and "post_cell" not in already_processed:
            already_processed.add("post_cell")
            outfile.write(
                " postCell=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.post_cell), input_name="postCell"
                        )
                    ),
                )
            )
        if self.post_segment != 0 and "post_segment" not in already_processed:
            already_processed.add("post_segment")
            outfile.write(
                ' postSegment="%s"'
                % self.gds_format_integer(self.post_segment, input_name="postSegment")
            )
        if (
            self.post_fraction_along != 0.5
            and "post_fraction_along" not in already_processed
        ):
            already_processed.add("post_fraction_along")
            outfile.write(
                ' postFractionAlong="%s"'
                % self.gds_format_float(
                    self.post_fraction_along, input_name="postFractionAlong"
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseConnectionNewFormat",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BaseConnectionNewFormat, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.pre_cell, "pre_cell"
        )
        self.gds_check_cardinality_(self.pre_cell, "pre_cell", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NonNegativeInteger, self.pre_segment, "pre_segment"
        )
        self.gds_check_cardinality_(self.pre_segment, "pre_segment", required=False)
        self.gds_validate_defined_ST_(
            self.validate_ZeroToOne, self.pre_fraction_along, "pre_fraction_along"
        )
        self.gds_check_cardinality_(
            self.pre_fraction_along, "pre_fraction_along", required=False
        )
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.post_cell, "post_cell"
        )
        self.gds_check_cardinality_(self.post_cell, "post_cell", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NonNegativeInteger, self.post_segment, "post_segment"
        )
        self.gds_check_cardinality_(self.post_segment, "post_segment", required=False)
        self.gds_validate_defined_ST_(
            self.validate_ZeroToOne, self.post_fraction_along, "post_fraction_along"
        )
        self.gds_check_cardinality_(
            self.post_fraction_along, "post_fraction_along", required=False
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("preCell", node)
        if value is not None and "preCell" not in already_processed:
            already_processed.add("preCell")
            self.pre_cell = value
        value = find_attr_value_("preSegment", node)
        if value is not None and "preSegment" not in already_processed:
            already_processed.add("preSegment")
            self.pre_segment = self.gds_parse_integer(value, node, "preSegment")
            if self.pre_segment < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
            self.validate_NonNegativeInteger(
                self.pre_segment
            )  # validate type NonNegativeInteger
        value = find_attr_value_("preFractionAlong", node)
        if value is not None and "preFractionAlong" not in already_processed:
            already_processed.add("preFractionAlong")
            value = self.gds_parse_float(value, node, "preFractionAlong")
            self.pre_fraction_along = value
            self.validate_ZeroToOne(self.pre_fraction_along)  # validate type ZeroToOne
        value = find_attr_value_("postCell", node)
        if value is not None and "postCell" not in already_processed:
            already_processed.add("postCell")
            self.post_cell = value
        value = find_attr_value_("postSegment", node)
        if value is not None and "postSegment" not in already_processed:
            already_processed.add("postSegment")
            self.post_segment = self.gds_parse_integer(value, node, "postSegment")
            if self.post_segment < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
            self.validate_NonNegativeInteger(
                self.post_segment
            )  # validate type NonNegativeInteger
        value = find_attr_value_("postFractionAlong", node)
        if value is not None and "postFractionAlong" not in already_processed:
            already_processed.add("postFractionAlong")
            value = self.gds_parse_float(value, node, "postFractionAlong")
            self.post_fraction_along = value
            self.validate_ZeroToOne(self.post_fraction_along)  # validate type ZeroToOne
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(BaseConnectionNewFormat, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BaseConnectionNewFormat, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class BaseConnectionNewFormat


class BaseConnectionOldFormat(BaseConnection):
    """BaseConnectionOldFormat -- Base of all synaptic connections with preCellId, postSegmentId, etc.
    Note: this is not the best name for these attributes, since Id is superfluous, hence BaseConnectionNewFormat

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "pre_cell_id", "xs:string", 0, 0, {"use": "required", "name": "pre_cell_id"}
        ),
        MemberSpec_(
            "pre_segment_id",
            "NonNegativeInteger",
            0,
            1,
            {"use": "optional", "name": "pre_segment_id"},
        ),
        MemberSpec_(
            "pre_fraction_along",
            "ZeroToOne",
            0,
            1,
            {"use": "optional", "name": "pre_fraction_along"},
        ),
        MemberSpec_(
            "post_cell_id",
            "xs:string",
            0,
            0,
            {"use": "required", "name": "post_cell_id"},
        ),
        MemberSpec_(
            "post_segment_id",
            "NonNegativeInteger",
            0,
            1,
            {"use": "optional", "name": "post_segment_id"},
        ),
        MemberSpec_(
            "post_fraction_along",
            "ZeroToOne",
            0,
            1,
            {"use": "optional", "name": "post_fraction_along"},
        ),
    ]
    subclass = None
    superclass = BaseConnection

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        pre_cell_id: "a string (required)" = None,
        pre_segment_id: "a NonNegativeInteger (optional)" = "0",
        pre_fraction_along: "a ZeroToOne (optional)" = "0.5",
        post_cell_id: "a string (required)" = None,
        post_segment_id: "a NonNegativeInteger (optional)" = "0",
        post_fraction_along: "a ZeroToOne (optional)" = "0.5",
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BaseConnectionOldFormat"), self).__init__(
            id, neuro_lex_id, extensiontype_, **kwargs_
        )
        self.pre_cell_id = _cast(None, pre_cell_id)
        self.pre_cell_id_nsprefix_ = None
        self.pre_segment_id = _cast(int, pre_segment_id)
        self.pre_segment_id_nsprefix_ = None
        self.pre_fraction_along = _cast(float, pre_fraction_along)
        self.pre_fraction_along_nsprefix_ = None
        self.post_cell_id = _cast(None, post_cell_id)
        self.post_cell_id_nsprefix_ = None
        self.post_segment_id = _cast(int, post_segment_id)
        self.post_segment_id_nsprefix_ = None
        self.post_fraction_along = _cast(float, post_fraction_along)
        self.post_fraction_along_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseConnectionOldFormat
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseConnectionOldFormat.subclass:
            return BaseConnectionOldFormat.subclass(*args_, **kwargs_)
        else:
            return BaseConnectionOldFormat(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (int)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            pass

    def validate_ZeroToOne(self, value):
        # Validate type ZeroToOne, a restriction on xs:float.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (float)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ZeroToOne'
                    % {"value": value, "lineno": lineno}
                )
                result = False
            if value > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ZeroToOne'
                    % {"value": value, "lineno": lineno}
                )
                result = False

    def _hasContent(self):
        if super(BaseConnectionOldFormat, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseConnectionOldFormat",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BaseConnectionOldFormat")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BaseConnectionOldFormat":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseConnectionOldFormat",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BaseConnectionOldFormat",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BaseConnectionOldFormat",
    ):
        super(BaseConnectionOldFormat, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseConnectionOldFormat",
        )
        if self.pre_cell_id is not None and "pre_cell_id" not in already_processed:
            already_processed.add("pre_cell_id")
            outfile.write(
                " preCellId=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.pre_cell_id), input_name="preCellId"
                        )
                    ),
                )
            )
        if self.pre_segment_id != 0 and "pre_segment_id" not in already_processed:
            already_processed.add("pre_segment_id")
            outfile.write(
                ' preSegmentId="%s"'
                % self.gds_format_integer(
                    self.pre_segment_id, input_name="preSegmentId"
                )
            )
        if (
            self.pre_fraction_along != 0.5
            and "pre_fraction_along" not in already_processed
        ):
            already_processed.add("pre_fraction_along")
            outfile.write(
                ' preFractionAlong="%s"'
                % self.gds_format_float(
                    self.pre_fraction_along, input_name="preFractionAlong"
                )
            )
        if self.post_cell_id is not None and "post_cell_id" not in already_processed:
            already_processed.add("post_cell_id")
            outfile.write(
                " postCellId=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.post_cell_id), input_name="postCellId"
                        )
                    ),
                )
            )
        if self.post_segment_id != 0 and "post_segment_id" not in already_processed:
            already_processed.add("post_segment_id")
            outfile.write(
                ' postSegmentId="%s"'
                % self.gds_format_integer(
                    self.post_segment_id, input_name="postSegmentId"
                )
            )
        if (
            self.post_fraction_along != 0.5
            and "post_fraction_along" not in already_processed
        ):
            already_processed.add("post_fraction_along")
            outfile.write(
                ' postFractionAlong="%s"'
                % self.gds_format_float(
                    self.post_fraction_along, input_name="postFractionAlong"
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseConnectionOldFormat",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BaseConnectionOldFormat, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.pre_cell_id, "pre_cell_id"
        )
        self.gds_check_cardinality_(self.pre_cell_id, "pre_cell_id", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NonNegativeInteger, self.pre_segment_id, "pre_segment_id"
        )
        self.gds_check_cardinality_(
            self.pre_segment_id, "pre_segment_id", required=False
        )
        self.gds_validate_defined_ST_(
            self.validate_ZeroToOne, self.pre_fraction_along, "pre_fraction_along"
        )
        self.gds_check_cardinality_(
            self.pre_fraction_along, "pre_fraction_along", required=False
        )
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.post_cell_id, "post_cell_id"
        )
        self.gds_check_cardinality_(self.post_cell_id, "post_cell_id", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NonNegativeInteger, self.post_segment_id, "post_segment_id"
        )
        self.gds_check_cardinality_(
            self.post_segment_id, "post_segment_id", required=False
        )
        self.gds_validate_defined_ST_(
            self.validate_ZeroToOne, self.post_fraction_along, "post_fraction_along"
        )
        self.gds_check_cardinality_(
            self.post_fraction_along, "post_fraction_along", required=False
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("preCellId", node)
        if value is not None and "preCellId" not in already_processed:
            already_processed.add("preCellId")
            self.pre_cell_id = value
        value = find_attr_value_("preSegmentId", node)
        if value is not None and "preSegmentId" not in already_processed:
            already_processed.add("preSegmentId")
            self.pre_segment_id = self.gds_parse_integer(value, node, "preSegmentId")
            if self.pre_segment_id < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
            self.validate_NonNegativeInteger(
                self.pre_segment_id
            )  # validate type NonNegativeInteger
        value = find_attr_value_("preFractionAlong", node)
        if value is not None and "preFractionAlong" not in already_processed:
            already_processed.add("preFractionAlong")
            value = self.gds_parse_float(value, node, "preFractionAlong")
            self.pre_fraction_along = value
            self.validate_ZeroToOne(self.pre_fraction_along)  # validate type ZeroToOne
        value = find_attr_value_("postCellId", node)
        if value is not None and "postCellId" not in already_processed:
            already_processed.add("postCellId")
            self.post_cell_id = value
        value = find_attr_value_("postSegmentId", node)
        if value is not None and "postSegmentId" not in already_processed:
            already_processed.add("postSegmentId")
            self.post_segment_id = self.gds_parse_integer(value, node, "postSegmentId")
            if self.post_segment_id < 0:
                raise_parse_error(node, "Invalid NonNegativeInteger")
            self.validate_NonNegativeInteger(
                self.post_segment_id
            )  # validate type NonNegativeInteger
        value = find_attr_value_("postFractionAlong", node)
        if value is not None and "postFractionAlong" not in already_processed:
            already_processed.add("postFractionAlong")
            value = self.gds_parse_float(value, node, "postFractionAlong")
            self.post_fraction_along = value
            self.validate_ZeroToOne(self.post_fraction_along)  # validate type ZeroToOne
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(BaseConnectionOldFormat, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BaseConnectionOldFormat, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class BaseConnectionOldFormat


class Projection(BaseProjection):
    """Projection -- Projection from one population, **presynapticPopulation**  to another, **postsynapticPopulation,**  through **synapse.**  Contains lists of  **connection**  or  **connectionWD**  elements."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("synapse", "NmlId", 0, 0, {"use": "required", "name": "synapse"}),
        MemberSpec_(
            "connections",
            "Connection",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "connection",
                "type": "Connection",
            },
            None,
        ),
        MemberSpec_(
            "connection_wds",
            "ConnectionWD",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "connectionWD",
                "type": "ConnectionWD",
            },
            None,
        ),
    ]
    subclass = None
    superclass = BaseProjection

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        presynaptic_population: "a NmlId (required)" = None,
        postsynaptic_population: "a NmlId (required)" = None,
        synapse: "a NmlId (required)" = None,
        connections: "list of Connection(s) (optional)" = None,
        connection_wds: "list of ConnectionWD(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Projection"), self).__init__(
            id, presynaptic_population, postsynaptic_population, **kwargs_
        )
        self.synapse = _cast(None, synapse)
        self.synapse_nsprefix_ = None
        if connections is None:
            self.connections = []
        else:
            self.connections = connections
        self.connections_nsprefix_ = None
        if connection_wds is None:
            self.connection_wds = []
        else:
            self.connection_wds = connection_wds
        self.connection_wds_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Projection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Projection.subclass:
            return Projection.subclass(*args_, **kwargs_)
        else:
            return Projection(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if (
            self.connections
            or self.connection_wds
            or super(Projection, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Projection",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Projection")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Projection":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Projection"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Projection",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Projection"
    ):
        super(Projection, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Projection"
        )
        if self.synapse is not None and "synapse" not in already_processed:
            already_processed.add("synapse")
            outfile.write(
                " synapse=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.synapse), input_name="synapse"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Projection",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Projection, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for connection_ in self.connections:
            namespaceprefix_ = (
                self.connections_nsprefix_ + ":"
                if (UseCapturedNS_ and self.connections_nsprefix_)
                else ""
            )
            connection_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="connection",
                pretty_print=pretty_print,
            )
        for connectionWD_ in self.connection_wds:
            namespaceprefix_ = (
                self.connection_wds_nsprefix_ + ":"
                if (UseCapturedNS_ and self.connection_wds_nsprefix_)
                else ""
            )
            connectionWD_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="connectionWD",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.synapse, "synapse")
        self.gds_check_cardinality_(self.synapse, "synapse", required=True)
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.connections, "connections", min_occurs=0, max_occurs=9999999
        )
        self.gds_check_cardinality_(
            self.connection_wds, "connection_wds", min_occurs=0, max_occurs=9999999
        )
        if recursive:
            for item in self.connections:
                item.validate_(gds_collector, recursive=True)
            for item in self.connection_wds:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("synapse", node)
        if value is not None and "synapse" not in already_processed:
            already_processed.add("synapse")
            self.synapse = value
            self.validate_NmlId(self.synapse)  # validate type NmlId
        super(Projection, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "connection":
            obj_ = Connection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.connections.append(obj_)
            obj_.original_tagname_ = "connection"
        elif nodeName_ == "connectionWD":
            obj_ = ConnectionWD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.connection_wds.append(obj_)
            obj_.original_tagname_ = "connectionWD"
        super(Projection, self)._buildChildren(child_, node, nodeName_, True)

    def exportHdf5(self, h5file, h5Group):
        """Export to HDF5 file."""
        # print("Exporting Projection: "+str(self.id)+" as HDF5")

        projGroup = h5file.create_group(h5Group, "projection_" + self.id)
        projGroup._f_setattr("id", self.id)
        projGroup._f_setattr("type", "projection")
        projGroup._f_setattr("presynapticPopulation", self.presynaptic_population)
        projGroup._f_setattr("postsynapticPopulation", self.postsynaptic_population)
        projGroup._f_setattr("synapse", self.synapse)

        # print("Exporting "+str(len(self.connections))+" connections, "+str(len(self.connection_wds))+" connections with weight")

        connection_wds = len(self.connection_wds) > 0

        cols = 2

        extra_cols = {}

        include_segment_fraction = neuroml.utils.has_segment_fraction_info(
            self.connections
        ) or neuroml.utils.has_segment_fraction_info(self.connection_wds)

        if include_segment_fraction:
            extra_cols["column_" + str(cols)] = "pre_segment_id"
            extra_cols["column_" + str(cols + 1)] = "post_segment_id"
            extra_cols["column_" + str(cols + 2)] = "pre_fraction_along"
            extra_cols["column_" + str(cols + 3)] = "post_fraction_along"
            cols += 4

        if connection_wds:
            extra_cols["column_" + str(cols)] = "weight"
            extra_cols["column_" + str(cols + 1)] = "delay"
            cols += 2

        a = numpy.zeros(
            [len(self.connections) + len(self.connection_wds), cols], numpy.float32
        )

        count = 0

        for connection in self.connections:
            ####a[count,0] = connection.id
            a[count, 0] = connection.get_pre_cell_id()
            a[count, 1] = connection.get_post_cell_id()
            if include_segment_fraction:
                a[count, 2] = connection.pre_segment_id
                a[count, 3] = connection.post_segment_id
                a[count, 4] = connection.pre_fraction_along
                a[count, 5] = connection.post_fraction_along
            count = count + 1

        for connection in self.connection_wds:
            ###a[count,0] = connection.id
            a[count, 0] = connection.get_pre_cell_id()
            a[count, 1] = connection.get_post_cell_id()

            if include_segment_fraction:
                a[count, 2] = connection.pre_segment_id
                a[count, 3] = connection.post_segment_id
                a[count, 4] = connection.pre_fraction_along
                a[count, 5] = connection.post_fraction_along

            a[count, cols - 2] = connection.weight
            if "ms" in connection.delay:
                delay = float(connection.delay[:-2].strip())
            elif "s" in connection.delay:
                delay = float(connection.delay[:-1].strip()) * 1000.0
            elif "us" in connection.delay:
                delay = float(connection.delay[:-2].strip()) / 1e3

            a[count, cols - 1] = delay
            count = count + 1

        if len(a) > 0:
            array = h5file.create_carray(
                projGroup, self.id, obj=a, title="Connections of cells in " + self.id
            )

            ###array._f_setattr("column_0", "id")
            array._f_setattr("column_0", "pre_cell_id")
            array._f_setattr("column_1", "post_cell_id")

            for col in extra_cols.keys():
                array._f_setattr(col, extra_cols[col])

    def __str__(self):
        return (
            "Projection: "
            + self.id
            + " from "
            + self.presynaptic_population
            + " to "
            + self.postsynaptic_population
            + ", synapse: "
            + self.synapse
        )

    # end class Projection


class SpikeGeneratorRefPoisson(SpikeGeneratorPoisson):
    """SpikeGeneratorRefPoisson -- Generator of spikes whose ISI distribution is the maximum entropy distribution over [ **minimumISI,**  +infinity ) with mean: 1 / **averageRate**
    \n
    :param minimumISI: The minimum interspike interval
    :type minimumISI: time
    :param averageRate: The average rate at which spikes are emitted
    :type averageRate: per_time

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "minimum_isi",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "minimum_isi"},
        ),
    ]
    subclass = None
    superclass = SpikeGeneratorPoisson

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        average_rate: "a Nml2Quantity_pertime (required)" = None,
        minimum_isi: "a Nml2Quantity_time (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SpikeGeneratorRefPoisson"), self).__init__(
            id, metaid, notes, properties, annotation, average_rate, **kwargs_
        )
        self.minimum_isi = _cast(None, minimum_isi)
        self.minimum_isi_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpikeGeneratorRefPoisson
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeGeneratorRefPoisson.subclass:
            return SpikeGeneratorRefPoisson.subclass(*args_, **kwargs_)
        else:
            return SpikeGeneratorRefPoisson(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(SpikeGeneratorRefPoisson, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpikeGeneratorRefPoisson",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SpikeGeneratorRefPoisson")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SpikeGeneratorRefPoisson":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="SpikeGeneratorRefPoisson",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SpikeGeneratorRefPoisson",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SpikeGeneratorRefPoisson",
    ):
        super(SpikeGeneratorRefPoisson, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="SpikeGeneratorRefPoisson",
        )
        if self.minimum_isi is not None and "minimum_isi" not in already_processed:
            already_processed.add("minimum_isi")
            outfile.write(
                " minimumISI=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.minimum_isi), input_name="minimumISI"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SpikeGeneratorRefPoisson",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SpikeGeneratorRefPoisson, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.minimum_isi, "minimum_isi"
        )
        self.gds_check_cardinality_(self.minimum_isi, "minimum_isi", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("minimumISI", node)
        if value is not None and "minimumISI" not in already_processed:
            already_processed.add("minimumISI")
            self.minimum_isi = value
            self.validate_Nml2Quantity_time(
                self.minimum_isi
            )  # validate type Nml2Quantity_time
        super(SpikeGeneratorRefPoisson, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SpikeGeneratorRefPoisson, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class SpikeGeneratorRefPoisson


class IntracellularProperties2CaPools(IntracellularProperties):
    """IntracellularProperties2CaPools -- Variant of intracellularProperties with 2 independent Ca pools"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = IntracellularProperties

    def __init__(
        self,
        species: "list of Species(s) (optional)" = None,
        resistivities: "list of Resistivity(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IntracellularProperties2CaPools"), self).__init__(
            species, resistivities, **kwargs_
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntracellularProperties2CaPools
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntracellularProperties2CaPools.subclass:
            return IntracellularProperties2CaPools.subclass(*args_, **kwargs_)
        else:
            return IntracellularProperties2CaPools(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(IntracellularProperties2CaPools, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IntracellularProperties2CaPools",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "IntracellularProperties2CaPools"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "IntracellularProperties2CaPools"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="IntracellularProperties2CaPools",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IntracellularProperties2CaPools",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="IntracellularProperties2CaPools",
    ):
        super(IntracellularProperties2CaPools, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="IntracellularProperties2CaPools",
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IntracellularProperties2CaPools",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IntracellularProperties2CaPools, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(IntracellularProperties2CaPools, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(IntracellularProperties2CaPools, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class IntracellularProperties2CaPools


class ConcentrationModel_D(DecayingPoolConcentrationModel):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("type", "xs:string", 0, 0, {"use": "required", "name": "type"}),
    ]
    subclass = None
    superclass = DecayingPoolConcentrationModel

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        ion: "a NmlId (required)" = None,
        resting_conc: "a Nml2Quantity_concentration (required)" = None,
        decay_constant: "a Nml2Quantity_time (required)" = None,
        shell_thickness: "a Nml2Quantity_length (required)" = None,
        type: "a string (required)" = "decayingPoolConcentrationModel",
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ConcentrationModel_D"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            ion,
            resting_conc,
            decay_constant,
            shell_thickness,
            **kwargs_,
        )
        self.type = _cast(None, type)
        self.type_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConcentrationModel_D
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConcentrationModel_D.subclass:
            return ConcentrationModel_D.subclass(*args_, **kwargs_)
        else:
            return ConcentrationModel_D(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(ConcentrationModel_D, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ConcentrationModel_D",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ConcentrationModel_D")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ConcentrationModel_D":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ConcentrationModel_D",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ConcentrationModel_D",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ConcentrationModel_D",
    ):
        super(ConcentrationModel_D, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ConcentrationModel_D",
        )
        if self.type is not None and "type" not in already_processed:
            already_processed.add("type")
            outfile.write(
                " type=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.type), input_name="type"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ConcentrationModel_D",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ConcentrationModel_D, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.type, "type")
        self.gds_check_cardinality_(self.type, "type", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type = value
        super(ConcentrationModel_D, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ConcentrationModel_D, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class ConcentrationModel_D


class ChannelDensityNernstCa2(ChannelDensityNernst):
    """ChannelDensityNernstCa2 -- This component is similar to the original component type  **channelDensityNernst**  but it is changed in order to have a reversal potential that depends on a second independent Ca++ pool ( ca2 ). See https://github.com/OpenSourceBrain/ghk-nernst.
    \n
    :param condDensity:
    :type condDensity: conductanceDensity

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = ChannelDensityNernst

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        ion_channel: "a NmlId (required)" = None,
        cond_density: "a Nml2Quantity_conductanceDensity (optional)" = None,
        segment_groups: "a NmlId (optional)" = "all",
        segments: "a NonNegativeInteger (optional)" = None,
        ion: "a NmlId (required)" = None,
        variable_parameters: "list of VariableParameter(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ChannelDensityNernstCa2"), self).__init__(
            id,
            ion_channel,
            cond_density,
            segment_groups,
            segments,
            ion,
            variable_parameters,
            **kwargs_,
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityNernstCa2
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityNernstCa2.subclass:
            return ChannelDensityNernstCa2.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityNernstCa2(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(ChannelDensityNernstCa2, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ChannelDensityNernstCa2",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ChannelDensityNernstCa2")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ChannelDensityNernstCa2":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityNernstCa2",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ChannelDensityNernstCa2",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ChannelDensityNernstCa2",
    ):
        super(ChannelDensityNernstCa2, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityNernstCa2",
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ChannelDensityNernstCa2",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ChannelDensityNernstCa2, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(ChannelDensityNernstCa2, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ChannelDensityNernstCa2, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class ChannelDensityNernstCa2


class ChannelDensityVShift(ChannelDensity):
    """ChannelDensityVShift -- Same as  **channelDensity** , but with a **vShift**  parameter to change voltage activation of gates. The exact usage of **vShift**  in expressions for rates is determined by the individual gates.
    \n
    :param vShift:
    :type vShift: voltage
    :param erev: The reversal potential of the current produced
    :type erev: voltage
    :param condDensity:
    :type condDensity: conductanceDensity

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "v_shift",
            "Nml2Quantity_voltage",
            0,
            0,
            {"use": "required", "name": "v_shift"},
        ),
    ]
    subclass = None
    superclass = ChannelDensity

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        ion_channel: "a NmlId (required)" = None,
        cond_density: "a Nml2Quantity_conductanceDensity (optional)" = None,
        erev: "a Nml2Quantity_voltage (required)" = None,
        segment_groups: "a NmlId (optional)" = "all",
        segments: "a NonNegativeInteger (optional)" = None,
        ion: "a NmlId (required)" = None,
        variable_parameters: "list of VariableParameter(s) (optional)" = None,
        v_shift: "a Nml2Quantity_voltage (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ChannelDensityVShift"), self).__init__(
            id,
            ion_channel,
            cond_density,
            erev,
            segment_groups,
            segments,
            ion,
            variable_parameters,
            **kwargs_,
        )
        self.v_shift = _cast(None, v_shift)
        self.v_shift_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityVShift
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityVShift.subclass:
            return ChannelDensityVShift.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityVShift(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def _hasContent(self):
        if super(ChannelDensityVShift, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ChannelDensityVShift",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ChannelDensityVShift")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ChannelDensityVShift":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityVShift",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ChannelDensityVShift",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ChannelDensityVShift",
    ):
        super(ChannelDensityVShift, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ChannelDensityVShift",
        )
        if self.v_shift is not None and "v_shift" not in already_processed:
            already_processed.add("v_shift")
            outfile.write(
                " vShift=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.v_shift), input_name="vShift"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ChannelDensityVShift",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ChannelDensityVShift, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.v_shift, "v_shift"
        )
        self.gds_check_cardinality_(self.v_shift, "v_shift", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("vShift", node)
        if value is not None and "vShift" not in already_processed:
            already_processed.add("vShift")
            self.v_shift = value
            self.validate_Nml2Quantity_voltage(
                self.v_shift
            )  # validate type Nml2Quantity_voltage
        super(ChannelDensityVShift, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ChannelDensityVShift, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class ChannelDensityVShift


class MembraneProperties2CaPools(MembraneProperties):
    """MembraneProperties2CaPools -- Variant of membraneProperties with 2 independent Ca pools"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "channel_density_nernst_ca2s",
            "ChannelDensityNernstCa2",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "channelDensityNernstCa2",
                "type": "ChannelDensityNernstCa2",
            },
            None,
        ),
    ]
    subclass = None
    superclass = MembraneProperties

    def __init__(
        self,
        channel_populations: "list of ChannelPopulation(s) (optional)" = None,
        channel_densities: "list of ChannelDensity(s) (optional)" = None,
        channel_density_v_shifts: "list of ChannelDensityVShift(s) (optional)" = None,
        channel_density_nernsts: "list of ChannelDensityNernst(s) (optional)" = None,
        channel_density_ghks: "list of ChannelDensityGHK(s) (optional)" = None,
        channel_density_ghk2s: "list of ChannelDensityGHK2(s) (optional)" = None,
        channel_density_non_uniforms: "list of ChannelDensityNonUniform(s) (optional)" = None,
        channel_density_non_uniform_nernsts: "list of ChannelDensityNonUniformNernst(s) (optional)" = None,
        channel_density_non_uniform_ghks: "list of ChannelDensityNonUniformGHK(s) (optional)" = None,
        spike_threshes: "list of SpikeThresh(s) (optional)" = None,
        specific_capacitances: "list of SpecificCapacitance(s) (optional)" = None,
        init_memb_potentials: "list of InitMembPotential(s) (optional)" = None,
        channel_density_nernst_ca2s: "list of ChannelDensityNernstCa2(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("MembraneProperties2CaPools"), self).__init__(
            channel_populations,
            channel_densities,
            channel_density_v_shifts,
            channel_density_nernsts,
            channel_density_ghks,
            channel_density_ghk2s,
            channel_density_non_uniforms,
            channel_density_non_uniform_nernsts,
            channel_density_non_uniform_ghks,
            spike_threshes,
            specific_capacitances,
            init_memb_potentials,
            **kwargs_,
        )
        if channel_density_nernst_ca2s is None:
            self.channel_density_nernst_ca2s = []
        else:
            self.channel_density_nernst_ca2s = channel_density_nernst_ca2s
        self.channel_density_nernst_ca2s_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MembraneProperties2CaPools
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MembraneProperties2CaPools.subclass:
            return MembraneProperties2CaPools.subclass(*args_, **kwargs_)
        else:
            return MembraneProperties2CaPools(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.channel_density_nernst_ca2s
            or super(MembraneProperties2CaPools, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="MembraneProperties2CaPools",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("MembraneProperties2CaPools")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "MembraneProperties2CaPools":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="MembraneProperties2CaPools",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="MembraneProperties2CaPools",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="MembraneProperties2CaPools",
    ):
        super(MembraneProperties2CaPools, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="MembraneProperties2CaPools",
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="MembraneProperties2CaPools",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(MembraneProperties2CaPools, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for channelDensityNernstCa2_ in self.channel_density_nernst_ca2s:
            namespaceprefix_ = (
                self.channel_density_nernst_ca2s_nsprefix_ + ":"
                if (UseCapturedNS_ and self.channel_density_nernst_ca2s_nsprefix_)
                else ""
            )
            channelDensityNernstCa2_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="channelDensityNernstCa2",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.channel_density_nernst_ca2s,
            "channel_density_nernst_ca2s",
            min_occurs=0,
            max_occurs=9999999,
        )
        if recursive:
            for item in self.channel_density_nernst_ca2s:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(MembraneProperties2CaPools, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "channelDensityNernstCa2":
            obj_ = ChannelDensityNernstCa2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channel_density_nernst_ca2s.append(obj_)
            obj_.original_tagname_ = "channelDensityNernstCa2"
        super(MembraneProperties2CaPools, self)._buildChildren(
            child_, node, nodeName_, True
        )


# end class MembraneProperties2CaPools


class Cell(BaseCell):
    """Cell -- Cell with  **segment** s specified in a  **morphology**  element along with details on its  **biophysicalProperties** . NOTE: this can only be correctly simulated using jLEMS when there is a single segment in the cell, and **v**  of this cell represents the membrane potential in that isopotential segment."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "morphology_attr",
            "NmlId",
            0,
            1,
            {"use": "optional", "name": "morphology_attr"},
        ),
        MemberSpec_(
            "biophysical_properties_attr",
            "NmlId",
            0,
            1,
            {"use": "optional", "name": "biophysical_properties_attr"},
        ),
        MemberSpec_(
            "morphology",
            "Morphology",
            0,
            1,
            {"minOccurs": "0", "name": "morphology", "type": "Morphology"},
            None,
        ),
        MemberSpec_(
            "biophysical_properties",
            "BiophysicalProperties",
            0,
            1,
            {
                "minOccurs": "0",
                "name": "biophysicalProperties",
                "type": "BiophysicalProperties",
            },
            None,
        ),
    ]
    subclass = None
    superclass = BaseCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        morphology_attr: "a NmlId (optional)" = None,
        biophysical_properties_attr: "a NmlId (optional)" = None,
        morphology: "a Morphology (optional)" = None,
        biophysical_properties: "a BiophysicalProperties (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Cell"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            extensiontype_,
            **kwargs_,
        )
        self.morphology_attr = _cast(None, morphology_attr)
        self.morphology_attr_nsprefix_ = None
        self.biophysical_properties_attr = _cast(None, biophysical_properties_attr)
        self.biophysical_properties_attr_nsprefix_ = None
        self.morphology = morphology
        self.morphology_nsprefix_ = None
        self.biophysical_properties = biophysical_properties
        self.biophysical_properties_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Cell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cell.subclass:
            return Cell.subclass(*args_, **kwargs_)
        else:
            return Cell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if (
            self.morphology is not None
            or self.biophysical_properties is not None
            or super(Cell, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Cell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Cell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Cell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Cell"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Cell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Cell"
    ):
        super(Cell, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Cell"
        )
        if (
            self.morphology_attr is not None
            and "morphology_attr" not in already_processed
        ):
            already_processed.add("morphology_attr")
            outfile.write(
                " morphology=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.morphology_attr),
                            input_name="morphology_attr",
                        )
                    ),
                )
            )
        if (
            self.biophysical_properties_attr is not None
            and "biophysical_properties_attr" not in already_processed
        ):
            already_processed.add("biophysical_properties_attr")
            outfile.write(
                " biophysicalProperties=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.biophysical_properties_attr),
                            input_name="biophysical_properties_attr",
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Cell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Cell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.morphology is not None:
            namespaceprefix_ = (
                self.morphology_nsprefix_ + ":"
                if (UseCapturedNS_ and self.morphology_nsprefix_)
                else ""
            )
            self.morphology.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="morphology",
                pretty_print=pretty_print,
            )
        if self.biophysical_properties is not None:
            namespaceprefix_ = (
                self.biophysical_properties_nsprefix_ + ":"
                if (UseCapturedNS_ and self.biophysical_properties_nsprefix_)
                else ""
            )
            self.biophysical_properties.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="biophysicalProperties",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.morphology_attr, "morphology_attr"
        )
        self.gds_check_cardinality_(
            self.morphology_attr, "morphology_attr", required=False
        )
        self.gds_validate_defined_ST_(
            self.validate_NmlId,
            self.biophysical_properties_attr,
            "biophysical_properties_attr",
        )
        self.gds_check_cardinality_(
            self.biophysical_properties_attr,
            "biophysical_properties_attr",
            required=False,
        )
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.morphology, "morphology", min_occurs=0, max_occurs=1
        )
        self.gds_check_cardinality_(
            self.biophysical_properties,
            "biophysical_properties",
            min_occurs=0,
            max_occurs=1,
        )
        if recursive:
            if self.morphology is not None:
                self.morphology.validate_(gds_collector, recursive=True)
            if self.biophysical_properties is not None:
                self.biophysical_properties.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("morphology", node)
        if value is not None and "morphology_attr" not in already_processed:
            already_processed.add("morphology_attr")
            self.morphology_attr = value
            self.validate_NmlId(self.morphology_attr)  # validate type NmlId
        value = find_attr_value_("biophysicalProperties", node)
        if value is not None and "biophysical_properties_attr" not in already_processed:
            already_processed.add("biophysical_properties_attr")
            self.biophysical_properties_attr = value
            self.validate_NmlId(self.biophysical_properties_attr)  # validate type NmlId
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(Cell, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "morphology":
            obj_ = Morphology.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.morphology = obj_
            obj_.original_tagname_ = "morphology"
        elif nodeName_ == "biophysicalProperties":
            obj_ = BiophysicalProperties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.biophysical_properties = obj_
            obj_.original_tagname_ = "biophysicalProperties"
        super(Cell, self)._buildChildren(child_, node, nodeName_, True)

    # Get segment object by its id
    def get_segment(self, segment_id):
        # type: (int) -> Segment
        """Get segment object by its id

        :param segment_id: ID of segment
        :return: segment

        :raises ValueError: if the segment is not found in the cell
        """

        for segment in self.morphology.segments:
            if segment.id == segment_id:
                return segment

        raise ValueError(
            "Segment with id " + str(segment_id) + " not found in cell " + str(self.id)
        )

    def get_segments_by_substring(self, substring):
        # type: (str) -> dict
        """Get a dictionary of segment IDs and the segment matching the specified substring

        :param substring: substring to match
        :type substring: str
        :return: dictionary with segment ID as key, and segment as value
        :raises Exception: if no segments are found

        """
        segments = {}
        if substring:
            for segment in self.morphology.segments:
                if substring in segment.id:
                    segments[segment.id] = segment
        if len(segments) == 0:
            raise Exception(
                "Segments with id matching "
                + str(substring)
                + " not found in cell "
                + str(self.id)
            )
        return segments

    # Get the proximal point of a segment, even the proximal field is None and
    # so the proximal point is on the parent (at a point set by fraction_along)
    def get_actual_proximal(self, segment_id):
        # type: (str) -> Point3DWithDiam
        """Get the proximal point of a segment.

        If the proximal for the segment is set to None, calculate the proximal
        on the parent using fraction_along and return it.

        :param segment_id: ID of segment
        :return: proximal point
        """

        segment = self.get_segment(segment_id)
        if segment.proximal:
            return segment.proximal

        parent = self.get_segment(segment.parent.segments)
        fract = float(segment.parent.fraction_along)
        if fract == 1:
            return parent.distal
        elif fract == 0:
            return self.get_actual_proximal(segment.parent.segments)
        else:
            pd = parent.distal
            pp = self.get_actual_proximal(segment.parent.segments)
            # pp + f(pd - pp) = (1 - f)pp + f*pd
            p = Point3DWithDiam(
                x=(1 - fract) * pp.x + fract * pd.x,
                y=(1 - fract) * pp.y + fract * pd.y,
                z=(1 - fract) * pp.z + fract * pd.z,
            )
            p.diameter = (1 - fract) * pp.diameter + fract * pd.diameter

            return p

    def get_segment_length(self, segment_id):
        # type: (str) -> float
        """Get the length of the segment.

        :param segment_id: ID of segment
        :return: length of segment
        """

        segment = self.get_segment(segment_id)
        if segment.proximal:
            return segment.length
        else:
            prox = self.get_actual_proximal(segment_id)

            length = segment.distal.distance_to(prox)

            return length

    def get_segment_surface_area(self, segment_id):
        # type: (str) -> float
        """Get the surface area of the segment.

        :param segment_id: ID of the segment
        :return: surface area of segment
        """

        segment = self.get_segment(segment_id)
        if segment.proximal:
            return segment.surface_area
        else:
            prox = self.get_actual_proximal(segment_id)

            temp_seg = Segment(distal=segment.distal, proximal=prox)

            return temp_seg.surface_area

    def get_segment_volume(self, segment_id):
        # type: (str) -> float
        """Get volume of segment

        :param segment_id: ID of the segment
        :return: volume of the segment
        """
        segment = self.get_segment(segment_id)
        if segment.proximal:
            return segment.volume
        else:
            prox = self.get_actual_proximal(segment_id)

            temp_seg = Segment(distal=segment.distal, proximal=prox)

            return temp_seg.volume

    def get_segment_ids_vs_segments(self):
        # type: () -> Dict
        """Get a dictionary of segment IDs and the segments in the cell.

        :return: dictionary with segment ID as key, and segment as value
        """

        segments = {}
        for segment in self.morphology.segments:
            segments[segment.id] = segment

        return segments

    def get_all_segments_in_group(self, segment_group, assume_all_means_all=True):
        # type: (SegmentGroup, bool) -> List[int]
        """Get all the segments in a segment group of the cell.

        :param segment_group: segment group to get all segments of
        :param assume_all_means_all: return all segments if the "all" segment
            group wasn't explicitly defined
        :return: list of segment ids
        :rtype: list[int]

        :raises Exception: if no segment group is found in the cell.
        """

        if isinstance(segment_group, str):
            for sg in self.morphology.segment_groups:
                if sg.id == segment_group:
                    segment_group = sg
            if isinstance(segment_group, str):
                if (
                    assume_all_means_all and segment_group == "all"
                ):  # i.e. wasn't explicitly defined, but assume it means all segments
                    return [seg.id for seg in self.morphology.segments]

                raise Exception(
                    "No segment group " + segment_group + " found in cell " + self.id
                )

        all_segs = []

        for member in segment_group.members:
            if not member.segments in all_segs:
                all_segs.append(member.segments)

        for include in segment_group.includes:
            segs_here = self.get_all_segments_in_group(include.segment_groups)
            for s in segs_here:
                if not s in all_segs:
                    all_segs.append(s)

        return all_segs

    def get_ordered_segments_in_groups(
        self,
        group_list,
        check_parentage=False,
        include_cumulative_lengths=False,
        include_path_lengths=False,
        path_length_metric="Path Length from root",
    ):  # Only option supported
        # type: (List, bool, bool, bool, str) -> Any
        """
        Get ordered list of segments in specified groups, with additional
        information.

        Note that this method orders segments by id, so the assumption is that
        all segment with id `N + m` will be a descendent of segment with id `N`
        in the segment group.

        :param group_list: a group id or list of group ids to get segments from
        :type group_list: str or list(str)
        :param check_parentage: verify parentage
        :type check_parentage: bool
        :param include_cumulative_lengths: also include cummulative length of
            each segment from root
        :type include_cumulative_lengths: bool
        :param include_path_lengths: also include path lengths from segment
            group's root segment to proximal and distal points of each segment
        :type include_path_lengths: bool
        :param path_length_metric: metric to use for path length ("Path Length
            from root" is currently the only supported option, and the default)
        :type path_length_metric: str

        :returns: depending on provided arguments:

                - if no additional options are provided, returns a dictionary
                  with segment group ids as keys, and lists of ordered segments
                  in those segment groups as values (`ord_segs`)
                - if only `include_path_lengths` is set, returns a tuple:
                  `[ord_segs, path_lengths_to_proximal ,
                  path_lengths_to_distal]`
                - if only `include_cumulative_lengths` is set, returns a tuple:
                  `[ord_segs, cumulative_lengths]`
                - if both `include_path_lengths` and
                  `include_cumulative_lengths` are set, returns a tuple:
                  `[ord_segs, cumulative_lengths, path_lengths_to_proximal ,
                  path_lengths_to_distal]`

        :raises: Exception if check_parentage is True and parentage cannot be verified
        """

        unord_segs = {}
        other_segs = {}

        # convert to list if a single segment group ID has been provided
        if isinstance(group_list, str):
            group_list = [group_list]

        # populate the dict to ensure that the order of segment groups is
        # maintained in the returned result
        for sgid in group_list:
            unord_segs[sgid] = None

        # get a dict of all segments in the cell, with their ids as keys
        segments = self.get_segment_ids_vs_segments()

        # get list of segments in all segment groups
        # and store this information in two dicts:
        # - unord_segs: for segment groups in group_list
        # - other_segs: for segment groups not in group_list
        for sg in self.morphology.segment_groups:
            # get all segments in a segment group
            all_segs_here = self.get_all_segments_in_group(sg)

            if sg.id in group_list:
                unord_segs[sg.id] = [segments[s] for s in all_segs_here]
            else:
                other_segs[sg.id] = [segments[s] for s in all_segs_here]

        ord_segs = {}

        # sort unord_segs by id to get an ordered list in ord_segs
        for key, segs in unord_segs.items():
            if segs is not None:
                if len(segs) == 1 or len(segs) == 0:
                    ord_segs[key] = segs
                else:
                    ord_segs[key] = sorted(segs, key=attrgetter("id"), reverse=False)

        if check_parentage:
            # check parent ordering

            for key in ord_segs.keys():
                existing_ids = []
                for s in ord_segs[key]:
                    if s.id != ord_segs[key][0].id:
                        if not s.parent or not s.parent.segments in existing_ids:
                            raise Exception(
                                "Problem with finding parent of seg: "
                                + str(s)
                                + " in list: "
                                + str(ord_segs)
                            )
                    existing_ids.append(s.id)

        if include_cumulative_lengths or include_path_lengths:
            cumulative_lengths = {}
            path_lengths_to_proximal = {}
            path_lengths_to_distal = {}

            for key in ord_segs.keys():
                cumulative_lengths[key] = []
                path_lengths_to_proximal[key] = {}
                path_lengths_to_distal[key] = {}

                tot_len = 0
                for seg in ord_segs[key]:
                    length = self.get_segment_length(seg.id)

                    if (
                        not seg.parent
                        or not seg.parent.segments in path_lengths_to_distal[key]
                    ):
                        path_lengths_to_proximal[key][seg.id] = 0
                        last_seg = seg
                        par_seg_element = seg.parent
                        while par_seg_element != None:
                            par_seg = segments[par_seg_element.segments]
                            par_length = self.get_segment_length(par_seg.id)

                            fract = float(last_seg.parent.fraction_along)
                            path_lengths_to_proximal[key][seg.id] += par_length * fract

                            last_seg = par_seg
                            par_seg_element = par_seg.parent

                    else:
                        pd = path_lengths_to_distal[key][seg.parent.segments]
                        pp = path_lengths_to_proximal[key][seg.parent.segments]
                        fract = float(seg.parent.fraction_along)

                        path_lengths_to_proximal[key][seg.id] = pp + (pd - pp) * fract

                    path_lengths_to_distal[key][seg.id] = (
                        path_lengths_to_proximal[key][seg.id] + length
                    )

                    tot_len += length
                    cumulative_lengths[key].append(tot_len)

        if include_path_lengths and not include_cumulative_lengths:
            return ord_segs, path_lengths_to_proximal, path_lengths_to_distal

        if include_cumulative_lengths and not include_path_lengths:
            return ord_segs, cumulative_lengths

        if include_cumulative_lengths and include_path_lengths:
            return (
                ord_segs,
                cumulative_lengths,
                path_lengths_to_proximal,
                path_lengths_to_distal,
            )

        return ord_segs

    def get_segment_group(self, sg_id):
        # type: (str) -> SegmentGroup
        """Return the SegmentGroup object for the specified segment group id.

        :param sg_id: id of segment group to find
        :type sg_id: str
        :returns: SegmentGroup object of specified ID
        :raises ValueError: if segment group is not found in cell
        """
        if sg_id:
            for sg in self.morphology.segment_groups:
                if sg.id == sg_id:
                    return sg

        raise ValueError(
            "Segment group with id " + str(sg_id) + " not found in cell " + str(self.id)
        )

    def get_segment_groups_by_substring(self, substring):
        # type: (str) -> dict
        """Get a dictionary of segment group IDs and the segment groups matching the specified substring

        :param substring: substring to match
        :type substring: str
        :return: dictionary with segment group ID as key, and segment group as value
        :raises ValueError: if no matching segment groups are found in cell
        """
        sgs = {}
        for sg in self.morphology.segment_groups:
            if substring in sg.id:
                sgs[sg.id] = sg
        if len(sgs) == 0:
            raise ValueError(
                "Segment group with id matching "
                + str(substring)
                + " not found in cell "
                + str(self.id)
            )
        return sgs

    def summary(self, morph=True, biophys=True):
        """Print cell summary.

        Shows the number of segments and segment groups, and information on the
        biophysical properties of the cell. See the `morphinfo` and
        `biophysinfo` methods for more details.

        :param morph: toggle showing/hiding morphology information
        :type morph: bool
        :param biophys: toggle showing/hiding biophysology information
        :type biophys: bool
        :returns: None
        """

        print(f"*********** Summary ({self.id}) ************")
        print("* Notes: " + str(self.notes))
        print()

        if morph:
            print(f"*********** Morphology summary ({self.id}) ************")
            self.morphinfo()
            print("*******************************************************")
            print("Tip: use morphinfo(True) to see more detailed information.")

        if biophys:
            print(f"*********** Biophys summary ({self.id}) ************")
            self.biophysinfo()
            print("*******************************************************")

    def morphinfo(self, segment_detail=False):
        """Show info on morphology of the cell.
        By default, since cells can have large numbers of segments and segment
        groups, it only provides metrics on the total numbers. To see details,
        pass `segment_detail=True`.

        See also: `get_segment_group_info`.

        :param segment_detail: toggle whether to show detailed information on
            segment groups and their segments
        :type segment_detail: bool
        :returns: None

        """
        print("* Segments: " + str(len(self.morphology.segments)))
        print("* SegmentGroups: " + str(len(self.morphology.segment_groups)))

        if segment_detail:
            for sg in self.morphology.segment_groups:
                self.get_segment_group_info(sg.id)

    def biophysinfo(self):
        """Get information on the biophysical properties of the cell.
        :returns: None

        """
        bp = None
        mp = None
        ip = None
        if self.__class__.__name__ == "Cell":
            bp = self.biophysical_properties
            mp = bp.membrane_properties
            ip = bp.intracellular_properties
        elif self.__class__.__name__ == "Cell2CaPools":
            bp = self.biophysical_properties2_ca_pools
            mp = bp.membrane_properties2_ca_pools
            ip = bp.intracellular_properties2_ca_pools

        membp = mp.info(show_contents=True, return_format="dict")
        # check if there are any membrane properties
        for prop, val in membp.items():
            if len(val["members"]) > 0:
                print(f"* Membrane properties")
                break

        for prop, val in membp.items():
            ctype = val["type"]
            # objects
            ms = val["members"]
            if len(ms) > 0:
                print(f"	* {ctype}:")
                for am in ms:
                    inf = am.info(show_contents=True, return_format="dict")
                    for p, v in inf.items():
                        print(f"		* {p}: {v['members']}")

                    print()

        intp = ip.info(show_contents=True, return_format="dict")
        for prop, val in intp.items():
            if len(val["members"]) > 0:
                print(f"* Intracellular properties")
                break

        for prop, val in intp.items():
            ctype = val["type"]
            # objects
            ms = val["members"]
            if len(ms) > 0:
                print(f"	* {ctype}:")
                for am in ms:
                    inf = am.info(show_contents=True, return_format="dict")
                    for p, v in inf.items():
                        print(f"		* {p}: {v['members']}")

                    print()

    def get_segment_group_info(self, group_id):
        """Get information about a segment group

        :param group_id: id of segment group
        :type group_id: int
        :returns: None

        """
        print(f"* Segment group: {group_id}:")
        segs = self.get_all_segments_in_group(segment_group=group_id)
        for s in segs:
            sinfo = self.get_segment(s)
            print(
                f"	 * {s} (Parent: {sinfo.parent.segments if sinfo.parent else '-'}; {self.get_actual_proximal(s)} -> {sinfo.distal})"
            )

    def add_segment(
        self,
        prox,
        dist,
        seg_id=None,
        name=None,
        parent=None,
        fraction_along=1.0,
        group_id=None,
        use_convention=True,
        seg_type=None,
        reorder_segment_groups=True,
        optimise_segment_groups=True,
    ):
        """Add a segment to the cell, to the provided segment group, creating
        it if required.

        :param prox: proximal segment information
        :type prox: list with 4 float entries: [x, y, z, diameter]
        :param dist: dist segment information
        :type dist: list with 4 float entries: [x, y, z, diameter]
        :param seg_id: explicit ID to set for segment
            When not provided, the function will automatically add an ID based
            on the number of segments already included in the cell. It is best
            to either always set an explicit ID or let the function set it
            automatically, but not to mix the two. A `ValueError` is raised if
            a segment with the provided ID already exists
        :type seg_id: str
        :param name: name of segment
            If a name is given, it is used.
            If no name is given, but a segment group is provided, the segment
            is named: "Seg<number>_<group name>" where <number> is the number
            of the segment in the segment group. (to be read as "segment
            <number> in <group>"; the group name should indicate the type here)
            If no name is given, and no segment group is provided, the segment
            is simply named: "Seg<segment id>".
        :type name: str
        :seg_type: type of segment ("axon", "dendrite", "soma")
            If `use_convention` is `True`, and a `group_id` is provided, the
            segment group will also be added to the default segment groups if
            it has not been previously added. If `group_id` is `None`, the
            segment will be added to the default groups instead.

            If `use_convention` is `False`, this is unused.
        :type seg_type: str
        :param parent: parent segment object
        :type parent: Segment
        :param fraction_along: where the new segment is connected to the parent (0: distal point, 1: proximal point)
        :type fraction_along: float
        :param group_id: id of segment group to add the segment to
            If a segment group with this id does not exist, a new segment group
            will be created.

            The suggested convention is: `axon_`, `soma_`, `dend_` for axonal,
            somatic, and dendritic segment groups respectively.

            Note that a newly created segment group will not be marked as an
            unbranched segment group. If you wish to add a segment to an
            unbranched segment group, please create one using
            `add_unbranched_segment_group` and then add segments to it.
        :type group_id: str
        :param use_convention: whether the segment or its group should be added
            to the global segment groups. The `seg_type` notes what global
            group this segment or its segment group should also be added to.
        :type use_convention: bool
        :param reorder_segment_groups: whether the groups should be reordered
            to put the default segment groups last after the segment has been
            added.
            This is required for a valid NeuroML file because segment groups
            included in the default groups should be declared before they are
            used in the default groups. When adding lots of segments, one may
            want to only reorder at the end of the process instead of after
            each segment is added.

            This is only relevant if `use_convention=True`.
        :type reorder_segment_groups: bool
        :param optimise_segment_groups: toggle whether segment groups should be
            optimised after operation
        :type optimise_segment_groups: bool
        :returns: the created segment
        :rtype: Segment
        :raises ValueError: if `seg_id` is provided and a segment with this ID
            already exists

        """
        try:
            if prox:
                p = self.component_factory(
                    "Point3DWithDiam", x=prox[0], y=prox[1], z=prox[2], diameter=prox[3]
                )
            else:
                p = None
        except IndexError as e:
            print("{}: prox must be a list of 4 elements".format(e))
        try:
            d = self.component_factory(
                "Point3DWithDiam", x=dist[0], y=dist[1], z=dist[2], diameter=dist[3]
            )
        except IndexError as e:
            print("{}: dist must be a list of 4 elements".format(e))

        segid = len(self.morphology.segments)
        if segid > 0 and parent is None:
            raise Exception(
                "There are currently more than one segments in the cell, but one is being added without specifying a parent segment"
            )

        sp = (
            self.component_factory(
                "SegmentParent", segments=parent.id, fraction_along=fraction_along
            )
            if parent
            else None
        )

        if seg_id:
            try:
                seg = None
                seg = self.get_segment(seg_id)
                if seg:
                    raise ValueError(
                        f"A segment with provided id {seg_id} already exists"
                    )
            except ValueError:
                # a segment with this ID does not already exist
                pass
        else:
            seg_id = segid

        segment = self.component_factory(
            "Segment", id=seg_id, proximal=p, distal=d, parent=sp
        )

        seg_group = None
        if group_id:
            seg_group_default = None

            # cell.get_segment_group throws an exception of the segment group
            # does not exist
            try:
                seg_group = self.get_segment_group(group_id)
            except ValueError as e:
                print("Warning: {}".format(e))
                print(f"Warning: creating Segment Group with id {group_id}")
                seg_group = self.add_segment_group(group_id=group_id)
            seg_group.members.append(Member(segments=segment.id))

        if use_convention:
            if not seg_type:
                raise ValueError("Please provide a seg_type")
            if seg_type == "axon":
                [seg_group_all, seg_group_default] = self.setup_default_segment_groups(
                    use_convention=True, default_groups=["all", "axon_group"]
                )
            elif seg_type == "soma":
                [seg_group_all, seg_group_default] = self.setup_default_segment_groups(
                    use_convention=True, default_groups=["all", "soma_group"]
                )
            elif seg_type == "dendrite":
                [seg_group_all, seg_group_default] = self.setup_default_segment_groups(
                    use_convention=True, default_groups=["all", "dendrite_group"]
                )
            else:
                raise ValueError(f"Invalid segment type provided: {seg_type}")

            # Now add the segment group that contains this segment if it exists
            # to the global groups. If a segment group does not exist for this
            # segment, add the segment itself to the global groups

            # Do not use add here, we do not need it's extra features (and
            # their performance costs)
            # De-duplicate/optimise later if required
            if seg_group and seg_group.id != seg_group_default.id:
                seg_group_default.includes.append(Include(segment_groups=seg_group.id))
                seg_group_all.includes.append(Include(segment_groups=seg_group.id))
            else:
                seg_group_default.members.append(Member(segments=segment.id))
                seg_group_all.members.append(Member(segments=segment.id))

            if reorder_segment_groups:
                self.reorder_segment_groups()

        if name:
            segment.name = name
        else:
            # set a default name based on the group membership if group
            # provided
            if group_id:
                # seg_group will exist by now: either it already existed or it
                # was created above
                segments_in_group = len(seg_group.members)
                segment_name = f"Seg{segments_in_group - 1}_{group_id}"
            else:
                # if it doesn't belong to a group, use the type to indicate
                # what kind of segment this is
                segment_name = f"Seg{seg_id}"
            segment.name = segment_name

        self.morphology.segments.append(segment)

        if optimise_segment_groups:
            self.optimise_segment_groups()

        return segment

    def add_segment_group(self, group_id, neuro_lex_id=None, notes=None):
        """Add a new general segment group.

        The segments included in this group do not need to be contiguous. This
        segment group will not be automatically marked as a section using the
        required NeuroLex ID.

        If a segment group with provided ID already exists, it will not be
        overwritten.

        :param group_id: ID of segment group
        :type group_id: str
        :param neuro_lex_id: NeuroLex ID to use for segment group
        :type neuro_lex_id: str
        :param notes: Notes text to add
        :type notes: str
        :returns: new segment group
        :rtype: SegmentGroup

        """
        seg_group = None
        try:
            seg_group = self.get_segment_group(group_id)
        except ValueError:
            seg_group = self.morphology.add(
                "SegmentGroup",
                id=group_id,
                neuro_lex_id=neuro_lex_id,
                notes=notes,
                validate=False,
            )
        else:
            print(f"Warning: Segment group {seg_group.id} already exists.")

        return seg_group

    def add_unbranched_segment_group(self, group_id, notes=None):
        """Add a new unbranched segment group.

        This is similar to the `add_segment_group` method, but this segment
        group will be used to store contiguous segments, which form an
        unbranched section of a cell. It adds the NeuroLex ID for a neuronal
        branch to the segment group.

        :param group_id: ID of segment group
        :type group_id: str
        :param notes: notes to add
        :type notes: str
        :returns: new segment group
        :rtype: SegmentGroup

        """
        seg_group = self.add_segment_group(
            group_id=group_id,
            neuro_lex_id=neuroml.neuro_lex_ids.neuro_lex_ids["section"],
            notes=notes,
        )
        return seg_group

    def reorder_segment_groups(self):
        """Move default segment groups to the end.

        This is required so that the segment groups included in the default
        groups are defined before they are used.

        :returns: None

        """
        seg_groups = self.morphology.segment_groups
        for group in ["soma_group", "axon_group", "dendrite_group", "all"]:
            try:
                sg = self.get_segment_group(group)
                seg_groups.append(seg_groups.pop(seg_groups.index(sg)))
            except ValueError:
                pass

    def optimise_segment_groups(self):
        """Optimise all segment groups in the cell.

        This will:

        - deduplicate members and includes in segment groups
        - remove members that have already been included using a segment group

        """
        for seg_group in self.morphology.segment_groups:
            self.optimise_segment_group(seg_group.id)

    def optimise_segment_group(self, seg_group_id):
        """Optimise segment group with id `seg_group_id`.

        :param seg_group_id: id of segment group to optimise
        :type seg_group_id: str

        """
        seg_group = self.get_segment_group(seg_group_id)
        # de-duplicate members and includes
        # cannot use list(set(list)) because the hash values for NeuroML
        # classes with identical values is also different

        members = seg_group.members
        new_members = []
        for i in members:
            if i not in new_members:
                new_members.append(i)
        members = new_members
        seg_group.members = list(members)

        includes = seg_group.includes
        new_includes = []
        for i in includes:
            if i not in new_includes:
                new_includes.append(i)
        includes = set(new_includes)
        seg_group.includes = list(includes)

        # remove members that are included by included segment groups
        if len(includes) > 0 and len(members) > 0:
            new_members = []
            for inc in includes:
                all_segment_ids_in_group = set(
                    self.get_all_segments_in_group(inc.segment_groups)
                )
                for i in members:
                    if i.segments not in all_segment_ids_in_group:
                        new_members.append(i)
            seg_group.members = list(new_members)

    def set_spike_thresh(self, v, group_id="all"):
        """Set the spike threshold of the cell.

        :param v: value to set for spike threshold with units
        :type v: str
        :param group_id: id of segment group to modify
        :type group_id: str
        """
        self.add_membrane_property("SpikeThresh", value=v, segment_groups=group_id)

    def set_init_memb_potential(self, v, group_id="all"):
        """Set the initial membrane potential of the cell.

        :param v: value to set for membrane potential with units
        :type v: str
        :param group_id: id of segment group to modify
        :type group_id: str
        """
        self.add_membrane_property(
            "InitMembPotential", value=v, segment_groups=group_id
        )

    def set_resistivity(self, resistivity, group_id="all") -> None:
        """Set the resistivity of the cell

        :type resistivity: str
        :param group_id: segment group to modify
        :type group_id: str
        """
        self.add_intracellular_property(
            "Resistivity", value=resistivity, segment_groups=group_id
        )

    def set_specific_capacitance(self, spec_cap, group_id="all"):
        """Set the specific capacitance for the cell.

        :param spec_cap: value of specific capacitance with units
        :type spec_cap: str
        :param group_id: segment group to modify
        :type group_id: str
        """
        self.add_membrane_property(
            "SpecificCapacitance", value=spec_cap, segment_groups=group_id
        )

    def add_intracellular_property(self, property_name, **kwargs):
        """Generic function to add an intracellular property to the cell.

        For a full list of membrane properties, see:
        https://docs.neuroml.org/Userdocs/Schemas/Cells.html?#intracellularproperties

        :param property_name: name of intracellular property to add
        :type property_name: str
        :param kwargs: named arguments for intracellular property to be added
        :type kwargs: Any
        :returns: added property

        """
        self.setup_nml_cell(use_convention=False)
        prop = self.biophysical_properties.intracellular_properties.add(
            property_name, **kwargs
        )
        return prop

    def add_membrane_property(self, property_name, **kwargs):
        """Generic function to add a membrane property to the cell.

        For a full list of membrane properties, see:
        https://docs.neuroml.org/Userdocs/Schemas/Cells.html?#membraneproperties

        Please also see specific functions in this module, which are designed to be
        easier to use than this generic function.

        :param property_name: name of membrane to add
        :type property_name: str
        :param kwargs: named arguments for membrane property to be added
        :type kwargs: Any
        :returns: added property

        """
        self.setup_nml_cell(use_convention=False)
        prop = self.biophysical_properties.membrane_properties.add(
            property_name, **kwargs
        )
        return prop

    def add_channel_density_v(
        self, channel_density_type, nml_cell_doc, ion_chan_def_file="", **kwargs
    ):
        """Generic function to add channel density components to a Cell.

        :param channel_density_type: type of channel density to add.
            See https://docs.neuroml.org/Userdocs/Schemas/Cells.html for the
            complete list.
        :type channel_density_type: str
        :param nml_cell_doc: cell NeuroML document to which channel density is to be added
        :type nml_cell_doc: NeuroMLDocument
        :param ion_chan_def_file: path to NeuroML2 file defining the ion channel, if empty, it assumes the channel is defined in the same file
        :type ion_chan_def_file: str
        :param kwargs: named arguments for required channel density type
        :type kwargs: Any
        :returns: added channel density
        """

        cd = self.add_membrane_property(channel_density_type, **kwargs)

        if len(ion_chan_def_file) > 0:
            if (
                self.component_factory("IncludeType", href=ion_chan_def_file)
                not in nml_cell_doc.includes
            ):
                nml_cell_doc.add("IncludeType", href=ion_chan_def_file)

        return cd

    def add_channel_density(
        self,
        nml_cell_doc,
        cd_id,
        ion_channel,
        cond_density,
        erev="0.0 mV",
        group_id="all",
        ion="non_specific",
        ion_chan_def_file="",
    ):
        """Add channel density.

        :param nml_cell_doc: cell NeuroML document to which channel density is to be added
        :type nml_cell_doc: NeuroMLDocument
        :param cd_id: id for channel density
        :type cd_id: str
        :param ion_channel: name of ion channel
        :type ion_channel: str
        :param cond_density: value of conductance density with units
        :type cond_density: str
        :param erev: value of reversal potential with units
        :type erev: str
        :param group_id: segment groups to add to
        :type group_id: str
        :param ion: name of ion
        :type ion: str
        :param ion_chan_def_file: path to NeuroML2 file defining the ion channel, if empty, it assumes the channel is defined in the same file
        :type ion_chan_def_file: str
        :returns: added channel density
        :rtype: ChannelDensity
        """
        cd = self.add_membrane_property(
            "ChannelDensity",
            id=cd_id,
            segment_groups=group_id,
            ion=ion,
            ion_channel=ion_channel,
            erev=erev,
            cond_density=cond_density,
        )

        if len(ion_chan_def_file) > 0:
            if (
                self.component_factory("IncludeType", href=ion_chan_def_file)
                not in nml_cell_doc.includes
            ):
                nml_cell_doc.add("IncludeType", href=ion_chan_def_file)

        return cd

    def setup_nml_cell(
        self, use_convention=True, overwrite=False, default_groups=["all", "soma_group"]
    ):
        """Correctly initialise a NeuroML cell.

        To be called after a new component has been created to initialise the
        cell with these properties:

        - Morphology: id="morphology"
        - BiophysicalProperties: id="biophys":

          - MembraneProperties
          - IntracellularProperties

        If `use_convention` is True, it also creates the provided
        `default_groups` SegmentGroups for convenience. By default, it creates
        the "all", and "soma_group" groups since each cell must at least have a
        soma.

        When dendritic and axonal segments are added, the `add_segment`
        function will create `dendrite_group` and `axon_group` groups as
        required.

        Note that since this cell does not currently include a segment in its
        morphology, it is *not* a valid NeuroML construct. Use the `add_segment`
        and `add_unbranched_segments` functions to add segments and branches.
        They will also populate the default segment groups.

        :param id: id of the cell
        :type id: str
        :param use_convention: whether helper segment groups should be created using the default convention
        :type use_convention: bool
        :param overwrite: overwrite existing components
        :type overwrite: bool
        :param default_groups: list of default segment groups to create
        :type default_groups: list of strings
        :returns: None
        :rtype: None

        """
        # do not validate yet, because segments are required
        self.add("Morphology", id="morphology", validate=False, force=overwrite)

        # add does not overwrite existing values
        self.add("BiophysicalProperties", id="biophys", validate=False, force=overwrite)
        self.biophysical_properties.add(
            "IntracellularProperties", validate=False, force=overwrite
        )
        self.biophysical_properties.add(
            "MembraneProperties", validate=False, force=overwrite
        )

        self.setup_default_segment_groups(use_convention, default_groups)

    def setup_default_segment_groups(
        self, use_convention=True, default_groups=["all", "soma_group"]
    ):
        """Create default segment groups for the cell.

        If `use_convention` is True, it also creates the provided
        `default_groups` SegmentGroups for convenience. By default, it creates
        the "all", and "soma_group" groups since each cell must at least have a
        soma. Allowed values are: "all", "soma_group", "axon_group", "dendrite_group".

        :param use_convention: whether helper segment groups should be created using the default convention
        :type use_convention: bool
        :param default_groups: list of default segment groups to create
        :type default_groups: list of strings
        :returns: list of created segment groups (or empty list if none created)
        :rtype: list
        """
        new_groups = []
        if use_convention:
            for grp in default_groups:
                neuro_lex_id = None
                notes = None

                if grp == "soma_group":
                    neuro_lex_id = neuroml.neuro_lex_ids.neuro_lex_ids["soma"]
                    notes = "Default soma segment group for the cell"
                elif grp == "axon_group":
                    neuro_lex_id = neuroml.neuro_lex_ids.neuro_lex_ids["axon"]
                    notes = "Default axon segment group for the cell"
                elif grp == "dendrite_group":
                    neuro_lex_id = neuroml.neuro_lex_ids.neuro_lex_ids["dend"]
                    notes = "Default dendrite segment group for the cell"
                elif grp == "all":
                    neuro_lex_id = None
                    notes = "Default segment group for all segments in the cell"
                else:
                    print(
                        f"Error: only 'all', 'soma_group', 'dendrite_group', and 'axon_group' are supported. Received {grp}"
                    )
                    return []

                seg_group = self.add_segment_group(
                    group_id=grp, neuro_lex_id=neuro_lex_id, notes=notes
                )
                new_groups.append(seg_group)

            self.reorder_segment_groups()

        return new_groups

    def add_unbranched_segments(
        self,
        points,
        parent=None,
        fraction_along=1.0,
        group_id=None,
        use_convention=True,
        seg_type=None,
        reorder_segment_groups=True,
        optimise_segment_groups=True,
    ):
        """Add an unbranched list of segments to the cell.

        The list of points will include the first proximal point where this
        should be joined to the cell, followed by a list of distal points:

        ::

            |-----|-----|-----|------|.....---|
            p1    d1    d2    d3     d4       d N-1

        So, a list of N points will create a list of N-1 segments

        The list of points will be of the form::

            [[x1, y1, z1, d1], [x2, y2, z2, d2] ...]

        Please ensure that the first point, p1, is correctly set to ensure that
        this segment list is correctly connected to the rest of the cell.

        :param points: 3D points to create the segments
        :type points: list of [x, y, z, d] points
        :param parent: parent segment where first segment of list is to be attached
        :type parent: SegmentParent
        :param fraction_along: where the new segment list is connected to the parent (0: distal point, 1: proximal point)
            Note that the second and following segments will all be added at the
            distal point of the previous segment
        :type fraction_along: float
        :param group_id: segment group to add the segment to
            if a segment group does not already exist, it will be created
        :type group_id: SegmentGroup
        :param use_convention: whether helper segment groups should be created using the default convention
            See the documentation of the `add_segment` method for more information
            on the convention
        :type use_convention: bool
        :param seg_type: type of segments ("axon", "soma", "dendrite")
        :type seg_type: str
        :param reorder_segment_groups: whether the groups should be reordered
            to put the default segment groups last after the segment has been
            added.
            This is required for a valid NeuroML file because segment groups
            included in the default groups should be declared before they are
            used in the default groups. When adding lots of segments, one may
            want to only reorder at the end of the process instead of after
            each segment is added.

            This is only relevant if `use_convention=True`.
        :type reorder_segment_groups: bool
        :param optimise_segment_groups: toggle whether segment groups should be
            optimised after operation
        :type optimise_segment_groups: bool
        :returns: the segment group containing this new list of segments
        :rtype: SegmentGroup

        """
        prox = points[0]
        dist = points[1]

        seg_group = self.add_unbranched_segment_group(group_id=group_id)

        # first segment
        seg = self.add_segment(
            prox=prox,
            dist=dist,
            name=None,
            parent=parent,
            fraction_along=fraction_along,
            group_id=group_id,
            use_convention=use_convention,
            seg_type=seg_type,
            reorder_segment_groups=False,
        )

        # rest of the segments
        prox = dist
        for pt in points[2:]:
            dist = pt
            seg = self.add_segment(
                prox=prox,
                dist=dist,
                name=None,
                parent=seg,
                fraction_along=1.0,
                group_id=group_id,
                use_convention=use_convention,
                seg_type=seg_type,
                reorder_segment_groups=False,
            )
            prox = dist

        if reorder_segment_groups:
            self.reorder_segment_groups()

        if optimise_segment_groups:
            self.optimise_segment_groups()

        return self.get_segment_group(group_id)

    def create_unbranched_segment_group_branches(
        self,
        root_segment_id: int,
        use_convention: bool = True,
        reorder_segment_groups=True,
        optimise_segment_groups=True,
    ):
        """Organise the segments of the cell into new segment groups that each
        form a single contiguous unbranched cell branch.

        Note that the first segment (root segment) of a branch must have a proximal
        point that connects it to the rest of the neuronal morphology. If, when
        constructing these branches, a root segment is found that does not include
        a proximal point, one will be added using the `get_actual_proximal` method.

        No other changes will be made to any segments, or to any pre-existing
        segment groups.

        :param root_segment_id: id of segment considered the root of the tree,
            generally the first soma segment
        :type root_segment_id: int
        :param use_convention: toggle using NeuroML convention for segment groups
        :type use_convention: bool
        :param reorder_segment_groups: whether the groups should be reordered
            to put the default segment groups last after the segment has been
            added.
            This is required for a valid NeuroML file because segment groups
            included in the default groups should be declared before they are
            used in the default groups. When adding lots of segments, one may
            want to only reorder at the end of the process instead of after
            each segment is added.

            This is only relevant if `use_convention=True`.
        :type reorder_segment_groups: bool
        :param optimise_segment_groups: toggle whether segment groups should be
            optimised after operation
        :type optimise_segment_groups: bool
        :returns: modified cell with new section groups
        :rtype: neuroml.Cell

        """
        # don't recompute if already exists
        # get morphology tree
        morph_tree = getattr(self, "adjacency_list", None)
        if morph_tree is None:
            morph_tree = self.get_segment_adjacency_list()

        # initialise root segment and first segment group
        seg = self.get_segment(root_segment_id)
        group_name = f"seg_group_{len(self.morphology.segment_groups) - 1}_seg_{seg.id}"
        new_seg_group = self.add_unbranched_segment_group(group_name)

        # run recursive function
        self.__sectionise(root_segment_id, new_seg_group, morph_tree)

        if reorder_segment_groups:
            self.reorder_segment_groups()

        if optimise_segment_groups:
            self.optimise_segment_groups()

    def __sectionise(self, root_segment_id, seg_group, morph_tree):
        """Main recursive sectionising method.

        :param root_segment_id: id of root of branch
        :type root_segment_id: int
        :returns: TODO

        """
        # print(f"Processing element: {root_segment_id}")

        try:
            children = morph_tree[root_segment_id]
            # keep going while there's only one child
            # no need to use recursion here---hits Python's recursion limits in
            # long segment groups
            # - if there are no children, it'll go to the except block
            # - if there are more than one children, it'll go to the next
            # conditional
            while len(children) == 1:
                seg_group.add("Member", segments=root_segment_id)
                root_segment_id = children[0]
                children = morph_tree[root_segment_id]
            # if there are more than one children, we've reached the end of this
            # segment group but not of the branch. New segment groups need to start
            # from here.
            if len(children) > 1:
                # this becomes the last segment of the current segment group
                seg_group.add("Member", segments=root_segment_id)

                # each child will start a new segment group
                for child in children:
                    seg = self.get_segment(child)
                    # Ensure that a proximal point is set.
                    # This is required for the first segment of unbranched segment
                    # groups
                    seg.proximal = self.get_actual_proximal(seg.id)
                    group_name = f"seg_group_{len(self.morphology.segment_groups) - 1}_seg_{seg.id}"
                    new_seg_group = self.add_unbranched_segment_group(group_name)

                    self.__sectionise(child, new_seg_group, morph_tree)
        # if there are no children, it's a leaf node, so we just add to the current
        # seg_group and do nothing else
        except KeyError:
            seg_group.add("Member", segments=root_segment_id)

    def get_segment_adjacency_list(self):
        """Get the adjacency list of all segments in the cell morphology.
        Returns a dict where each key is a parent segment, and the value is the
        list of its children segments.

        Segment without children (leaf segments) are not included as parents in the
        adjacency list.

        This method also stores the computed adjacency list in
        `self.adjacency_list` for future use by other methods.

        `self.adjacency_list` is populated each time this method is run, to
        ensure that users can regenerate it after making modifications to the
        cell morphology. If the morphology has not changed, one only needs to
        populate it once and then re-use it as required.

        :returns: dict with parent segment ids as keys and ids of their children as values
        :rtype: dict[int, list[int]]

        """
        # create data structure holding list of children for each segment
        child_lists = {}
        for segment in self.morphology.segments:
            try:
                parent = segment.parent.segments
                if parent not in child_lists:
                    child_lists[parent] = []
                child_lists[parent].append(segment.id)
            except AttributeError:
                print(f"Warning: Segment: {segment} has no parent")

        self.adjacency_list = child_lists
        return child_lists

    def get_graph(self):
        """Get a networkx DiGraph of the morphology of the cell with distances
        between the proximal point of a parent and the point where a child
        connects to it as the weights of the edges of the graph.

        Please see https://networkx.org/documentation/stable/reference
        for information on networkx routines that can be used on this graph.

        This method also stores the graph in the `self.cell_graph` attribute
        for future use.

        :returns: networkx.Graph

        """
        cell_graph = nx.DiGraph()

        # don't recompute if already exists
        adlist = getattr(self, "adjacency_list", None)
        if adlist is None:
            adlist = self.get_segment_adjacency_list()

        for parid, childrenids in adlist.items():
            par_length = self.get_segment_length(parid)

            for cid in childrenids:
                child = self.get_segment(cid)

                fract = float(child.parent.fraction_along)
                len_to_proximal = par_length * fract

                cell_graph.add_edge(parid, cid, weight=len_to_proximal)

        self.cell_graph = cell_graph
        return cell_graph

    def get_distance(self, dest, source=0):
        """Get path length between between two segments on a cell.

        Uses `networkx.dijkstra_path_length` to compute the shortest
        path between source and dest

        :param from: id of segment to get distance from
        :type from: int
        :param to: id of segment to get distance to
        :type to: int
        :returns: float
        """
        graph = getattr(self, "cell_graph", None)
        if graph is None:
            graph = self.get_graph()
        return nx.dijkstra_path_length(graph, source, dest)

    def get_all_distances_from_segment(self, seg_id=0):
        """Get distances of all segments from the segment with id seg_id.

        Useful to get distances of segments from the soma.

        Uses networkx.single_source_dijkstra on the cell graph, without a
        target.

        :param seg_id: id of segment to get distances from
        :type seg_id: int
        :returns: pair of dictionaries for distance, path
            The return value is a tuple of two dictionaries keyed by target
            nodes. The first dictionary stores distance to each target node.
            The second stores the path to each target node.

        """
        graph = getattr(self, "cell_graph", None)
        if graph is None:
            graph = self.get_graph()
        return nx.single_source_dijkstra(graph, source=seg_id)

    def get_segments_at_distance(self, distance, src_seg=0):
        """Get all segments at distance from the provided `src_seg`.

        For each segment, it returns the fraction along the segment that the
        provided distance is at. For example, if segment N is 500 units long,
        and the `distance` cut-off is at 200, the fraction along is: 200/500.

        :param src_seg: id of segment to get distances from
        :type src_seg: int
        :param distance: distance to get segments at
        :type distance: float
        :returns: dict with segment ids as keys, and fraction along at which
            the cut off is as values

        """
        graph = getattr(self, "cell_graph", None)
        if graph is None:
            graph = self.get_graph()
        # returns all segments that are less than `distance` away.
        (target_dict, path_dict) = nx.single_source_dijkstra(
            graph, source=src_seg, cutoff=distance
        )

        segs_frac_alongs = {}

        for tgt, dist in target_dict.items():
            try:
                frac_along = (distance - dist) / self.get_segment_length(tgt)
            except ZeroDivisionError:
                # ignore zero length segments
                print(f"Warning: encountered zero length segment: {tgt}")
                continue

            if frac_along > 1.0:
                # not in this segment
                continue
            else:
                segs_frac_alongs[tgt] = frac_along

        return segs_frac_alongs

    def get_branching_points(self):
        """Get segments where the cell morphology branches.

        That is, the out-degree of the segment is > 1

        :returns: list of segment ids

        """
        graph = getattr(self, "cell_graph", None)
        if graph is None:
            graph = self.get_graph()

        segs = [n for (n, d) in graph.out_degree if d > 1]
        return segs

    def get_extremeties(self):
        """Get segments that are at the ends/tips of the neuronal morphology,
        with their distances from the soma.

        :returns: dict of segment ids and their distances from cell root as values

        """
        graph = getattr(self, "cell_graph", None)
        if graph is None:
            graph = self.get_graph()
        segs = [n for (n, d) in graph.out_degree if d == 0]

        res = {}
        for s in segs:
            res[s] = self.get_distance(s)
        return res

    def get_segment_location_info(self, seg_id):
        """Get location information about a particular segment.

        :param seg_id: id of segment to get information for
        :type seg_id: int
        :returns: a dictionary with various metrics about the segment

            - length of segment
            - distance from cell root
            - distance from nearest branching point
            - name of unbranched segment group segment belongs to (if any)
            - id of root segment of the unbranched segment group
            - distance from the segment group root segment

        """
        soma_id = self.get_morphology_root()
        distance_from_soma = self.get_distance(seg_id, source=soma_id)
        in_sg = None
        sg_segs = None
        sg_root = None
        distance_from_sg_root = None
        distance_from_bpt = None

        # get the unbranched segment group that this segment is in
        for sg in self.morphology.segment_groups:
            if sg.neuro_lex_id == neuroml.neuro_lex_ids.neuro_lex_ids["section"]:
                sg_segs = self.get_all_segments_in_group(sg)
                if seg_id in sg_segs:
                    in_sg = sg

                    # break out of loop
                    break

        graph = getattr(self, "cell_graph", None)
        if graph is None:
            graph = self.get_graph()

        # find first ancestral branching point
        # (a segment with more than one child)
        current = seg_id
        sg_root = current
        parent = list(graph.predecessors(current))[0]
        children = list(graph.successors(parent))

        while len(children) == 1:
            # the root of the segment group may not be at a
            # branching point: an unbranched cell branch can consist of
            # multiple unbranched segment groups
            if in_sg is not None:
                if current in sg_segs:
                    sg_root = current

            current = parent
            parent = list(graph.predecessors(current))[0]
            children = list(graph.successors(parent))

        distance_from_bpt = self.get_distance(seg_id, source=current)

        res = {}
        res["id"] = seg_id
        res["length"] = self.get_segment_length(seg_id)
        res["distance_from_cell_root"] = distance_from_soma
        res["distance_from_nearest_branching_point"] = distance_from_bpt

        # at unbranched segment root
        if in_sg is not None:
            res["in_unbranched_segment_group"] = in_sg.id
            res["unbranched_segment_group_root"] = sg_root
            distance_from_sg_root = self.get_distance(seg_id, source=sg_root)
            res["distance_from_segment_group_root"] = distance_from_sg_root

        return res

    def get_morphology_root(self):
        """Return the root of the complete cell morphology.

        This is usually the first segment of the soma, and there should only be
        one such segment.

        :returns: id of the root segment

        """
        # check if convention was followed and segment id 0 is root (has no
        # parents)
        try:
            root_seg = self.get_segment(0)
            if root_seg.parent is None:
                return 0
        except ValueError:
            pass

        graph = getattr(self, "cell_graph", None)
        if graph is None:
            graph = self.get_graph()
        segs = [n for (n, d) in graph.in_degree if d == 0]
        # there should only be one segment with 0 indegree
        assert len(segs) == 1
        return segs[0]

    # end class Cell


class PinskyRinzelCA3Cell(BaseCell):
    """PinskyRinzelCA3Cell -- Reduced CA3 cell model from Pinsky and Rinzel 1994. See https://github.com/OpenSourceBrain/PinskyRinzelModel
    \n
    :param iSoma:
    :type iSoma: currentDensity
    :param iDend:
    :type iDend: currentDensity
    :param gLs:
    :type gLs: conductanceDensity
    :param gLd:
    :type gLd: conductanceDensity
    :param gNa:
    :type gNa: conductanceDensity
    :param gKdr:
    :type gKdr: conductanceDensity
    :param gCa:
    :type gCa: conductanceDensity
    :param gKahp:
    :type gKahp: conductanceDensity
    :param gKC:
    :type gKC: conductanceDensity
    :param gc:
    :type gc: conductanceDensity
    :param eNa:
    :type eNa: voltage
    :param eCa:
    :type eCa: voltage
    :param eK:
    :type eK: voltage
    :param eL:
    :type eL: voltage
    :param pp:
    :type pp: none
    :param cm:
    :type cm: specificCapacitance
    :param alphac:
    :type alphac: none
    :param betac:
    :type betac: none
    :param gNmda:
    :type gNmda: conductanceDensity
    :param gAmpa:
    :type gAmpa: conductanceDensity
    :param qd0:
    :type qd0: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "i_soma",
            "Nml2Quantity_currentDensity",
            0,
            0,
            {"use": "required", "name": "i_soma"},
        ),
        MemberSpec_(
            "i_dend",
            "Nml2Quantity_currentDensity",
            0,
            0,
            {"use": "required", "name": "i_dend"},
        ),
        MemberSpec_(
            "gc",
            "Nml2Quantity_conductanceDensity",
            0,
            0,
            {"use": "required", "name": "gc"},
        ),
        MemberSpec_(
            "g_ls",
            "Nml2Quantity_conductanceDensity",
            0,
            0,
            {"use": "required", "name": "g_ls"},
        ),
        MemberSpec_(
            "g_ld",
            "Nml2Quantity_conductanceDensity",
            0,
            0,
            {"use": "required", "name": "g_ld"},
        ),
        MemberSpec_(
            "g_na",
            "Nml2Quantity_conductanceDensity",
            0,
            0,
            {"use": "required", "name": "g_na"},
        ),
        MemberSpec_(
            "g_kdr",
            "Nml2Quantity_conductanceDensity",
            0,
            0,
            {"use": "required", "name": "g_kdr"},
        ),
        MemberSpec_(
            "g_ca",
            "Nml2Quantity_conductanceDensity",
            0,
            0,
            {"use": "required", "name": "g_ca"},
        ),
        MemberSpec_(
            "g_kahp",
            "Nml2Quantity_conductanceDensity",
            0,
            0,
            {"use": "required", "name": "g_kahp"},
        ),
        MemberSpec_(
            "g_kc",
            "Nml2Quantity_conductanceDensity",
            0,
            0,
            {"use": "required", "name": "g_kc"},
        ),
        MemberSpec_(
            "g_nmda",
            "Nml2Quantity_conductanceDensity",
            0,
            0,
            {"use": "required", "name": "g_nmda"},
        ),
        MemberSpec_(
            "g_ampa",
            "Nml2Quantity_conductanceDensity",
            0,
            0,
            {"use": "required", "name": "g_ampa"},
        ),
        MemberSpec_(
            "e_na", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "e_na"}
        ),
        MemberSpec_(
            "e_ca", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "e_ca"}
        ),
        MemberSpec_(
            "e_k", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "e_k"}
        ),
        MemberSpec_(
            "e_l", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "e_l"}
        ),
        MemberSpec_(
            "qd0", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "qd0"}
        ),
        MemberSpec_("pp", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "pp"}),
        MemberSpec_(
            "alphac", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "alphac"}
        ),
        MemberSpec_(
            "betac", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "betac"}
        ),
        MemberSpec_(
            "cm",
            "Nml2Quantity_specificCapacitance",
            0,
            0,
            {"use": "required", "name": "cm"},
        ),
    ]
    subclass = None
    superclass = BaseCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        i_soma: "a Nml2Quantity_currentDensity (required)" = None,
        i_dend: "a Nml2Quantity_currentDensity (required)" = None,
        gc: "a Nml2Quantity_conductanceDensity (required)" = None,
        g_ls: "a Nml2Quantity_conductanceDensity (required)" = None,
        g_ld: "a Nml2Quantity_conductanceDensity (required)" = None,
        g_na: "a Nml2Quantity_conductanceDensity (required)" = None,
        g_kdr: "a Nml2Quantity_conductanceDensity (required)" = None,
        g_ca: "a Nml2Quantity_conductanceDensity (required)" = None,
        g_kahp: "a Nml2Quantity_conductanceDensity (required)" = None,
        g_kc: "a Nml2Quantity_conductanceDensity (required)" = None,
        g_nmda: "a Nml2Quantity_conductanceDensity (required)" = None,
        g_ampa: "a Nml2Quantity_conductanceDensity (required)" = None,
        e_na: "a Nml2Quantity_voltage (required)" = None,
        e_ca: "a Nml2Quantity_voltage (required)" = None,
        e_k: "a Nml2Quantity_voltage (required)" = None,
        e_l: "a Nml2Quantity_voltage (required)" = None,
        qd0: "a Nml2Quantity_none (required)" = None,
        pp: "a Nml2Quantity_none (required)" = None,
        alphac: "a Nml2Quantity_none (required)" = None,
        betac: "a Nml2Quantity_none (required)" = None,
        cm: "a Nml2Quantity_specificCapacitance (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("PinskyRinzelCA3Cell"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, **kwargs_
        )
        self.i_soma = _cast(None, i_soma)
        self.i_soma_nsprefix_ = None
        self.i_dend = _cast(None, i_dend)
        self.i_dend_nsprefix_ = None
        self.gc = _cast(None, gc)
        self.gc_nsprefix_ = None
        self.g_ls = _cast(None, g_ls)
        self.g_ls_nsprefix_ = None
        self.g_ld = _cast(None, g_ld)
        self.g_ld_nsprefix_ = None
        self.g_na = _cast(None, g_na)
        self.g_na_nsprefix_ = None
        self.g_kdr = _cast(None, g_kdr)
        self.g_kdr_nsprefix_ = None
        self.g_ca = _cast(None, g_ca)
        self.g_ca_nsprefix_ = None
        self.g_kahp = _cast(None, g_kahp)
        self.g_kahp_nsprefix_ = None
        self.g_kc = _cast(None, g_kc)
        self.g_kc_nsprefix_ = None
        self.g_nmda = _cast(None, g_nmda)
        self.g_nmda_nsprefix_ = None
        self.g_ampa = _cast(None, g_ampa)
        self.g_ampa_nsprefix_ = None
        self.e_na = _cast(None, e_na)
        self.e_na_nsprefix_ = None
        self.e_ca = _cast(None, e_ca)
        self.e_ca_nsprefix_ = None
        self.e_k = _cast(None, e_k)
        self.e_k_nsprefix_ = None
        self.e_l = _cast(None, e_l)
        self.e_l_nsprefix_ = None
        self.qd0 = _cast(None, qd0)
        self.qd0_nsprefix_ = None
        self.pp = _cast(None, pp)
        self.pp_nsprefix_ = None
        self.alphac = _cast(None, alphac)
        self.alphac_nsprefix_ = None
        self.betac = _cast(None, betac)
        self.betac_nsprefix_ = None
        self.cm = _cast(None, cm)
        self.cm_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PinskyRinzelCA3Cell
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PinskyRinzelCA3Cell.subclass:
            return PinskyRinzelCA3Cell.subclass(*args_, **kwargs_)
        else:
            return PinskyRinzelCA3Cell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_currentDensity(self, value):
        # Validate type Nml2Quantity_currentDensity, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_currentDensity_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_currentDensity_patterns_,
                    )
                )

    validate_Nml2Quantity_currentDensity_patterns_ = [
        [
            "^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A_per_m2|uA_per_cm2|mA_per_cm2))$"
        ]
    ]

    def validate_Nml2Quantity_conductanceDensity(self, value):
        # Validate type Nml2Quantity_conductanceDensity, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductanceDensity_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductanceDensity_patterns_,
                    )
                )

    validate_Nml2Quantity_conductanceDensity_patterns_ = [
        [
            "^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S_per_m2|mS_per_cm2|S_per_cm2))$"
        ]
    ]

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_none_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_none_patterns_,
                    )
                )

    validate_Nml2Quantity_none_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$"]
    ]

    def validate_Nml2Quantity_specificCapacitance(self, value):
        # Validate type Nml2Quantity_specificCapacitance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_specificCapacitance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_specificCapacitance_patterns_,
                    )
                )

    validate_Nml2Quantity_specificCapacitance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(F_per_m2|uF_per_cm2))$"]
    ]

    def _hasContent(self):
        if super(PinskyRinzelCA3Cell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="PinskyRinzelCA3Cell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("PinskyRinzelCA3Cell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "PinskyRinzelCA3Cell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="PinskyRinzelCA3Cell",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="PinskyRinzelCA3Cell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="PinskyRinzelCA3Cell",
    ):
        super(PinskyRinzelCA3Cell, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="PinskyRinzelCA3Cell",
        )
        if self.i_soma is not None and "i_soma" not in already_processed:
            already_processed.add("i_soma")
            outfile.write(
                " iSoma=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.i_soma), input_name="iSoma"
                        )
                    ),
                )
            )
        if self.i_dend is not None and "i_dend" not in already_processed:
            already_processed.add("i_dend")
            outfile.write(
                " iDend=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.i_dend), input_name="iDend"
                        )
                    ),
                )
            )
        if self.gc is not None and "gc" not in already_processed:
            already_processed.add("gc")
            outfile.write(
                " gc=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.gc), input_name="gc")
                    ),
                )
            )
        if self.g_ls is not None and "g_ls" not in already_processed:
            already_processed.add("g_ls")
            outfile.write(
                " gLs=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.g_ls), input_name="gLs"
                        )
                    ),
                )
            )
        if self.g_ld is not None and "g_ld" not in already_processed:
            already_processed.add("g_ld")
            outfile.write(
                " gLd=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.g_ld), input_name="gLd"
                        )
                    ),
                )
            )
        if self.g_na is not None and "g_na" not in already_processed:
            already_processed.add("g_na")
            outfile.write(
                " gNa=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.g_na), input_name="gNa"
                        )
                    ),
                )
            )
        if self.g_kdr is not None and "g_kdr" not in already_processed:
            already_processed.add("g_kdr")
            outfile.write(
                " gKdr=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.g_kdr), input_name="gKdr"
                        )
                    ),
                )
            )
        if self.g_ca is not None and "g_ca" not in already_processed:
            already_processed.add("g_ca")
            outfile.write(
                " gCa=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.g_ca), input_name="gCa"
                        )
                    ),
                )
            )
        if self.g_kahp is not None and "g_kahp" not in already_processed:
            already_processed.add("g_kahp")
            outfile.write(
                " gKahp=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.g_kahp), input_name="gKahp"
                        )
                    ),
                )
            )
        if self.g_kc is not None and "g_kc" not in already_processed:
            already_processed.add("g_kc")
            outfile.write(
                " gKC=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.g_kc), input_name="gKC"
                        )
                    ),
                )
            )
        if self.g_nmda is not None and "g_nmda" not in already_processed:
            already_processed.add("g_nmda")
            outfile.write(
                " gNmda=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.g_nmda), input_name="gNmda"
                        )
                    ),
                )
            )
        if self.g_ampa is not None and "g_ampa" not in already_processed:
            already_processed.add("g_ampa")
            outfile.write(
                " gAmpa=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.g_ampa), input_name="gAmpa"
                        )
                    ),
                )
            )
        if self.e_na is not None and "e_na" not in already_processed:
            already_processed.add("e_na")
            outfile.write(
                " eNa=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.e_na), input_name="eNa"
                        )
                    ),
                )
            )
        if self.e_ca is not None and "e_ca" not in already_processed:
            already_processed.add("e_ca")
            outfile.write(
                " eCa=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.e_ca), input_name="eCa"
                        )
                    ),
                )
            )
        if self.e_k is not None and "e_k" not in already_processed:
            already_processed.add("e_k")
            outfile.write(
                " eK=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.e_k), input_name="eK")
                    ),
                )
            )
        if self.e_l is not None and "e_l" not in already_processed:
            already_processed.add("e_l")
            outfile.write(
                " eL=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.e_l), input_name="eL")
                    ),
                )
            )
        if self.qd0 is not None and "qd0" not in already_processed:
            already_processed.add("qd0")
            outfile.write(
                " qd0=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.qd0), input_name="qd0")
                    ),
                )
            )
        if self.pp is not None and "pp" not in already_processed:
            already_processed.add("pp")
            outfile.write(
                " pp=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.pp), input_name="pp")
                    ),
                )
            )
        if self.alphac is not None and "alphac" not in already_processed:
            already_processed.add("alphac")
            outfile.write(
                " alphac=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.alphac), input_name="alphac"
                        )
                    ),
                )
            )
        if self.betac is not None and "betac" not in already_processed:
            already_processed.add("betac")
            outfile.write(
                " betac=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.betac), input_name="betac"
                        )
                    ),
                )
            )
        if self.cm is not None and "cm" not in already_processed:
            already_processed.add("cm")
            outfile.write(
                " cm=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.cm), input_name="cm")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="PinskyRinzelCA3Cell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(PinskyRinzelCA3Cell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_currentDensity, self.i_soma, "i_soma"
        )
        self.gds_check_cardinality_(self.i_soma, "i_soma", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_currentDensity, self.i_dend, "i_dend"
        )
        self.gds_check_cardinality_(self.i_dend, "i_dend", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductanceDensity, self.gc, "gc"
        )
        self.gds_check_cardinality_(self.gc, "gc", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductanceDensity, self.g_ls, "g_ls"
        )
        self.gds_check_cardinality_(self.g_ls, "g_ls", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductanceDensity, self.g_ld, "g_ld"
        )
        self.gds_check_cardinality_(self.g_ld, "g_ld", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductanceDensity, self.g_na, "g_na"
        )
        self.gds_check_cardinality_(self.g_na, "g_na", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductanceDensity, self.g_kdr, "g_kdr"
        )
        self.gds_check_cardinality_(self.g_kdr, "g_kdr", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductanceDensity, self.g_ca, "g_ca"
        )
        self.gds_check_cardinality_(self.g_ca, "g_ca", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductanceDensity, self.g_kahp, "g_kahp"
        )
        self.gds_check_cardinality_(self.g_kahp, "g_kahp", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductanceDensity, self.g_kc, "g_kc"
        )
        self.gds_check_cardinality_(self.g_kc, "g_kc", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductanceDensity, self.g_nmda, "g_nmda"
        )
        self.gds_check_cardinality_(self.g_nmda, "g_nmda", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductanceDensity, self.g_ampa, "g_ampa"
        )
        self.gds_check_cardinality_(self.g_ampa, "g_ampa", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.e_na, "e_na"
        )
        self.gds_check_cardinality_(self.e_na, "e_na", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.e_ca, "e_ca"
        )
        self.gds_check_cardinality_(self.e_ca, "e_ca", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.e_k, "e_k"
        )
        self.gds_check_cardinality_(self.e_k, "e_k", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.e_l, "e_l"
        )
        self.gds_check_cardinality_(self.e_l, "e_l", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_none, self.qd0, "qd0")
        self.gds_check_cardinality_(self.qd0, "qd0", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_none, self.pp, "pp")
        self.gds_check_cardinality_(self.pp, "pp", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_none, self.alphac, "alphac"
        )
        self.gds_check_cardinality_(self.alphac, "alphac", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_none, self.betac, "betac"
        )
        self.gds_check_cardinality_(self.betac, "betac", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_specificCapacitance, self.cm, "cm"
        )
        self.gds_check_cardinality_(self.cm, "cm", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("iSoma", node)
        if value is not None and "iSoma" not in already_processed:
            already_processed.add("iSoma")
            self.i_soma = value
            self.validate_Nml2Quantity_currentDensity(
                self.i_soma
            )  # validate type Nml2Quantity_currentDensity
        value = find_attr_value_("iDend", node)
        if value is not None and "iDend" not in already_processed:
            already_processed.add("iDend")
            self.i_dend = value
            self.validate_Nml2Quantity_currentDensity(
                self.i_dend
            )  # validate type Nml2Quantity_currentDensity
        value = find_attr_value_("gc", node)
        if value is not None and "gc" not in already_processed:
            already_processed.add("gc")
            self.gc = value
            self.validate_Nml2Quantity_conductanceDensity(
                self.gc
            )  # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_("gLs", node)
        if value is not None and "gLs" not in already_processed:
            already_processed.add("gLs")
            self.g_ls = value
            self.validate_Nml2Quantity_conductanceDensity(
                self.g_ls
            )  # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_("gLd", node)
        if value is not None and "gLd" not in already_processed:
            already_processed.add("gLd")
            self.g_ld = value
            self.validate_Nml2Quantity_conductanceDensity(
                self.g_ld
            )  # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_("gNa", node)
        if value is not None and "gNa" not in already_processed:
            already_processed.add("gNa")
            self.g_na = value
            self.validate_Nml2Quantity_conductanceDensity(
                self.g_na
            )  # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_("gKdr", node)
        if value is not None and "gKdr" not in already_processed:
            already_processed.add("gKdr")
            self.g_kdr = value
            self.validate_Nml2Quantity_conductanceDensity(
                self.g_kdr
            )  # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_("gCa", node)
        if value is not None and "gCa" not in already_processed:
            already_processed.add("gCa")
            self.g_ca = value
            self.validate_Nml2Quantity_conductanceDensity(
                self.g_ca
            )  # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_("gKahp", node)
        if value is not None and "gKahp" not in already_processed:
            already_processed.add("gKahp")
            self.g_kahp = value
            self.validate_Nml2Quantity_conductanceDensity(
                self.g_kahp
            )  # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_("gKC", node)
        if value is not None and "gKC" not in already_processed:
            already_processed.add("gKC")
            self.g_kc = value
            self.validate_Nml2Quantity_conductanceDensity(
                self.g_kc
            )  # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_("gNmda", node)
        if value is not None and "gNmda" not in already_processed:
            already_processed.add("gNmda")
            self.g_nmda = value
            self.validate_Nml2Quantity_conductanceDensity(
                self.g_nmda
            )  # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_("gAmpa", node)
        if value is not None and "gAmpa" not in already_processed:
            already_processed.add("gAmpa")
            self.g_ampa = value
            self.validate_Nml2Quantity_conductanceDensity(
                self.g_ampa
            )  # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_("eNa", node)
        if value is not None and "eNa" not in already_processed:
            already_processed.add("eNa")
            self.e_na = value
            self.validate_Nml2Quantity_voltage(
                self.e_na
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("eCa", node)
        if value is not None and "eCa" not in already_processed:
            already_processed.add("eCa")
            self.e_ca = value
            self.validate_Nml2Quantity_voltage(
                self.e_ca
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("eK", node)
        if value is not None and "eK" not in already_processed:
            already_processed.add("eK")
            self.e_k = value
            self.validate_Nml2Quantity_voltage(
                self.e_k
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("eL", node)
        if value is not None and "eL" not in already_processed:
            already_processed.add("eL")
            self.e_l = value
            self.validate_Nml2Quantity_voltage(
                self.e_l
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("qd0", node)
        if value is not None and "qd0" not in already_processed:
            already_processed.add("qd0")
            self.qd0 = value
            self.validate_Nml2Quantity_none(self.qd0)  # validate type Nml2Quantity_none
        value = find_attr_value_("pp", node)
        if value is not None and "pp" not in already_processed:
            already_processed.add("pp")
            self.pp = value
            self.validate_Nml2Quantity_none(self.pp)  # validate type Nml2Quantity_none
        value = find_attr_value_("alphac", node)
        if value is not None and "alphac" not in already_processed:
            already_processed.add("alphac")
            self.alphac = value
            self.validate_Nml2Quantity_none(
                self.alphac
            )  # validate type Nml2Quantity_none
        value = find_attr_value_("betac", node)
        if value is not None and "betac" not in already_processed:
            already_processed.add("betac")
            self.betac = value
            self.validate_Nml2Quantity_none(
                self.betac
            )  # validate type Nml2Quantity_none
        value = find_attr_value_("cm", node)
        if value is not None and "cm" not in already_processed:
            already_processed.add("cm")
            self.cm = value
            self.validate_Nml2Quantity_specificCapacitance(
                self.cm
            )  # validate type Nml2Quantity_specificCapacitance
        super(PinskyRinzelCA3Cell, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(PinskyRinzelCA3Cell, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class PinskyRinzelCA3Cell


class FitzHughNagumo1969Cell(BaseCell):
    """FitzHughNagumo1969Cell -- The Fitzhugh Nagumo model is a two-dimensional simplification of the Hodgkin-Huxley model of spike generation in squid giant axons. This system was suggested by FitzHugh ( FitzHugh R. [1961]: Impulses and physiological states in theoretical models of nerve membrane. Biophysical J. 1:445-466 ), who called it " Bonhoeffer-van der Pol model ", and the equivalent circuit by Nagumo et al. ( Nagumo J. , Arimoto S. , and Yoshizawa S. [1962] An active pulse transmission line simulating nerve axon. Proc IRE. 50:2061-2070. 1962 ). This version corresponds to the one described in FitzHugh R. [1969]: Mathematical models of excitation and propagation in nerve. Chapter 1 ( pp. 1-85 in H. P. Schwan, ed. Biological Engineering, McGraw-Hill Book Co. , N. Y. )
    \n
    :param a:
    :type a: none
    :param b:
    :type b: none
    :param I: plays the role of an external injected current
    :type I: none
    :param phi:
    :type phi: none
    :param V0:
    :type V0: none
    :param W0:
    :type W0: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("a", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "a"}),
        MemberSpec_("b", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "b"}),
        MemberSpec_("I", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "I"}),
        MemberSpec_(
            "phi", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "phi"}
        ),
        MemberSpec_("V0", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "V0"}),
        MemberSpec_("W0", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "W0"}),
    ]
    subclass = None
    superclass = BaseCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        a: "a Nml2Quantity_none (required)" = None,
        b: "a Nml2Quantity_none (required)" = None,
        I: "a Nml2Quantity_none (required)" = None,
        phi: "a Nml2Quantity_none (required)" = None,
        V0: "a Nml2Quantity_none (required)" = None,
        W0: "a Nml2Quantity_none (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("FitzHughNagumo1969Cell"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, **kwargs_
        )
        self.a = _cast(None, a)
        self.a_nsprefix_ = None
        self.b = _cast(None, b)
        self.b_nsprefix_ = None
        self.I = _cast(None, I)
        self.I_nsprefix_ = None
        self.phi = _cast(None, phi)
        self.phi_nsprefix_ = None
        self.V0 = _cast(None, V0)
        self.V0_nsprefix_ = None
        self.W0 = _cast(None, W0)
        self.W0_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FitzHughNagumo1969Cell
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FitzHughNagumo1969Cell.subclass:
            return FitzHughNagumo1969Cell.subclass(*args_, **kwargs_)
        else:
            return FitzHughNagumo1969Cell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_none_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_none_patterns_,
                    )
                )

    validate_Nml2Quantity_none_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$"]
    ]

    def _hasContent(self):
        if super(FitzHughNagumo1969Cell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="FitzHughNagumo1969Cell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("FitzHughNagumo1969Cell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "FitzHughNagumo1969Cell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="FitzHughNagumo1969Cell",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="FitzHughNagumo1969Cell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="FitzHughNagumo1969Cell",
    ):
        super(FitzHughNagumo1969Cell, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="FitzHughNagumo1969Cell",
        )
        if self.a is not None and "a" not in already_processed:
            already_processed.add("a")
            outfile.write(
                " a=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.a), input_name="a")
                    ),
                )
            )
        if self.b is not None and "b" not in already_processed:
            already_processed.add("b")
            outfile.write(
                " b=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.b), input_name="b")
                    ),
                )
            )
        if self.I is not None and "I" not in already_processed:
            already_processed.add("I")
            outfile.write(
                " I=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.I), input_name="I")
                    ),
                )
            )
        if self.phi is not None and "phi" not in already_processed:
            already_processed.add("phi")
            outfile.write(
                " phi=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.phi), input_name="phi")
                    ),
                )
            )
        if self.V0 is not None and "V0" not in already_processed:
            already_processed.add("V0")
            outfile.write(
                " V0=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.V0), input_name="V0")
                    ),
                )
            )
        if self.W0 is not None and "W0" not in already_processed:
            already_processed.add("W0")
            outfile.write(
                " W0=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.W0), input_name="W0")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="FitzHughNagumo1969Cell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(FitzHughNagumo1969Cell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_none, self.a, "a")
        self.gds_check_cardinality_(self.a, "a", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_none, self.b, "b")
        self.gds_check_cardinality_(self.b, "b", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_none, self.I, "I")
        self.gds_check_cardinality_(self.I, "I", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_none, self.phi, "phi")
        self.gds_check_cardinality_(self.phi, "phi", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_none, self.V0, "V0")
        self.gds_check_cardinality_(self.V0, "V0", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_none, self.W0, "W0")
        self.gds_check_cardinality_(self.W0, "W0", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("a", node)
        if value is not None and "a" not in already_processed:
            already_processed.add("a")
            self.a = value
            self.validate_Nml2Quantity_none(self.a)  # validate type Nml2Quantity_none
        value = find_attr_value_("b", node)
        if value is not None and "b" not in already_processed:
            already_processed.add("b")
            self.b = value
            self.validate_Nml2Quantity_none(self.b)  # validate type Nml2Quantity_none
        value = find_attr_value_("I", node)
        if value is not None and "I" not in already_processed:
            already_processed.add("I")
            self.I = value
            self.validate_Nml2Quantity_none(self.I)  # validate type Nml2Quantity_none
        value = find_attr_value_("phi", node)
        if value is not None and "phi" not in already_processed:
            already_processed.add("phi")
            self.phi = value
            self.validate_Nml2Quantity_none(self.phi)  # validate type Nml2Quantity_none
        value = find_attr_value_("V0", node)
        if value is not None and "V0" not in already_processed:
            already_processed.add("V0")
            self.V0 = value
            self.validate_Nml2Quantity_none(self.V0)  # validate type Nml2Quantity_none
        value = find_attr_value_("W0", node)
        if value is not None and "W0" not in already_processed:
            already_processed.add("W0")
            self.W0 = value
            self.validate_Nml2Quantity_none(self.W0)  # validate type Nml2Quantity_none
        super(FitzHughNagumo1969Cell, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(FitzHughNagumo1969Cell, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class FitzHughNagumo1969Cell


class FitzHughNagumoCell(BaseCell):
    """FitzHughNagumoCell -- Simple dimensionless model of spiking cell from FitzHugh and Nagumo. Superseded by **fitzHughNagumo1969Cell**  ( See https://github.com/NeuroML/NeuroML2/issues/42 )
    \n
    :param I:
    :type I: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("I", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "I"}),
    ]
    subclass = None
    superclass = BaseCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        I: "a Nml2Quantity_none (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("FitzHughNagumoCell"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, **kwargs_
        )
        self.I = _cast(None, I)
        self.I_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FitzHughNagumoCell
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FitzHughNagumoCell.subclass:
            return FitzHughNagumoCell.subclass(*args_, **kwargs_)
        else:
            return FitzHughNagumoCell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_none_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_none_patterns_,
                    )
                )

    validate_Nml2Quantity_none_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$"]
    ]

    def _hasContent(self):
        if super(FitzHughNagumoCell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="FitzHughNagumoCell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("FitzHughNagumoCell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "FitzHughNagumoCell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="FitzHughNagumoCell",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="FitzHughNagumoCell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="FitzHughNagumoCell",
    ):
        super(FitzHughNagumoCell, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="FitzHughNagumoCell",
        )
        if self.I is not None and "I" not in already_processed:
            already_processed.add("I")
            outfile.write(
                " I=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.I), input_name="I")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="FitzHughNagumoCell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(FitzHughNagumoCell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_none, self.I, "I")
        self.gds_check_cardinality_(self.I, "I", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("I", node)
        if value is not None and "I" not in already_processed:
            already_processed.add("I")
            self.I = value
            self.validate_Nml2Quantity_none(self.I)  # validate type Nml2Quantity_none
        super(FitzHughNagumoCell, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(FitzHughNagumoCell, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class FitzHughNagumoCell


class BaseCellMembPotCap(BaseCell):
    """BaseCellMembPotCap -- Any cell with a membrane potential **v**  with voltage units and a membrane capacitance **C.**  Also defines exposed value **iSyn**  for current due to external synapses and **iMemb**  for total transmembrane current ( usually channel currents plus **iSyn**  )
    \n
    :param C: Total capacitance of the cell membrane
    :type C: capacitance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "C", "Nml2Quantity_capacitance", 0, 0, {"use": "required", "name": "C"}
        ),
    ]
    subclass = None
    superclass = BaseCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        C: "a Nml2Quantity_capacitance (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BaseCellMembPotCap"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            extensiontype_,
            **kwargs_,
        )
        self.C = _cast(None, C)
        self.C_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseCellMembPotCap
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseCellMembPotCap.subclass:
            return BaseCellMembPotCap.subclass(*args_, **kwargs_)
        else:
            return BaseCellMembPotCap(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_capacitance(self, value):
        # Validate type Nml2Quantity_capacitance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_capacitance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_capacitance_patterns_,
                    )
                )

    validate_Nml2Quantity_capacitance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(F|uF|nF|pF))$"]
    ]

    def _hasContent(self):
        if super(BaseCellMembPotCap, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseCellMembPotCap",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BaseCellMembPotCap")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BaseCellMembPotCap":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseCellMembPotCap",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BaseCellMembPotCap",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BaseCellMembPotCap",
    ):
        super(BaseCellMembPotCap, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseCellMembPotCap",
        )
        if self.C is not None and "C" not in already_processed:
            already_processed.add("C")
            outfile.write(
                " C=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.C), input_name="C")
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseCellMembPotCap",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BaseCellMembPotCap, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_capacitance, self.C, "C"
        )
        self.gds_check_cardinality_(self.C, "C", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("C", node)
        if value is not None and "C" not in already_processed:
            already_processed.add("C")
            self.C = value
            self.validate_Nml2Quantity_capacitance(
                self.C
            )  # validate type Nml2Quantity_capacitance
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(BaseCellMembPotCap, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BaseCellMembPotCap, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class BaseCellMembPotCap


class IzhikevichCell(BaseCell):
    """IzhikevichCell -- Cell based on the 2003 model of Izhikevich, see http://izhikevich.org/publications/spikes.htm
    \n
    :param v0: Initial membrane potential
    :type v0: voltage
    :param a: Time scale of the recovery variable U
    :type a: none
    :param b: Sensitivity of U to the subthreshold fluctuations of the membrane potential V
    :type b: none
    :param c: After-spike reset value of V
    :type c: none
    :param d: After-spike increase to U
    :type d: none
    :param thresh: Spike threshold
    :type thresh: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "v0", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "v0"}
        ),
        MemberSpec_(
            "thresh",
            "Nml2Quantity_voltage",
            0,
            0,
            {"use": "required", "name": "thresh"},
        ),
        MemberSpec_("a", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "a"}),
        MemberSpec_("b", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "b"}),
        MemberSpec_("c", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "c"}),
        MemberSpec_("d", "Nml2Quantity_none", 0, 0, {"use": "required", "name": "d"}),
    ]
    subclass = None
    superclass = BaseCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        v0: "a Nml2Quantity_voltage (required)" = None,
        thresh: "a Nml2Quantity_voltage (required)" = None,
        a: "a Nml2Quantity_none (required)" = None,
        b: "a Nml2Quantity_none (required)" = None,
        c: "a Nml2Quantity_none (required)" = None,
        d: "a Nml2Quantity_none (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IzhikevichCell"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, **kwargs_
        )
        self.v0 = _cast(None, v0)
        self.v0_nsprefix_ = None
        self.thresh = _cast(None, thresh)
        self.thresh_nsprefix_ = None
        self.a = _cast(None, a)
        self.a_nsprefix_ = None
        self.b = _cast(None, b)
        self.b_nsprefix_ = None
        self.c = _cast(None, c)
        self.c_nsprefix_ = None
        self.d = _cast(None, d)
        self.d_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IzhikevichCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IzhikevichCell.subclass:
            return IzhikevichCell.subclass(*args_, **kwargs_)
        else:
            return IzhikevichCell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_none_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_none_patterns_,
                    )
                )

    validate_Nml2Quantity_none_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$"]
    ]

    def _hasContent(self):
        if super(IzhikevichCell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IzhikevichCell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IzhikevichCell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IzhikevichCell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IzhikevichCell"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IzhikevichCell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="IzhikevichCell",
    ):
        super(IzhikevichCell, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IzhikevichCell"
        )
        if self.v0 is not None and "v0" not in already_processed:
            already_processed.add("v0")
            outfile.write(
                " v0=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.v0), input_name="v0")
                    ),
                )
            )
        if self.thresh is not None and "thresh" not in already_processed:
            already_processed.add("thresh")
            outfile.write(
                " thresh=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.thresh), input_name="thresh"
                        )
                    ),
                )
            )
        if self.a is not None and "a" not in already_processed:
            already_processed.add("a")
            outfile.write(
                " a=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.a), input_name="a")
                    ),
                )
            )
        if self.b is not None and "b" not in already_processed:
            already_processed.add("b")
            outfile.write(
                " b=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.b), input_name="b")
                    ),
                )
            )
        if self.c is not None and "c" not in already_processed:
            already_processed.add("c")
            outfile.write(
                " c=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.c), input_name="c")
                    ),
                )
            )
        if self.d is not None and "d" not in already_processed:
            already_processed.add("d")
            outfile.write(
                " d=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.d), input_name="d")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IzhikevichCell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IzhikevichCell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_voltage, self.v0, "v0")
        self.gds_check_cardinality_(self.v0, "v0", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.thresh, "thresh"
        )
        self.gds_check_cardinality_(self.thresh, "thresh", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_none, self.a, "a")
        self.gds_check_cardinality_(self.a, "a", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_none, self.b, "b")
        self.gds_check_cardinality_(self.b, "b", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_none, self.c, "c")
        self.gds_check_cardinality_(self.c, "c", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_none, self.d, "d")
        self.gds_check_cardinality_(self.d, "d", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("v0", node)
        if value is not None and "v0" not in already_processed:
            already_processed.add("v0")
            self.v0 = value
            self.validate_Nml2Quantity_voltage(
                self.v0
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("thresh", node)
        if value is not None and "thresh" not in already_processed:
            already_processed.add("thresh")
            self.thresh = value
            self.validate_Nml2Quantity_voltage(
                self.thresh
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("a", node)
        if value is not None and "a" not in already_processed:
            already_processed.add("a")
            self.a = value
            self.validate_Nml2Quantity_none(self.a)  # validate type Nml2Quantity_none
        value = find_attr_value_("b", node)
        if value is not None and "b" not in already_processed:
            already_processed.add("b")
            self.b = value
            self.validate_Nml2Quantity_none(self.b)  # validate type Nml2Quantity_none
        value = find_attr_value_("c", node)
        if value is not None and "c" not in already_processed:
            already_processed.add("c")
            self.c = value
            self.validate_Nml2Quantity_none(self.c)  # validate type Nml2Quantity_none
        value = find_attr_value_("d", node)
        if value is not None and "d" not in already_processed:
            already_processed.add("d")
            self.d = value
            self.validate_Nml2Quantity_none(self.d)  # validate type Nml2Quantity_none
        super(IzhikevichCell, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(IzhikevichCell, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class IzhikevichCell


class IafCell(BaseCell):
    """IafCell -- Integrate and fire cell with capacitance **C,**  **leakConductance**  and **leakReversal**
    \n
    :param leakConductance:
    :type leakConductance: conductance
    :param leakReversal:
    :type leakReversal: voltage
    :param thresh:
    :type thresh: voltage
    :param reset:
    :type reset: voltage
    :param C: Total capacitance of the cell membrane
    :type C: capacitance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "leak_reversal",
            "Nml2Quantity_voltage",
            0,
            0,
            {"use": "required", "name": "leak_reversal"},
        ),
        MemberSpec_(
            "thresh",
            "Nml2Quantity_voltage",
            0,
            0,
            {"use": "required", "name": "thresh"},
        ),
        MemberSpec_(
            "reset", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "reset"}
        ),
        MemberSpec_(
            "C", "Nml2Quantity_capacitance", 0, 0, {"use": "required", "name": "C"}
        ),
        MemberSpec_(
            "leak_conductance",
            "Nml2Quantity_conductance",
            0,
            0,
            {"use": "required", "name": "leak_conductance"},
        ),
    ]
    subclass = None
    superclass = BaseCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        leak_reversal: "a Nml2Quantity_voltage (required)" = None,
        thresh: "a Nml2Quantity_voltage (required)" = None,
        reset: "a Nml2Quantity_voltage (required)" = None,
        C: "a Nml2Quantity_capacitance (required)" = None,
        leak_conductance: "a Nml2Quantity_conductance (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IafCell"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            extensiontype_,
            **kwargs_,
        )
        self.leak_reversal = _cast(None, leak_reversal)
        self.leak_reversal_nsprefix_ = None
        self.thresh = _cast(None, thresh)
        self.thresh_nsprefix_ = None
        self.reset = _cast(None, reset)
        self.reset_nsprefix_ = None
        self.C = _cast(None, C)
        self.C_nsprefix_ = None
        self.leak_conductance = _cast(None, leak_conductance)
        self.leak_conductance_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IafCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IafCell.subclass:
            return IafCell.subclass(*args_, **kwargs_)
        else:
            return IafCell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def validate_Nml2Quantity_capacitance(self, value):
        # Validate type Nml2Quantity_capacitance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_capacitance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_capacitance_patterns_,
                    )
                )

    validate_Nml2Quantity_capacitance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(F|uF|nF|pF))$"]
    ]

    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductance_patterns_,
                    )
                )

    validate_Nml2Quantity_conductance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$"]
    ]

    def _hasContent(self):
        if super(IafCell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IafCell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IafCell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IafCell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IafCell"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IafCell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="IafCell"
    ):
        super(IafCell, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IafCell"
        )
        if self.leak_reversal is not None and "leak_reversal" not in already_processed:
            already_processed.add("leak_reversal")
            outfile.write(
                " leakReversal=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.leak_reversal), input_name="leakReversal"
                        )
                    ),
                )
            )
        if self.thresh is not None and "thresh" not in already_processed:
            already_processed.add("thresh")
            outfile.write(
                " thresh=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.thresh), input_name="thresh"
                        )
                    ),
                )
            )
        if self.reset is not None and "reset" not in already_processed:
            already_processed.add("reset")
            outfile.write(
                " reset=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.reset), input_name="reset"
                        )
                    ),
                )
            )
        if self.C is not None and "C" not in already_processed:
            already_processed.add("C")
            outfile.write(
                " C=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.C), input_name="C")
                    ),
                )
            )
        if (
            self.leak_conductance is not None
            and "leak_conductance" not in already_processed
        ):
            already_processed.add("leak_conductance")
            outfile.write(
                " leakConductance=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.leak_conductance),
                            input_name="leakConductance",
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IafCell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IafCell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.leak_reversal, "leak_reversal"
        )
        self.gds_check_cardinality_(self.leak_reversal, "leak_reversal", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.thresh, "thresh"
        )
        self.gds_check_cardinality_(self.thresh, "thresh", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.reset, "reset"
        )
        self.gds_check_cardinality_(self.reset, "reset", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_capacitance, self.C, "C"
        )
        self.gds_check_cardinality_(self.C, "C", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductance,
            self.leak_conductance,
            "leak_conductance",
        )
        self.gds_check_cardinality_(
            self.leak_conductance, "leak_conductance", required=True
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("leakReversal", node)
        if value is not None and "leakReversal" not in already_processed:
            already_processed.add("leakReversal")
            self.leak_reversal = value
            self.validate_Nml2Quantity_voltage(
                self.leak_reversal
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("thresh", node)
        if value is not None and "thresh" not in already_processed:
            already_processed.add("thresh")
            self.thresh = value
            self.validate_Nml2Quantity_voltage(
                self.thresh
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("reset", node)
        if value is not None and "reset" not in already_processed:
            already_processed.add("reset")
            self.reset = value
            self.validate_Nml2Quantity_voltage(
                self.reset
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("C", node)
        if value is not None and "C" not in already_processed:
            already_processed.add("C")
            self.C = value
            self.validate_Nml2Quantity_capacitance(
                self.C
            )  # validate type Nml2Quantity_capacitance
        value = find_attr_value_("leakConductance", node)
        if value is not None and "leakConductance" not in already_processed:
            already_processed.add("leakConductance")
            self.leak_conductance = value
            self.validate_Nml2Quantity_conductance(
                self.leak_conductance
            )  # validate type Nml2Quantity_conductance
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(IafCell, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(IafCell, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class IafCell


class IafTauCell(BaseCell):
    """IafTauCell -- Integrate and fire cell which returns to its leak reversal potential of **leakReversal**  with a time constant **tau**
    \n
    :param leakReversal:
    :type leakReversal: voltage
    :param tau:
    :type tau: time
    :param thresh: The membrane potential at which to emit a spiking event and reset voltage
    :type thresh: voltage
    :param reset: The value the membrane potential is reset to on spiking
    :type reset: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "leak_reversal",
            "Nml2Quantity_voltage",
            0,
            0,
            {"use": "required", "name": "leak_reversal"},
        ),
        MemberSpec_(
            "thresh",
            "Nml2Quantity_voltage",
            0,
            0,
            {"use": "required", "name": "thresh"},
        ),
        MemberSpec_(
            "reset", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "reset"}
        ),
        MemberSpec_(
            "tau", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "tau"}
        ),
    ]
    subclass = None
    superclass = BaseCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        leak_reversal: "a Nml2Quantity_voltage (required)" = None,
        thresh: "a Nml2Quantity_voltage (required)" = None,
        reset: "a Nml2Quantity_voltage (required)" = None,
        tau: "a Nml2Quantity_time (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IafTauCell"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            extensiontype_,
            **kwargs_,
        )
        self.leak_reversal = _cast(None, leak_reversal)
        self.leak_reversal_nsprefix_ = None
        self.thresh = _cast(None, thresh)
        self.thresh_nsprefix_ = None
        self.reset = _cast(None, reset)
        self.reset_nsprefix_ = None
        self.tau = _cast(None, tau)
        self.tau_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IafTauCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IafTauCell.subclass:
            return IafTauCell.subclass(*args_, **kwargs_)
        else:
            return IafTauCell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(IafTauCell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IafTauCell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IafTauCell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IafTauCell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IafTauCell"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IafTauCell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="IafTauCell"
    ):
        super(IafTauCell, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IafTauCell"
        )
        if self.leak_reversal is not None and "leak_reversal" not in already_processed:
            already_processed.add("leak_reversal")
            outfile.write(
                " leakReversal=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.leak_reversal), input_name="leakReversal"
                        )
                    ),
                )
            )
        if self.thresh is not None and "thresh" not in already_processed:
            already_processed.add("thresh")
            outfile.write(
                " thresh=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.thresh), input_name="thresh"
                        )
                    ),
                )
            )
        if self.reset is not None and "reset" not in already_processed:
            already_processed.add("reset")
            outfile.write(
                " reset=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.reset), input_name="reset"
                        )
                    ),
                )
            )
        if self.tau is not None and "tau" not in already_processed:
            already_processed.add("tau")
            outfile.write(
                " tau=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.tau), input_name="tau")
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IafTauCell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IafTauCell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.leak_reversal, "leak_reversal"
        )
        self.gds_check_cardinality_(self.leak_reversal, "leak_reversal", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.thresh, "thresh"
        )
        self.gds_check_cardinality_(self.thresh, "thresh", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.reset, "reset"
        )
        self.gds_check_cardinality_(self.reset, "reset", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_time, self.tau, "tau")
        self.gds_check_cardinality_(self.tau, "tau", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("leakReversal", node)
        if value is not None and "leakReversal" not in already_processed:
            already_processed.add("leakReversal")
            self.leak_reversal = value
            self.validate_Nml2Quantity_voltage(
                self.leak_reversal
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("thresh", node)
        if value is not None and "thresh" not in already_processed:
            already_processed.add("thresh")
            self.thresh = value
            self.validate_Nml2Quantity_voltage(
                self.thresh
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("reset", node)
        if value is not None and "reset" not in already_processed:
            already_processed.add("reset")
            self.reset = value
            self.validate_Nml2Quantity_voltage(
                self.reset
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("tau", node)
        if value is not None and "tau" not in already_processed:
            already_processed.add("tau")
            self.tau = value
            self.validate_Nml2Quantity_time(self.tau)  # validate type Nml2Quantity_time
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(IafTauCell, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(IafTauCell, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class IafTauCell


class GradedSynapse(BaseSynapse):
    """GradedSynapse -- Graded/analog synapse. Based on synapse in Methods of http://www. nature.com/neuro/journal/v7/n12/abs/nn1352.html
    \n
    :param conductance:
    :type conductance: conductance
    :param delta: Slope of the activation curve
    :type delta: voltage
    :param k: Rate constant for transmitter-receptor dissociation rate
    :type k: per_time
    :param Vth: The half-activation voltage of the synapse
    :type Vth: voltage
    :param erev: The reversal potential of the synapse
    :type erev: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "conductance",
            "Nml2Quantity_conductance",
            0,
            0,
            {"use": "required", "name": "conductance"},
        ),
        MemberSpec_(
            "delta", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "delta"}
        ),
        MemberSpec_(
            "Vth", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "Vth"}
        ),
        MemberSpec_(
            "k", "Nml2Quantity_pertime", 0, 0, {"use": "required", "name": "k"}
        ),
        MemberSpec_(
            "erev", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "erev"}
        ),
    ]
    subclass = None
    superclass = BaseSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        conductance: "a Nml2Quantity_conductance (required)" = None,
        delta: "a Nml2Quantity_voltage (required)" = None,
        Vth: "a Nml2Quantity_voltage (required)" = None,
        k: "a Nml2Quantity_pertime (required)" = None,
        erev: "a Nml2Quantity_voltage (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("GradedSynapse"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, **kwargs_
        )
        self.conductance = _cast(None, conductance)
        self.conductance_nsprefix_ = None
        self.delta = _cast(None, delta)
        self.delta_nsprefix_ = None
        self.Vth = _cast(None, Vth)
        self.Vth_nsprefix_ = None
        self.k = _cast(None, k)
        self.k_nsprefix_ = None
        self.erev = _cast(None, erev)
        self.erev_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GradedSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GradedSynapse.subclass:
            return GradedSynapse.subclass(*args_, **kwargs_)
        else:
            return GradedSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductance_patterns_,
                    )
                )

    validate_Nml2Quantity_conductance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$"]
    ]

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_pertime_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_pertime_patterns_,
                    )
                )

    validate_Nml2Quantity_pertime_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$"]
    ]

    def _hasContent(self):
        if super(GradedSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="GradedSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GradedSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GradedSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GradedSynapse"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GradedSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GradedSynapse",
    ):
        super(GradedSynapse, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GradedSynapse"
        )
        if self.conductance is not None and "conductance" not in already_processed:
            already_processed.add("conductance")
            outfile.write(
                " conductance=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.conductance), input_name="conductance"
                        )
                    ),
                )
            )
        if self.delta is not None and "delta" not in already_processed:
            already_processed.add("delta")
            outfile.write(
                " delta=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.delta), input_name="delta"
                        )
                    ),
                )
            )
        if self.Vth is not None and "Vth" not in already_processed:
            already_processed.add("Vth")
            outfile.write(
                " Vth=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.Vth), input_name="Vth")
                    ),
                )
            )
        if self.k is not None and "k" not in already_processed:
            already_processed.add("k")
            outfile.write(
                " k=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.k), input_name="k")
                    ),
                )
            )
        if self.erev is not None and "erev" not in already_processed:
            already_processed.add("erev")
            outfile.write(
                " erev=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.erev), input_name="erev"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="GradedSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(GradedSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductance, self.conductance, "conductance"
        )
        self.gds_check_cardinality_(self.conductance, "conductance", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.delta, "delta"
        )
        self.gds_check_cardinality_(self.delta, "delta", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.Vth, "Vth"
        )
        self.gds_check_cardinality_(self.Vth, "Vth", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_pertime, self.k, "k")
        self.gds_check_cardinality_(self.k, "k", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.erev, "erev"
        )
        self.gds_check_cardinality_(self.erev, "erev", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("conductance", node)
        if value is not None and "conductance" not in already_processed:
            already_processed.add("conductance")
            self.conductance = value
            self.validate_Nml2Quantity_conductance(
                self.conductance
            )  # validate type Nml2Quantity_conductance
        value = find_attr_value_("delta", node)
        if value is not None and "delta" not in already_processed:
            already_processed.add("delta")
            self.delta = value
            self.validate_Nml2Quantity_voltage(
                self.delta
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("Vth", node)
        if value is not None and "Vth" not in already_processed:
            already_processed.add("Vth")
            self.Vth = value
            self.validate_Nml2Quantity_voltage(
                self.Vth
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("k", node)
        if value is not None and "k" not in already_processed:
            already_processed.add("k")
            self.k = value
            self.validate_Nml2Quantity_pertime(
                self.k
            )  # validate type Nml2Quantity_pertime
        value = find_attr_value_("erev", node)
        if value is not None and "erev" not in already_processed:
            already_processed.add("erev")
            self.erev = value
            self.validate_Nml2Quantity_voltage(
                self.erev
            )  # validate type Nml2Quantity_voltage
        super(GradedSynapse, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(GradedSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class GradedSynapse


class LinearGradedSynapse(BaseSynapse):
    """LinearGradedSynapse -- Behaves just like a one way gap junction.
    \n
    :param conductance:
    :type conductance: conductance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "conductance",
            "Nml2Quantity_conductance",
            0,
            0,
            {"use": "required", "name": "conductance"},
        ),
    ]
    subclass = None
    superclass = BaseSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        conductance: "a Nml2Quantity_conductance (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("LinearGradedSynapse"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, **kwargs_
        )
        self.conductance = _cast(None, conductance)
        self.conductance_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinearGradedSynapse
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinearGradedSynapse.subclass:
            return LinearGradedSynapse.subclass(*args_, **kwargs_)
        else:
            return LinearGradedSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductance_patterns_,
                    )
                )

    validate_Nml2Quantity_conductance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$"]
    ]

    def _hasContent(self):
        if super(LinearGradedSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="LinearGradedSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LinearGradedSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LinearGradedSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="LinearGradedSynapse",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LinearGradedSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LinearGradedSynapse",
    ):
        super(LinearGradedSynapse, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="LinearGradedSynapse",
        )
        if self.conductance is not None and "conductance" not in already_processed:
            already_processed.add("conductance")
            outfile.write(
                " conductance=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.conductance), input_name="conductance"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="LinearGradedSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(LinearGradedSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductance, self.conductance, "conductance"
        )
        self.gds_check_cardinality_(self.conductance, "conductance", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("conductance", node)
        if value is not None and "conductance" not in already_processed:
            already_processed.add("conductance")
            self.conductance = value
            self.validate_Nml2Quantity_conductance(
                self.conductance
            )  # validate type Nml2Quantity_conductance
        super(LinearGradedSynapse, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(LinearGradedSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class LinearGradedSynapse


class SilentSynapse(BaseSynapse):
    """SilentSynapse -- Dummy synapse which emits no current. Used as presynaptic endpoint for analog synaptic connection."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = BaseSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("SilentSynapse"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, **kwargs_
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, SilentSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SilentSynapse.subclass:
            return SilentSynapse.subclass(*args_, **kwargs_)
        else:
            return SilentSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(SilentSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SilentSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("SilentSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "SilentSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SilentSynapse"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="SilentSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="SilentSynapse",
    ):
        super(SilentSynapse, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="SilentSynapse"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="SilentSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(SilentSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(SilentSynapse, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(SilentSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class SilentSynapse


class GapJunction(BaseSynapse):
    """GapJunction -- Gap junction/single electrical connection
    \n
    :param conductance:
    :type conductance: conductance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "conductance",
            "Nml2Quantity_conductance",
            0,
            0,
            {"use": "required", "name": "conductance"},
        ),
    ]
    subclass = None
    superclass = BaseSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        conductance: "a Nml2Quantity_conductance (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("GapJunction"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, **kwargs_
        )
        self.conductance = _cast(None, conductance)
        self.conductance_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, GapJunction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GapJunction.subclass:
            return GapJunction.subclass(*args_, **kwargs_)
        else:
            return GapJunction(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductance_patterns_,
                    )
                )

    validate_Nml2Quantity_conductance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$"]
    ]

    def _hasContent(self):
        if super(GapJunction, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="GapJunction",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("GapJunction")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "GapJunction":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GapJunction"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="GapJunction",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="GapJunction",
    ):
        super(GapJunction, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="GapJunction"
        )
        if self.conductance is not None and "conductance" not in already_processed:
            already_processed.add("conductance")
            outfile.write(
                " conductance=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.conductance), input_name="conductance"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="GapJunction",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(GapJunction, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductance, self.conductance, "conductance"
        )
        self.gds_check_cardinality_(self.conductance, "conductance", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("conductance", node)
        if value is not None and "conductance" not in already_processed:
            already_processed.add("conductance")
            self.conductance = value
            self.validate_Nml2Quantity_conductance(
                self.conductance
            )  # validate type Nml2Quantity_conductance
        super(GapJunction, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(GapJunction, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class GapJunction


class BaseCurrentBasedSynapse(BaseSynapse):
    """BaseCurrentBasedSynapse -- Synapse model which produces a synaptic current."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = BaseSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BaseCurrentBasedSynapse"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            extensiontype_,
            **kwargs_,
        )
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseCurrentBasedSynapse
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseCurrentBasedSynapse.subclass:
            return BaseCurrentBasedSynapse.subclass(*args_, **kwargs_)
        else:
            return BaseCurrentBasedSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(BaseCurrentBasedSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseCurrentBasedSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BaseCurrentBasedSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BaseCurrentBasedSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseCurrentBasedSynapse",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BaseCurrentBasedSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BaseCurrentBasedSynapse",
    ):
        super(BaseCurrentBasedSynapse, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseCurrentBasedSynapse",
        )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseCurrentBasedSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BaseCurrentBasedSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(BaseCurrentBasedSynapse, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BaseCurrentBasedSynapse, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class BaseCurrentBasedSynapse


class BaseVoltageDepSynapse(BaseSynapse):
    """BaseVoltageDepSynapse -- Base type for synapses with a dependence on membrane potential"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = BaseSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BaseVoltageDepSynapse"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            extensiontype_,
            **kwargs_,
        )
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseVoltageDepSynapse
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseVoltageDepSynapse.subclass:
            return BaseVoltageDepSynapse.subclass(*args_, **kwargs_)
        else:
            return BaseVoltageDepSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(BaseVoltageDepSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseVoltageDepSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BaseVoltageDepSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BaseVoltageDepSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseVoltageDepSynapse",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BaseVoltageDepSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BaseVoltageDepSynapse",
    ):
        super(BaseVoltageDepSynapse, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseVoltageDepSynapse",
        )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseVoltageDepSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BaseVoltageDepSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(BaseVoltageDepSynapse, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BaseVoltageDepSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class BaseVoltageDepSynapse


class IonChannel(IonChannelScalable):
    """IonChannel -- Note  **ionChannel**  and  **ionChannelHH**  are currently functionally identical. This is needed since many existing examples use ionChannel, some use ionChannelHH. NeuroML v2beta4 should remove one of these, probably ionChannelHH.
    \n
    :param conductance:
    :type conductance: conductance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("species", "NmlId", 0, 1, {"use": "optional", "name": "species"}),
        MemberSpec_("type", "channelTypes", 0, 1, {"use": "optional", "name": "type"}),
        MemberSpec_(
            "conductance",
            "Nml2Quantity_conductance",
            0,
            1,
            {"use": "optional", "name": "conductance"},
        ),
        MemberSpec_(
            "gates",
            "GateHHUndetermined",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "gate",
                "type": "GateHHUndetermined",
            },
            1,
        ),
        MemberSpec_(
            "gate_hh_rates",
            "GateHHRates",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "gateHHrates",
                "type": "GateHHRates",
            },
            1,
        ),
        MemberSpec_(
            "gate_h_hrates_taus",
            "GateHHRatesTau",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "gateHHratesTau",
                "type": "GateHHRatesTau",
            },
            1,
        ),
        MemberSpec_(
            "gate_hh_tau_infs",
            "GateHHTauInf",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "gateHHtauInf",
                "type": "GateHHTauInf",
            },
            1,
        ),
        MemberSpec_(
            "gate_h_hrates_infs",
            "GateHHRatesInf",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "gateHHratesInf",
                "type": "GateHHRatesInf",
            },
            1,
        ),
        MemberSpec_(
            "gate_h_hrates_tau_infs",
            "GateHHRatesTauInf",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "gateHHratesTauInf",
                "type": "GateHHRatesTauInf",
            },
            1,
        ),
        MemberSpec_(
            "gate_hh_instantaneouses",
            "GateHHInstantaneous",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "gateHHInstantaneous",
                "type": "GateHHInstantaneous",
            },
            1,
        ),
        MemberSpec_(
            "gate_fractionals",
            "GateFractional",
            1,
            1,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "0",
                "name": "gateFractional",
                "type": "GateFractional",
            },
            1,
        ),
    ]
    subclass = None
    superclass = IonChannelScalable

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        q10_conductance_scalings: "list of Q10ConductanceScaling(s) (optional)" = None,
        species: "a NmlId (optional)" = None,
        type: "a channelTypes (optional)" = None,
        conductance: "a Nml2Quantity_conductance (optional)" = None,
        gates: "list of GateHHUndetermined(s) (optional)" = None,
        gate_hh_rates: "list of GateHHRates(s) (optional)" = None,
        gate_h_hrates_taus: "list of GateHHRatesTau(s) (optional)" = None,
        gate_hh_tau_infs: "list of GateHHTauInf(s) (optional)" = None,
        gate_h_hrates_infs: "list of GateHHRatesInf(s) (optional)" = None,
        gate_h_hrates_tau_infs: "list of GateHHRatesTauInf(s) (optional)" = None,
        gate_hh_instantaneouses: "list of GateHHInstantaneous(s) (optional)" = None,
        gate_fractionals: "list of GateFractional(s) (optional)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IonChannel"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            q10_conductance_scalings,
            extensiontype_,
            **kwargs_,
        )
        self.species = _cast(None, species)
        self.species_nsprefix_ = None
        self.type = _cast(None, type)
        self.type_nsprefix_ = None
        self.conductance = _cast(None, conductance)
        self.conductance_nsprefix_ = None
        if gates is None:
            self.gates = []
        else:
            self.gates = gates
        self.gates_nsprefix_ = None
        if gate_hh_rates is None:
            self.gate_hh_rates = []
        else:
            self.gate_hh_rates = gate_hh_rates
        self.gate_hh_rates_nsprefix_ = None
        if gate_h_hrates_taus is None:
            self.gate_h_hrates_taus = []
        else:
            self.gate_h_hrates_taus = gate_h_hrates_taus
        self.gate_h_hrates_taus_nsprefix_ = None
        if gate_hh_tau_infs is None:
            self.gate_hh_tau_infs = []
        else:
            self.gate_hh_tau_infs = gate_hh_tau_infs
        self.gate_hh_tau_infs_nsprefix_ = None
        if gate_h_hrates_infs is None:
            self.gate_h_hrates_infs = []
        else:
            self.gate_h_hrates_infs = gate_h_hrates_infs
        self.gate_h_hrates_infs_nsprefix_ = None
        if gate_h_hrates_tau_infs is None:
            self.gate_h_hrates_tau_infs = []
        else:
            self.gate_h_hrates_tau_infs = gate_h_hrates_tau_infs
        self.gate_h_hrates_tau_infs_nsprefix_ = None
        if gate_hh_instantaneouses is None:
            self.gate_hh_instantaneouses = []
        else:
            self.gate_hh_instantaneouses = gate_hh_instantaneouses
        self.gate_hh_instantaneouses_nsprefix_ = None
        if gate_fractionals is None:
            self.gate_fractionals = []
        else:
            self.gate_fractionals = gate_fractionals
        self.gate_fractionals_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IonChannel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IonChannel.subclass:
            return IonChannel.subclass(*args_, **kwargs_)
        else:
            return IonChannel(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def validate_channelTypes(self, value):
        # Validate type channelTypes, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            value = value
            enumerations = ["ionChannelPassive", "ionChannelHH"]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on channelTypes'
                    % {"value": encode_str_2_3(value), "lineno": lineno}
                )
                result = False

    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductance_patterns_,
                    )
                )

    validate_Nml2Quantity_conductance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$"]
    ]

    def _hasContent(self):
        if (
            self.gates
            or self.gate_hh_rates
            or self.gate_h_hrates_taus
            or self.gate_hh_tau_infs
            or self.gate_h_hrates_infs
            or self.gate_h_hrates_tau_infs
            or self.gate_hh_instantaneouses
            or self.gate_fractionals
            or super(IonChannel, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="IonChannel",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IonChannel")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IonChannel":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IonChannel"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IonChannel",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="IonChannel"
    ):
        super(IonChannel, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IonChannel"
        )
        if self.species is not None and "species" not in already_processed:
            already_processed.add("species")
            outfile.write(
                " species=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.species), input_name="species"
                        )
                    ),
                )
            )
        if self.type is not None and "type" not in already_processed:
            already_processed.add("type")
            outfile.write(
                " type=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.type), input_name="type"
                        )
                    ),
                )
            )
        if self.conductance is not None and "conductance" not in already_processed:
            already_processed.add("conductance")
            outfile.write(
                " conductance=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.conductance), input_name="conductance"
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="IonChannel",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IonChannel, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for gate_ in self.gates:
            namespaceprefix_ = (
                self.gates_nsprefix_ + ":"
                if (UseCapturedNS_ and self.gates_nsprefix_)
                else ""
            )
            gate_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="gate",
                pretty_print=pretty_print,
            )
        for gateHHrates_ in self.gate_hh_rates:
            namespaceprefix_ = (
                self.gate_hh_rates_nsprefix_ + ":"
                if (UseCapturedNS_ and self.gate_hh_rates_nsprefix_)
                else ""
            )
            gateHHrates_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="gateHHrates",
                pretty_print=pretty_print,
            )
        for gateHHratesTau_ in self.gate_h_hrates_taus:
            namespaceprefix_ = (
                self.gate_h_hrates_taus_nsprefix_ + ":"
                if (UseCapturedNS_ and self.gate_h_hrates_taus_nsprefix_)
                else ""
            )
            gateHHratesTau_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="gateHHratesTau",
                pretty_print=pretty_print,
            )
        for gateHHtauInf_ in self.gate_hh_tau_infs:
            namespaceprefix_ = (
                self.gate_hh_tau_infs_nsprefix_ + ":"
                if (UseCapturedNS_ and self.gate_hh_tau_infs_nsprefix_)
                else ""
            )
            gateHHtauInf_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="gateHHtauInf",
                pretty_print=pretty_print,
            )
        for gateHHratesInf_ in self.gate_h_hrates_infs:
            namespaceprefix_ = (
                self.gate_h_hrates_infs_nsprefix_ + ":"
                if (UseCapturedNS_ and self.gate_h_hrates_infs_nsprefix_)
                else ""
            )
            gateHHratesInf_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="gateHHratesInf",
                pretty_print=pretty_print,
            )
        for gateHHratesTauInf_ in self.gate_h_hrates_tau_infs:
            namespaceprefix_ = (
                self.gate_h_hrates_tau_infs_nsprefix_ + ":"
                if (UseCapturedNS_ and self.gate_h_hrates_tau_infs_nsprefix_)
                else ""
            )
            gateHHratesTauInf_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="gateHHratesTauInf",
                pretty_print=pretty_print,
            )
        for gateHHInstantaneous_ in self.gate_hh_instantaneouses:
            namespaceprefix_ = (
                self.gate_hh_instantaneouses_nsprefix_ + ":"
                if (UseCapturedNS_ and self.gate_hh_instantaneouses_nsprefix_)
                else ""
            )
            gateHHInstantaneous_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="gateHHInstantaneous",
                pretty_print=pretty_print,
            )
        for gateFractional_ in self.gate_fractionals:
            namespaceprefix_ = (
                self.gate_fractionals_nsprefix_ + ":"
                if (UseCapturedNS_ and self.gate_fractionals_nsprefix_)
                else ""
            )
            gateFractional_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="gateFractional",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.species, "species")
        self.gds_check_cardinality_(self.species, "species", required=False)
        self.gds_validate_defined_ST_(self.validate_channelTypes, self.type, "type")
        self.gds_check_cardinality_(self.type, "type", required=False)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductance, self.conductance, "conductance"
        )
        self.gds_check_cardinality_(self.conductance, "conductance", required=False)
        # validate simple type children
        # validate complex type children
        # cardinality check omitted for choice item gates
        # self.gds_check_cardinality_(self.gates, 'gates', min_occurs=0, max_occurs=9999999)
        # cardinality check omitted for choice item gate_hh_rates
        # self.gds_check_cardinality_(self.gate_hh_rates, 'gate_hh_rates', min_occurs=0, max_occurs=9999999)
        # cardinality check omitted for choice item gate_h_hrates_taus
        # self.gds_check_cardinality_(self.gate_h_hrates_taus, 'gate_h_hrates_taus', min_occurs=0, max_occurs=9999999)
        # cardinality check omitted for choice item gate_hh_tau_infs
        # self.gds_check_cardinality_(self.gate_hh_tau_infs, 'gate_hh_tau_infs', min_occurs=0, max_occurs=9999999)
        # cardinality check omitted for choice item gate_h_hrates_infs
        # self.gds_check_cardinality_(self.gate_h_hrates_infs, 'gate_h_hrates_infs', min_occurs=0, max_occurs=9999999)
        # cardinality check omitted for choice item gate_h_hrates_tau_infs
        # self.gds_check_cardinality_(self.gate_h_hrates_tau_infs, 'gate_h_hrates_tau_infs', min_occurs=0, max_occurs=9999999)
        # cardinality check omitted for choice item gate_hh_instantaneouses
        # self.gds_check_cardinality_(self.gate_hh_instantaneouses, 'gate_hh_instantaneouses', min_occurs=0, max_occurs=9999999)
        # cardinality check omitted for choice item gate_fractionals
        # self.gds_check_cardinality_(self.gate_fractionals, 'gate_fractionals', min_occurs=0, max_occurs=9999999)
        if recursive:
            for item in self.gates:
                item.validate_(gds_collector, recursive=True)
            for item in self.gate_hh_rates:
                item.validate_(gds_collector, recursive=True)
            for item in self.gate_h_hrates_taus:
                item.validate_(gds_collector, recursive=True)
            for item in self.gate_hh_tau_infs:
                item.validate_(gds_collector, recursive=True)
            for item in self.gate_h_hrates_infs:
                item.validate_(gds_collector, recursive=True)
            for item in self.gate_h_hrates_tau_infs:
                item.validate_(gds_collector, recursive=True)
            for item in self.gate_hh_instantaneouses:
                item.validate_(gds_collector, recursive=True)
            for item in self.gate_fractionals:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("species", node)
        if value is not None and "species" not in already_processed:
            already_processed.add("species")
            self.species = value
            self.validate_NmlId(self.species)  # validate type NmlId
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type = value
            self.validate_channelTypes(self.type)  # validate type channelTypes
        value = find_attr_value_("conductance", node)
        if value is not None and "conductance" not in already_processed:
            already_processed.add("conductance")
            self.conductance = value
            self.validate_Nml2Quantity_conductance(
                self.conductance
            )  # validate type Nml2Quantity_conductance
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(IonChannel, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "gate":
            obj_ = GateHHUndetermined.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gates.append(obj_)
            obj_.original_tagname_ = "gate"
        elif nodeName_ == "gateHHrates":
            obj_ = GateHHRates.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gate_hh_rates.append(obj_)
            obj_.original_tagname_ = "gateHHrates"
        elif nodeName_ == "gateHHratesTau":
            obj_ = GateHHRatesTau.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gate_h_hrates_taus.append(obj_)
            obj_.original_tagname_ = "gateHHratesTau"
        elif nodeName_ == "gateHHtauInf":
            obj_ = GateHHTauInf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gate_hh_tau_infs.append(obj_)
            obj_.original_tagname_ = "gateHHtauInf"
        elif nodeName_ == "gateHHratesInf":
            obj_ = GateHHRatesInf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gate_h_hrates_infs.append(obj_)
            obj_.original_tagname_ = "gateHHratesInf"
        elif nodeName_ == "gateHHratesTauInf":
            obj_ = GateHHRatesTauInf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gate_h_hrates_tau_infs.append(obj_)
            obj_.original_tagname_ = "gateHHratesTauInf"
        elif nodeName_ == "gateHHInstantaneous":
            obj_ = GateHHInstantaneous.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gate_hh_instantaneouses.append(obj_)
            obj_.original_tagname_ = "gateHHInstantaneous"
        elif nodeName_ == "gateFractional":
            obj_ = GateFractional.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gate_fractionals.append(obj_)
            obj_.original_tagname_ = "gateFractional"
        super(IonChannel, self)._buildChildren(child_, node, nodeName_, True)


# end class IonChannel


class ConditionalDerivedVariable(NamedDimensionalVariable):
    """ConditionalDerivedVariable -- LEMS ComponentType for ConditionalDerivedVariable"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "Case",
            "Case",
            1,
            0,
            {
                "maxOccurs": "unbounded",
                "minOccurs": "1",
                "name": "Case",
                "type": "Case",
            },
            None,
        ),
    ]
    subclass = None
    superclass = NamedDimensionalVariable

    def __init__(
        self,
        name: "a string (required)" = None,
        dimension: "a string (required)" = None,
        description: "a string (optional)" = None,
        exposure: "a string (optional)" = None,
        Case: "list of Case(s) (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ConditionalDerivedVariable"), self).__init__(
            name, dimension, description, exposure, **kwargs_
        )
        if Case is None:
            self.Case = []
        else:
            self.Case = Case
        self.Case_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConditionalDerivedVariable
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConditionalDerivedVariable.subclass:
            return ConditionalDerivedVariable.subclass(*args_, **kwargs_)
        else:
            return ConditionalDerivedVariable(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if self.Case or super(ConditionalDerivedVariable, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ConditionalDerivedVariable",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ConditionalDerivedVariable")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ConditionalDerivedVariable":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ConditionalDerivedVariable",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ConditionalDerivedVariable",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ConditionalDerivedVariable",
    ):
        super(ConditionalDerivedVariable, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ConditionalDerivedVariable",
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="ConditionalDerivedVariable",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ConditionalDerivedVariable, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        for Case_ in self.Case:
            namespaceprefix_ = (
                self.Case_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Case_nsprefix_)
                else ""
            )
            Case_.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="Case",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(self.Case, "Case", min_occurs=1, max_occurs=9999999)
        if recursive:
            for item in self.Case:
                item.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(ConditionalDerivedVariable, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "Case":
            obj_ = Case.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Case.append(obj_)
            obj_.original_tagname_ = "Case"
        super(ConditionalDerivedVariable, self)._buildChildren(
            child_, node, nodeName_, True
        )


# end class ConditionalDerivedVariable


class StateVariable(NamedDimensionalVariable):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = NamedDimensionalVariable

    def __init__(
        self,
        name: "a string (required)" = None,
        dimension: "a string (required)" = None,
        description: "a string (optional)" = None,
        exposure: "a string (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("StateVariable"), self).__init__(
            name, dimension, description, exposure, **kwargs_
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, StateVariable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StateVariable.subclass:
            return StateVariable.subclass(*args_, **kwargs_)
        else:
            return StateVariable(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(StateVariable, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="StateVariable",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("StateVariable")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "StateVariable":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="StateVariable"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="StateVariable",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="StateVariable",
    ):
        super(StateVariable, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="StateVariable"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="StateVariable",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(StateVariable, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(StateVariable, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(StateVariable, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class StateVariable


class DerivedVariable(NamedDimensionalVariable):
    """DerivedVariable -- LEMS ComponentType for DerivedVariable"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("value", "xs:string", 0, 1, {"use": "optional", "name": "value"}),
        MemberSpec_("select", "xs:string", 0, 1, {"use": "optional", "name": "select"}),
    ]
    subclass = None
    superclass = NamedDimensionalVariable

    def __init__(
        self,
        name: "a string (required)" = None,
        dimension: "a string (required)" = None,
        description: "a string (optional)" = None,
        exposure: "a string (optional)" = None,
        value: "a string (optional)" = None,
        select: "a string (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("DerivedVariable"), self).__init__(
            name, dimension, description, exposure, **kwargs_
        )
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.select = _cast(None, select)
        self.select_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, DerivedVariable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DerivedVariable.subclass:
            return DerivedVariable.subclass(*args_, **kwargs_)
        else:
            return DerivedVariable(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(DerivedVariable, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DerivedVariable",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("DerivedVariable")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "DerivedVariable":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="DerivedVariable"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="DerivedVariable",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="DerivedVariable",
    ):
        super(DerivedVariable, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="DerivedVariable"
        )
        if self.value is not None and "value" not in already_processed:
            already_processed.add("value")
            outfile.write(
                " value=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.value), input_name="value"
                        )
                    ),
                )
            )
        if self.select is not None and "select" not in already_processed:
            already_processed.add("select")
            outfile.write(
                " select=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.select), input_name="select"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DerivedVariable",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(DerivedVariable, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.value, "value")
        self.gds_check_cardinality_(self.value, "value", required=False)
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.select, "select")
        self.gds_check_cardinality_(self.select, "select", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("value", node)
        if value is not None and "value" not in already_processed:
            already_processed.add("value")
            self.value = value
        value = find_attr_value_("select", node)
        if value is not None and "select" not in already_processed:
            already_processed.add("select")
            self.select = value
        super(DerivedVariable, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(DerivedVariable, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class DerivedVariable


class Requirement(NamedDimensionalType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = NamedDimensionalType

    def __init__(
        self,
        name: "a string (required)" = None,
        dimension: "a string (required)" = None,
        description: "a string (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Requirement"), self).__init__(
            name, dimension, description, **kwargs_
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Requirement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Requirement.subclass:
            return Requirement.subclass(*args_, **kwargs_)
        else:
            return Requirement(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(Requirement, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Requirement",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Requirement")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Requirement":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Requirement"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Requirement",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Requirement",
    ):
        super(Requirement, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Requirement"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Requirement",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Requirement, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(Requirement, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Requirement, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class Requirement


class LEMS_Property(NamedDimensionalType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "default_value",
            "xs:double",
            0,
            1,
            {"use": "optional", "name": "default_value"},
        ),
    ]
    subclass = None
    superclass = NamedDimensionalType

    def __init__(
        self,
        name: "a string (required)" = None,
        dimension: "a string (required)" = None,
        description: "a string (optional)" = None,
        default_value: "a double (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("LEMS_Property"), self).__init__(
            name, dimension, description, **kwargs_
        )
        self.default_value = _cast(float, default_value)
        self.default_value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, LEMS_Property)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LEMS_Property.subclass:
            return LEMS_Property.subclass(*args_, **kwargs_)
        else:
            return LEMS_Property(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(LEMS_Property, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="LEMS_Property",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("LEMS_Property")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "LEMS_Property":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="LEMS_Property"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="LEMS_Property",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="LEMS_Property",
    ):
        super(LEMS_Property, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="LEMS_Property"
        )
        if self.default_value is not None and "default_value" not in already_processed:
            already_processed.add("default_value")
            outfile.write(
                ' defaultValue="%s"'
                % self.gds_format_double(self.default_value, input_name="defaultValue")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="LEMS_Property",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(LEMS_Property, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(
            self.gds_validate_double, self.default_value, "default_value"
        )
        self.gds_check_cardinality_(self.default_value, "default_value", required=False)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("defaultValue", node)
        if value is not None and "defaultValue" not in already_processed:
            already_processed.add("defaultValue")
            value = self.gds_parse_double(value, node, "defaultValue")
            self.default_value = value
        super(LEMS_Property, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(LEMS_Property, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class LEMS_Property


class DerivedParameter(NamedDimensionalType):
    """DerivedParameter -- LEMS DerivedParamter element"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("value", "xs:string", 0, 0, {"use": "required", "name": "value"}),
    ]
    subclass = None
    superclass = NamedDimensionalType

    def __init__(
        self,
        name: "a string (required)" = None,
        dimension: "a string (required)" = None,
        description: "a string (optional)" = None,
        value: "a string (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("DerivedParameter"), self).__init__(
            name, dimension, description, **kwargs_
        )
        self.value = _cast(None, value)
        self.value_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, DerivedParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DerivedParameter.subclass:
            return DerivedParameter.subclass(*args_, **kwargs_)
        else:
            return DerivedParameter(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(DerivedParameter, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DerivedParameter",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("DerivedParameter")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "DerivedParameter":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="DerivedParameter",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="DerivedParameter",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="DerivedParameter",
    ):
        super(DerivedParameter, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="DerivedParameter",
        )
        if self.value is not None and "value" not in already_processed:
            already_processed.add("value")
            outfile.write(
                " value=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.value), input_name="value"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DerivedParameter",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(DerivedParameter, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_string, self.value, "value")
        self.gds_check_cardinality_(self.value, "value", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("value", node)
        if value is not None and "value" not in already_processed:
            already_processed.add("value")
            self.value = value
        super(DerivedParameter, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(DerivedParameter, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class DerivedParameter


class Parameter(NamedDimensionalType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = NamedDimensionalType

    def __init__(
        self,
        name: "a string (required)" = None,
        dimension: "a string (required)" = None,
        description: "a string (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Parameter"), self).__init__(
            name, dimension, description, **kwargs_
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Parameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Parameter.subclass:
            return Parameter.subclass(*args_, **kwargs_)
        else:
            return Parameter(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(Parameter, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Parameter",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Parameter")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Parameter":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Parameter"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Parameter",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Parameter"
    ):
        super(Parameter, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Parameter"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Parameter",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Parameter, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(Parameter, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Parameter, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class Parameter


class AlphaCurrSynapse(BasePynnSynapse):
    """AlphaCurrSynapse -- Alpha synapse: rise time and decay time are both tau_syn. Current based synapse.
    \n
    :param tau_syn:
    :type tau_syn: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = BasePynnSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        tau_syn: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("AlphaCurrSynapse"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, tau_syn, **kwargs_
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AlphaCurrSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlphaCurrSynapse.subclass:
            return AlphaCurrSynapse.subclass(*args_, **kwargs_)
        else:
            return AlphaCurrSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(AlphaCurrSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AlphaCurrSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AlphaCurrSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AlphaCurrSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AlphaCurrSynapse",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AlphaCurrSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AlphaCurrSynapse",
    ):
        super(AlphaCurrSynapse, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AlphaCurrSynapse",
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AlphaCurrSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(AlphaCurrSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(AlphaCurrSynapse, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(AlphaCurrSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class AlphaCurrSynapse


class ExpCurrSynapse(BasePynnSynapse):
    """ExpCurrSynapse -- Current based synapse with instantaneous rise and single exponential decay ( with time constant tau_syn )
    \n
    :param tau_syn:
    :type tau_syn: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = BasePynnSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        tau_syn: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ExpCurrSynapse"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, tau_syn, **kwargs_
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ExpCurrSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpCurrSynapse.subclass:
            return ExpCurrSynapse.subclass(*args_, **kwargs_)
        else:
            return ExpCurrSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(ExpCurrSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ExpCurrSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ExpCurrSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ExpCurrSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ExpCurrSynapse"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ExpCurrSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ExpCurrSynapse",
    ):
        super(ExpCurrSynapse, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ExpCurrSynapse"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ExpCurrSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ExpCurrSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(ExpCurrSynapse, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ExpCurrSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class ExpCurrSynapse


class AlphaCondSynapse(BasePynnSynapse):
    """AlphaCondSynapse -- Alpha synapse: rise time and decay time are both tau_syn. Conductance based synapse.
    \n
    :param e_rev:
    :type e_rev: none
    :param tau_syn:
    :type tau_syn: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("e_rev", "xs:float", 0, 0, {"use": "required", "name": "e_rev"}),
    ]
    subclass = None
    superclass = BasePynnSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        tau_syn: "a float (required)" = None,
        e_rev: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("AlphaCondSynapse"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, tau_syn, **kwargs_
        )
        self.e_rev = _cast(float, e_rev)
        self.e_rev_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AlphaCondSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlphaCondSynapse.subclass:
            return AlphaCondSynapse.subclass(*args_, **kwargs_)
        else:
            return AlphaCondSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(AlphaCondSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AlphaCondSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AlphaCondSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AlphaCondSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AlphaCondSynapse",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AlphaCondSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AlphaCondSynapse",
    ):
        super(AlphaCondSynapse, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AlphaCondSynapse",
        )
        if self.e_rev is not None and "e_rev" not in already_processed:
            already_processed.add("e_rev")
            outfile.write(
                ' e_rev="%s"' % self.gds_format_float(self.e_rev, input_name="e_rev")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AlphaCondSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(AlphaCondSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.e_rev, "e_rev")
        self.gds_check_cardinality_(self.e_rev, "e_rev", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("e_rev", node)
        if value is not None and "e_rev" not in already_processed:
            already_processed.add("e_rev")
            value = self.gds_parse_float(value, node, "e_rev")
            self.e_rev = value
        super(AlphaCondSynapse, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(AlphaCondSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class AlphaCondSynapse


class ExpCondSynapse(BasePynnSynapse):
    """ExpCondSynapse -- Conductance based synapse with instantaneous rise and single exponential decay ( with time constant tau_syn )
    \n
    :param e_rev:
    :type e_rev: none
    :param tau_syn:
    :type tau_syn: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("e_rev", "xs:float", 0, 0, {"use": "required", "name": "e_rev"}),
    ]
    subclass = None
    superclass = BasePynnSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        tau_syn: "a float (required)" = None,
        e_rev: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ExpCondSynapse"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, tau_syn, **kwargs_
        )
        self.e_rev = _cast(float, e_rev)
        self.e_rev_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ExpCondSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpCondSynapse.subclass:
            return ExpCondSynapse.subclass(*args_, **kwargs_)
        else:
            return ExpCondSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(ExpCondSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ExpCondSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ExpCondSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ExpCondSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ExpCondSynapse"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ExpCondSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ExpCondSynapse",
    ):
        super(ExpCondSynapse, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ExpCondSynapse"
        )
        if self.e_rev is not None and "e_rev" not in already_processed:
            already_processed.add("e_rev")
            outfile.write(
                ' e_rev="%s"' % self.gds_format_float(self.e_rev, input_name="e_rev")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ExpCondSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ExpCondSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.e_rev, "e_rev")
        self.gds_check_cardinality_(self.e_rev, "e_rev", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("e_rev", node)
        if value is not None and "e_rev" not in already_processed:
            already_processed.add("e_rev")
            value = self.gds_parse_float(value, node, "e_rev")
            self.e_rev = value
        super(ExpCondSynapse, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ExpCondSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class ExpCondSynapse


class HH_cond_exp(basePyNNCell):
    """HH_cond_exp -- Single-compartment Hodgkin-Huxley-type neuron with transient sodium and delayed-rectifier potassium currents using the ion channel models from Traub.
    \n
    :param gbar_K:
    :type gbar_K: none
    :param gbar_Na:
    :type gbar_Na: none
    :param g_leak:
    :type g_leak: none
    :param e_rev_K:
    :type e_rev_K: none
    :param e_rev_Na:
    :type e_rev_Na: none
    :param e_rev_leak:
    :type e_rev_leak: none
    :param v_offset:
    :type v_offset: none
    :param e_rev_E:
    :type e_rev_E: none
    :param e_rev_I:
    :type e_rev_I: none
    :param cm:
    :type cm: none
    :param i_offset:
    :type i_offset: none
    :param tau_syn_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_E: none
    :param tau_syn_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_I: none
    :param v_init:
    :type v_init: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "v_offset", "xs:float", 0, 0, {"use": "required", "name": "v_offset"}
        ),
        MemberSpec_(
            "e_rev_E", "xs:float", 0, 0, {"use": "required", "name": "e_rev_E"}
        ),
        MemberSpec_(
            "e_rev_I", "xs:float", 0, 0, {"use": "required", "name": "e_rev_I"}
        ),
        MemberSpec_(
            "e_rev_K", "xs:float", 0, 0, {"use": "required", "name": "e_rev_K"}
        ),
        MemberSpec_(
            "e_rev_Na", "xs:float", 0, 0, {"use": "required", "name": "e_rev_Na"}
        ),
        MemberSpec_(
            "e_rev_leak", "xs:float", 0, 0, {"use": "required", "name": "e_rev_leak"}
        ),
        MemberSpec_("g_leak", "xs:float", 0, 0, {"use": "required", "name": "g_leak"}),
        MemberSpec_("gbar_K", "xs:float", 0, 0, {"use": "required", "name": "gbar_K"}),
        MemberSpec_(
            "gbar_Na", "xs:float", 0, 0, {"use": "required", "name": "gbar_Na"}
        ),
    ]
    subclass = None
    superclass = basePyNNCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        cm: "a float (required)" = None,
        i_offset: "a float (required)" = None,
        tau_syn_E: "a float (required)" = None,
        tau_syn_I: "a float (required)" = None,
        v_init: "a float (required)" = None,
        v_offset: "a float (required)" = None,
        e_rev_E: "a float (required)" = None,
        e_rev_I: "a float (required)" = None,
        e_rev_K: "a float (required)" = None,
        e_rev_Na: "a float (required)" = None,
        e_rev_leak: "a float (required)" = None,
        g_leak: "a float (required)" = None,
        gbar_K: "a float (required)" = None,
        gbar_Na: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("HH_cond_exp"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            cm,
            i_offset,
            tau_syn_E,
            tau_syn_I,
            v_init,
            **kwargs_,
        )
        self.v_offset = _cast(float, v_offset)
        self.v_offset_nsprefix_ = None
        self.e_rev_E = _cast(float, e_rev_E)
        self.e_rev_E_nsprefix_ = None
        self.e_rev_I = _cast(float, e_rev_I)
        self.e_rev_I_nsprefix_ = None
        self.e_rev_K = _cast(float, e_rev_K)
        self.e_rev_K_nsprefix_ = None
        self.e_rev_Na = _cast(float, e_rev_Na)
        self.e_rev_Na_nsprefix_ = None
        self.e_rev_leak = _cast(float, e_rev_leak)
        self.e_rev_leak_nsprefix_ = None
        self.g_leak = _cast(float, g_leak)
        self.g_leak_nsprefix_ = None
        self.gbar_K = _cast(float, gbar_K)
        self.gbar_K_nsprefix_ = None
        self.gbar_Na = _cast(float, gbar_Na)
        self.gbar_Na_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, HH_cond_exp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HH_cond_exp.subclass:
            return HH_cond_exp.subclass(*args_, **kwargs_)
        else:
            return HH_cond_exp(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(HH_cond_exp, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="HH_cond_exp",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("HH_cond_exp")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "HH_cond_exp":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="HH_cond_exp"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="HH_cond_exp",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="HH_cond_exp",
    ):
        super(HH_cond_exp, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="HH_cond_exp"
        )
        if self.v_offset is not None and "v_offset" not in already_processed:
            already_processed.add("v_offset")
            outfile.write(
                ' v_offset="%s"'
                % self.gds_format_float(self.v_offset, input_name="v_offset")
            )
        if self.e_rev_E is not None and "e_rev_E" not in already_processed:
            already_processed.add("e_rev_E")
            outfile.write(
                ' e_rev_E="%s"'
                % self.gds_format_float(self.e_rev_E, input_name="e_rev_E")
            )
        if self.e_rev_I is not None and "e_rev_I" not in already_processed:
            already_processed.add("e_rev_I")
            outfile.write(
                ' e_rev_I="%s"'
                % self.gds_format_float(self.e_rev_I, input_name="e_rev_I")
            )
        if self.e_rev_K is not None and "e_rev_K" not in already_processed:
            already_processed.add("e_rev_K")
            outfile.write(
                ' e_rev_K="%s"'
                % self.gds_format_float(self.e_rev_K, input_name="e_rev_K")
            )
        if self.e_rev_Na is not None and "e_rev_Na" not in already_processed:
            already_processed.add("e_rev_Na")
            outfile.write(
                ' e_rev_Na="%s"'
                % self.gds_format_float(self.e_rev_Na, input_name="e_rev_Na")
            )
        if self.e_rev_leak is not None and "e_rev_leak" not in already_processed:
            already_processed.add("e_rev_leak")
            outfile.write(
                ' e_rev_leak="%s"'
                % self.gds_format_float(self.e_rev_leak, input_name="e_rev_leak")
            )
        if self.g_leak is not None and "g_leak" not in already_processed:
            already_processed.add("g_leak")
            outfile.write(
                ' g_leak="%s"' % self.gds_format_float(self.g_leak, input_name="g_leak")
            )
        if self.gbar_K is not None and "gbar_K" not in already_processed:
            already_processed.add("gbar_K")
            outfile.write(
                ' gbar_K="%s"' % self.gds_format_float(self.gbar_K, input_name="gbar_K")
            )
        if self.gbar_Na is not None and "gbar_Na" not in already_processed:
            already_processed.add("gbar_Na")
            outfile.write(
                ' gbar_Na="%s"'
                % self.gds_format_float(self.gbar_Na, input_name="gbar_Na")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="HH_cond_exp",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(HH_cond_exp, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(
            self.gds_validate_float, self.v_offset, "v_offset"
        )
        self.gds_check_cardinality_(self.v_offset, "v_offset", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.e_rev_E, "e_rev_E")
        self.gds_check_cardinality_(self.e_rev_E, "e_rev_E", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.e_rev_I, "e_rev_I")
        self.gds_check_cardinality_(self.e_rev_I, "e_rev_I", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.e_rev_K, "e_rev_K")
        self.gds_check_cardinality_(self.e_rev_K, "e_rev_K", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_float, self.e_rev_Na, "e_rev_Na"
        )
        self.gds_check_cardinality_(self.e_rev_Na, "e_rev_Na", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_float, self.e_rev_leak, "e_rev_leak"
        )
        self.gds_check_cardinality_(self.e_rev_leak, "e_rev_leak", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.g_leak, "g_leak")
        self.gds_check_cardinality_(self.g_leak, "g_leak", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.gbar_K, "gbar_K")
        self.gds_check_cardinality_(self.gbar_K, "gbar_K", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.gbar_Na, "gbar_Na")
        self.gds_check_cardinality_(self.gbar_Na, "gbar_Na", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("v_offset", node)
        if value is not None and "v_offset" not in already_processed:
            already_processed.add("v_offset")
            value = self.gds_parse_float(value, node, "v_offset")
            self.v_offset = value
        value = find_attr_value_("e_rev_E", node)
        if value is not None and "e_rev_E" not in already_processed:
            already_processed.add("e_rev_E")
            value = self.gds_parse_float(value, node, "e_rev_E")
            self.e_rev_E = value
        value = find_attr_value_("e_rev_I", node)
        if value is not None and "e_rev_I" not in already_processed:
            already_processed.add("e_rev_I")
            value = self.gds_parse_float(value, node, "e_rev_I")
            self.e_rev_I = value
        value = find_attr_value_("e_rev_K", node)
        if value is not None and "e_rev_K" not in already_processed:
            already_processed.add("e_rev_K")
            value = self.gds_parse_float(value, node, "e_rev_K")
            self.e_rev_K = value
        value = find_attr_value_("e_rev_Na", node)
        if value is not None and "e_rev_Na" not in already_processed:
            already_processed.add("e_rev_Na")
            value = self.gds_parse_float(value, node, "e_rev_Na")
            self.e_rev_Na = value
        value = find_attr_value_("e_rev_leak", node)
        if value is not None and "e_rev_leak" not in already_processed:
            already_processed.add("e_rev_leak")
            value = self.gds_parse_float(value, node, "e_rev_leak")
            self.e_rev_leak = value
        value = find_attr_value_("g_leak", node)
        if value is not None and "g_leak" not in already_processed:
            already_processed.add("g_leak")
            value = self.gds_parse_float(value, node, "g_leak")
            self.g_leak = value
        value = find_attr_value_("gbar_K", node)
        if value is not None and "gbar_K" not in already_processed:
            already_processed.add("gbar_K")
            value = self.gds_parse_float(value, node, "gbar_K")
            self.gbar_K = value
        value = find_attr_value_("gbar_Na", node)
        if value is not None and "gbar_Na" not in already_processed:
            already_processed.add("gbar_Na")
            value = self.gds_parse_float(value, node, "gbar_Na")
            self.gbar_Na = value
        super(HH_cond_exp, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(HH_cond_exp, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class HH_cond_exp


class basePyNNIaFCell(basePyNNCell):
    """basePyNNIaFCell -- Base type of any PyNN standard integrate and fire model
    \n
    :param tau_refrac:
    :type tau_refrac: none
    :param v_thresh:
    :type v_thresh: none
    :param tau_m:
    :type tau_m: none
    :param v_rest:
    :type v_rest: none
    :param v_reset:
    :type v_reset: none
    :param cm:
    :type cm: none
    :param i_offset:
    :type i_offset: none
    :param tau_syn_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_E: none
    :param tau_syn_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_I: none
    :param v_init:
    :type v_init: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("tau_m", "xs:float", 0, 0, {"use": "required", "name": "tau_m"}),
        MemberSpec_(
            "tau_refrac", "xs:float", 0, 0, {"use": "required", "name": "tau_refrac"}
        ),
        MemberSpec_(
            "v_reset", "xs:float", 0, 0, {"use": "required", "name": "v_reset"}
        ),
        MemberSpec_("v_rest", "xs:float", 0, 0, {"use": "required", "name": "v_rest"}),
        MemberSpec_(
            "v_thresh", "xs:float", 0, 0, {"use": "required", "name": "v_thresh"}
        ),
    ]
    subclass = None
    superclass = basePyNNCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        cm: "a float (required)" = None,
        i_offset: "a float (required)" = None,
        tau_syn_E: "a float (required)" = None,
        tau_syn_I: "a float (required)" = None,
        v_init: "a float (required)" = None,
        tau_m: "a float (required)" = None,
        tau_refrac: "a float (required)" = None,
        v_reset: "a float (required)" = None,
        v_rest: "a float (required)" = None,
        v_thresh: "a float (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("basePyNNIaFCell"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            cm,
            i_offset,
            tau_syn_E,
            tau_syn_I,
            v_init,
            extensiontype_,
            **kwargs_,
        )
        self.tau_m = _cast(float, tau_m)
        self.tau_m_nsprefix_ = None
        self.tau_refrac = _cast(float, tau_refrac)
        self.tau_refrac_nsprefix_ = None
        self.v_reset = _cast(float, v_reset)
        self.v_reset_nsprefix_ = None
        self.v_rest = _cast(float, v_rest)
        self.v_rest_nsprefix_ = None
        self.v_thresh = _cast(float, v_thresh)
        self.v_thresh_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, basePyNNIaFCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basePyNNIaFCell.subclass:
            return basePyNNIaFCell.subclass(*args_, **kwargs_)
        else:
            return basePyNNIaFCell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(basePyNNIaFCell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="basePyNNIaFCell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("basePyNNIaFCell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "basePyNNIaFCell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="basePyNNIaFCell"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="basePyNNIaFCell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="basePyNNIaFCell",
    ):
        super(basePyNNIaFCell, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="basePyNNIaFCell"
        )
        if self.tau_m is not None and "tau_m" not in already_processed:
            already_processed.add("tau_m")
            outfile.write(
                ' tau_m="%s"' % self.gds_format_float(self.tau_m, input_name="tau_m")
            )
        if self.tau_refrac is not None and "tau_refrac" not in already_processed:
            already_processed.add("tau_refrac")
            outfile.write(
                ' tau_refrac="%s"'
                % self.gds_format_float(self.tau_refrac, input_name="tau_refrac")
            )
        if self.v_reset is not None and "v_reset" not in already_processed:
            already_processed.add("v_reset")
            outfile.write(
                ' v_reset="%s"'
                % self.gds_format_float(self.v_reset, input_name="v_reset")
            )
        if self.v_rest is not None and "v_rest" not in already_processed:
            already_processed.add("v_rest")
            outfile.write(
                ' v_rest="%s"' % self.gds_format_float(self.v_rest, input_name="v_rest")
            )
        if self.v_thresh is not None and "v_thresh" not in already_processed:
            already_processed.add("v_thresh")
            outfile.write(
                ' v_thresh="%s"'
                % self.gds_format_float(self.v_thresh, input_name="v_thresh")
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="basePyNNIaFCell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(basePyNNIaFCell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.tau_m, "tau_m")
        self.gds_check_cardinality_(self.tau_m, "tau_m", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_float, self.tau_refrac, "tau_refrac"
        )
        self.gds_check_cardinality_(self.tau_refrac, "tau_refrac", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.v_reset, "v_reset")
        self.gds_check_cardinality_(self.v_reset, "v_reset", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.v_rest, "v_rest")
        self.gds_check_cardinality_(self.v_rest, "v_rest", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_float, self.v_thresh, "v_thresh"
        )
        self.gds_check_cardinality_(self.v_thresh, "v_thresh", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("tau_m", node)
        if value is not None and "tau_m" not in already_processed:
            already_processed.add("tau_m")
            value = self.gds_parse_float(value, node, "tau_m")
            self.tau_m = value
        value = find_attr_value_("tau_refrac", node)
        if value is not None and "tau_refrac" not in already_processed:
            already_processed.add("tau_refrac")
            value = self.gds_parse_float(value, node, "tau_refrac")
            self.tau_refrac = value
        value = find_attr_value_("v_reset", node)
        if value is not None and "v_reset" not in already_processed:
            already_processed.add("v_reset")
            value = self.gds_parse_float(value, node, "v_reset")
            self.v_reset = value
        value = find_attr_value_("v_rest", node)
        if value is not None and "v_rest" not in already_processed:
            already_processed.add("v_rest")
            value = self.gds_parse_float(value, node, "v_rest")
            self.v_rest = value
        value = find_attr_value_("v_thresh", node)
        if value is not None and "v_thresh" not in already_processed:
            already_processed.add("v_thresh")
            value = self.gds_parse_float(value, node, "v_thresh")
            self.v_thresh = value
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(basePyNNIaFCell, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(basePyNNIaFCell, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class basePyNNIaFCell


class ContinuousConnection(BaseConnectionNewFormat):
    """ContinuousConnection -- An instance of a connection in a  **continuousProjection**  between **presynapticPopulation**  to another **postsynapticPopulation**  through a **preComponent**  at the start and **postComponent**  at the end. Can be used for analog synapses."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "pre_component", "NmlId", 0, 0, {"use": "required", "name": "pre_component"}
        ),
        MemberSpec_(
            "post_component",
            "NmlId",
            0,
            0,
            {"use": "required", "name": "post_component"},
        ),
    ]
    subclass = None
    superclass = BaseConnectionNewFormat

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        pre_cell: "a string (required)" = None,
        pre_segment: "a NonNegativeInteger (optional)" = "0",
        pre_fraction_along: "a ZeroToOne (optional)" = "0.5",
        post_cell: "a string (required)" = None,
        post_segment: "a NonNegativeInteger (optional)" = "0",
        post_fraction_along: "a ZeroToOne (optional)" = "0.5",
        pre_component: "a NmlId (required)" = None,
        post_component: "a NmlId (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ContinuousConnection"), self).__init__(
            id,
            neuro_lex_id,
            pre_cell,
            pre_segment,
            pre_fraction_along,
            post_cell,
            post_segment,
            post_fraction_along,
            extensiontype_,
            **kwargs_,
        )
        self.pre_component = _cast(None, pre_component)
        self.pre_component_nsprefix_ = None
        self.post_component = _cast(None, post_component)
        self.post_component_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContinuousConnection
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContinuousConnection.subclass:
            return ContinuousConnection.subclass(*args_, **kwargs_)
        else:
            return ContinuousConnection(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if super(ContinuousConnection, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ContinuousConnection",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ContinuousConnection")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ContinuousConnection":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ContinuousConnection",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ContinuousConnection",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ContinuousConnection",
    ):
        super(ContinuousConnection, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ContinuousConnection",
        )
        if self.pre_component is not None and "pre_component" not in already_processed:
            already_processed.add("pre_component")
            outfile.write(
                " preComponent=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.pre_component), input_name="preComponent"
                        )
                    ),
                )
            )
        if (
            self.post_component is not None
            and "post_component" not in already_processed
        ):
            already_processed.add("post_component")
            outfile.write(
                " postComponent=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.post_component),
                            input_name="postComponent",
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ContinuousConnection",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ContinuousConnection, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.pre_component, "pre_component"
        )
        self.gds_check_cardinality_(self.pre_component, "pre_component", required=True)
        self.gds_validate_defined_ST_(
            self.validate_NmlId, self.post_component, "post_component"
        )
        self.gds_check_cardinality_(
            self.post_component, "post_component", required=True
        )
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("preComponent", node)
        if value is not None and "preComponent" not in already_processed:
            already_processed.add("preComponent")
            self.pre_component = value
            self.validate_NmlId(self.pre_component)  # validate type NmlId
        value = find_attr_value_("postComponent", node)
        if value is not None and "postComponent" not in already_processed:
            already_processed.add("postComponent")
            self.post_component = value
            self.validate_NmlId(self.post_component)  # validate type NmlId
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(ContinuousConnection, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ContinuousConnection, self)._buildChildren(child_, node, nodeName_, True)
        pass

    def _get_cell_id(self, id_string):
        return int(float(id_string))

    def get_pre_cell_id(self):
        """Get the ID of the pre-synaptic cell

        :returns: ID of pre-synaptic cell
        :rtype: str
        """

        return self._get_cell_id(self.pre_cell)

    def get_post_cell_id(self):
        """Get the ID of the post-synaptic cell

        :returns: ID of post-synaptic cell
        :rtype: str
        """

        return self._get_cell_id(self.post_cell)

    def get_pre_segment_id(self):
        """Get the ID of the pre-synpatic segment

        :returns: ID of pre-synaptic segment.
        :rtype: str
        """

        return int(self.pre_segment)

    def get_post_segment_id(self):
        """Get the ID of the post-synpatic segment

        :returns: ID of post-synaptic segment.
        :rtype: str
        """

        return int(self.post_segment)

    def get_pre_fraction_along(self):
        """Get pre-synaptic fraction along information"""

        return float(self.pre_fraction_along)

    def get_post_fraction_along(self):
        """Get post-synaptic fraction along information"""

        return float(self.post_fraction_along)

    def get_pre_info(self):
        """Get pre-synaptic information summary"""

        return str(self.get_pre_cell_id()) + (
            ":"
            + str(self.get_pre_segment_id())
            + "("
            + "%.5f" % self.get_pre_fraction_along()
            + ")"
            if self.get_pre_segment_id() != 0 or self.get_pre_fraction_along() != 0.5
            else ""
        )

    def get_post_info(self):
        """Get post-synaptic information summary"""

        return str(self.get_post_cell_id()) + (
            ":"
            + str(self.get_post_segment_id())
            + "("
            + "%.5f" % self.get_post_fraction_along()
            + ")"
            if self.get_post_segment_id() != 0 or self.get_post_fraction_along() != 0.5
            else ""
        )

    def __str__(self):
        return (
            "Continuous Connection "
            + str(self.id)
            + ": "
            + str(self.get_pre_info())
            + " -> "
            + str(self.get_post_info())
            + ", pre comp: "
            + str(self.pre_component)
            + ", post comp: "
            + str(self.post_component)
        )

    # end class ContinuousConnection


class ElectricalConnection(BaseConnectionNewFormat):
    """ElectricalConnection -- To enable connections between populations through gap junctions."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("synapse", "NmlId", 0, 0, {"use": "required", "name": "synapse"}),
    ]
    subclass = None
    superclass = BaseConnectionNewFormat

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        pre_cell: "a string (required)" = None,
        pre_segment: "a NonNegativeInteger (optional)" = "0",
        pre_fraction_along: "a ZeroToOne (optional)" = "0.5",
        post_cell: "a string (required)" = None,
        post_segment: "a NonNegativeInteger (optional)" = "0",
        post_fraction_along: "a ZeroToOne (optional)" = "0.5",
        synapse: "a NmlId (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ElectricalConnection"), self).__init__(
            id,
            neuro_lex_id,
            pre_cell,
            pre_segment,
            pre_fraction_along,
            post_cell,
            post_segment,
            post_fraction_along,
            extensiontype_,
            **kwargs_,
        )
        self.synapse = _cast(None, synapse)
        self.synapse_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricalConnection
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricalConnection.subclass:
            return ElectricalConnection.subclass(*args_, **kwargs_)
        else:
            return ElectricalConnection(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if super(ElectricalConnection, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ElectricalConnection",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ElectricalConnection")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ElectricalConnection":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ElectricalConnection",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ElectricalConnection",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ElectricalConnection",
    ):
        super(ElectricalConnection, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ElectricalConnection",
        )
        if self.synapse is not None and "synapse" not in already_processed:
            already_processed.add("synapse")
            outfile.write(
                " synapse=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.synapse), input_name="synapse"
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ElectricalConnection",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ElectricalConnection, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.synapse, "synapse")
        self.gds_check_cardinality_(self.synapse, "synapse", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("synapse", node)
        if value is not None and "synapse" not in already_processed:
            already_processed.add("synapse")
            self.synapse = value
            self.validate_NmlId(self.synapse)  # validate type NmlId
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(ElectricalConnection, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ElectricalConnection, self)._buildChildren(child_, node, nodeName_, True)
        pass

    def _get_cell_id(self, id_string):
        return int(float(id_string))

    def get_pre_cell_id(self):
        """Get the ID of the pre-synaptic cell

        :returns: ID of pre-synaptic cell
        :rtype: str
        """

        return self._get_cell_id(self.pre_cell)

    def get_post_cell_id(self):
        """Get the ID of the post-synaptic cell

        :returns: ID of post-synaptic cell
        :rtype: str
        """

        return self._get_cell_id(self.post_cell)

    def get_pre_segment_id(self):
        """Get the ID of the pre-synpatic segment

        :returns: ID of pre-synaptic segment.
        :rtype: str
        """

        return int(self.pre_segment)

    def get_post_segment_id(self):
        """Get the ID of the post-synpatic segment

        :returns: ID of post-synaptic segment.
        :rtype: str
        """

        return int(self.post_segment)

    def get_pre_fraction_along(self):
        """Get pre-synaptic fraction along information"""

        return float(self.pre_fraction_along)

    def get_post_fraction_along(self):
        """Get post-synaptic fraction along information"""

        return float(self.post_fraction_along)

    def get_pre_info(self):
        """Get pre-synaptic information summary"""

        return str(self.get_pre_cell_id()) + (
            ":"
            + str(self.get_pre_segment_id())
            + "("
            + "%.5f" % self.get_pre_fraction_along()
            + ")"
            if self.get_pre_segment_id() != 0 or self.get_pre_fraction_along() != 0.5
            else ""
        )

    def get_post_info(self):
        """Get post-synaptic information summary"""

        return str(self.get_post_cell_id()) + (
            ":"
            + str(self.get_post_segment_id())
            + "("
            + "%.5f" % self.get_post_fraction_along()
            + ")"
            if self.get_post_segment_id() != 0 or self.get_post_fraction_along() != 0.5
            else ""
        )

    def __str__(self):
        return (
            "Electrical Connection "
            + str(self.id)
            + ": "
            + str(self.get_pre_info())
            + " -> "
            + str(self.get_post_info())
            + ", synapse: "
            + str(self.synapse)
        )

    # end class ElectricalConnection


class ConnectionWD(BaseConnectionOldFormat):
    """ConnectionWD -- Event connection between named components, which gets processed via a new instance of a synapse component which is created on the target component, includes setting of **weight**  and **delay**  for the synaptic connection
    \n
    :param weight:
    :type weight: none
    :param delay:
    :type delay: time

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("weight", "xs:float", 0, 0, {"use": "required", "name": "weight"}),
        MemberSpec_(
            "delay", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "delay"}
        ),
    ]
    subclass = None
    superclass = BaseConnectionOldFormat

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        pre_cell_id: "a string (required)" = None,
        pre_segment_id: "a NonNegativeInteger (optional)" = "0",
        pre_fraction_along: "a ZeroToOne (optional)" = "0.5",
        post_cell_id: "a string (required)" = None,
        post_segment_id: "a NonNegativeInteger (optional)" = "0",
        post_fraction_along: "a ZeroToOne (optional)" = "0.5",
        weight: "a float (required)" = None,
        delay: "a Nml2Quantity_time (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ConnectionWD"), self).__init__(
            id,
            neuro_lex_id,
            pre_cell_id,
            pre_segment_id,
            pre_fraction_along,
            post_cell_id,
            post_segment_id,
            post_fraction_along,
            **kwargs_,
        )
        self.weight = _cast(float, weight)
        self.weight_nsprefix_ = None
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ConnectionWD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConnectionWD.subclass:
            return ConnectionWD.subclass(*args_, **kwargs_)
        else:
            return ConnectionWD(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(ConnectionWD, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ConnectionWD",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ConnectionWD")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ConnectionWD":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ConnectionWD"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ConnectionWD",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ConnectionWD",
    ):
        super(ConnectionWD, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ConnectionWD"
        )
        if self.weight is not None and "weight" not in already_processed:
            already_processed.add("weight")
            outfile.write(
                ' weight="%s"' % self.gds_format_float(self.weight, input_name="weight")
            )
        if self.delay is not None and "delay" not in already_processed:
            already_processed.add("delay")
            outfile.write(
                " delay=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.delay), input_name="delay"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ConnectionWD",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ConnectionWD, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.weight, "weight")
        self.gds_check_cardinality_(self.weight, "weight", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.delay, "delay"
        )
        self.gds_check_cardinality_(self.delay, "delay", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("weight", node)
        if value is not None and "weight" not in already_processed:
            already_processed.add("weight")
            value = self.gds_parse_float(value, node, "weight")
            self.weight = value
        value = find_attr_value_("delay", node)
        if value is not None and "delay" not in already_processed:
            already_processed.add("delay")
            self.delay = value
            self.validate_Nml2Quantity_time(
                self.delay
            )  # validate type Nml2Quantity_time
        super(ConnectionWD, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ConnectionWD, self)._buildChildren(child_, node, nodeName_, True)
        pass

    def _get_cell_id(self, id_string):
        if "[" in id_string:
            return int(id_string.split("[")[1].split("]")[0])
        else:
            return int(id_string.split("/")[2])

    def get_pre_cell_id(self):
        """Get the ID of the pre-synaptic cell

        :returns: ID of pre-synaptic cell
        :rtype: str
        """

        return self._get_cell_id(self.pre_cell_id)

    def get_post_cell_id(self):
        """Get the ID of the post-synaptic cell

        :returns: ID of post-synaptic cell
        :rtype: str
        """

        return self._get_cell_id(self.post_cell_id)

    def get_pre_segment_id(self):
        """Get the ID of the pre-synpatic segment

        :returns: ID of pre-synaptic segment.
        :rtype: str
        """

        return int(self.pre_segment_id)

    def get_post_segment_id(self):
        """Get the ID of the post-synpatic segment

        :returns: ID of post-synaptic segment.
        :rtype: str
        """

        return int(self.post_segment_id)

    def get_pre_fraction_along(self):
        """Get pre-synaptic fraction along information"""

        return float(self.pre_fraction_along)

    def get_post_fraction_along(self):
        """Get post-synaptic fraction along information"""

        return float(self.post_fraction_along)

    def get_pre_info(self):
        """Get pre-synaptic information summary"""

        return str(self.get_pre_cell_id()) + (
            ":"
            + str(self.get_pre_segment_id())
            + "("
            + "%.5f" % self.get_pre_fraction_along()
            + ")"
            if self.get_pre_segment_id() != 0 or self.get_pre_fraction_along() != 0.5
            else ""
        )

    def get_post_info(self):
        """Get post-synaptic information summary"""

        return str(self.get_post_cell_id()) + (
            ":"
            + str(self.get_post_segment_id())
            + "("
            + "%.5f" % self.get_post_fraction_along()
            + ")"
            if self.get_post_segment_id() != 0 or self.get_post_fraction_along() != 0.5
            else ""
        )

    def __str__(self):
        return (
            "Connection "
            + str(self.id)
            + ": "
            + str(self.get_pre_info())
            + " -> "
            + str(self.get_post_info())
        )

    def __str__(self):
        return (
            "Connection "
            + str(self.id)
            + ": "
            + str(self.get_pre_info())
            + " -> "
            + str(self.get_post_info())
            + ", weight: "
            + "%f" % (float(self.weight))
            + ", delay: "
            + "%.5f" % (self.get_delay_in_ms())
            + " ms"
        )

    def get_delay_in_ms(self):
        """Get connection delay in milli seconds

        :returns: connection delay in milli seconds
        :rtype: float
        """
        if "ms" in self.delay:
            return float(self.delay[:-2].strip())
        elif "s" in self.delay:
            return float(self.delay[:-1].strip()) * 1000.0

    # end class ConnectionWD


class Connection(BaseConnectionOldFormat):
    """Connection -- Event connection directly between named components, which gets processed via a new instance of a **synapse**  component which is created on the target component. Normally contained inside a  **projection**  element."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = BaseConnectionOldFormat

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        pre_cell_id: "a string (required)" = None,
        pre_segment_id: "a NonNegativeInteger (optional)" = "0",
        pre_fraction_along: "a ZeroToOne (optional)" = "0.5",
        post_cell_id: "a string (required)" = None,
        post_segment_id: "a NonNegativeInteger (optional)" = "0",
        post_fraction_along: "a ZeroToOne (optional)" = "0.5",
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Connection"), self).__init__(
            id,
            neuro_lex_id,
            pre_cell_id,
            pre_segment_id,
            pre_fraction_along,
            post_cell_id,
            post_segment_id,
            post_fraction_along,
            **kwargs_,
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Connection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Connection.subclass:
            return Connection.subclass(*args_, **kwargs_)
        else:
            return Connection(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(Connection, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Connection",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Connection")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Connection":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Connection"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Connection",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="Connection"
    ):
        super(Connection, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Connection"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Connection",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Connection, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(Connection, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Connection, self)._buildChildren(child_, node, nodeName_, True)
        pass

    def _get_cell_id(self, id_string):
        if "[" in id_string:
            return int(id_string.split("[")[1].split("]")[0])
        else:
            return int(id_string.split("/")[2])

    def get_pre_cell_id(self):
        """Get the ID of the pre-synaptic cell

        :returns: ID of pre-synaptic cell
        :rtype: str
        """

        return self._get_cell_id(self.pre_cell_id)

    def get_post_cell_id(self):
        """Get the ID of the post-synaptic cell

        :returns: ID of post-synaptic cell
        :rtype: str
        """

        return self._get_cell_id(self.post_cell_id)

    def get_pre_segment_id(self):
        """Get the ID of the pre-synpatic segment

        :returns: ID of pre-synaptic segment.
        :rtype: str
        """

        return int(self.pre_segment_id)

    def get_post_segment_id(self):
        """Get the ID of the post-synpatic segment

        :returns: ID of post-synaptic segment.
        :rtype: str
        """

        return int(self.post_segment_id)

    def get_pre_fraction_along(self):
        """Get pre-synaptic fraction along information"""

        return float(self.pre_fraction_along)

    def get_post_fraction_along(self):
        """Get post-synaptic fraction along information"""

        return float(self.post_fraction_along)

    def get_pre_info(self):
        """Get pre-synaptic information summary"""

        return str(self.get_pre_cell_id()) + (
            ":"
            + str(self.get_pre_segment_id())
            + "("
            + "%.5f" % self.get_pre_fraction_along()
            + ")"
            if self.get_pre_segment_id() != 0 or self.get_pre_fraction_along() != 0.5
            else ""
        )

    def get_post_info(self):
        """Get post-synaptic information summary"""

        return str(self.get_post_cell_id()) + (
            ":"
            + str(self.get_post_segment_id())
            + "("
            + "%.5f" % self.get_post_fraction_along()
            + ")"
            if self.get_post_segment_id() != 0 or self.get_post_fraction_along() != 0.5
            else ""
        )

    def __str__(self):
        return (
            "Connection "
            + str(self.id)
            + ": "
            + str(self.get_pre_info())
            + " -> "
            + str(self.get_post_info())
        )

    # end class Connection


class Cell2CaPools(Cell):
    """Cell2CaPools -- Variant of cell with two independent Ca2+ pools. Cell with  **segment** s specified in a  **morphology**  element along with details on its  **biophysicalProperties** . NOTE: this can only be correctly simulated using jLEMS when there is a single segment in the cell, and **v**  of this cell represents the membrane potential in that isopotential segment."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "biophysical_properties2_ca_pools",
            "BiophysicalProperties2CaPools",
            0,
            1,
            {
                "minOccurs": "0",
                "name": "biophysicalProperties2CaPools",
                "type": "BiophysicalProperties2CaPools",
            },
            None,
        ),
    ]
    subclass = None
    superclass = Cell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        morphology_attr: "a NmlId (optional)" = None,
        biophysical_properties_attr: "a NmlId (optional)" = None,
        morphology: "a Morphology (optional)" = None,
        biophysical_properties: "a BiophysicalProperties (optional)" = None,
        biophysical_properties2_ca_pools: "a BiophysicalProperties2CaPools (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Cell2CaPools"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            morphology_attr,
            biophysical_properties_attr,
            morphology,
            biophysical_properties,
            **kwargs_,
        )
        self.biophysical_properties2_ca_pools = biophysical_properties2_ca_pools
        self.biophysical_properties2_ca_pools_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, Cell2CaPools)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cell2CaPools.subclass:
            return Cell2CaPools.subclass(*args_, **kwargs_)
        else:
            return Cell2CaPools(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.biophysical_properties2_ca_pools is not None
            or super(Cell2CaPools, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Cell2CaPools",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Cell2CaPools")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Cell2CaPools":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Cell2CaPools"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Cell2CaPools",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Cell2CaPools",
    ):
        super(Cell2CaPools, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="Cell2CaPools"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="Cell2CaPools",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Cell2CaPools, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.biophysical_properties2_ca_pools is not None:
            namespaceprefix_ = (
                self.biophysical_properties2_ca_pools_nsprefix_ + ":"
                if (UseCapturedNS_ and self.biophysical_properties2_ca_pools_nsprefix_)
                else ""
            )
            self.biophysical_properties2_ca_pools.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="biophysicalProperties2CaPools",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.biophysical_properties2_ca_pools,
            "biophysical_properties2_ca_pools",
            min_occurs=0,
            max_occurs=1,
        )
        if recursive:
            if self.biophysical_properties2_ca_pools is not None:
                self.biophysical_properties2_ca_pools.validate_(
                    gds_collector, recursive=True
                )
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(Cell2CaPools, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "biophysicalProperties2CaPools":
            obj_ = BiophysicalProperties2CaPools.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.biophysical_properties2_ca_pools = obj_
            obj_.original_tagname_ = "biophysicalProperties2CaPools"
        super(Cell2CaPools, self)._buildChildren(child_, node, nodeName_, True)


# end class Cell2CaPools


class AdExIaFCell(BaseCellMembPotCap):
    """AdExIaFCell -- Model based on Brette R and Gerstner W ( 2005 ) Adaptive Exponential Integrate-and-Fire Model as an Effective Description of Neuronal Activity. J Neurophysiol 94:3637-3642
    \n
    :param gL:
    :type gL: conductance
    :param EL:
    :type EL: voltage
    :param VT:
    :type VT: voltage
    :param thresh:
    :type thresh: voltage
    :param reset:
    :type reset: voltage
    :param delT:
    :type delT: voltage
    :param tauw:
    :type tauw: time
    :param refract:
    :type refract: time
    :param a:
    :type a: conductance
    :param b:
    :type b: current
    :param C: Total capacitance of the cell membrane
    :type C: capacitance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "g_l", "Nml2Quantity_conductance", 0, 0, {"use": "required", "name": "g_l"}
        ),
        MemberSpec_(
            "EL", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "EL"}
        ),
        MemberSpec_(
            "reset", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "reset"}
        ),
        MemberSpec_(
            "VT", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "VT"}
        ),
        MemberSpec_(
            "thresh",
            "Nml2Quantity_voltage",
            0,
            0,
            {"use": "required", "name": "thresh"},
        ),
        MemberSpec_(
            "del_t", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "del_t"}
        ),
        MemberSpec_(
            "tauw", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "tauw"}
        ),
        MemberSpec_(
            "refract", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "refract"}
        ),
        MemberSpec_(
            "a", "Nml2Quantity_conductance", 0, 0, {"use": "required", "name": "a"}
        ),
        MemberSpec_(
            "b", "Nml2Quantity_current", 0, 0, {"use": "required", "name": "b"}
        ),
    ]
    subclass = None
    superclass = BaseCellMembPotCap

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        C: "a Nml2Quantity_capacitance (required)" = None,
        g_l: "a Nml2Quantity_conductance (required)" = None,
        EL: "a Nml2Quantity_voltage (required)" = None,
        reset: "a Nml2Quantity_voltage (required)" = None,
        VT: "a Nml2Quantity_voltage (required)" = None,
        thresh: "a Nml2Quantity_voltage (required)" = None,
        del_t: "a Nml2Quantity_voltage (required)" = None,
        tauw: "a Nml2Quantity_time (required)" = None,
        refract: "a Nml2Quantity_time (required)" = None,
        a: "a Nml2Quantity_conductance (required)" = None,
        b: "a Nml2Quantity_current (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("AdExIaFCell"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, C, **kwargs_
        )
        self.g_l = _cast(None, g_l)
        self.g_l_nsprefix_ = None
        self.EL = _cast(None, EL)
        self.EL_nsprefix_ = None
        self.reset = _cast(None, reset)
        self.reset_nsprefix_ = None
        self.VT = _cast(None, VT)
        self.VT_nsprefix_ = None
        self.thresh = _cast(None, thresh)
        self.thresh_nsprefix_ = None
        self.del_t = _cast(None, del_t)
        self.del_t_nsprefix_ = None
        self.tauw = _cast(None, tauw)
        self.tauw_nsprefix_ = None
        self.refract = _cast(None, refract)
        self.refract_nsprefix_ = None
        self.a = _cast(None, a)
        self.a_nsprefix_ = None
        self.b = _cast(None, b)
        self.b_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AdExIaFCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdExIaFCell.subclass:
            return AdExIaFCell.subclass(*args_, **kwargs_)
        else:
            return AdExIaFCell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductance_patterns_,
                    )
                )

    validate_Nml2Quantity_conductance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$"]
    ]

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_current_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_current_patterns_,
                    )
                )

    validate_Nml2Quantity_current_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A|uA|nA|pA))$"]
    ]

    def _hasContent(self):
        if super(AdExIaFCell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AdExIaFCell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AdExIaFCell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AdExIaFCell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="AdExIaFCell"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AdExIaFCell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AdExIaFCell",
    ):
        super(AdExIaFCell, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="AdExIaFCell"
        )
        if self.g_l is not None and "g_l" not in already_processed:
            already_processed.add("g_l")
            outfile.write(
                " gL=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.g_l), input_name="gL")
                    ),
                )
            )
        if self.EL is not None and "EL" not in already_processed:
            already_processed.add("EL")
            outfile.write(
                " EL=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.EL), input_name="EL")
                    ),
                )
            )
        if self.reset is not None and "reset" not in already_processed:
            already_processed.add("reset")
            outfile.write(
                " reset=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.reset), input_name="reset"
                        )
                    ),
                )
            )
        if self.VT is not None and "VT" not in already_processed:
            already_processed.add("VT")
            outfile.write(
                " VT=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.VT), input_name="VT")
                    ),
                )
            )
        if self.thresh is not None and "thresh" not in already_processed:
            already_processed.add("thresh")
            outfile.write(
                " thresh=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.thresh), input_name="thresh"
                        )
                    ),
                )
            )
        if self.del_t is not None and "del_t" not in already_processed:
            already_processed.add("del_t")
            outfile.write(
                " delT=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.del_t), input_name="delT"
                        )
                    ),
                )
            )
        if self.tauw is not None and "tauw" not in already_processed:
            already_processed.add("tauw")
            outfile.write(
                " tauw=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.tauw), input_name="tauw"
                        )
                    ),
                )
            )
        if self.refract is not None and "refract" not in already_processed:
            already_processed.add("refract")
            outfile.write(
                " refract=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.refract), input_name="refract"
                        )
                    ),
                )
            )
        if self.a is not None and "a" not in already_processed:
            already_processed.add("a")
            outfile.write(
                " a=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.a), input_name="a")
                    ),
                )
            )
        if self.b is not None and "b" not in already_processed:
            already_processed.add("b")
            outfile.write(
                " b=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.b), input_name="b")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AdExIaFCell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(AdExIaFCell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductance, self.g_l, "g_l"
        )
        self.gds_check_cardinality_(self.g_l, "g_l", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_voltage, self.EL, "EL")
        self.gds_check_cardinality_(self.EL, "EL", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.reset, "reset"
        )
        self.gds_check_cardinality_(self.reset, "reset", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_voltage, self.VT, "VT")
        self.gds_check_cardinality_(self.VT, "VT", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.thresh, "thresh"
        )
        self.gds_check_cardinality_(self.thresh, "thresh", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.del_t, "del_t"
        )
        self.gds_check_cardinality_(self.del_t, "del_t", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.tauw, "tauw"
        )
        self.gds_check_cardinality_(self.tauw, "tauw", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.refract, "refract"
        )
        self.gds_check_cardinality_(self.refract, "refract", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductance, self.a, "a"
        )
        self.gds_check_cardinality_(self.a, "a", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_current, self.b, "b")
        self.gds_check_cardinality_(self.b, "b", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("gL", node)
        if value is not None and "gL" not in already_processed:
            already_processed.add("gL")
            self.g_l = value
            self.validate_Nml2Quantity_conductance(
                self.g_l
            )  # validate type Nml2Quantity_conductance
        value = find_attr_value_("EL", node)
        if value is not None and "EL" not in already_processed:
            already_processed.add("EL")
            self.EL = value
            self.validate_Nml2Quantity_voltage(
                self.EL
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("reset", node)
        if value is not None and "reset" not in already_processed:
            already_processed.add("reset")
            self.reset = value
            self.validate_Nml2Quantity_voltage(
                self.reset
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("VT", node)
        if value is not None and "VT" not in already_processed:
            already_processed.add("VT")
            self.VT = value
            self.validate_Nml2Quantity_voltage(
                self.VT
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("thresh", node)
        if value is not None and "thresh" not in already_processed:
            already_processed.add("thresh")
            self.thresh = value
            self.validate_Nml2Quantity_voltage(
                self.thresh
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("delT", node)
        if value is not None and "delT" not in already_processed:
            already_processed.add("delT")
            self.del_t = value
            self.validate_Nml2Quantity_voltage(
                self.del_t
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("tauw", node)
        if value is not None and "tauw" not in already_processed:
            already_processed.add("tauw")
            self.tauw = value
            self.validate_Nml2Quantity_time(
                self.tauw
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("refract", node)
        if value is not None and "refract" not in already_processed:
            already_processed.add("refract")
            self.refract = value
            self.validate_Nml2Quantity_time(
                self.refract
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("a", node)
        if value is not None and "a" not in already_processed:
            already_processed.add("a")
            self.a = value
            self.validate_Nml2Quantity_conductance(
                self.a
            )  # validate type Nml2Quantity_conductance
        value = find_attr_value_("b", node)
        if value is not None and "b" not in already_processed:
            already_processed.add("b")
            self.b = value
            self.validate_Nml2Quantity_current(
                self.b
            )  # validate type Nml2Quantity_current
        super(AdExIaFCell, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(AdExIaFCell, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class AdExIaFCell


class Izhikevich2007Cell(BaseCellMembPotCap):
    """Izhikevich2007Cell -- Cell based on the modified Izhikevich model in Izhikevich 2007, Dynamical systems in neuroscience, MIT Press
    \n
    :param v0:
    :type v0: voltage
    :param k:
    :type k: conductance_per_voltage
    :param vr:
    :type vr: voltage
    :param vt:
    :type vt: voltage
    :param vpeak:
    :type vpeak: voltage
    :param a:
    :type a: per_time
    :param b:
    :type b: conductance
    :param c:
    :type c: voltage
    :param d:
    :type d: current
    :param C: Total capacitance of the cell membrane
    :type C: capacitance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "v0", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "v0"}
        ),
        MemberSpec_(
            "k",
            "Nml2Quantity_conductancePerVoltage",
            0,
            0,
            {"use": "required", "name": "k"},
        ),
        MemberSpec_(
            "vr", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "vr"}
        ),
        MemberSpec_(
            "vt", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "vt"}
        ),
        MemberSpec_(
            "vpeak", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "vpeak"}
        ),
        MemberSpec_(
            "a", "Nml2Quantity_pertime", 0, 0, {"use": "required", "name": "a"}
        ),
        MemberSpec_(
            "b", "Nml2Quantity_conductance", 0, 0, {"use": "required", "name": "b"}
        ),
        MemberSpec_(
            "c", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "c"}
        ),
        MemberSpec_(
            "d", "Nml2Quantity_current", 0, 0, {"use": "required", "name": "d"}
        ),
    ]
    subclass = None
    superclass = BaseCellMembPotCap

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        C: "a Nml2Quantity_capacitance (required)" = None,
        v0: "a Nml2Quantity_voltage (required)" = None,
        k: "a Nml2Quantity_conductancePerVoltage (required)" = None,
        vr: "a Nml2Quantity_voltage (required)" = None,
        vt: "a Nml2Quantity_voltage (required)" = None,
        vpeak: "a Nml2Quantity_voltage (required)" = None,
        a: "a Nml2Quantity_pertime (required)" = None,
        b: "a Nml2Quantity_conductance (required)" = None,
        c: "a Nml2Quantity_voltage (required)" = None,
        d: "a Nml2Quantity_current (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("Izhikevich2007Cell"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, C, **kwargs_
        )
        self.v0 = _cast(None, v0)
        self.v0_nsprefix_ = None
        self.k = _cast(None, k)
        self.k_nsprefix_ = None
        self.vr = _cast(None, vr)
        self.vr_nsprefix_ = None
        self.vt = _cast(None, vt)
        self.vt_nsprefix_ = None
        self.vpeak = _cast(None, vpeak)
        self.vpeak_nsprefix_ = None
        self.a = _cast(None, a)
        self.a_nsprefix_ = None
        self.b = _cast(None, b)
        self.b_nsprefix_ = None
        self.c = _cast(None, c)
        self.c_nsprefix_ = None
        self.d = _cast(None, d)
        self.d_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Izhikevich2007Cell
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Izhikevich2007Cell.subclass:
            return Izhikevich2007Cell.subclass(*args_, **kwargs_)
        else:
            return Izhikevich2007Cell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def validate_Nml2Quantity_conductancePerVoltage(self, value):
        # Validate type Nml2Quantity_conductancePerVoltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductancePerVoltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductancePerVoltage_patterns_,
                    )
                )

    validate_Nml2Quantity_conductancePerVoltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S_per_V|nS_per_mV))$"]
    ]

    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_pertime_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_pertime_patterns_,
                    )
                )

    validate_Nml2Quantity_pertime_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$"]
    ]

    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductance_patterns_,
                    )
                )

    validate_Nml2Quantity_conductance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$"]
    ]

    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_current_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_current_patterns_,
                    )
                )

    validate_Nml2Quantity_current_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A|uA|nA|pA))$"]
    ]

    def _hasContent(self):
        if super(Izhikevich2007Cell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Izhikevich2007Cell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("Izhikevich2007Cell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "Izhikevich2007Cell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="Izhikevich2007Cell",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="Izhikevich2007Cell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="Izhikevich2007Cell",
    ):
        super(Izhikevich2007Cell, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="Izhikevich2007Cell",
        )
        if self.v0 is not None and "v0" not in already_processed:
            already_processed.add("v0")
            outfile.write(
                " v0=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.v0), input_name="v0")
                    ),
                )
            )
        if self.k is not None and "k" not in already_processed:
            already_processed.add("k")
            outfile.write(
                " k=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.k), input_name="k")
                    ),
                )
            )
        if self.vr is not None and "vr" not in already_processed:
            already_processed.add("vr")
            outfile.write(
                " vr=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.vr), input_name="vr")
                    ),
                )
            )
        if self.vt is not None and "vt" not in already_processed:
            already_processed.add("vt")
            outfile.write(
                " vt=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.vt), input_name="vt")
                    ),
                )
            )
        if self.vpeak is not None and "vpeak" not in already_processed:
            already_processed.add("vpeak")
            outfile.write(
                " vpeak=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.vpeak), input_name="vpeak"
                        )
                    ),
                )
            )
        if self.a is not None and "a" not in already_processed:
            already_processed.add("a")
            outfile.write(
                " a=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.a), input_name="a")
                    ),
                )
            )
        if self.b is not None and "b" not in already_processed:
            already_processed.add("b")
            outfile.write(
                " b=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.b), input_name="b")
                    ),
                )
            )
        if self.c is not None and "c" not in already_processed:
            already_processed.add("c")
            outfile.write(
                " c=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.c), input_name="c")
                    ),
                )
            )
        if self.d is not None and "d" not in already_processed:
            already_processed.add("d")
            outfile.write(
                " d=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.d), input_name="d")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="Izhikevich2007Cell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(Izhikevich2007Cell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_voltage, self.v0, "v0")
        self.gds_check_cardinality_(self.v0, "v0", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductancePerVoltage, self.k, "k"
        )
        self.gds_check_cardinality_(self.k, "k", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_voltage, self.vr, "vr")
        self.gds_check_cardinality_(self.vr, "vr", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_voltage, self.vt, "vt")
        self.gds_check_cardinality_(self.vt, "vt", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.vpeak, "vpeak"
        )
        self.gds_check_cardinality_(self.vpeak, "vpeak", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_pertime, self.a, "a")
        self.gds_check_cardinality_(self.a, "a", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductance, self.b, "b"
        )
        self.gds_check_cardinality_(self.b, "b", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_voltage, self.c, "c")
        self.gds_check_cardinality_(self.c, "c", required=True)
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_current, self.d, "d")
        self.gds_check_cardinality_(self.d, "d", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("v0", node)
        if value is not None and "v0" not in already_processed:
            already_processed.add("v0")
            self.v0 = value
            self.validate_Nml2Quantity_voltage(
                self.v0
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("k", node)
        if value is not None and "k" not in already_processed:
            already_processed.add("k")
            self.k = value
            self.validate_Nml2Quantity_conductancePerVoltage(
                self.k
            )  # validate type Nml2Quantity_conductancePerVoltage
        value = find_attr_value_("vr", node)
        if value is not None and "vr" not in already_processed:
            already_processed.add("vr")
            self.vr = value
            self.validate_Nml2Quantity_voltage(
                self.vr
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("vt", node)
        if value is not None and "vt" not in already_processed:
            already_processed.add("vt")
            self.vt = value
            self.validate_Nml2Quantity_voltage(
                self.vt
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("vpeak", node)
        if value is not None and "vpeak" not in already_processed:
            already_processed.add("vpeak")
            self.vpeak = value
            self.validate_Nml2Quantity_voltage(
                self.vpeak
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("a", node)
        if value is not None and "a" not in already_processed:
            already_processed.add("a")
            self.a = value
            self.validate_Nml2Quantity_pertime(
                self.a
            )  # validate type Nml2Quantity_pertime
        value = find_attr_value_("b", node)
        if value is not None and "b" not in already_processed:
            already_processed.add("b")
            self.b = value
            self.validate_Nml2Quantity_conductance(
                self.b
            )  # validate type Nml2Quantity_conductance
        value = find_attr_value_("c", node)
        if value is not None and "c" not in already_processed:
            already_processed.add("c")
            self.c = value
            self.validate_Nml2Quantity_voltage(
                self.c
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("d", node)
        if value is not None and "d" not in already_processed:
            already_processed.add("d")
            self.d = value
            self.validate_Nml2Quantity_current(
                self.d
            )  # validate type Nml2Quantity_current
        super(Izhikevich2007Cell, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(Izhikevich2007Cell, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class Izhikevich2007Cell


class IafRefCell(IafCell):
    """IafRefCell -- Integrate and fire cell with capacitance **C,**  **leakConductance,**  **leakReversal**  and refractory period **refract**
    \n
    :param refract:
    :type refract: time
    :param leakConductance:
    :type leakConductance: conductance
    :param leakReversal:
    :type leakReversal: voltage
    :param thresh:
    :type thresh: voltage
    :param reset:
    :type reset: voltage
    :param C: Total capacitance of the cell membrane
    :type C: capacitance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "refract", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "refract"}
        ),
    ]
    subclass = None
    superclass = IafCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        leak_reversal: "a Nml2Quantity_voltage (required)" = None,
        thresh: "a Nml2Quantity_voltage (required)" = None,
        reset: "a Nml2Quantity_voltage (required)" = None,
        C: "a Nml2Quantity_capacitance (required)" = None,
        leak_conductance: "a Nml2Quantity_conductance (required)" = None,
        refract: "a Nml2Quantity_time (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IafRefCell"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            leak_reversal,
            thresh,
            reset,
            C,
            leak_conductance,
            **kwargs_,
        )
        self.refract = _cast(None, refract)
        self.refract_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IafRefCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IafRefCell.subclass:
            return IafRefCell.subclass(*args_, **kwargs_)
        else:
            return IafRefCell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(IafRefCell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IafRefCell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IafRefCell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IafRefCell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IafRefCell"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IafRefCell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix_="", name_="IafRefCell"
    ):
        super(IafRefCell, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IafRefCell"
        )
        if self.refract is not None and "refract" not in already_processed:
            already_processed.add("refract")
            outfile.write(
                " refract=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.refract), input_name="refract"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IafRefCell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IafRefCell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.refract, "refract"
        )
        self.gds_check_cardinality_(self.refract, "refract", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("refract", node)
        if value is not None and "refract" not in already_processed:
            already_processed.add("refract")
            self.refract = value
            self.validate_Nml2Quantity_time(
                self.refract
            )  # validate type Nml2Quantity_time
        super(IafRefCell, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(IafRefCell, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class IafRefCell


class IafTauRefCell(IafTauCell):
    """IafTauRefCell -- Integrate and fire cell which returns to its leak reversal potential of **leakReversal**  with a time course **tau.**  It has a refractory period of **refract**  after spiking
    \n
    :param refract:
    :type refract: time
    :param leakReversal:
    :type leakReversal: voltage
    :param tau:
    :type tau: time
    :param thresh: The membrane potential at which to emit a spiking event and reset voltage
    :type thresh: voltage
    :param reset: The value the membrane potential is reset to on spiking
    :type reset: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "refract", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "refract"}
        ),
    ]
    subclass = None
    superclass = IafTauCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        leak_reversal: "a Nml2Quantity_voltage (required)" = None,
        thresh: "a Nml2Quantity_voltage (required)" = None,
        reset: "a Nml2Quantity_voltage (required)" = None,
        tau: "a Nml2Quantity_time (required)" = None,
        refract: "a Nml2Quantity_time (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IafTauRefCell"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            leak_reversal,
            thresh,
            reset,
            tau,
            **kwargs_,
        )
        self.refract = _cast(None, refract)
        self.refract_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IafTauRefCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IafTauRefCell.subclass:
            return IafTauRefCell.subclass(*args_, **kwargs_)
        else:
            return IafTauRefCell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(IafTauRefCell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IafTauRefCell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IafTauRefCell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IafTauRefCell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IafTauRefCell"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IafTauRefCell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="IafTauRefCell",
    ):
        super(IafTauRefCell, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IafTauRefCell"
        )
        if self.refract is not None and "refract" not in already_processed:
            already_processed.add("refract")
            outfile.write(
                " refract=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.refract), input_name="refract"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IafTauRefCell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IafTauRefCell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.refract, "refract"
        )
        self.gds_check_cardinality_(self.refract, "refract", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("refract", node)
        if value is not None and "refract" not in already_processed:
            already_processed.add("refract")
            self.refract = value
            self.validate_Nml2Quantity_time(
                self.refract
            )  # validate type Nml2Quantity_time
        super(IafTauRefCell, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(IafTauRefCell, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class IafTauRefCell


class DoubleSynapse(BaseVoltageDepSynapse):
    """DoubleSynapse -- Synapse consisting of two independent synaptic mechanisms ( e. g. AMPA-R and NMDA-R ), which can be easily colocated in connections"""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("synapse1", "NmlId", 0, 0, {"use": "required", "name": "synapse1"}),
        MemberSpec_("synapse2", "NmlId", 0, 0, {"use": "required", "name": "synapse2"}),
        MemberSpec_(
            "synapse1_path",
            "xs:string",
            0,
            0,
            {"use": "required", "name": "synapse1_path"},
        ),
        MemberSpec_(
            "synapse2_path",
            "xs:string",
            0,
            0,
            {"use": "required", "name": "synapse2_path"},
        ),
    ]
    subclass = None
    superclass = BaseVoltageDepSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        synapse1: "a NmlId (required)" = None,
        synapse2: "a NmlId (required)" = None,
        synapse1_path: "a string (required)" = None,
        synapse2_path: "a string (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("DoubleSynapse"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, **kwargs_
        )
        self.synapse1 = _cast(None, synapse1)
        self.synapse1_nsprefix_ = None
        self.synapse2 = _cast(None, synapse2)
        self.synapse2_nsprefix_ = None
        self.synapse1_path = _cast(None, synapse1_path)
        self.synapse1_path_nsprefix_ = None
        self.synapse2_path = _cast(None, synapse2_path)
        self.synapse2_path_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, DoubleSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoubleSynapse.subclass:
            return DoubleSynapse.subclass(*args_, **kwargs_)
        else:
            return DoubleSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_NmlId_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_NmlId_patterns_,
                    )
                )

    validate_NmlId_patterns_ = [["^([a-zA-Z_][a-zA-Z0-9_]*)$"]]

    def _hasContent(self):
        if super(DoubleSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DoubleSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("DoubleSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "DoubleSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="DoubleSynapse"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="DoubleSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="DoubleSynapse",
    ):
        super(DoubleSynapse, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="DoubleSynapse"
        )
        if self.synapse1 is not None and "synapse1" not in already_processed:
            already_processed.add("synapse1")
            outfile.write(
                " synapse1=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.synapse1), input_name="synapse1"
                        )
                    ),
                )
            )
        if self.synapse2 is not None and "synapse2" not in already_processed:
            already_processed.add("synapse2")
            outfile.write(
                " synapse2=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.synapse2), input_name="synapse2"
                        )
                    ),
                )
            )
        if self.synapse1_path is not None and "synapse1_path" not in already_processed:
            already_processed.add("synapse1_path")
            outfile.write(
                " synapse1Path=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.synapse1_path), input_name="synapse1Path"
                        )
                    ),
                )
            )
        if self.synapse2_path is not None and "synapse2_path" not in already_processed:
            already_processed.add("synapse2_path")
            outfile.write(
                " synapse2Path=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.synapse2_path), input_name="synapse2Path"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="DoubleSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(DoubleSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_NmlId, self.synapse1, "synapse1")
        self.gds_check_cardinality_(self.synapse1, "synapse1", required=True)
        self.gds_validate_defined_ST_(self.validate_NmlId, self.synapse2, "synapse2")
        self.gds_check_cardinality_(self.synapse2, "synapse2", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.synapse1_path, "synapse1_path"
        )
        self.gds_check_cardinality_(self.synapse1_path, "synapse1_path", required=True)
        self.gds_validate_builtin_ST_(
            self.gds_validate_string, self.synapse2_path, "synapse2_path"
        )
        self.gds_check_cardinality_(self.synapse2_path, "synapse2_path", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("synapse1", node)
        if value is not None and "synapse1" not in already_processed:
            already_processed.add("synapse1")
            self.synapse1 = value
            self.validate_NmlId(self.synapse1)  # validate type NmlId
        value = find_attr_value_("synapse2", node)
        if value is not None and "synapse2" not in already_processed:
            already_processed.add("synapse2")
            self.synapse2 = value
            self.validate_NmlId(self.synapse2)  # validate type NmlId
        value = find_attr_value_("synapse1Path", node)
        if value is not None and "synapse1Path" not in already_processed:
            already_processed.add("synapse1Path")
            self.synapse1_path = value
        value = find_attr_value_("synapse2Path", node)
        if value is not None and "synapse2Path" not in already_processed:
            already_processed.add("synapse2Path")
            self.synapse2_path = value
        super(DoubleSynapse, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(DoubleSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class DoubleSynapse


class AlphaCurrentSynapse(BaseCurrentBasedSynapse):
    """AlphaCurrentSynapse -- Alpha current synapse: rise time and decay time are both **tau.**
    \n
    :param tau: Time course for rise and decay
    :type tau: time
    :param ibase: Baseline current increase after receiving a spike
    :type ibase: current

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "tau", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "tau"}
        ),
        MemberSpec_(
            "ibase", "Nml2Quantity_current", 0, 0, {"use": "required", "name": "ibase"}
        ),
    ]
    subclass = None
    superclass = BaseCurrentBasedSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        tau: "a Nml2Quantity_time (required)" = None,
        ibase: "a Nml2Quantity_current (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("AlphaCurrentSynapse"), self).__init__(
            id, metaid, notes, properties, annotation, neuro_lex_id, **kwargs_
        )
        self.tau = _cast(None, tau)
        self.tau_nsprefix_ = None
        self.ibase = _cast(None, ibase)
        self.ibase_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlphaCurrentSynapse
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlphaCurrentSynapse.subclass:
            return AlphaCurrentSynapse.subclass(*args_, **kwargs_)
        else:
            return AlphaCurrentSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_current_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_current_patterns_,
                    )
                )

    validate_Nml2Quantity_current_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A|uA|nA|pA))$"]
    ]

    def _hasContent(self):
        if super(AlphaCurrentSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AlphaCurrentSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AlphaCurrentSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AlphaCurrentSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AlphaCurrentSynapse",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AlphaCurrentSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AlphaCurrentSynapse",
    ):
        super(AlphaCurrentSynapse, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="AlphaCurrentSynapse",
        )
        if self.tau is not None and "tau" not in already_processed:
            already_processed.add("tau")
            outfile.write(
                " tau=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.tau), input_name="tau")
                    ),
                )
            )
        if self.ibase is not None and "ibase" not in already_processed:
            already_processed.add("ibase")
            outfile.write(
                " ibase=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.ibase), input_name="ibase"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AlphaCurrentSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(AlphaCurrentSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_time, self.tau, "tau")
        self.gds_check_cardinality_(self.tau, "tau", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_current, self.ibase, "ibase"
        )
        self.gds_check_cardinality_(self.ibase, "ibase", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("tau", node)
        if value is not None and "tau" not in already_processed:
            already_processed.add("tau")
            self.tau = value
            self.validate_Nml2Quantity_time(self.tau)  # validate type Nml2Quantity_time
        value = find_attr_value_("ibase", node)
        if value is not None and "ibase" not in already_processed:
            already_processed.add("ibase")
            self.ibase = value
            self.validate_Nml2Quantity_current(
                self.ibase
            )  # validate type Nml2Quantity_current
        super(AlphaCurrentSynapse, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(AlphaCurrentSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class AlphaCurrentSynapse


class BaseConductanceBasedSynapseTwo(BaseVoltageDepSynapse):
    """BaseConductanceBasedSynapseTwo -- Synapse model suited for a sum of two expTwoSynapses which exposes a conductance **g**  in addition to producing a current. Not necessarily ohmic!! cno_0000027
    \n
    :param gbase1: Baseline conductance 1
    :type gbase1: conductance
    :param gbase2: Baseline conductance 2
    :type gbase2: conductance
    :param erev: Reversal potential of the synapse
    :type erev: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "gbase1",
            "Nml2Quantity_conductance",
            0,
            0,
            {"use": "required", "name": "gbase1"},
        ),
        MemberSpec_(
            "gbase2",
            "Nml2Quantity_conductance",
            0,
            0,
            {"use": "required", "name": "gbase2"},
        ),
        MemberSpec_(
            "erev", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "erev"}
        ),
    ]
    subclass = None
    superclass = BaseVoltageDepSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        gbase1: "a Nml2Quantity_conductance (required)" = None,
        gbase2: "a Nml2Quantity_conductance (required)" = None,
        erev: "a Nml2Quantity_voltage (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BaseConductanceBasedSynapseTwo"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            extensiontype_,
            **kwargs_,
        )
        self.gbase1 = _cast(None, gbase1)
        self.gbase1_nsprefix_ = None
        self.gbase2 = _cast(None, gbase2)
        self.gbase2_nsprefix_ = None
        self.erev = _cast(None, erev)
        self.erev_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseConductanceBasedSynapseTwo
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseConductanceBasedSynapseTwo.subclass:
            return BaseConductanceBasedSynapseTwo.subclass(*args_, **kwargs_)
        else:
            return BaseConductanceBasedSynapseTwo(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductance_patterns_,
                    )
                )

    validate_Nml2Quantity_conductance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$"]
    ]

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def _hasContent(self):
        if super(BaseConductanceBasedSynapseTwo, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseConductanceBasedSynapseTwo",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get(
            "BaseConductanceBasedSynapseTwo"
        )
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "BaseConductanceBasedSynapseTwo"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseConductanceBasedSynapseTwo",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BaseConductanceBasedSynapseTwo",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BaseConductanceBasedSynapseTwo",
    ):
        super(BaseConductanceBasedSynapseTwo, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseConductanceBasedSynapseTwo",
        )
        if self.gbase1 is not None and "gbase1" not in already_processed:
            already_processed.add("gbase1")
            outfile.write(
                " gbase1=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.gbase1), input_name="gbase1"
                        )
                    ),
                )
            )
        if self.gbase2 is not None and "gbase2" not in already_processed:
            already_processed.add("gbase2")
            outfile.write(
                " gbase2=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.gbase2), input_name="gbase2"
                        )
                    ),
                )
            )
        if self.erev is not None and "erev" not in already_processed:
            already_processed.add("erev")
            outfile.write(
                " erev=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.erev), input_name="erev"
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseConductanceBasedSynapseTwo",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BaseConductanceBasedSynapseTwo, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductance, self.gbase1, "gbase1"
        )
        self.gds_check_cardinality_(self.gbase1, "gbase1", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductance, self.gbase2, "gbase2"
        )
        self.gds_check_cardinality_(self.gbase2, "gbase2", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.erev, "erev"
        )
        self.gds_check_cardinality_(self.erev, "erev", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("gbase1", node)
        if value is not None and "gbase1" not in already_processed:
            already_processed.add("gbase1")
            self.gbase1 = value
            self.validate_Nml2Quantity_conductance(
                self.gbase1
            )  # validate type Nml2Quantity_conductance
        value = find_attr_value_("gbase2", node)
        if value is not None and "gbase2" not in already_processed:
            already_processed.add("gbase2")
            self.gbase2 = value
            self.validate_Nml2Quantity_conductance(
                self.gbase2
            )  # validate type Nml2Quantity_conductance
        value = find_attr_value_("erev", node)
        if value is not None and "erev" not in already_processed:
            already_processed.add("erev")
            self.erev = value
            self.validate_Nml2Quantity_voltage(
                self.erev
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(BaseConductanceBasedSynapseTwo, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BaseConductanceBasedSynapseTwo, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class BaseConductanceBasedSynapseTwo


class BaseConductanceBasedSynapse(BaseVoltageDepSynapse):
    """BaseConductanceBasedSynapse -- Synapse model which exposes a conductance **g**  in addition to producing a current. Not necessarily ohmic!! cno_0000027
    \n
    :param gbase: Baseline conductance, generally the maximum conductance following a single spike
    :type gbase: conductance
    :param erev: Reversal potential of the synapse
    :type erev: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "gbase",
            "Nml2Quantity_conductance",
            0,
            0,
            {"use": "required", "name": "gbase"},
        ),
        MemberSpec_(
            "erev", "Nml2Quantity_voltage", 0, 0, {"use": "required", "name": "erev"}
        ),
    ]
    subclass = None
    superclass = BaseVoltageDepSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        gbase: "a Nml2Quantity_conductance (required)" = None,
        erev: "a Nml2Quantity_voltage (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BaseConductanceBasedSynapse"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            extensiontype_,
            **kwargs_,
        )
        self.gbase = _cast(None, gbase)
        self.gbase_nsprefix_ = None
        self.erev = _cast(None, erev)
        self.erev_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseConductanceBasedSynapse
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseConductanceBasedSynapse.subclass:
            return BaseConductanceBasedSynapse.subclass(*args_, **kwargs_)
        else:
            return BaseConductanceBasedSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_conductance_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_conductance_patterns_,
                    )
                )

    validate_Nml2Quantity_conductance_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$"]
    ]

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def _hasContent(self):
        if super(BaseConductanceBasedSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseConductanceBasedSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BaseConductanceBasedSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "BaseConductanceBasedSynapse"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseConductanceBasedSynapse",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BaseConductanceBasedSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BaseConductanceBasedSynapse",
    ):
        super(BaseConductanceBasedSynapse, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BaseConductanceBasedSynapse",
        )
        if self.gbase is not None and "gbase" not in already_processed:
            already_processed.add("gbase")
            outfile.write(
                " gbase=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.gbase), input_name="gbase"
                        )
                    ),
                )
            )
        if self.erev is not None and "erev" not in already_processed:
            already_processed.add("erev")
            outfile.write(
                " erev=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.erev), input_name="erev"
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="BaseConductanceBasedSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BaseConductanceBasedSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_conductance, self.gbase, "gbase"
        )
        self.gds_check_cardinality_(self.gbase, "gbase", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.erev, "erev"
        )
        self.gds_check_cardinality_(self.erev, "erev", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("gbase", node)
        if value is not None and "gbase" not in already_processed:
            already_processed.add("gbase")
            self.gbase = value
            self.validate_Nml2Quantity_conductance(
                self.gbase
            )  # validate type Nml2Quantity_conductance
        value = find_attr_value_("erev", node)
        if value is not None and "erev" not in already_processed:
            already_processed.add("erev")
            self.erev = value
            self.validate_Nml2Quantity_voltage(
                self.erev
            )  # validate type Nml2Quantity_voltage
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(BaseConductanceBasedSynapse, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(BaseConductanceBasedSynapse, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class BaseConductanceBasedSynapse


class IonChannelVShift(IonChannel):
    """IonChannelVShift -- Same as  **ionChannel** , but with a **vShift**  parameter to change voltage activation of gates. The exact usage of **vShift**  in expressions for rates is determined by the individual gates.
    \n
    :param vShift:
    :type vShift: voltage
    :param conductance:
    :type conductance: conductance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "v_shift",
            "Nml2Quantity_voltage",
            0,
            0,
            {"use": "required", "name": "v_shift"},
        ),
    ]
    subclass = None
    superclass = IonChannel

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        q10_conductance_scalings: "list of Q10ConductanceScaling(s) (optional)" = None,
        species: "a NmlId (optional)" = None,
        type: "a channelTypes (optional)" = None,
        conductance: "a Nml2Quantity_conductance (optional)" = None,
        gates: "list of GateHHUndetermined(s) (optional)" = None,
        gate_hh_rates: "list of GateHHRates(s) (optional)" = None,
        gate_h_hrates_taus: "list of GateHHRatesTau(s) (optional)" = None,
        gate_hh_tau_infs: "list of GateHHTauInf(s) (optional)" = None,
        gate_h_hrates_infs: "list of GateHHRatesInf(s) (optional)" = None,
        gate_h_hrates_tau_infs: "list of GateHHRatesTauInf(s) (optional)" = None,
        gate_hh_instantaneouses: "list of GateHHInstantaneous(s) (optional)" = None,
        gate_fractionals: "list of GateFractional(s) (optional)" = None,
        v_shift: "a Nml2Quantity_voltage (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IonChannelVShift"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            q10_conductance_scalings,
            species,
            type,
            conductance,
            gates,
            gate_hh_rates,
            gate_h_hrates_taus,
            gate_hh_tau_infs,
            gate_h_hrates_infs,
            gate_h_hrates_tau_infs,
            gate_hh_instantaneouses,
            gate_fractionals,
            **kwargs_,
        )
        self.v_shift = _cast(None, v_shift)
        self.v_shift_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IonChannelVShift)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IonChannelVShift.subclass:
            return IonChannelVShift.subclass(*args_, **kwargs_)
        else:
            return IonChannelVShift(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_voltage_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_voltage_patterns_,
                    )
                )

    validate_Nml2Quantity_voltage_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$"]
    ]

    def _hasContent(self):
        if super(IonChannelVShift, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IonChannelVShift",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IonChannelVShift")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IonChannelVShift":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="IonChannelVShift",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IonChannelVShift",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="IonChannelVShift",
    ):
        super(IonChannelVShift, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="IonChannelVShift",
        )
        if self.v_shift is not None and "v_shift" not in already_processed:
            already_processed.add("v_shift")
            outfile.write(
                " vShift=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.v_shift), input_name="vShift"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IonChannelVShift",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IonChannelVShift, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_voltage, self.v_shift, "v_shift"
        )
        self.gds_check_cardinality_(self.v_shift, "v_shift", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("vShift", node)
        if value is not None and "vShift" not in already_processed:
            already_processed.add("vShift")
            self.v_shift = value
            self.validate_Nml2Quantity_voltage(
                self.v_shift
            )  # validate type Nml2Quantity_voltage
        super(IonChannelVShift, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(IonChannelVShift, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class IonChannelVShift


class IonChannelHH(IonChannel):
    """IonChannelHH -- Note  **ionChannel**  and  **ionChannelHH**  are currently functionally identical. This is needed since many existing examples use ionChannel, some use ionChannelHH. NeuroML v2beta4 should remove one of these, probably ionChannelHH.
    \n
    :param conductance:
    :type conductance: conductance

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = IonChannel

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        q10_conductance_scalings: "list of Q10ConductanceScaling(s) (optional)" = None,
        species: "a NmlId (optional)" = None,
        type: "a channelTypes (optional)" = None,
        conductance: "a Nml2Quantity_conductance (optional)" = None,
        gates: "list of GateHHUndetermined(s) (optional)" = None,
        gate_hh_rates: "list of GateHHRates(s) (optional)" = None,
        gate_h_hrates_taus: "list of GateHHRatesTau(s) (optional)" = None,
        gate_hh_tau_infs: "list of GateHHTauInf(s) (optional)" = None,
        gate_h_hrates_infs: "list of GateHHRatesInf(s) (optional)" = None,
        gate_h_hrates_tau_infs: "list of GateHHRatesTauInf(s) (optional)" = None,
        gate_hh_instantaneouses: "list of GateHHInstantaneous(s) (optional)" = None,
        gate_fractionals: "list of GateFractional(s) (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IonChannelHH"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            q10_conductance_scalings,
            species,
            type,
            conductance,
            gates,
            gate_hh_rates,
            gate_h_hrates_taus,
            gate_hh_tau_infs,
            gate_h_hrates_infs,
            gate_h_hrates_tau_infs,
            gate_hh_instantaneouses,
            gate_fractionals,
            **kwargs_,
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IonChannelHH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IonChannelHH.subclass:
            return IonChannelHH.subclass(*args_, **kwargs_)
        else:
            return IonChannelHH(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(IonChannelHH, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IonChannelHH",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IonChannelHH")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IonChannelHH":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IonChannelHH"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IonChannelHH",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="IonChannelHH",
    ):
        super(IonChannelHH, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IonChannelHH"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IonChannelHH",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IonChannelHH, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(IonChannelHH, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(IonChannelHH, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class IonChannelHH


class IF_curr_exp(basePyNNIaFCell):
    """IF_curr_exp -- Leaky integrate and fire model with fixed threshold and decaying-exponential post-synaptic current
    \n
    :param tau_refrac:
    :type tau_refrac: none
    :param v_thresh:
    :type v_thresh: none
    :param tau_m:
    :type tau_m: none
    :param v_rest:
    :type v_rest: none
    :param v_reset:
    :type v_reset: none
    :param cm:
    :type cm: none
    :param i_offset:
    :type i_offset: none
    :param tau_syn_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_E: none
    :param tau_syn_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_I: none
    :param v_init:
    :type v_init: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = basePyNNIaFCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        cm: "a float (required)" = None,
        i_offset: "a float (required)" = None,
        tau_syn_E: "a float (required)" = None,
        tau_syn_I: "a float (required)" = None,
        v_init: "a float (required)" = None,
        tau_m: "a float (required)" = None,
        tau_refrac: "a float (required)" = None,
        v_reset: "a float (required)" = None,
        v_rest: "a float (required)" = None,
        v_thresh: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IF_curr_exp"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            cm,
            i_offset,
            tau_syn_E,
            tau_syn_I,
            v_init,
            tau_m,
            tau_refrac,
            v_reset,
            v_rest,
            v_thresh,
            **kwargs_,
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IF_curr_exp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IF_curr_exp.subclass:
            return IF_curr_exp.subclass(*args_, **kwargs_)
        else:
            return IF_curr_exp(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(IF_curr_exp, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IF_curr_exp",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IF_curr_exp")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IF_curr_exp":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IF_curr_exp"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IF_curr_exp",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="IF_curr_exp",
    ):
        super(IF_curr_exp, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IF_curr_exp"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IF_curr_exp",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IF_curr_exp, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(IF_curr_exp, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(IF_curr_exp, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class IF_curr_exp


class IF_curr_alpha(basePyNNIaFCell):
    """IF_curr_alpha -- Leaky integrate and fire model with fixed threshold and alpha-function-shaped post-synaptic current
    \n
    :param tau_refrac:
    :type tau_refrac: none
    :param v_thresh:
    :type v_thresh: none
    :param tau_m:
    :type tau_m: none
    :param v_rest:
    :type v_rest: none
    :param v_reset:
    :type v_reset: none
    :param cm:
    :type cm: none
    :param i_offset:
    :type i_offset: none
    :param tau_syn_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_E: none
    :param tau_syn_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_I: none
    :param v_init:
    :type v_init: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = basePyNNIaFCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        cm: "a float (required)" = None,
        i_offset: "a float (required)" = None,
        tau_syn_E: "a float (required)" = None,
        tau_syn_I: "a float (required)" = None,
        v_init: "a float (required)" = None,
        tau_m: "a float (required)" = None,
        tau_refrac: "a float (required)" = None,
        v_reset: "a float (required)" = None,
        v_rest: "a float (required)" = None,
        v_thresh: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IF_curr_alpha"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            cm,
            i_offset,
            tau_syn_E,
            tau_syn_I,
            v_init,
            tau_m,
            tau_refrac,
            v_reset,
            v_rest,
            v_thresh,
            **kwargs_,
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IF_curr_alpha)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IF_curr_alpha.subclass:
            return IF_curr_alpha.subclass(*args_, **kwargs_)
        else:
            return IF_curr_alpha(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(IF_curr_alpha, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IF_curr_alpha",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IF_curr_alpha")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IF_curr_alpha":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IF_curr_alpha"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IF_curr_alpha",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="IF_curr_alpha",
    ):
        super(IF_curr_alpha, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IF_curr_alpha"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IF_curr_alpha",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IF_curr_alpha, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(IF_curr_alpha, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(IF_curr_alpha, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class IF_curr_alpha


class basePyNNIaFCondCell(basePyNNIaFCell):
    """basePyNNIaFCondCell -- Base type of conductance based PyNN IaF cell models
    \n
    :param e_rev_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type e_rev_E: none
    :param e_rev_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type e_rev_I: none
    :param tau_refrac:
    :type tau_refrac: none
    :param v_thresh:
    :type v_thresh: none
    :param tau_m:
    :type tau_m: none
    :param v_rest:
    :type v_rest: none
    :param v_reset:
    :type v_reset: none
    :param cm:
    :type cm: none
    :param i_offset:
    :type i_offset: none
    :param tau_syn_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_E: none
    :param tau_syn_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_I: none
    :param v_init:
    :type v_init: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "e_rev_E", "xs:float", 0, 0, {"use": "required", "name": "e_rev_E"}
        ),
        MemberSpec_(
            "e_rev_I", "xs:float", 0, 0, {"use": "required", "name": "e_rev_I"}
        ),
    ]
    subclass = None
    superclass = basePyNNIaFCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        cm: "a float (required)" = None,
        i_offset: "a float (required)" = None,
        tau_syn_E: "a float (required)" = None,
        tau_syn_I: "a float (required)" = None,
        v_init: "a float (required)" = None,
        tau_m: "a float (required)" = None,
        tau_refrac: "a float (required)" = None,
        v_reset: "a float (required)" = None,
        v_rest: "a float (required)" = None,
        v_thresh: "a float (required)" = None,
        e_rev_E: "a float (required)" = None,
        e_rev_I: "a float (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("basePyNNIaFCondCell"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            cm,
            i_offset,
            tau_syn_E,
            tau_syn_I,
            v_init,
            tau_m,
            tau_refrac,
            v_reset,
            v_rest,
            v_thresh,
            extensiontype_,
            **kwargs_,
        )
        self.e_rev_E = _cast(float, e_rev_E)
        self.e_rev_E_nsprefix_ = None
        self.e_rev_I = _cast(float, e_rev_I)
        self.e_rev_I_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basePyNNIaFCondCell
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basePyNNIaFCondCell.subclass:
            return basePyNNIaFCondCell.subclass(*args_, **kwargs_)
        else:
            return basePyNNIaFCondCell(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(basePyNNIaFCondCell, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="basePyNNIaFCondCell",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("basePyNNIaFCondCell")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "basePyNNIaFCondCell":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="basePyNNIaFCondCell",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="basePyNNIaFCondCell",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="basePyNNIaFCondCell",
    ):
        super(basePyNNIaFCondCell, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="basePyNNIaFCondCell",
        )
        if self.e_rev_E is not None and "e_rev_E" not in already_processed:
            already_processed.add("e_rev_E")
            outfile.write(
                ' e_rev_E="%s"'
                % self.gds_format_float(self.e_rev_E, input_name="e_rev_E")
            )
        if self.e_rev_I is not None and "e_rev_I" not in already_processed:
            already_processed.add("e_rev_I")
            outfile.write(
                ' e_rev_I="%s"'
                % self.gds_format_float(self.e_rev_I, input_name="e_rev_I")
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="basePyNNIaFCondCell",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(basePyNNIaFCondCell, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.e_rev_E, "e_rev_E")
        self.gds_check_cardinality_(self.e_rev_E, "e_rev_E", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.e_rev_I, "e_rev_I")
        self.gds_check_cardinality_(self.e_rev_I, "e_rev_I", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("e_rev_E", node)
        if value is not None and "e_rev_E" not in already_processed:
            already_processed.add("e_rev_E")
            value = self.gds_parse_float(value, node, "e_rev_E")
            self.e_rev_E = value
        value = find_attr_value_("e_rev_I", node)
        if value is not None and "e_rev_I" not in already_processed:
            already_processed.add("e_rev_I")
            value = self.gds_parse_float(value, node, "e_rev_I")
            self.e_rev_I = value
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(basePyNNIaFCondCell, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(basePyNNIaFCondCell, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class basePyNNIaFCondCell


class ContinuousConnectionInstance(ContinuousConnection):
    """ContinuousConnectionInstance -- An instance of a connection in a  **continuousProjection**  between **presynapticPopulation**  to another **postsynapticPopulation**  through a **preComponent**  at the start and **postComponent**  at the end. Populations need to be of type  **populationList**  and contain  **instance**  and  **location**  elements. Can be used for analog synapses."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = ContinuousConnection

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        pre_cell: "a string (required)" = None,
        pre_segment: "a NonNegativeInteger (optional)" = "0",
        pre_fraction_along: "a ZeroToOne (optional)" = "0.5",
        post_cell: "a string (required)" = None,
        post_segment: "a NonNegativeInteger (optional)" = "0",
        post_fraction_along: "a ZeroToOne (optional)" = "0.5",
        pre_component: "a NmlId (required)" = None,
        post_component: "a NmlId (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ContinuousConnectionInstance"), self).__init__(
            id,
            neuro_lex_id,
            pre_cell,
            pre_segment,
            pre_fraction_along,
            post_cell,
            post_segment,
            post_fraction_along,
            pre_component,
            post_component,
            extensiontype_,
            **kwargs_,
        )
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContinuousConnectionInstance
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContinuousConnectionInstance.subclass:
            return ContinuousConnectionInstance.subclass(*args_, **kwargs_)
        else:
            return ContinuousConnectionInstance(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(ContinuousConnectionInstance, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ContinuousConnectionInstance",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ContinuousConnectionInstance")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "ContinuousConnectionInstance"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ContinuousConnectionInstance",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ContinuousConnectionInstance",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ContinuousConnectionInstance",
    ):
        super(ContinuousConnectionInstance, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ContinuousConnectionInstance",
        )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ContinuousConnectionInstance",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ContinuousConnectionInstance, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(ContinuousConnectionInstance, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ContinuousConnectionInstance, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass

    def _get_cell_id(self, id_string):
        if "[" in id_string:
            return int(id_string.split("[")[1].split("]")[0])
        else:
            return int(id_string.split("/")[2])

    def __str__(self):
        return (
            "Continuous Connection (Instance based) "
            + str(self.id)
            + ": "
            + str(self.get_pre_info())
            + " -> "
            + str(self.get_post_info())
            + ", pre comp: "
            + str(self.pre_component)
            + ", post comp: "
            + str(self.post_component)
        )

    # end class ContinuousConnectionInstance


class ElectricalConnectionInstance(ElectricalConnection):
    """ElectricalConnectionInstance -- To enable connections between populations through gap junctions. Populations need to be of type  **populationList**  and contain  **instance**  and  **location**  elements."""

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = ElectricalConnection

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        pre_cell: "a string (required)" = None,
        pre_segment: "a NonNegativeInteger (optional)" = "0",
        pre_fraction_along: "a ZeroToOne (optional)" = "0.5",
        post_cell: "a string (required)" = None,
        post_segment: "a NonNegativeInteger (optional)" = "0",
        post_fraction_along: "a ZeroToOne (optional)" = "0.5",
        synapse: "a NmlId (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ElectricalConnectionInstance"), self).__init__(
            id,
            neuro_lex_id,
            pre_cell,
            pre_segment,
            pre_fraction_along,
            post_cell,
            post_segment,
            post_fraction_along,
            synapse,
            extensiontype_,
            **kwargs_,
        )
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricalConnectionInstance
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricalConnectionInstance.subclass:
            return ElectricalConnectionInstance.subclass(*args_, **kwargs_)
        else:
            return ElectricalConnectionInstance(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(ElectricalConnectionInstance, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ElectricalConnectionInstance",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ElectricalConnectionInstance")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "ElectricalConnectionInstance"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ElectricalConnectionInstance",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ElectricalConnectionInstance",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ElectricalConnectionInstance",
    ):
        super(ElectricalConnectionInstance, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ElectricalConnectionInstance",
        )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ElectricalConnectionInstance",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ElectricalConnectionInstance, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(ElectricalConnectionInstance, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ElectricalConnectionInstance, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass

    def _get_cell_id(self, id_string):
        if "[" in id_string:
            return int(id_string.split("[")[1].split("]")[0])
        else:
            return int(id_string.split("/")[2])

    def __str__(self):
        return (
            "Electrical Connection (Instance based) "
            + str(self.id)
            + ": "
            + str(self.get_pre_info())
            + " -> "
            + str(self.get_post_info())
            + ", synapse: "
            + str(self.synapse)
        )

    # end class ElectricalConnectionInstance


class ExpThreeSynapse(BaseConductanceBasedSynapseTwo):
    """ExpThreeSynapse -- Ohmic synapse similar to expTwoSynapse but consisting of two components that can differ in decay times and max conductances but share the same rise time.
    \n
    :param tauRise:
    :type tauRise: time
    :param tauDecay1:
    :type tauDecay1: time
    :param tauDecay2:
    :type tauDecay2: time
    :param gbase1: Baseline conductance 1
    :type gbase1: conductance
    :param gbase2: Baseline conductance 2
    :type gbase2: conductance
    :param erev: Reversal potential of the synapse
    :type erev: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "tau_decay1",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "tau_decay1"},
        ),
        MemberSpec_(
            "tau_decay2",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "tau_decay2"},
        ),
        MemberSpec_(
            "tau_rise",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "tau_rise"},
        ),
    ]
    subclass = None
    superclass = BaseConductanceBasedSynapseTwo

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        gbase1: "a Nml2Quantity_conductance (required)" = None,
        gbase2: "a Nml2Quantity_conductance (required)" = None,
        erev: "a Nml2Quantity_voltage (required)" = None,
        tau_decay1: "a Nml2Quantity_time (required)" = None,
        tau_decay2: "a Nml2Quantity_time (required)" = None,
        tau_rise: "a Nml2Quantity_time (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ExpThreeSynapse"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            gbase1,
            gbase2,
            erev,
            **kwargs_,
        )
        self.tau_decay1 = _cast(None, tau_decay1)
        self.tau_decay1_nsprefix_ = None
        self.tau_decay2 = _cast(None, tau_decay2)
        self.tau_decay2_nsprefix_ = None
        self.tau_rise = _cast(None, tau_rise)
        self.tau_rise_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ExpThreeSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpThreeSynapse.subclass:
            return ExpThreeSynapse.subclass(*args_, **kwargs_)
        else:
            return ExpThreeSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(ExpThreeSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ExpThreeSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ExpThreeSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ExpThreeSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ExpThreeSynapse"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ExpThreeSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ExpThreeSynapse",
    ):
        super(ExpThreeSynapse, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ExpThreeSynapse"
        )
        if self.tau_decay1 is not None and "tau_decay1" not in already_processed:
            already_processed.add("tau_decay1")
            outfile.write(
                " tauDecay1=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.tau_decay1), input_name="tauDecay1"
                        )
                    ),
                )
            )
        if self.tau_decay2 is not None and "tau_decay2" not in already_processed:
            already_processed.add("tau_decay2")
            outfile.write(
                " tauDecay2=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.tau_decay2), input_name="tauDecay2"
                        )
                    ),
                )
            )
        if self.tau_rise is not None and "tau_rise" not in already_processed:
            already_processed.add("tau_rise")
            outfile.write(
                " tauRise=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.tau_rise), input_name="tauRise"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ExpThreeSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ExpThreeSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.tau_decay1, "tau_decay1"
        )
        self.gds_check_cardinality_(self.tau_decay1, "tau_decay1", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.tau_decay2, "tau_decay2"
        )
        self.gds_check_cardinality_(self.tau_decay2, "tau_decay2", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.tau_rise, "tau_rise"
        )
        self.gds_check_cardinality_(self.tau_rise, "tau_rise", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("tauDecay1", node)
        if value is not None and "tauDecay1" not in already_processed:
            already_processed.add("tauDecay1")
            self.tau_decay1 = value
            self.validate_Nml2Quantity_time(
                self.tau_decay1
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("tauDecay2", node)
        if value is not None and "tauDecay2" not in already_processed:
            already_processed.add("tauDecay2")
            self.tau_decay2 = value
            self.validate_Nml2Quantity_time(
                self.tau_decay2
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("tauRise", node)
        if value is not None and "tauRise" not in already_processed:
            already_processed.add("tauRise")
            self.tau_rise = value
            self.validate_Nml2Quantity_time(
                self.tau_rise
            )  # validate type Nml2Quantity_time
        super(ExpThreeSynapse, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ExpThreeSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class ExpThreeSynapse


class ExpTwoSynapse(BaseConductanceBasedSynapse):
    """ExpTwoSynapse -- Ohmic synapse model whose conductance waveform on receiving an event has a rise time of **tauRise**  and a decay time of **tauDecay.**  Max conductance reached during this time ( assuming zero conductance before ) is **gbase**  * **weight.**
    \n
    :param tauRise:
    :type tauRise: time
    :param tauDecay:
    :type tauDecay: time
    :param gbase: Baseline conductance, generally the maximum conductance following a single spike
    :type gbase: conductance
    :param erev: Reversal potential of the synapse
    :type erev: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "tau_decay",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "tau_decay"},
        ),
        MemberSpec_(
            "tau_rise",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "tau_rise"},
        ),
    ]
    subclass = None
    superclass = BaseConductanceBasedSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        gbase: "a Nml2Quantity_conductance (required)" = None,
        erev: "a Nml2Quantity_voltage (required)" = None,
        tau_decay: "a Nml2Quantity_time (required)" = None,
        tau_rise: "a Nml2Quantity_time (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ExpTwoSynapse"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            gbase,
            erev,
            extensiontype_,
            **kwargs_,
        )
        self.tau_decay = _cast(None, tau_decay)
        self.tau_decay_nsprefix_ = None
        self.tau_rise = _cast(None, tau_rise)
        self.tau_rise_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ExpTwoSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpTwoSynapse.subclass:
            return ExpTwoSynapse.subclass(*args_, **kwargs_)
        else:
            return ExpTwoSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(ExpTwoSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ExpTwoSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ExpTwoSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ExpTwoSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ExpTwoSynapse"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ExpTwoSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ExpTwoSynapse",
    ):
        super(ExpTwoSynapse, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ExpTwoSynapse"
        )
        if self.tau_decay is not None and "tau_decay" not in already_processed:
            already_processed.add("tau_decay")
            outfile.write(
                " tauDecay=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.tau_decay), input_name="tauDecay"
                        )
                    ),
                )
            )
        if self.tau_rise is not None and "tau_rise" not in already_processed:
            already_processed.add("tau_rise")
            outfile.write(
                " tauRise=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.tau_rise), input_name="tauRise"
                        )
                    ),
                )
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ExpTwoSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ExpTwoSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.tau_decay, "tau_decay"
        )
        self.gds_check_cardinality_(self.tau_decay, "tau_decay", required=True)
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.tau_rise, "tau_rise"
        )
        self.gds_check_cardinality_(self.tau_rise, "tau_rise", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("tauDecay", node)
        if value is not None and "tauDecay" not in already_processed:
            already_processed.add("tauDecay")
            self.tau_decay = value
            self.validate_Nml2Quantity_time(
                self.tau_decay
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("tauRise", node)
        if value is not None and "tauRise" not in already_processed:
            already_processed.add("tauRise")
            self.tau_rise = value
            self.validate_Nml2Quantity_time(
                self.tau_rise
            )  # validate type Nml2Quantity_time
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(ExpTwoSynapse, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ExpTwoSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class ExpTwoSynapse


class ExpOneSynapse(BaseConductanceBasedSynapse):
    """ExpOneSynapse -- Ohmic synapse model whose conductance rises instantaneously by ( **gbase**  * **weight**  ) on receiving an event, and which decays exponentially to zero with time course **tauDecay**
    \n
    :param tauDecay: Time course of decay
    :type tauDecay: time
    :param gbase: Baseline conductance, generally the maximum conductance following a single spike
    :type gbase: conductance
    :param erev: Reversal potential of the synapse
    :type erev: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "tau_decay",
            "Nml2Quantity_time",
            0,
            0,
            {"use": "required", "name": "tau_decay"},
        ),
    ]
    subclass = None
    superclass = BaseConductanceBasedSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        gbase: "a Nml2Quantity_conductance (required)" = None,
        erev: "a Nml2Quantity_voltage (required)" = None,
        tau_decay: "a Nml2Quantity_time (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ExpOneSynapse"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            gbase,
            erev,
            **kwargs_,
        )
        self.tau_decay = _cast(None, tau_decay)
        self.tau_decay_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, ExpOneSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpOneSynapse.subclass:
            return ExpOneSynapse.subclass(*args_, **kwargs_)
        else:
            return ExpOneSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(ExpOneSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ExpOneSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ExpOneSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "ExpOneSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ExpOneSynapse"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ExpOneSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ExpOneSynapse",
    ):
        super(ExpOneSynapse, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="ExpOneSynapse"
        )
        if self.tau_decay is not None and "tau_decay" not in already_processed:
            already_processed.add("tau_decay")
            outfile.write(
                " tauDecay=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(
                            quote_attrib(self.tau_decay), input_name="tauDecay"
                        )
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ExpOneSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ExpOneSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(
            self.validate_Nml2Quantity_time, self.tau_decay, "tau_decay"
        )
        self.gds_check_cardinality_(self.tau_decay, "tau_decay", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("tauDecay", node)
        if value is not None and "tauDecay" not in already_processed:
            already_processed.add("tauDecay")
            self.tau_decay = value
            self.validate_Nml2Quantity_time(
                self.tau_decay
            )  # validate type Nml2Quantity_time
        super(ExpOneSynapse, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ExpOneSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class ExpOneSynapse


class AlphaSynapse(BaseConductanceBasedSynapse):
    """AlphaSynapse -- Ohmic synapse model where rise time and decay time are both **tau.**  Max conductance reached during this time ( assuming zero conductance before ) is **gbase**  * **weight.**
    \n
    :param tau: Time course of rise/decay
    :type tau: time
    :param gbase: Baseline conductance, generally the maximum conductance following a single spike
    :type gbase: conductance
    :param erev: Reversal potential of the synapse
    :type erev: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "tau", "Nml2Quantity_time", 0, 0, {"use": "required", "name": "tau"}
        ),
    ]
    subclass = None
    superclass = BaseConductanceBasedSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        gbase: "a Nml2Quantity_conductance (required)" = None,
        erev: "a Nml2Quantity_voltage (required)" = None,
        tau: "a Nml2Quantity_time (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("AlphaSynapse"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            gbase,
            erev,
            **kwargs_,
        )
        self.tau = _cast(None, tau)
        self.tau_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, AlphaSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlphaSynapse.subclass:
            return AlphaSynapse.subclass(*args_, **kwargs_)
        else:
            return AlphaSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if (
            value is not None
            and Validate_simpletypes_
            and self.gds_collector_ is not None
        ):
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)'
                    % {
                        "value": value,
                        "lineno": lineno,
                    }
                )
                return False
            if not self.gds_validate_simple_patterns(
                self.validate_Nml2Quantity_time_patterns_, value
            ):
                self.gds_collector_.add_message(
                    'Value "%s" does not match xsd pattern restrictions: %s'
                    % (
                        encode_str_2_3(value),
                        self.validate_Nml2Quantity_time_patterns_,
                    )
                )

    validate_Nml2Quantity_time_patterns_ = [
        ["^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$"]
    ]

    def _hasContent(self):
        if super(AlphaSynapse, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AlphaSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("AlphaSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "AlphaSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="AlphaSynapse"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="AlphaSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="AlphaSynapse",
    ):
        super(AlphaSynapse, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="AlphaSynapse"
        )
        if self.tau is not None and "tau" not in already_processed:
            already_processed.add("tau")
            outfile.write(
                " tau=%s"
                % (
                    self.gds_encode(
                        self.gds_format_string(quote_attrib(self.tau), input_name="tau")
                    ),
                )
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="AlphaSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(AlphaSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_defined_ST_(self.validate_Nml2Quantity_time, self.tau, "tau")
        self.gds_check_cardinality_(self.tau, "tau", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("tau", node)
        if value is not None and "tau" not in already_processed:
            already_processed.add("tau")
            self.tau = value
            self.validate_Nml2Quantity_time(self.tau)  # validate type Nml2Quantity_time
        super(AlphaSynapse, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(AlphaSynapse, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class AlphaSynapse


class EIF_cond_exp_isfa_ista(basePyNNIaFCondCell):
    """EIF_cond_exp_isfa_ista -- Adaptive exponential integrate and fire neuron according to Brette R and Gerstner W ( 2005 ) with exponentially-decaying post-synaptic conductance
    \n
    :param v_spike:
    :type v_spike: none
    :param delta_T:
    :type delta_T: none
    :param tau_w:
    :type tau_w: none
    :param a:
    :type a: none
    :param b:
    :type b: none
    :param e_rev_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type e_rev_E: none
    :param e_rev_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type e_rev_I: none
    :param tau_refrac:
    :type tau_refrac: none
    :param v_thresh:
    :type v_thresh: none
    :param tau_m:
    :type tau_m: none
    :param v_rest:
    :type v_rest: none
    :param v_reset:
    :type v_reset: none
    :param cm:
    :type cm: none
    :param i_offset:
    :type i_offset: none
    :param tau_syn_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_E: none
    :param tau_syn_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_I: none
    :param v_init:
    :type v_init: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("a", "xs:float", 0, 0, {"use": "required", "name": "a"}),
        MemberSpec_("b", "xs:float", 0, 0, {"use": "required", "name": "b"}),
        MemberSpec_(
            "delta_T", "xs:float", 0, 0, {"use": "required", "name": "delta_T"}
        ),
        MemberSpec_("tau_w", "xs:float", 0, 0, {"use": "required", "name": "tau_w"}),
        MemberSpec_(
            "v_spike", "xs:float", 0, 0, {"use": "required", "name": "v_spike"}
        ),
    ]
    subclass = None
    superclass = basePyNNIaFCondCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        cm: "a float (required)" = None,
        i_offset: "a float (required)" = None,
        tau_syn_E: "a float (required)" = None,
        tau_syn_I: "a float (required)" = None,
        v_init: "a float (required)" = None,
        tau_m: "a float (required)" = None,
        tau_refrac: "a float (required)" = None,
        v_reset: "a float (required)" = None,
        v_rest: "a float (required)" = None,
        v_thresh: "a float (required)" = None,
        e_rev_E: "a float (required)" = None,
        e_rev_I: "a float (required)" = None,
        a: "a float (required)" = None,
        b: "a float (required)" = None,
        delta_T: "a float (required)" = None,
        tau_w: "a float (required)" = None,
        v_spike: "a float (required)" = None,
        extensiontype_=None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("EIF_cond_exp_isfa_ista"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            cm,
            i_offset,
            tau_syn_E,
            tau_syn_I,
            v_init,
            tau_m,
            tau_refrac,
            v_reset,
            v_rest,
            v_thresh,
            e_rev_E,
            e_rev_I,
            extensiontype_,
            **kwargs_,
        )
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.delta_T = _cast(float, delta_T)
        self.delta_T_nsprefix_ = None
        self.tau_w = _cast(float, tau_w)
        self.tau_w_nsprefix_ = None
        self.v_spike = _cast(float, v_spike)
        self.v_spike_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EIF_cond_exp_isfa_ista
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EIF_cond_exp_isfa_ista.subclass:
            return EIF_cond_exp_isfa_ista.subclass(*args_, **kwargs_)
        else:
            return EIF_cond_exp_isfa_ista(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(EIF_cond_exp_isfa_ista, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="EIF_cond_exp_isfa_ista",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("EIF_cond_exp_isfa_ista")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "EIF_cond_exp_isfa_ista":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="EIF_cond_exp_isfa_ista",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="EIF_cond_exp_isfa_ista",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="EIF_cond_exp_isfa_ista",
    ):
        super(EIF_cond_exp_isfa_ista, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="EIF_cond_exp_isfa_ista",
        )
        if self.a is not None and "a" not in already_processed:
            already_processed.add("a")
            outfile.write(' a="%s"' % self.gds_format_float(self.a, input_name="a"))
        if self.b is not None and "b" not in already_processed:
            already_processed.add("b")
            outfile.write(' b="%s"' % self.gds_format_float(self.b, input_name="b"))
        if self.delta_T is not None and "delta_T" not in already_processed:
            already_processed.add("delta_T")
            outfile.write(
                ' delta_T="%s"'
                % self.gds_format_float(self.delta_T, input_name="delta_T")
            )
        if self.tau_w is not None and "tau_w" not in already_processed:
            already_processed.add("tau_w")
            outfile.write(
                ' tau_w="%s"' % self.gds_format_float(self.tau_w, input_name="tau_w")
            )
        if self.v_spike is not None and "v_spike" not in already_processed:
            already_processed.add("v_spike")
            outfile.write(
                ' v_spike="%s"'
                % self.gds_format_float(self.v_spike, input_name="v_spike")
            )
        if self.extensiontype_ is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(
                    self.extensiontype_, ""
                )
                outfile.write(
                    ' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_)
                )
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="EIF_cond_exp_isfa_ista",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(EIF_cond_exp_isfa_ista, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.a, "a")
        self.gds_check_cardinality_(self.a, "a", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.b, "b")
        self.gds_check_cardinality_(self.b, "b", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.delta_T, "delta_T")
        self.gds_check_cardinality_(self.delta_T, "delta_T", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.tau_w, "tau_w")
        self.gds_check_cardinality_(self.tau_w, "tau_w", required=True)
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.v_spike, "v_spike")
        self.gds_check_cardinality_(self.v_spike, "v_spike", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("a", node)
        if value is not None and "a" not in already_processed:
            already_processed.add("a")
            value = self.gds_parse_float(value, node, "a")
            self.a = value
        value = find_attr_value_("b", node)
        if value is not None and "b" not in already_processed:
            already_processed.add("b")
            value = self.gds_parse_float(value, node, "b")
            self.b = value
        value = find_attr_value_("delta_T", node)
        if value is not None and "delta_T" not in already_processed:
            already_processed.add("delta_T")
            value = self.gds_parse_float(value, node, "delta_T")
            self.delta_T = value
        value = find_attr_value_("tau_w", node)
        if value is not None and "tau_w" not in already_processed:
            already_processed.add("tau_w")
            value = self.gds_parse_float(value, node, "tau_w")
            self.tau_w = value
        value = find_attr_value_("v_spike", node)
        if value is not None and "v_spike" not in already_processed:
            already_processed.add("v_spike")
            value = self.gds_parse_float(value, node, "v_spike")
            self.v_spike = value
        value = find_attr_value_("xsi:type", node)
        if value is not None and "xsi:type" not in already_processed:
            already_processed.add("xsi:type")
            self.extensiontype_ = value
        super(EIF_cond_exp_isfa_ista, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(EIF_cond_exp_isfa_ista, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class EIF_cond_exp_isfa_ista


class IF_cond_exp(basePyNNIaFCondCell):
    """IF_cond_exp -- Leaky integrate and fire model with fixed threshold and exponentially-decaying post-synaptic conductance
    \n
    :param e_rev_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type e_rev_E: none
    :param e_rev_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type e_rev_I: none
    :param tau_refrac:
    :type tau_refrac: none
    :param v_thresh:
    :type v_thresh: none
    :param tau_m:
    :type tau_m: none
    :param v_rest:
    :type v_rest: none
    :param v_reset:
    :type v_reset: none
    :param cm:
    :type cm: none
    :param i_offset:
    :type i_offset: none
    :param tau_syn_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_E: none
    :param tau_syn_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_I: none
    :param v_init:
    :type v_init: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = basePyNNIaFCondCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        cm: "a float (required)" = None,
        i_offset: "a float (required)" = None,
        tau_syn_E: "a float (required)" = None,
        tau_syn_I: "a float (required)" = None,
        v_init: "a float (required)" = None,
        tau_m: "a float (required)" = None,
        tau_refrac: "a float (required)" = None,
        v_reset: "a float (required)" = None,
        v_rest: "a float (required)" = None,
        v_thresh: "a float (required)" = None,
        e_rev_E: "a float (required)" = None,
        e_rev_I: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IF_cond_exp"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            cm,
            i_offset,
            tau_syn_E,
            tau_syn_I,
            v_init,
            tau_m,
            tau_refrac,
            v_reset,
            v_rest,
            v_thresh,
            e_rev_E,
            e_rev_I,
            **kwargs_,
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IF_cond_exp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IF_cond_exp.subclass:
            return IF_cond_exp.subclass(*args_, **kwargs_)
        else:
            return IF_cond_exp(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(IF_cond_exp, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IF_cond_exp",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IF_cond_exp")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IF_cond_exp":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IF_cond_exp"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IF_cond_exp",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="IF_cond_exp",
    ):
        super(IF_cond_exp, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IF_cond_exp"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IF_cond_exp",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IF_cond_exp, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(IF_cond_exp, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(IF_cond_exp, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class IF_cond_exp


class IF_cond_alpha(basePyNNIaFCondCell):
    """IF_cond_alpha -- Leaky integrate and fire model with fixed threshold and alpha-function-shaped post-synaptic conductance
    \n
    :param e_rev_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type e_rev_E: none
    :param e_rev_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type e_rev_I: none
    :param tau_refrac:
    :type tau_refrac: none
    :param v_thresh:
    :type v_thresh: none
    :param tau_m:
    :type tau_m: none
    :param v_rest:
    :type v_rest: none
    :param v_reset:
    :type v_reset: none
    :param cm:
    :type cm: none
    :param i_offset:
    :type i_offset: none
    :param tau_syn_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_E: none
    :param tau_syn_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_I: none
    :param v_init:
    :type v_init: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = basePyNNIaFCondCell

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        cm: "a float (required)" = None,
        i_offset: "a float (required)" = None,
        tau_syn_E: "a float (required)" = None,
        tau_syn_I: "a float (required)" = None,
        v_init: "a float (required)" = None,
        tau_m: "a float (required)" = None,
        tau_refrac: "a float (required)" = None,
        v_reset: "a float (required)" = None,
        v_rest: "a float (required)" = None,
        v_thresh: "a float (required)" = None,
        e_rev_E: "a float (required)" = None,
        e_rev_I: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("IF_cond_alpha"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            cm,
            i_offset,
            tau_syn_E,
            tau_syn_I,
            v_init,
            tau_m,
            tau_refrac,
            v_reset,
            v_rest,
            v_thresh,
            e_rev_E,
            e_rev_I,
            **kwargs_,
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(CurrentSubclassModule_, IF_cond_alpha)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IF_cond_alpha.subclass:
            return IF_cond_alpha.subclass(*args_, **kwargs_)
        else:
            return IF_cond_alpha(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(IF_cond_alpha, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IF_cond_alpha",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("IF_cond_alpha")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "IF_cond_alpha":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IF_cond_alpha"
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="IF_cond_alpha",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="IF_cond_alpha",
    ):
        super(IF_cond_alpha, self)._exportAttributes(
            outfile, level, already_processed, namespaceprefix_, name_="IF_cond_alpha"
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="IF_cond_alpha",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(IF_cond_alpha, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(IF_cond_alpha, self)._buildAttributes(node, attrs, already_processed)

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(IF_cond_alpha, self)._buildChildren(child_, node, nodeName_, True)
        pass


# end class IF_cond_alpha


class ContinuousConnectionInstanceW(ContinuousConnectionInstance):
    """ContinuousConnectionInstanceW -- An instance of a connection in a  **continuousProjection**  between **presynapticPopulation**  to another **postsynapticPopulation**  through a **preComponent**  at the start and **postComponent**  at the end. Populations need to be of type  **populationList**  and contain  **instance**  and  **location**  elements. Can be used for analog synapses. Includes setting of **weight**  for the connection
    \n
    :param weight:
    :type weight: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("weight", "xs:float", 0, 0, {"use": "required", "name": "weight"}),
    ]
    subclass = None
    superclass = ContinuousConnectionInstance

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        pre_cell: "a string (required)" = None,
        pre_segment: "a NonNegativeInteger (optional)" = "0",
        pre_fraction_along: "a ZeroToOne (optional)" = "0.5",
        post_cell: "a string (required)" = None,
        post_segment: "a NonNegativeInteger (optional)" = "0",
        post_fraction_along: "a ZeroToOne (optional)" = "0.5",
        pre_component: "a NmlId (required)" = None,
        post_component: "a NmlId (required)" = None,
        weight: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ContinuousConnectionInstanceW"), self).__init__(
            id,
            neuro_lex_id,
            pre_cell,
            pre_segment,
            pre_fraction_along,
            post_cell,
            post_segment,
            post_fraction_along,
            pre_component,
            post_component,
            **kwargs_,
        )
        self.weight = _cast(float, weight)
        self.weight_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContinuousConnectionInstanceW
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContinuousConnectionInstanceW.subclass:
            return ContinuousConnectionInstanceW.subclass(*args_, **kwargs_)
        else:
            return ContinuousConnectionInstanceW(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(ContinuousConnectionInstanceW, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ContinuousConnectionInstanceW",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ContinuousConnectionInstanceW")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "ContinuousConnectionInstanceW"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ContinuousConnectionInstanceW",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ContinuousConnectionInstanceW",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ContinuousConnectionInstanceW",
    ):
        super(ContinuousConnectionInstanceW, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ContinuousConnectionInstanceW",
        )
        if self.weight is not None and "weight" not in already_processed:
            already_processed.add("weight")
            outfile.write(
                ' weight="%s"' % self.gds_format_float(self.weight, input_name="weight")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ContinuousConnectionInstanceW",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ContinuousConnectionInstanceW, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.weight, "weight")
        self.gds_check_cardinality_(self.weight, "weight", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("weight", node)
        if value is not None and "weight" not in already_processed:
            already_processed.add("weight")
            value = self.gds_parse_float(value, node, "weight")
            self.weight = value
        super(ContinuousConnectionInstanceW, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ContinuousConnectionInstanceW, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass

    def get_weight(self):
        """Get weight.

        If weight is not set, the default value of 1.0 is returned.
        """

        return float(self.weight) if self.weight != None else 1.0

    def __str__(self):
        return (
            "Continuous Connection (Instance based & weight) "
            + str(self.id)
            + ": "
            + str(self.get_pre_info())
            + " -> "
            + str(self.get_post_info())
            + ", pre comp: "
            + str(self.pre_component)
            + ", post comp: "
            + str(self.post_component)
            + ", weight: "
            + "%.6f" % self.get_weight()
        )

    # end class ContinuousConnectionInstanceW


class ElectricalConnectionInstanceW(ElectricalConnectionInstance):
    """ElectricalConnectionInstanceW -- To enable connections between populations through gap junctions. Populations need to be of type  **populationList**  and contain  **instance**  and  **location**  elements. Includes setting of **weight**  for the connection
    \n
    :param weight:
    :type weight: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_("weight", "xs:float", 0, 0, {"use": "required", "name": "weight"}),
    ]
    subclass = None
    superclass = ElectricalConnectionInstance

    def __init__(
        self,
        id: "a NonNegativeInteger (required)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        pre_cell: "a string (required)" = None,
        pre_segment: "a NonNegativeInteger (optional)" = "0",
        pre_fraction_along: "a ZeroToOne (optional)" = "0.5",
        post_cell: "a string (required)" = None,
        post_segment: "a NonNegativeInteger (optional)" = "0",
        post_fraction_along: "a ZeroToOne (optional)" = "0.5",
        synapse: "a NmlId (required)" = None,
        weight: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("ElectricalConnectionInstanceW"), self).__init__(
            id,
            neuro_lex_id,
            pre_cell,
            pre_segment,
            pre_fraction_along,
            post_cell,
            post_segment,
            post_fraction_along,
            synapse,
            **kwargs_,
        )
        self.weight = _cast(float, weight)
        self.weight_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricalConnectionInstanceW
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricalConnectionInstanceW.subclass:
            return ElectricalConnectionInstanceW.subclass(*args_, **kwargs_)
        else:
            return ElectricalConnectionInstanceW(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(ElectricalConnectionInstanceW, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ElectricalConnectionInstanceW",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("ElectricalConnectionInstanceW")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if (
            self.original_tagname_ is not None
            and name_ == "ElectricalConnectionInstanceW"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ElectricalConnectionInstanceW",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="ElectricalConnectionInstanceW",
                pretty_print=pretty_print,
            )
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="ElectricalConnectionInstanceW",
    ):
        super(ElectricalConnectionInstanceW, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="ElectricalConnectionInstanceW",
        )
        if self.weight is not None and "weight" not in already_processed:
            already_processed.add("weight")
            outfile.write(
                ' weight="%s"' % self.gds_format_float(self.weight, input_name="weight")
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="ElectricalConnectionInstanceW",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(ElectricalConnectionInstanceW, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        pass

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        self.gds_validate_builtin_ST_(self.gds_validate_float, self.weight, "weight")
        self.gds_check_cardinality_(self.weight, "weight", required=True)
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("weight", node)
        if value is not None and "weight" not in already_processed:
            already_processed.add("weight")
            value = self.gds_parse_float(value, node, "weight")
            self.weight = value
        super(ElectricalConnectionInstanceW, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(ElectricalConnectionInstanceW, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass

    def get_weight(self):
        """Get the weight of the connection

        If a weight is not set (or is set to None), returns the default value
        of 1.0.

        :returns: weight of connection or 1.0 if not set
        :rtype: float
        """

        return float(self.weight) if self.weight != None else 1.0

    def __str__(self):
        return (
            "Electrical Connection (Instance based & weight) "
            + str(self.id)
            + ": "
            + str(self.get_pre_info())
            + " -> "
            + str(self.get_post_info())
            + ", synapse: "
            + str(self.synapse)
            + ", weight: "
            + "%.6f" % self.get_weight()
        )

    # end class ElectricalConnectionInstanceW


class BlockingPlasticSynapse(ExpTwoSynapse):
    """BlockingPlasticSynapse -- Biexponential synapse that allows for optional block and plasticity mechanisms, which can be expressed as child elements.
    \n
    :param tauRise:
    :type tauRise: time
    :param tauDecay:
    :type tauDecay: time
    :param gbase: Baseline conductance, generally the maximum conductance following a single spike
    :type gbase: conductance
    :param erev: Reversal potential of the synapse
    :type erev: voltage

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_(
            "plasticity_mechanism",
            "PlasticityMechanism",
            0,
            1,
            {
                "minOccurs": "0",
                "name": "plasticityMechanism",
                "type": "PlasticityMechanism",
            },
            None,
        ),
        MemberSpec_(
            "block_mechanism",
            "BlockMechanism",
            0,
            1,
            {"minOccurs": "0", "name": "blockMechanism", "type": "BlockMechanism"},
            None,
        ),
    ]
    subclass = None
    superclass = ExpTwoSynapse

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        gbase: "a Nml2Quantity_conductance (required)" = None,
        erev: "a Nml2Quantity_voltage (required)" = None,
        tau_decay: "a Nml2Quantity_time (required)" = None,
        tau_rise: "a Nml2Quantity_time (required)" = None,
        plasticity_mechanism: "a PlasticityMechanism (optional)" = None,
        block_mechanism: "a BlockMechanism (optional)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("BlockingPlasticSynapse"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            gbase,
            erev,
            tau_decay,
            tau_rise,
            **kwargs_,
        )
        self.plasticity_mechanism = plasticity_mechanism
        self.plasticity_mechanism_nsprefix_ = None
        self.block_mechanism = block_mechanism
        self.block_mechanism_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BlockingPlasticSynapse
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockingPlasticSynapse.subclass:
            return BlockingPlasticSynapse.subclass(*args_, **kwargs_)
        else:
            return BlockingPlasticSynapse(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if (
            self.plasticity_mechanism is not None
            or self.block_mechanism is not None
            or super(BlockingPlasticSynapse, self)._hasContent()
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="BlockingPlasticSynapse",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("BlockingPlasticSynapse")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "BlockingPlasticSynapse":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BlockingPlasticSynapse",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="BlockingPlasticSynapse",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="BlockingPlasticSynapse",
    ):
        super(BlockingPlasticSynapse, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="BlockingPlasticSynapse",
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ',
        name_="BlockingPlasticSynapse",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(BlockingPlasticSynapse, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.plasticity_mechanism is not None:
            namespaceprefix_ = (
                self.plasticity_mechanism_nsprefix_ + ":"
                if (UseCapturedNS_ and self.plasticity_mechanism_nsprefix_)
                else ""
            )
            self.plasticity_mechanism.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="plasticityMechanism",
                pretty_print=pretty_print,
            )
        if self.block_mechanism is not None:
            namespaceprefix_ = (
                self.block_mechanism_nsprefix_ + ":"
                if (UseCapturedNS_ and self.block_mechanism_nsprefix_)
                else ""
            )
            self.block_mechanism.export(
                outfile,
                level,
                namespaceprefix_,
                namespacedef_="",
                name_="blockMechanism",
                pretty_print=pretty_print,
            )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        self.gds_check_cardinality_(
            self.plasticity_mechanism,
            "plasticity_mechanism",
            min_occurs=0,
            max_occurs=1,
        )
        self.gds_check_cardinality_(
            self.block_mechanism, "block_mechanism", min_occurs=0, max_occurs=1
        )
        if recursive:
            if self.plasticity_mechanism is not None:
                self.plasticity_mechanism.validate_(gds_collector, recursive=True)
            if self.block_mechanism is not None:
                self.block_mechanism.validate_(gds_collector, recursive=True)
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(BlockingPlasticSynapse, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        if nodeName_ == "plasticityMechanism":
            obj_ = PlasticityMechanism.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.plasticity_mechanism = obj_
            obj_.original_tagname_ = "plasticityMechanism"
        elif nodeName_ == "blockMechanism":
            obj_ = BlockMechanism.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.block_mechanism = obj_
            obj_.original_tagname_ = "blockMechanism"
        super(BlockingPlasticSynapse, self)._buildChildren(
            child_, node, nodeName_, True
        )


# end class BlockingPlasticSynapse


class EIF_cond_alpha_isfa_ista(EIF_cond_exp_isfa_ista):
    """EIF_cond_alpha_isfa_ista -- Adaptive exponential integrate and fire neuron according to Brette R and Gerstner W ( 2005 ) with alpha-function-shaped post-synaptic conductance
    \n
    :param v_spike:
    :type v_spike: none
    :param delta_T:
    :type delta_T: none
    :param tau_w:
    :type tau_w: none
    :param a:
    :type a: none
    :param b:
    :type b: none
    :param e_rev_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type e_rev_E: none
    :param e_rev_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type e_rev_I: none
    :param tau_refrac:
    :type tau_refrac: none
    :param v_thresh:
    :type v_thresh: none
    :param tau_m:
    :type tau_m: none
    :param v_rest:
    :type v_rest: none
    :param v_reset:
    :type v_reset: none
    :param cm:
    :type cm: none
    :param i_offset:
    :type i_offset: none
    :param tau_syn_E: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_E: none
    :param tau_syn_I: This parameter is never used in the NeuroML2 description of this cell! Any synapse producing a current can be placed on this cell
    :type tau_syn_I: none
    :param v_init:
    :type v_init: none

    """

    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = []
    subclass = None
    superclass = EIF_cond_exp_isfa_ista

    def __init__(
        self,
        id: "a NmlId (required)" = None,
        metaid: "a MetaId (optional)" = None,
        notes: "a string (optional)" = None,
        properties: "list of Property(s) (optional)" = None,
        annotation: "a Annotation (optional)" = None,
        neuro_lex_id: "a NeuroLexId (optional)" = None,
        cm: "a float (required)" = None,
        i_offset: "a float (required)" = None,
        tau_syn_E: "a float (required)" = None,
        tau_syn_I: "a float (required)" = None,
        v_init: "a float (required)" = None,
        tau_m: "a float (required)" = None,
        tau_refrac: "a float (required)" = None,
        v_reset: "a float (required)" = None,
        v_rest: "a float (required)" = None,
        v_thresh: "a float (required)" = None,
        e_rev_E: "a float (required)" = None,
        e_rev_I: "a float (required)" = None,
        a: "a float (required)" = None,
        b: "a float (required)" = None,
        delta_T: "a float (required)" = None,
        tau_w: "a float (required)" = None,
        v_spike: "a float (required)" = None,
        gds_collector_=None,
        **kwargs_,
    ):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get("parent_object_")
        self.ns_prefix_ = None
        super(globals().get("EIF_cond_alpha_isfa_ista"), self).__init__(
            id,
            metaid,
            notes,
            properties,
            annotation,
            neuro_lex_id,
            cm,
            i_offset,
            tau_syn_E,
            tau_syn_I,
            v_init,
            tau_m,
            tau_refrac,
            v_reset,
            v_rest,
            v_thresh,
            e_rev_E,
            e_rev_I,
            a,
            b,
            delta_T,
            tau_w,
            v_spike,
            **kwargs_,
        )

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EIF_cond_alpha_isfa_ista
            )
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EIF_cond_alpha_isfa_ista.subclass:
            return EIF_cond_alpha_isfa_ista.subclass(*args_, **kwargs_)
        else:
            return EIF_cond_alpha_isfa_ista(*args_, **kwargs_)

    factory = staticmethod(factory)

    def _hasContent(self):
        if super(EIF_cond_alpha_isfa_ista, self)._hasContent():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="EIF_cond_alpha_isfa_ista",
        pretty_print=True,
    ):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get("EIF_cond_alpha_isfa_ista")
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = "\n"
        else:
            eol_ = ""
        if self.original_tagname_ is not None and name_ == "EIF_cond_alpha_isfa_ista":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix_,
                name_,
                namespacedef_ and " " + namespacedef_ or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="EIF_cond_alpha_isfa_ista",
        )
        if self._hasContent():
            outfile.write(">%s" % (eol_,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix_,
                namespacedef_,
                name_="EIF_cond_alpha_isfa_ista",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix_, name_, eol_))
        else:
            outfile.write("/>%s" % (eol_,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix_="",
        name_="EIF_cond_alpha_isfa_ista",
    ):
        super(EIF_cond_alpha_isfa_ista, self)._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix_,
            name_="EIF_cond_alpha_isfa_ista",
        )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix_="",
        namespacedef_="",
        name_="EIF_cond_alpha_isfa_ista",
        fromsubclass_=False,
        pretty_print=True,
    ):
        super(EIF_cond_alpha_isfa_ista, self)._exportChildren(
            outfile,
            level,
            namespaceprefix_,
            namespacedef_,
            name_,
            True,
            pretty_print=pretty_print,
        )

    def validate_(self, gds_collector, recursive=False):
        self.gds_collector_ = gds_collector
        message_count = len(self.gds_collector_.get_messages())
        # validate simple type attributes
        # validate simple type children
        # validate complex type children
        if recursive:
            pass
        return message_count == len(self.gds_collector_.get_messages())

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        super(EIF_cond_alpha_isfa_ista, self)._buildAttributes(
            node, attrs, already_processed
        )

    def _buildChildren(
        self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None
    ):
        super(EIF_cond_alpha_isfa_ista, self)._buildChildren(
            child_, node, nodeName_, True
        )
        pass


# end class EIF_cond_alpha_isfa_ista


GDSClassesMapping = {
    "neuroml": NeuroMLDocument,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    """Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    """
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = " ".join(
        ['xmlns:{}="{}"'.format(prefix, uri) for prefix, uri in nsmap.items()]
    )
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = "Property"
        rootClass = Property
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag, namespacedef_=namespacedefs, pretty_print=True
        )
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ("-" * 50) + "\n"
        sys.stderr.write(separator)
        sys.stderr.write(
            "----- Warnings -- count: {} -----\n".format(
                len(gds_collector.get_messages()),
            )
        )
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(
    inFileName,
    silence=False,
    print_warnings=True,
    mapping=None,
    reverse_mapping=None,
    nsmap=None,
):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = "Property"
        rootClass = Property
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None,
        name_=rootTag,
        mapping_=mapping,
        reverse_mapping_=reverse_mapping,
        nsmap_=nsmap,
    )
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True, xml_declaration=True, encoding="utf-8"
        )
        sys.stdout.write(str(content))
        sys.stdout.write("\n")
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ("-" * 50) + "\n"
        sys.stderr.write(separator)
        sys.stderr.write(
            "----- Warnings -- count: {} -----\n".format(
                len(gds_collector.get_messages()),
            )
        )
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    """Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    """
    parser = None
    rootNode = parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = "Property"
        rootClass = Property
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(sys.stdout, 0, name_=rootTag, namespacedef_="")
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ("-" * 50) + "\n"
        sys.stderr.write(separator)
        sys.stderr.write(
            "----- Warnings -- count: {} -----\n".format(
                len(gds_collector.get_messages()),
            )
        )
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = "Property"
        rootClass = Property
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write("#from nml import *\n\n")
        sys.stdout.write("import nml as model_\n\n")
        sys.stdout.write("rootObj = model_.rootClass(\n")
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(")\n")
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ("-" * 50) + "\n"
        sys.stderr.write(separator)
        sys.stderr.write(
            "----- Warnings -- count: {} -----\n".format(
                len(gds_collector.get_messages()),
            )
        )
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == "__main__":
    # import pdb; pdb.set_trace()
    main()

RenameMappings_ = {}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {
    "http://www.neuroml.org/schema/neuroml2": [
        ("NmlId", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_none", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_voltage", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_length", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_resistance", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_resistivity", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_conductance", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_conductanceDensity", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_permeability", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_time", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_pertime", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_capacitance", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_specificCapacitance", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_concentration", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_current", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_currentDensity", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_temperature", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_rhoFactor", "NeuroML_v2.3.xsd", "ST"),
        ("Nml2Quantity_conductancePerVoltage", "NeuroML_v2.3.xsd", "ST"),
        ("MetaId", "NeuroML_v2.3.xsd", "ST"),
        ("NeuroLexId", "NeuroML_v2.3.xsd", "ST"),
        ("NonNegativeInteger", "NeuroML_v2.3.xsd", "ST"),
        ("PositiveInteger", "NeuroML_v2.3.xsd", "ST"),
        ("DoubleGreaterThanZero", "NeuroML_v2.3.xsd", "ST"),
        ("ZeroOrOne", "NeuroML_v2.3.xsd", "ST"),
        ("Notes", "NeuroML_v2.3.xsd", "ST"),
        ("TrueOrFalse", "NeuroML_v2.3.xsd", "ST"),
        ("ZeroToOne", "NeuroML_v2.3.xsd", "ST"),
        ("channelTypes", "NeuroML_v2.3.xsd", "ST"),
        ("gateTypes", "NeuroML_v2.3.xsd", "ST"),
        ("BlockTypes", "NeuroML_v2.3.xsd", "ST"),
        ("PlasticityTypes", "NeuroML_v2.3.xsd", "ST"),
        ("Metric", "NeuroML_v2.3.xsd", "ST"),
        ("networkTypes", "NeuroML_v2.3.xsd", "ST"),
        ("allowedSpaces", "NeuroML_v2.3.xsd", "ST"),
        ("populationTypes", "NeuroML_v2.3.xsd", "ST"),
        ("Property", "NeuroML_v2.3.xsd", "CT"),
        ("Annotation", "NeuroML_v2.3.xsd", "CT"),
        ("ComponentType", "NeuroML_v2.3.xsd", "CT"),
        ("Constant", "NeuroML_v2.3.xsd", "CT"),
        ("Exposure", "NeuroML_v2.3.xsd", "CT"),
        ("NamedDimensionalType", "NeuroML_v2.3.xsd", "CT"),
        ("NamedDimensionalVariable", "NeuroML_v2.3.xsd", "CT"),
        ("Parameter", "NeuroML_v2.3.xsd", "CT"),
        ("DerivedParameter", "NeuroML_v2.3.xsd", "CT"),
        ("LEMS_Property", "NeuroML_v2.3.xsd", "CT"),
        ("Requirement", "NeuroML_v2.3.xsd", "CT"),
        ("InstanceRequirement", "NeuroML_v2.3.xsd", "CT"),
        ("Dynamics", "NeuroML_v2.3.xsd", "CT"),
        ("DerivedVariable", "NeuroML_v2.3.xsd", "CT"),
        ("StateVariable", "NeuroML_v2.3.xsd", "CT"),
        ("ConditionalDerivedVariable", "NeuroML_v2.3.xsd", "CT"),
        ("Case", "NeuroML_v2.3.xsd", "CT"),
        ("TimeDerivative", "NeuroML_v2.3.xsd", "CT"),
        ("OnStart", "NeuroML_v2.3.xsd", "CT"),
        ("StateAssignment", "NeuroML_v2.3.xsd", "CT"),
        ("OnEvent", "NeuroML_v2.3.xsd", "CT"),
        ("EventOut", "NeuroML_v2.3.xsd", "CT"),
        ("OnCondition", "NeuroML_v2.3.xsd", "CT"),
        ("Transition", "NeuroML_v2.3.xsd", "CT"),
        ("Regime", "NeuroML_v2.3.xsd", "CT"),
        ("OnEntry", "NeuroML_v2.3.xsd", "CT"),
        ("NeuroMLDocument", "NeuroML_v2.3.xsd", "CT"),
        ("IncludeType", "NeuroML_v2.3.xsd", "CT"),
        ("IonChannelScalable", "NeuroML_v2.3.xsd", "CT"),
        ("IonChannelKS", "NeuroML_v2.3.xsd", "CT"),
        ("IonChannel", "NeuroML_v2.3.xsd", "CT"),
        ("IonChannelHH", "NeuroML_v2.3.xsd", "CT"),
        ("IonChannelVShift", "NeuroML_v2.3.xsd", "CT"),
        ("Q10ConductanceScaling", "NeuroML_v2.3.xsd", "CT"),
        ("ClosedState", "NeuroML_v2.3.xsd", "CT"),
        ("OpenState", "NeuroML_v2.3.xsd", "CT"),
        ("ForwardTransition", "NeuroML_v2.3.xsd", "CT"),
        ("ReverseTransition", "NeuroML_v2.3.xsd", "CT"),
        ("TauInfTransition", "NeuroML_v2.3.xsd", "CT"),
        ("GateKS", "NeuroML_v2.3.xsd", "CT"),
        ("GateHHUndetermined", "NeuroML_v2.3.xsd", "CT"),
        ("GateHHRates", "NeuroML_v2.3.xsd", "CT"),
        ("GateHHTauInf", "NeuroML_v2.3.xsd", "CT"),
        ("GateHHRatesTauInf", "NeuroML_v2.3.xsd", "CT"),
        ("GateHHRatesTau", "NeuroML_v2.3.xsd", "CT"),
        ("GateHHRatesInf", "NeuroML_v2.3.xsd", "CT"),
        ("GateHHInstantaneous", "NeuroML_v2.3.xsd", "CT"),
        ("GateFractional", "NeuroML_v2.3.xsd", "CT"),
        ("GateFractionalSubgate", "NeuroML_v2.3.xsd", "CT"),
        ("Q10Settings", "NeuroML_v2.3.xsd", "CT"),
        ("HHRate", "NeuroML_v2.3.xsd", "CT"),
        ("HHVariable", "NeuroML_v2.3.xsd", "CT"),
        ("HHTime", "NeuroML_v2.3.xsd", "CT"),
        ("DecayingPoolConcentrationModel", "NeuroML_v2.3.xsd", "CT"),
        ("FixedFactorConcentrationModel", "NeuroML_v2.3.xsd", "CT"),
        ("BaseSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("BaseVoltageDepSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("BaseCurrentBasedSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("BaseConductanceBasedSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("BaseConductanceBasedSynapseTwo", "NeuroML_v2.3.xsd", "CT"),
        ("GapJunction", "NeuroML_v2.3.xsd", "CT"),
        ("SilentSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("LinearGradedSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("GradedSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("AlphaCurrentSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("AlphaSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("ExpOneSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("ExpTwoSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("ExpThreeSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("DoubleSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("BlockingPlasticSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("BlockMechanism", "NeuroML_v2.3.xsd", "CT"),
        ("PlasticityMechanism", "NeuroML_v2.3.xsd", "CT"),
        ("BaseCell", "NeuroML_v2.3.xsd", "CT"),
        ("IafTauCell", "NeuroML_v2.3.xsd", "CT"),
        ("IafTauRefCell", "NeuroML_v2.3.xsd", "CT"),
        ("IafCell", "NeuroML_v2.3.xsd", "CT"),
        ("IafRefCell", "NeuroML_v2.3.xsd", "CT"),
        ("IzhikevichCell", "NeuroML_v2.3.xsd", "CT"),
        ("BaseCellMembPotCap", "NeuroML_v2.3.xsd", "CT"),
        ("Izhikevich2007Cell", "NeuroML_v2.3.xsd", "CT"),
        ("AdExIaFCell", "NeuroML_v2.3.xsd", "CT"),
        ("FitzHughNagumoCell", "NeuroML_v2.3.xsd", "CT"),
        ("FitzHughNagumo1969Cell", "NeuroML_v2.3.xsd", "CT"),
        ("PinskyRinzelCA3Cell", "NeuroML_v2.3.xsd", "CT"),
        ("Cell", "NeuroML_v2.3.xsd", "CT"),
        ("Cell2CaPools", "NeuroML_v2.3.xsd", "CT"),
        ("Morphology", "NeuroML_v2.3.xsd", "CT"),
        ("Segment", "NeuroML_v2.3.xsd", "CT"),
        ("SegmentParent", "NeuroML_v2.3.xsd", "CT"),
        ("Point3DWithDiam", "NeuroML_v2.3.xsd", "CT"),
        ("SegmentGroup", "NeuroML_v2.3.xsd", "CT"),
        ("InhomogeneousParameter", "NeuroML_v2.3.xsd", "CT"),
        ("ProximalDetails", "NeuroML_v2.3.xsd", "CT"),
        ("DistalDetails", "NeuroML_v2.3.xsd", "CT"),
        ("Member", "NeuroML_v2.3.xsd", "CT"),
        ("Include", "NeuroML_v2.3.xsd", "CT"),
        ("Path", "NeuroML_v2.3.xsd", "CT"),
        ("SubTree", "NeuroML_v2.3.xsd", "CT"),
        ("SegmentEndPoint", "NeuroML_v2.3.xsd", "CT"),
        ("BiophysicalProperties", "NeuroML_v2.3.xsd", "CT"),
        ("BiophysicalProperties2CaPools", "NeuroML_v2.3.xsd", "CT"),
        ("MembraneProperties", "NeuroML_v2.3.xsd", "CT"),
        ("MembraneProperties2CaPools", "NeuroML_v2.3.xsd", "CT"),
        ("SpikeThresh", "NeuroML_v2.3.xsd", "CT"),
        ("SpecificCapacitance", "NeuroML_v2.3.xsd", "CT"),
        ("InitMembPotential", "NeuroML_v2.3.xsd", "CT"),
        ("Resistivity", "NeuroML_v2.3.xsd", "CT"),
        ("ChannelPopulation", "NeuroML_v2.3.xsd", "CT"),
        ("ChannelDensityNonUniform", "NeuroML_v2.3.xsd", "CT"),
        ("ChannelDensityNonUniformNernst", "NeuroML_v2.3.xsd", "CT"),
        ("ChannelDensityNonUniformGHK", "NeuroML_v2.3.xsd", "CT"),
        ("ChannelDensity", "NeuroML_v2.3.xsd", "CT"),
        ("ChannelDensityVShift", "NeuroML_v2.3.xsd", "CT"),
        ("ChannelDensityNernst", "NeuroML_v2.3.xsd", "CT"),
        ("ChannelDensityNernstCa2", "NeuroML_v2.3.xsd", "CT"),
        ("ChannelDensityGHK", "NeuroML_v2.3.xsd", "CT"),
        ("ChannelDensityGHK2", "NeuroML_v2.3.xsd", "CT"),
        ("VariableParameter", "NeuroML_v2.3.xsd", "CT"),
        ("InhomogeneousValue", "NeuroML_v2.3.xsd", "CT"),
        ("Species", "NeuroML_v2.3.xsd", "CT"),
        ("ConcentrationModel_D", "NeuroML_v2.3.xsd", "CT"),
        ("IntracellularProperties", "NeuroML_v2.3.xsd", "CT"),
        ("IntracellularProperties2CaPools", "NeuroML_v2.3.xsd", "CT"),
        ("ExtracellularProperties", "NeuroML_v2.3.xsd", "CT"),
        ("ExtracellularPropertiesLocal", "NeuroML_v2.3.xsd", "CT"),
        ("ReactionScheme", "NeuroML_v2.3.xsd", "CT"),
        ("PulseGenerator", "NeuroML_v2.3.xsd", "CT"),
        ("PulseGeneratorDL", "NeuroML_v2.3.xsd", "CT"),
        ("SineGenerator", "NeuroML_v2.3.xsd", "CT"),
        ("SineGeneratorDL", "NeuroML_v2.3.xsd", "CT"),
        ("RampGenerator", "NeuroML_v2.3.xsd", "CT"),
        ("RampGeneratorDL", "NeuroML_v2.3.xsd", "CT"),
        ("CompoundInput", "NeuroML_v2.3.xsd", "CT"),
        ("CompoundInputDL", "NeuroML_v2.3.xsd", "CT"),
        ("VoltageClamp", "NeuroML_v2.3.xsd", "CT"),
        ("VoltageClampTriple", "NeuroML_v2.3.xsd", "CT"),
        ("Spike", "NeuroML_v2.3.xsd", "CT"),
        ("SpikeArray", "NeuroML_v2.3.xsd", "CT"),
        ("TimedSynapticInput", "NeuroML_v2.3.xsd", "CT"),
        ("SpikeGenerator", "NeuroML_v2.3.xsd", "CT"),
        ("SpikeGeneratorRandom", "NeuroML_v2.3.xsd", "CT"),
        ("SpikeGeneratorPoisson", "NeuroML_v2.3.xsd", "CT"),
        ("SpikeGeneratorRefPoisson", "NeuroML_v2.3.xsd", "CT"),
        ("PoissonFiringSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("TransientPoissonFiringSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("Network", "NeuroML_v2.3.xsd", "CT"),
        ("Space", "NeuroML_v2.3.xsd", "CT"),
        ("SpaceStructure", "NeuroML_v2.3.xsd", "CT"),
        ("Region", "NeuroML_v2.3.xsd", "CT"),
        ("Population", "NeuroML_v2.3.xsd", "CT"),
        ("Layout", "NeuroML_v2.3.xsd", "CT"),
        ("UnstructuredLayout", "NeuroML_v2.3.xsd", "CT"),
        ("RandomLayout", "NeuroML_v2.3.xsd", "CT"),
        ("GridLayout", "NeuroML_v2.3.xsd", "CT"),
        ("Instance", "NeuroML_v2.3.xsd", "CT"),
        ("Location", "NeuroML_v2.3.xsd", "CT"),
        ("CellSet", "NeuroML_v2.3.xsd", "CT"),
        ("SynapticConnection", "NeuroML_v2.3.xsd", "CT"),
        ("BaseProjection", "NeuroML_v2.3.xsd", "CT"),
        ("Projection", "NeuroML_v2.3.xsd", "CT"),
        ("BaseConnection", "NeuroML_v2.3.xsd", "CT"),
        ("BaseConnectionOldFormat", "NeuroML_v2.3.xsd", "CT"),
        ("BaseConnectionNewFormat", "NeuroML_v2.3.xsd", "CT"),
        ("Connection", "NeuroML_v2.3.xsd", "CT"),
        ("ConnectionWD", "NeuroML_v2.3.xsd", "CT"),
        ("ElectricalProjection", "NeuroML_v2.3.xsd", "CT"),
        ("ElectricalConnection", "NeuroML_v2.3.xsd", "CT"),
        ("ElectricalConnectionInstance", "NeuroML_v2.3.xsd", "CT"),
        ("ElectricalConnectionInstanceW", "NeuroML_v2.3.xsd", "CT"),
        ("ContinuousProjection", "NeuroML_v2.3.xsd", "CT"),
        ("ContinuousConnection", "NeuroML_v2.3.xsd", "CT"),
        ("ContinuousConnectionInstance", "NeuroML_v2.3.xsd", "CT"),
        ("ContinuousConnectionInstanceW", "NeuroML_v2.3.xsd", "CT"),
        ("ExplicitInput", "NeuroML_v2.3.xsd", "CT"),
        ("InputList", "NeuroML_v2.3.xsd", "CT"),
        ("Input", "NeuroML_v2.3.xsd", "CT"),
        ("InputW", "NeuroML_v2.3.xsd", "CT"),
        ("basePyNNCell", "NeuroML_v2.3.xsd", "CT"),
        ("basePyNNIaFCell", "NeuroML_v2.3.xsd", "CT"),
        ("basePyNNIaFCondCell", "NeuroML_v2.3.xsd", "CT"),
        ("IF_curr_alpha", "NeuroML_v2.3.xsd", "CT"),
        ("IF_curr_exp", "NeuroML_v2.3.xsd", "CT"),
        ("IF_cond_alpha", "NeuroML_v2.3.xsd", "CT"),
        ("IF_cond_exp", "NeuroML_v2.3.xsd", "CT"),
        ("EIF_cond_exp_isfa_ista", "NeuroML_v2.3.xsd", "CT"),
        ("EIF_cond_alpha_isfa_ista", "NeuroML_v2.3.xsd", "CT"),
        ("HH_cond_exp", "NeuroML_v2.3.xsd", "CT"),
        ("BasePynnSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("ExpCondSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("AlphaCondSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("ExpCurrSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("AlphaCurrSynapse", "NeuroML_v2.3.xsd", "CT"),
        ("SpikeSourcePoisson", "NeuroML_v2.3.xsd", "CT"),
        ("BaseWithoutId", "NeuroML_v2.3.xsd", "CT"),
        ("BaseNonNegativeIntegerId", "NeuroML_v2.3.xsd", "CT"),
        ("Base", "NeuroML_v2.3.xsd", "CT"),
        ("Standalone", "NeuroML_v2.3.xsd", "CT"),
    ]
}

__all__ = [
    "AdExIaFCell",
    "AlphaCondSynapse",
    "AlphaCurrSynapse",
    "AlphaCurrentSynapse",
    "AlphaSynapse",
    "Annotation",
    "Base",
    "BaseCell",
    "BaseCellMembPotCap",
    "BaseConductanceBasedSynapse",
    "BaseConductanceBasedSynapseTwo",
    "BaseConnection",
    "BaseConnectionNewFormat",
    "BaseConnectionOldFormat",
    "BaseCurrentBasedSynapse",
    "BaseNonNegativeIntegerId",
    "BaseProjection",
    "BasePynnSynapse",
    "BaseSynapse",
    "BaseVoltageDepSynapse",
    "BaseWithoutId",
    "BiophysicalProperties",
    "BiophysicalProperties2CaPools",
    "BlockMechanism",
    "BlockingPlasticSynapse",
    "Case",
    "Cell",
    "Cell2CaPools",
    "CellSet",
    "ChannelDensity",
    "ChannelDensityGHK",
    "ChannelDensityGHK2",
    "ChannelDensityNernst",
    "ChannelDensityNernstCa2",
    "ChannelDensityNonUniform",
    "ChannelDensityNonUniformGHK",
    "ChannelDensityNonUniformNernst",
    "ChannelDensityVShift",
    "ChannelPopulation",
    "ClosedState",
    "ComponentType",
    "CompoundInput",
    "CompoundInputDL",
    "ConcentrationModel_D",
    "ConditionalDerivedVariable",
    "Connection",
    "ConnectionWD",
    "Constant",
    "ContinuousConnection",
    "ContinuousConnectionInstance",
    "ContinuousConnectionInstanceW",
    "ContinuousProjection",
    "DecayingPoolConcentrationModel",
    "DerivedParameter",
    "DerivedVariable",
    "DistalDetails",
    "DoubleSynapse",
    "Dynamics",
    "EIF_cond_alpha_isfa_ista",
    "EIF_cond_exp_isfa_ista",
    "ElectricalConnection",
    "ElectricalConnectionInstance",
    "ElectricalConnectionInstanceW",
    "ElectricalProjection",
    "EventOut",
    "ExpCondSynapse",
    "ExpCurrSynapse",
    "ExpOneSynapse",
    "ExpThreeSynapse",
    "ExpTwoSynapse",
    "ExplicitInput",
    "Exposure",
    "ExtracellularProperties",
    "ExtracellularPropertiesLocal",
    "FitzHughNagumo1969Cell",
    "FitzHughNagumoCell",
    "FixedFactorConcentrationModel",
    "ForwardTransition",
    "GapJunction",
    "GateFractional",
    "GateFractionalSubgate",
    "GateHHInstantaneous",
    "GateHHRates",
    "GateHHRatesInf",
    "GateHHRatesTau",
    "GateHHRatesTauInf",
    "GateHHTauInf",
    "GateHHUndetermined",
    "GateKS",
    "GradedSynapse",
    "GridLayout",
    "HHRate",
    "HHTime",
    "HHVariable",
    "HH_cond_exp",
    "IF_cond_alpha",
    "IF_cond_exp",
    "IF_curr_alpha",
    "IF_curr_exp",
    "IafCell",
    "IafRefCell",
    "IafTauCell",
    "IafTauRefCell",
    "Include",
    "IncludeType",
    "InhomogeneousParameter",
    "InhomogeneousValue",
    "InitMembPotential",
    "Input",
    "InputList",
    "InputW",
    "Instance",
    "InstanceRequirement",
    "IntracellularProperties",
    "IntracellularProperties2CaPools",
    "IonChannel",
    "IonChannelHH",
    "IonChannelKS",
    "IonChannelScalable",
    "IonChannelVShift",
    "Izhikevich2007Cell",
    "IzhikevichCell",
    "LEMS_Property",
    "Layout",
    "LinearGradedSynapse",
    "Location",
    "Member",
    "MembraneProperties",
    "MembraneProperties2CaPools",
    "Morphology",
    "NamedDimensionalType",
    "NamedDimensionalVariable",
    "Network",
    "NeuroMLDocument",
    "OnCondition",
    "OnEntry",
    "OnEvent",
    "OnStart",
    "OpenState",
    "Parameter",
    "Path",
    "PinskyRinzelCA3Cell",
    "PlasticityMechanism",
    "Point3DWithDiam",
    "PoissonFiringSynapse",
    "Population",
    "Projection",
    "Property",
    "ProximalDetails",
    "PulseGenerator",
    "PulseGeneratorDL",
    "Q10ConductanceScaling",
    "Q10Settings",
    "RampGenerator",
    "RampGeneratorDL",
    "RandomLayout",
    "ReactionScheme",
    "Regime",
    "Region",
    "Requirement",
    "Resistivity",
    "ReverseTransition",
    "Segment",
    "SegmentEndPoint",
    "SegmentGroup",
    "SegmentParent",
    "SilentSynapse",
    "SineGenerator",
    "SineGeneratorDL",
    "Space",
    "SpaceStructure",
    "Species",
    "SpecificCapacitance",
    "Spike",
    "SpikeArray",
    "SpikeGenerator",
    "SpikeGeneratorPoisson",
    "SpikeGeneratorRandom",
    "SpikeGeneratorRefPoisson",
    "SpikeSourcePoisson",
    "SpikeThresh",
    "Standalone",
    "StateAssignment",
    "StateVariable",
    "SubTree",
    "SynapticConnection",
    "TauInfTransition",
    "TimeDerivative",
    "TimedSynapticInput",
    "TransientPoissonFiringSynapse",
    "Transition",
    "UnstructuredLayout",
    "VariableParameter",
    "VoltageClamp",
    "VoltageClampTriple",
    "basePyNNCell",
    "basePyNNIaFCell",
    "basePyNNIaFCondCell",
]

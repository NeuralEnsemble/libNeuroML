#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Fri Mar 26 09:44:40 2021 by generateDS.py version 2.35.5.
# Python 3.9.2 (default, Feb 20 2021, 00:00:00)  [GCC 11.0.0 20210210 (Red Hat 11.0.0-0)]
#
# Command line options:
#   ('-o', 'nml.py')
#   ('--use-getter-setter', 'none')
#   ('--silence', '')
#   ('--user-methods', 'helper_methods.py')
#
# Command line arguments:
#   NeuroML_v2.1.xsd
#
# Command line:
#   /home/asinha/.virtualenvs/generateds/bin/generateDS.py -o "nml.py" --use-getter-setter="none" --silence --user-methods="helper_methods.py" NeuroML_v2.1.xsd
#
# Current working directory (os.getcwd()):
#   nml
#

from six.moves import zip_longest
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return ('%0.10f' % input_data).rstrip('0')
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class BlockTypes(Enum):
    VOLTAGE_CONC_DEP_BLOCK_MECHANISM='voltageConcDepBlockMechanism'


class Metric(Enum):
    """Allowed metrics for InhomogeneousParam"""
    PATH_LENGTHFROMROOT='Path Length from root'


class PlasticityTypes(Enum):
    TSODYKS_MARKRAM_DEP_MECHANISM='tsodyksMarkramDepMechanism'
    TSODYKS_MARKRAM_DEP_FAC_MECHANISM='tsodyksMarkramDepFacMechanism'


class ZeroOrOne(Enum):
    """Value which is either 0 or 1"""
    _0='0'
    _1='1'


class allowedSpaces(Enum):
    EUCLIDEAN__1_D='Euclidean_1D'
    EUCLIDEAN__2_D='Euclidean_2D'
    EUCLIDEAN__3_D='Euclidean_3D'
    GRID__1_D='Grid_1D'
    GRID__2_D='Grid_2D'
    GRID__3_D='Grid_3D'


class channelTypes(Enum):
    ION_CHANNEL_PASSIVE='ionChannelPassive'
    ION_CHANNEL_HH='ionChannelHH'


class gateTypes(Enum):
    GATE_H_HRATES='gateHHrates'
    GATE_H_HRATES_TAU='gateHHratesTau'
    GATE_H_HTAU_INF='gateHHtauInf'
    GATE_H_HRATES_INF='gateHHratesInf'
    GATE_H_HRATES_TAU_INF='gateHHratesTauInf'
    GATE_HH_INSTANTANEOUS='gateHHInstantaneous'
    GATE_KS='gateKS'
    GATE_FRACTIONAL='gateFractional'


class networkTypes(Enum):
    NETWORK='network'
    NETWORK_WITH_TEMPERATURE='networkWithTemperature'


class populationTypes(Enum):
    POPULATION='population'
    POPULATION_LIST='populationList'


class Property(GeneratedsSuper):
    """Generic property with a tag and value"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('tag', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('value', 'xs:string', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, tag=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Property)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Property.subclass:
            return Property.subclass(*args_, **kwargs_)
        else:
            return Property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Property', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Property')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Property')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Property', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Property'):
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Property', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Property


class Annotation(GeneratedsSuper):
    """Placeholder for MIRIAM related metadata, among others."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('__ANY__', '__ANY__', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'processContents': 'skip'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Annotation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Annotation.subclass:
            return Annotation.subclass(*args_, **kwargs_)
        else:
            return Annotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='Annotation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Annotation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Annotation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Annotation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Annotation'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='Annotation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'Annotation')
        self.add_anytypeobjs_(content_)
# end class Annotation


class ComponentType(GeneratedsSuper):
    """Contains an extension to NeuroML by creating custom LEMS
    ComponentType."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('extends', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('description', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('Property', 'Property', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Property', 'type': 'LEMS_Property'}, None),
        MemberSpec_('Parameter', 'Parameter', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Parameter', 'type': 'Parameter'}, None),
        MemberSpec_('Constant', 'Constant', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Constant', 'type': 'Constant'}, None),
        MemberSpec_('Exposure', 'Exposure', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Exposure', 'type': 'Exposure'}, None),
        MemberSpec_('Requirement', 'Requirement', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Requirement', 'type': 'Requirement'}, None),
        MemberSpec_('InstanceRequirement', 'InstanceRequirement', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'InstanceRequirement', 'type': 'InstanceRequirement'}, None),
        MemberSpec_('Dynamics', 'Dynamics', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'Dynamics', 'type': 'Dynamics'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, extends=None, description=None, Property=None, Parameter=None, Constant=None, Exposure=None, Requirement=None, InstanceRequirement=None, Dynamics=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.extends = _cast(None, extends)
        self.extends_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
        self.Property_nsprefix_ = None
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        self.Parameter_nsprefix_ = None
        if Constant is None:
            self.Constant = []
        else:
            self.Constant = Constant
        self.Constant_nsprefix_ = None
        if Exposure is None:
            self.Exposure = []
        else:
            self.Exposure = Exposure
        self.Exposure_nsprefix_ = None
        if Requirement is None:
            self.Requirement = []
        else:
            self.Requirement = Requirement
        self.Requirement_nsprefix_ = None
        if InstanceRequirement is None:
            self.InstanceRequirement = []
        else:
            self.InstanceRequirement = InstanceRequirement
        self.InstanceRequirement_nsprefix_ = None
        if Dynamics is None:
            self.Dynamics = []
        else:
            self.Dynamics = Dynamics
        self.Dynamics_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComponentType.subclass:
            return ComponentType.subclass(*args_, **kwargs_)
        else:
            return ComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Property or
            self.Parameter or
            self.Constant or
            self.Exposure or
            self.Requirement or
            self.InstanceRequirement or
            self.Dynamics
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='ComponentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComponentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComponentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ComponentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ComponentType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.extends is not None and 'extends' not in already_processed:
            already_processed.add('extends')
            outfile.write(' extends=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.extends), input_name='extends')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='ComponentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Property_ in self.Property:
            namespaceprefix_ = self.Property_nsprefix_ + ':' if (UseCapturedNS_ and self.Property_nsprefix_) else ''
            Property_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Property', pretty_print=pretty_print)
        for Parameter_ in self.Parameter:
            namespaceprefix_ = self.Parameter_nsprefix_ + ':' if (UseCapturedNS_ and self.Parameter_nsprefix_) else ''
            Parameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Parameter', pretty_print=pretty_print)
        for Constant_ in self.Constant:
            namespaceprefix_ = self.Constant_nsprefix_ + ':' if (UseCapturedNS_ and self.Constant_nsprefix_) else ''
            Constant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Constant', pretty_print=pretty_print)
        for Exposure_ in self.Exposure:
            namespaceprefix_ = self.Exposure_nsprefix_ + ':' if (UseCapturedNS_ and self.Exposure_nsprefix_) else ''
            Exposure_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Exposure', pretty_print=pretty_print)
        for Requirement_ in self.Requirement:
            namespaceprefix_ = self.Requirement_nsprefix_ + ':' if (UseCapturedNS_ and self.Requirement_nsprefix_) else ''
            Requirement_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Requirement', pretty_print=pretty_print)
        for InstanceRequirement_ in self.InstanceRequirement:
            namespaceprefix_ = self.InstanceRequirement_nsprefix_ + ':' if (UseCapturedNS_ and self.InstanceRequirement_nsprefix_) else ''
            InstanceRequirement_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InstanceRequirement', pretty_print=pretty_print)
        for Dynamics_ in self.Dynamics:
            namespaceprefix_ = self.Dynamics_nsprefix_ + ':' if (UseCapturedNS_ and self.Dynamics_nsprefix_) else ''
            Dynamics_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Dynamics', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('extends', node)
        if value is not None and 'extends' not in already_processed:
            already_processed.add('extends')
            self.extends = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Property':
            obj_ = LEMS_Property.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Property.append(obj_)
            obj_.original_tagname_ = 'Property'
        elif nodeName_ == 'Parameter':
            obj_ = Parameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Parameter.append(obj_)
            obj_.original_tagname_ = 'Parameter'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Constant.append(obj_)
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'Exposure':
            obj_ = Exposure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Exposure.append(obj_)
            obj_.original_tagname_ = 'Exposure'
        elif nodeName_ == 'Requirement':
            obj_ = Requirement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Requirement.append(obj_)
            obj_.original_tagname_ = 'Requirement'
        elif nodeName_ == 'InstanceRequirement':
            obj_ = InstanceRequirement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstanceRequirement.append(obj_)
            obj_.original_tagname_ = 'InstanceRequirement'
        elif nodeName_ == 'Dynamics':
            obj_ = Dynamics.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dynamics.append(obj_)
            obj_.original_tagname_ = 'Dynamics'
# end class ComponentType


class Constant(GeneratedsSuper):
    """LEMS ComponentType for Constant."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('dimension', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('value', 'Nml2Quantity', 0, 0, {'use': 'required'}),
        MemberSpec_('description', 'xs:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, dimension=None, value=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.dimension = _cast(None, dimension)
        self.dimension_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Constant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Constant.subclass:
            return Constant.subclass(*args_, **kwargs_)
        else:
            return Constant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity(self, value):
        # Validate type Nml2Quantity, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_patterns_, ))
    validate_Nml2Quantity_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*([_a-zA-Z0-9])*)$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Constant', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Constant')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Constant')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Constant', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Constant'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.add('dimension')
            outfile.write(' dimension=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dimension), input_name='dimension')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Constant', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('dimension', node)
        if value is not None and 'dimension' not in already_processed:
            already_processed.add('dimension')
            self.dimension = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_Nml2Quantity(self.value)    # validate type Nml2Quantity
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Constant


class Exposure(GeneratedsSuper):
    """LEMS Exposure (ComponentType property)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('dimension', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('description', 'xs:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, dimension=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.dimension = _cast(None, dimension)
        self.dimension_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Exposure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Exposure.subclass:
            return Exposure.subclass(*args_, **kwargs_)
        else:
            return Exposure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Exposure', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Exposure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Exposure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Exposure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Exposure'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.add('dimension')
            outfile.write(' dimension=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dimension), input_name='dimension')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Exposure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('dimension', node)
        if value is not None and 'dimension' not in already_processed:
            already_processed.add('dimension')
            self.dimension = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Exposure


class NamedDimensionalType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('dimension', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('description', 'xs:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, dimension=None, description=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.dimension = _cast(None, dimension)
        self.dimension_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamedDimensionalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamedDimensionalType.subclass:
            return NamedDimensionalType.subclass(*args_, **kwargs_)
        else:
            return NamedDimensionalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NamedDimensionalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamedDimensionalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NamedDimensionalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NamedDimensionalType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NamedDimensionalType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.add('dimension')
            outfile.write(' dimension=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dimension), input_name='dimension')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NamedDimensionalType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('dimension', node)
        if value is not None and 'dimension' not in already_processed:
            already_processed.add('dimension')
            self.dimension = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NamedDimensionalType


class NamedDimensionalVariable(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('dimension', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('description', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('exposure', 'xs:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, dimension=None, description=None, exposure=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.dimension = _cast(None, dimension)
        self.dimension_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.exposure = _cast(None, exposure)
        self.exposure_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamedDimensionalVariable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamedDimensionalVariable.subclass:
            return NamedDimensionalVariable.subclass(*args_, **kwargs_)
        else:
            return NamedDimensionalVariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NamedDimensionalVariable', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamedDimensionalVariable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NamedDimensionalVariable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NamedDimensionalVariable', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NamedDimensionalVariable'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.dimension is not None and 'dimension' not in already_processed:
            already_processed.add('dimension')
            outfile.write(' dimension=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dimension), input_name='dimension')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.exposure is not None and 'exposure' not in already_processed:
            already_processed.add('exposure')
            outfile.write(' exposure=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.exposure), input_name='exposure')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NamedDimensionalVariable', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('dimension', node)
        if value is not None and 'dimension' not in already_processed:
            already_processed.add('dimension')
            self.dimension = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('exposure', node)
        if value is not None and 'exposure' not in already_processed:
            already_processed.add('exposure')
            self.exposure = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NamedDimensionalVariable


class Parameter(NamedDimensionalType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = NamedDimensionalType
    def __init__(self, name=None, dimension=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Parameter, self).__init__(name, dimension, description,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Parameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Parameter.subclass:
            return Parameter.subclass(*args_, **kwargs_)
        else:
            return Parameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Parameter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Parameter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Parameter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Parameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Parameter', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Parameter'):
        super(Parameter, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Parameter')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Parameter', fromsubclass_=False, pretty_print=True):
        super(Parameter, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Parameter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(Parameter, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Parameter


class LEMS_Property(NamedDimensionalType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('defaultValue', 'xs:double', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = NamedDimensionalType
    def __init__(self, name=None, dimension=None, description=None, defaultValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LEMS_Property, self).__init__(name, dimension, description,  **kwargs_)
        self.defaultValue = _cast(float, defaultValue)
        self.defaultValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LEMS_Property)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LEMS_Property.subclass:
            return LEMS_Property.subclass(*args_, **kwargs_)
        else:
            return LEMS_Property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(LEMS_Property, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LEMS_Property', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LEMS_Property')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LEMS_Property')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LEMS_Property', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LEMS_Property'):
        super(LEMS_Property, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LEMS_Property')
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            outfile.write(' defaultValue="%s"' % self.gds_format_double(self.defaultValue, input_name='defaultValue'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LEMS_Property', fromsubclass_=False, pretty_print=True):
        super(LEMS_Property, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            value = self.gds_parse_double(value, node, 'defaultValue')
            self.defaultValue = value
        super(LEMS_Property, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(LEMS_Property, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LEMS_Property


class Requirement(NamedDimensionalType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = NamedDimensionalType
    def __init__(self, name=None, dimension=None, description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Requirement, self).__init__(name, dimension, description,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Requirement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Requirement.subclass:
            return Requirement.subclass(*args_, **kwargs_)
        else:
            return Requirement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Requirement, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Requirement', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Requirement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Requirement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Requirement', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Requirement'):
        super(Requirement, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Requirement')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Requirement', fromsubclass_=False, pretty_print=True):
        super(Requirement, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Requirement, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(Requirement, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Requirement


class InstanceRequirement(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('type_', 'xs:string', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceRequirement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceRequirement.subclass:
            return InstanceRequirement.subclass(*args_, **kwargs_)
        else:
            return InstanceRequirement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InstanceRequirement', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InstanceRequirement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InstanceRequirement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InstanceRequirement', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InstanceRequirement'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InstanceRequirement', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class InstanceRequirement


class Dynamics(GeneratedsSuper):
    """LEMS ComponentType for Dynamics"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('StateVariable', 'StateVariable', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'StateVariable', 'type': 'StateVariable'}, None),
        MemberSpec_('DerivedVariable', 'DerivedVariable', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'DerivedVariable', 'type': 'DerivedVariable'}, None),
        MemberSpec_('ConditionalDerivedVariable', 'ConditionalDerivedVariable', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'ConditionalDerivedVariable', 'type': 'ConditionalDerivedVariable'}, None),
        MemberSpec_('TimeDerivative', 'TimeDerivative', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'TimeDerivative', 'type': 'TimeDerivative'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, StateVariable=None, DerivedVariable=None, ConditionalDerivedVariable=None, TimeDerivative=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if StateVariable is None:
            self.StateVariable = []
        else:
            self.StateVariable = StateVariable
        self.StateVariable_nsprefix_ = None
        if DerivedVariable is None:
            self.DerivedVariable = []
        else:
            self.DerivedVariable = DerivedVariable
        self.DerivedVariable_nsprefix_ = None
        if ConditionalDerivedVariable is None:
            self.ConditionalDerivedVariable = []
        else:
            self.ConditionalDerivedVariable = ConditionalDerivedVariable
        self.ConditionalDerivedVariable_nsprefix_ = None
        if TimeDerivative is None:
            self.TimeDerivative = []
        else:
            self.TimeDerivative = TimeDerivative
        self.TimeDerivative_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Dynamics)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Dynamics.subclass:
            return Dynamics.subclass(*args_, **kwargs_)
        else:
            return Dynamics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.StateVariable or
            self.DerivedVariable or
            self.ConditionalDerivedVariable or
            self.TimeDerivative
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='Dynamics', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Dynamics')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Dynamics')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Dynamics', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Dynamics'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='Dynamics', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for StateVariable_ in self.StateVariable:
            namespaceprefix_ = self.StateVariable_nsprefix_ + ':' if (UseCapturedNS_ and self.StateVariable_nsprefix_) else ''
            StateVariable_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StateVariable', pretty_print=pretty_print)
        for DerivedVariable_ in self.DerivedVariable:
            namespaceprefix_ = self.DerivedVariable_nsprefix_ + ':' if (UseCapturedNS_ and self.DerivedVariable_nsprefix_) else ''
            DerivedVariable_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DerivedVariable', pretty_print=pretty_print)
        for ConditionalDerivedVariable_ in self.ConditionalDerivedVariable:
            namespaceprefix_ = self.ConditionalDerivedVariable_nsprefix_ + ':' if (UseCapturedNS_ and self.ConditionalDerivedVariable_nsprefix_) else ''
            ConditionalDerivedVariable_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ConditionalDerivedVariable', pretty_print=pretty_print)
        for TimeDerivative_ in self.TimeDerivative:
            namespaceprefix_ = self.TimeDerivative_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeDerivative_nsprefix_) else ''
            TimeDerivative_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeDerivative', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'StateVariable':
            obj_ = StateVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StateVariable.append(obj_)
            obj_.original_tagname_ = 'StateVariable'
        elif nodeName_ == 'DerivedVariable':
            obj_ = DerivedVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DerivedVariable.append(obj_)
            obj_.original_tagname_ = 'DerivedVariable'
        elif nodeName_ == 'ConditionalDerivedVariable':
            obj_ = ConditionalDerivedVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConditionalDerivedVariable.append(obj_)
            obj_.original_tagname_ = 'ConditionalDerivedVariable'
        elif nodeName_ == 'TimeDerivative':
            obj_ = TimeDerivative.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeDerivative.append(obj_)
            obj_.original_tagname_ = 'TimeDerivative'
# end class Dynamics


class DerivedVariable(NamedDimensionalVariable):
    """LEMS ComponentType for DerivedVariable"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('value', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('select', 'xs:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = NamedDimensionalVariable
    def __init__(self, name=None, dimension=None, description=None, exposure=None, value=None, select=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DerivedVariable, self).__init__(name, dimension, description, exposure,  **kwargs_)
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.select = _cast(None, select)
        self.select_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DerivedVariable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DerivedVariable.subclass:
            return DerivedVariable.subclass(*args_, **kwargs_)
        else:
            return DerivedVariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DerivedVariable, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DerivedVariable', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DerivedVariable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DerivedVariable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DerivedVariable', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DerivedVariable'):
        super(DerivedVariable, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DerivedVariable')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.select is not None and 'select' not in already_processed:
            already_processed.add('select')
            outfile.write(' select=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.select), input_name='select')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DerivedVariable', fromsubclass_=False, pretty_print=True):
        super(DerivedVariable, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('select', node)
        if value is not None and 'select' not in already_processed:
            already_processed.add('select')
            self.select = value
        super(DerivedVariable, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DerivedVariable, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DerivedVariable


class StateVariable(NamedDimensionalVariable):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = NamedDimensionalVariable
    def __init__(self, name=None, dimension=None, description=None, exposure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(StateVariable, self).__init__(name, dimension, description, exposure,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StateVariable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StateVariable.subclass:
            return StateVariable.subclass(*args_, **kwargs_)
        else:
            return StateVariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(StateVariable, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StateVariable', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StateVariable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StateVariable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StateVariable', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StateVariable'):
        super(StateVariable, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StateVariable')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StateVariable', fromsubclass_=False, pretty_print=True):
        super(StateVariable, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StateVariable, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(StateVariable, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class StateVariable


class ConditionalDerivedVariable(NamedDimensionalVariable):
    """LEMS ComponentType for ConditionalDerivedVariable"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Case', 'Case', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'Case', 'type': 'Case'}, None),
    ]
    subclass = None
    superclass = NamedDimensionalVariable
    def __init__(self, name=None, dimension=None, description=None, exposure=None, Case=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ConditionalDerivedVariable, self).__init__(name, dimension, description, exposure,  **kwargs_)
        if Case is None:
            self.Case = []
        else:
            self.Case = Case
        self.Case_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConditionalDerivedVariable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConditionalDerivedVariable.subclass:
            return ConditionalDerivedVariable.subclass(*args_, **kwargs_)
        else:
            return ConditionalDerivedVariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Case or
            super(ConditionalDerivedVariable, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='ConditionalDerivedVariable', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConditionalDerivedVariable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConditionalDerivedVariable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConditionalDerivedVariable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConditionalDerivedVariable'):
        super(ConditionalDerivedVariable, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConditionalDerivedVariable')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='ConditionalDerivedVariable', fromsubclass_=False, pretty_print=True):
        super(ConditionalDerivedVariable, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Case_ in self.Case:
            namespaceprefix_ = self.Case_nsprefix_ + ':' if (UseCapturedNS_ and self.Case_nsprefix_) else ''
            Case_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Case', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConditionalDerivedVariable, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Case':
            obj_ = Case.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Case.append(obj_)
            obj_.original_tagname_ = 'Case'
        super(ConditionalDerivedVariable, self).buildChildren(child_, node, nodeName_, True)
# end class ConditionalDerivedVariable


class Case(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('condition', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('value', 'xs:string', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, condition=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.condition = _cast(None, condition)
        self.condition_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Case)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Case.subclass:
            return Case.subclass(*args_, **kwargs_)
        else:
            return Case(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Case', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Case')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Case')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Case', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Case'):
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            outfile.write(' condition=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.condition), input_name='condition')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Case', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('condition', node)
        if value is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            self.condition = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Case


class TimeDerivative(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('variable', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('value', 'xs:string', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, variable=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.variable = _cast(None, variable)
        self.variable_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeDerivative)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeDerivative.subclass:
            return TimeDerivative.subclass(*args_, **kwargs_)
        else:
            return TimeDerivative(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeDerivative', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeDerivative')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeDerivative')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeDerivative', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeDerivative'):
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.add('variable')
            outfile.write(' variable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.variable), input_name='variable')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeDerivative', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('variable', node)
        if value is not None and 'variable' not in already_processed:
            already_processed.add('variable')
            self.variable = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TimeDerivative


class IncludeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('href', 'xs:anyURI', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, href=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IncludeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IncludeType.subclass:
            return IncludeType.subclass(*args_, **kwargs_)
        else:
            return IncludeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IncludeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IncludeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IncludeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IncludeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IncludeType'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IncludeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class IncludeType


class Q10ConductanceScaling(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('q10Factor', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('experimentalTemp', 'Nml2Quantity_temperature', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, q10Factor=None, experimentalTemp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.q10Factor = _cast(None, q10Factor)
        self.q10Factor_nsprefix_ = None
        self.experimentalTemp = _cast(None, experimentalTemp)
        self.experimentalTemp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Q10ConductanceScaling)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Q10ConductanceScaling.subclass:
            return Q10ConductanceScaling.subclass(*args_, **kwargs_)
        else:
            return Q10ConductanceScaling(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_none_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_none_patterns_, ))
    validate_Nml2Quantity_none_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$']]
    def validate_Nml2Quantity_temperature(self, value):
        # Validate type Nml2Quantity_temperature, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_temperature_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_temperature_patterns_, ))
    validate_Nml2Quantity_temperature_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(degC))$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Q10ConductanceScaling', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Q10ConductanceScaling')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Q10ConductanceScaling')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Q10ConductanceScaling', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Q10ConductanceScaling'):
        if self.q10Factor is not None and 'q10Factor' not in already_processed:
            already_processed.add('q10Factor')
            outfile.write(' q10Factor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.q10Factor), input_name='q10Factor')), ))
        if self.experimentalTemp is not None and 'experimentalTemp' not in already_processed:
            already_processed.add('experimentalTemp')
            outfile.write(' experimentalTemp=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.experimentalTemp), input_name='experimentalTemp')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Q10ConductanceScaling', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('q10Factor', node)
        if value is not None and 'q10Factor' not in already_processed:
            already_processed.add('q10Factor')
            self.q10Factor = value
            self.validate_Nml2Quantity_none(self.q10Factor)    # validate type Nml2Quantity_none
        value = find_attr_value_('experimentalTemp', node)
        if value is not None and 'experimentalTemp' not in already_processed:
            already_processed.add('experimentalTemp')
            self.experimentalTemp = value
            self.validate_Nml2Quantity_temperature(self.experimentalTemp)    # validate type Nml2Quantity_temperature
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Q10ConductanceScaling


class Q10Settings(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('type_', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('fixedQ10', 'Nml2Quantity_none', 0, 1, {'use': 'optional'}),
        MemberSpec_('q10Factor', 'Nml2Quantity_none', 0, 1, {'use': 'optional'}),
        MemberSpec_('experimentalTemp', 'Nml2Quantity_temperature', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, type_=None, fixedQ10=None, q10Factor=None, experimentalTemp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.fixedQ10 = _cast(None, fixedQ10)
        self.fixedQ10_nsprefix_ = None
        self.q10Factor = _cast(None, q10Factor)
        self.q10Factor_nsprefix_ = None
        self.experimentalTemp = _cast(None, experimentalTemp)
        self.experimentalTemp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Q10Settings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Q10Settings.subclass:
            return Q10Settings.subclass(*args_, **kwargs_)
        else:
            return Q10Settings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_none_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_none_patterns_, ))
    validate_Nml2Quantity_none_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$']]
    def validate_Nml2Quantity_temperature(self, value):
        # Validate type Nml2Quantity_temperature, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_temperature_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_temperature_patterns_, ))
    validate_Nml2Quantity_temperature_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(degC))$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Q10Settings', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Q10Settings')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Q10Settings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Q10Settings', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Q10Settings'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.fixedQ10 is not None and 'fixedQ10' not in already_processed:
            already_processed.add('fixedQ10')
            outfile.write(' fixedQ10=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fixedQ10), input_name='fixedQ10')), ))
        if self.q10Factor is not None and 'q10Factor' not in already_processed:
            already_processed.add('q10Factor')
            outfile.write(' q10Factor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.q10Factor), input_name='q10Factor')), ))
        if self.experimentalTemp is not None and 'experimentalTemp' not in already_processed:
            already_processed.add('experimentalTemp')
            outfile.write(' experimentalTemp=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.experimentalTemp), input_name='experimentalTemp')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Q10Settings', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_NmlId(self.type_)    # validate type NmlId
        value = find_attr_value_('fixedQ10', node)
        if value is not None and 'fixedQ10' not in already_processed:
            already_processed.add('fixedQ10')
            self.fixedQ10 = value
            self.validate_Nml2Quantity_none(self.fixedQ10)    # validate type Nml2Quantity_none
        value = find_attr_value_('q10Factor', node)
        if value is not None and 'q10Factor' not in already_processed:
            already_processed.add('q10Factor')
            self.q10Factor = value
            self.validate_Nml2Quantity_none(self.q10Factor)    # validate type Nml2Quantity_none
        value = find_attr_value_('experimentalTemp', node)
        if value is not None and 'experimentalTemp' not in already_processed:
            already_processed.add('experimentalTemp')
            self.experimentalTemp = value
            self.validate_Nml2Quantity_temperature(self.experimentalTemp)    # validate type Nml2Quantity_temperature
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Q10Settings


class HHRate(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('type_', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('rate', 'Nml2Quantity_pertime', 0, 1, {'use': 'optional'}),
        MemberSpec_('midpoint', 'Nml2Quantity_voltage', 0, 1, {'use': 'optional'}),
        MemberSpec_('scale', 'Nml2Quantity_voltage', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, type_=None, rate=None, midpoint=None, scale=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.rate = _cast(None, rate)
        self.rate_nsprefix_ = None
        self.midpoint = _cast(None, midpoint)
        self.midpoint_nsprefix_ = None
        self.scale = _cast(None, scale)
        self.scale_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HHRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HHRate.subclass:
            return HHRate.subclass(*args_, **kwargs_)
        else:
            return HHRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_pertime_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_pertime_patterns_, ))
    validate_Nml2Quantity_pertime_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$']]
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HHRate', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HHRate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HHRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HHRate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HHRate'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            outfile.write(' rate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rate), input_name='rate')), ))
        if self.midpoint is not None and 'midpoint' not in already_processed:
            already_processed.add('midpoint')
            outfile.write(' midpoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.midpoint), input_name='midpoint')), ))
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            outfile.write(' scale=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scale), input_name='scale')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HHRate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_NmlId(self.type_)    # validate type NmlId
        value = find_attr_value_('rate', node)
        if value is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            self.rate = value
            self.validate_Nml2Quantity_pertime(self.rate)    # validate type Nml2Quantity_pertime
        value = find_attr_value_('midpoint', node)
        if value is not None and 'midpoint' not in already_processed:
            already_processed.add('midpoint')
            self.midpoint = value
            self.validate_Nml2Quantity_voltage(self.midpoint)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            self.scale = value
            self.validate_Nml2Quantity_voltage(self.scale)    # validate type Nml2Quantity_voltage
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class HHRate


class HHVariable(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('type_', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('rate', 'xs:float', 0, 1, {'use': 'optional'}),
        MemberSpec_('midpoint', 'Nml2Quantity_voltage', 0, 1, {'use': 'optional'}),
        MemberSpec_('scale', 'Nml2Quantity_voltage', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, type_=None, rate=None, midpoint=None, scale=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.rate = _cast(float, rate)
        self.rate_nsprefix_ = None
        self.midpoint = _cast(None, midpoint)
        self.midpoint_nsprefix_ = None
        self.scale = _cast(None, scale)
        self.scale_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HHVariable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HHVariable.subclass:
            return HHVariable.subclass(*args_, **kwargs_)
        else:
            return HHVariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HHVariable', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HHVariable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HHVariable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HHVariable', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HHVariable'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            outfile.write(' rate="%s"' % self.gds_format_float(self.rate, input_name='rate'))
        if self.midpoint is not None and 'midpoint' not in already_processed:
            already_processed.add('midpoint')
            outfile.write(' midpoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.midpoint), input_name='midpoint')), ))
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            outfile.write(' scale=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scale), input_name='scale')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HHVariable', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_NmlId(self.type_)    # validate type NmlId
        value = find_attr_value_('rate', node)
        if value is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            value = self.gds_parse_float(value, node, 'rate')
            self.rate = value
        value = find_attr_value_('midpoint', node)
        if value is not None and 'midpoint' not in already_processed:
            already_processed.add('midpoint')
            self.midpoint = value
            self.validate_Nml2Quantity_voltage(self.midpoint)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            self.scale = value
            self.validate_Nml2Quantity_voltage(self.scale)    # validate type Nml2Quantity_voltage
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class HHVariable


class HHTime(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('type_', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('rate', 'Nml2Quantity_time', 0, 1, {'use': 'optional'}),
        MemberSpec_('midpoint', 'Nml2Quantity_voltage', 0, 1, {'use': 'optional'}),
        MemberSpec_('scale', 'Nml2Quantity_voltage', 0, 1, {'use': 'optional'}),
        MemberSpec_('tau', 'Nml2Quantity_time', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, type_=None, rate=None, midpoint=None, scale=None, tau=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.rate = _cast(None, rate)
        self.rate_nsprefix_ = None
        self.midpoint = _cast(None, midpoint)
        self.midpoint_nsprefix_ = None
        self.scale = _cast(None, scale)
        self.scale_nsprefix_ = None
        self.tau = _cast(None, tau)
        self.tau_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HHTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HHTime.subclass:
            return HHTime.subclass(*args_, **kwargs_)
        else:
            return HHTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HHTime', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HHTime')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HHTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HHTime', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HHTime'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            outfile.write(' rate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rate), input_name='rate')), ))
        if self.midpoint is not None and 'midpoint' not in already_processed:
            already_processed.add('midpoint')
            outfile.write(' midpoint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.midpoint), input_name='midpoint')), ))
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            outfile.write(' scale=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scale), input_name='scale')), ))
        if self.tau is not None and 'tau' not in already_processed:
            already_processed.add('tau')
            outfile.write(' tau=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tau), input_name='tau')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HHTime', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_NmlId(self.type_)    # validate type NmlId
        value = find_attr_value_('rate', node)
        if value is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            self.rate = value
            self.validate_Nml2Quantity_time(self.rate)    # validate type Nml2Quantity_time
        value = find_attr_value_('midpoint', node)
        if value is not None and 'midpoint' not in already_processed:
            already_processed.add('midpoint')
            self.midpoint = value
            self.validate_Nml2Quantity_voltage(self.midpoint)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            self.scale = value
            self.validate_Nml2Quantity_voltage(self.scale)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('tau', node)
        if value is not None and 'tau' not in already_processed:
            already_processed.add('tau')
            self.tau = value
            self.validate_Nml2Quantity_time(self.tau)    # validate type Nml2Quantity_time
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class HHTime


class BlockMechanism(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('type_', 'BlockTypes', 0, 0, {'use': 'required'}),
        MemberSpec_('species', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('blockConcentration', 'Nml2Quantity_concentration', 0, 0, {'use': 'required'}),
        MemberSpec_('scalingConc', 'Nml2Quantity_concentration', 0, 0, {'use': 'required'}),
        MemberSpec_('scalingVolt', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, type_=None, species=None, blockConcentration=None, scalingConc=None, scalingVolt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.species = _cast(None, species)
        self.species_nsprefix_ = None
        self.blockConcentration = _cast(None, blockConcentration)
        self.blockConcentration_nsprefix_ = None
        self.scalingConc = _cast(None, scalingConc)
        self.scalingConc_nsprefix_ = None
        self.scalingVolt = _cast(None, scalingVolt)
        self.scalingVolt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BlockMechanism)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockMechanism.subclass:
            return BlockMechanism.subclass(*args_, **kwargs_)
        else:
            return BlockMechanism(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_BlockTypes(self, value):
        # Validate type BlockTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['voltageConcDepBlockMechanism']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BlockTypes' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_concentration(self, value):
        # Validate type Nml2Quantity_concentration, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_concentration_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_concentration_patterns_, ))
    validate_Nml2Quantity_concentration_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(mol_per_m3|mol_per_cm3|M|mM))$']]
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BlockMechanism', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BlockMechanism')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BlockMechanism')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BlockMechanism', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BlockMechanism'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.species is not None and 'species' not in already_processed:
            already_processed.add('species')
            outfile.write(' species=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.species), input_name='species')), ))
        if self.blockConcentration is not None and 'blockConcentration' not in already_processed:
            already_processed.add('blockConcentration')
            outfile.write(' blockConcentration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.blockConcentration), input_name='blockConcentration')), ))
        if self.scalingConc is not None and 'scalingConc' not in already_processed:
            already_processed.add('scalingConc')
            outfile.write(' scalingConc=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scalingConc), input_name='scalingConc')), ))
        if self.scalingVolt is not None and 'scalingVolt' not in already_processed:
            already_processed.add('scalingVolt')
            outfile.write(' scalingVolt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scalingVolt), input_name='scalingVolt')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BlockMechanism', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_BlockTypes(self.type_)    # validate type BlockTypes
        value = find_attr_value_('species', node)
        if value is not None and 'species' not in already_processed:
            already_processed.add('species')
            self.species = value
            self.validate_NmlId(self.species)    # validate type NmlId
        value = find_attr_value_('blockConcentration', node)
        if value is not None and 'blockConcentration' not in already_processed:
            already_processed.add('blockConcentration')
            self.blockConcentration = value
            self.validate_Nml2Quantity_concentration(self.blockConcentration)    # validate type Nml2Quantity_concentration
        value = find_attr_value_('scalingConc', node)
        if value is not None and 'scalingConc' not in already_processed:
            already_processed.add('scalingConc')
            self.scalingConc = value
            self.validate_Nml2Quantity_concentration(self.scalingConc)    # validate type Nml2Quantity_concentration
        value = find_attr_value_('scalingVolt', node)
        if value is not None and 'scalingVolt' not in already_processed:
            already_processed.add('scalingVolt')
            self.scalingVolt = value
            self.validate_Nml2Quantity_voltage(self.scalingVolt)    # validate type Nml2Quantity_voltage
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BlockMechanism


class PlasticityMechanism(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('type_', 'PlasticityTypes', 0, 0, {'use': 'required'}),
        MemberSpec_('initReleaseProb', 'ZeroToOne', 0, 0, {'use': 'required'}),
        MemberSpec_('tauRec', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('tauFac', 'Nml2Quantity_time', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, type_=None, initReleaseProb=None, tauRec=None, tauFac=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.initReleaseProb = _cast(float, initReleaseProb)
        self.initReleaseProb_nsprefix_ = None
        self.tauRec = _cast(None, tauRec)
        self.tauRec_nsprefix_ = None
        self.tauFac = _cast(None, tauFac)
        self.tauFac_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlasticityMechanism)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlasticityMechanism.subclass:
            return PlasticityMechanism.subclass(*args_, **kwargs_)
        else:
            return PlasticityMechanism(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_PlasticityTypes(self, value):
        # Validate type PlasticityTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['tsodyksMarkramDepMechanism', 'tsodyksMarkramDepFacMechanism']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PlasticityTypes' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ZeroToOne(self, value):
        # Validate type ZeroToOne, a restriction on xs:float.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ZeroToOne' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ZeroToOne' % {"value": value, "lineno": lineno} )
                result = False
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PlasticityMechanism', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PlasticityMechanism')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlasticityMechanism')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PlasticityMechanism', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PlasticityMechanism'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.initReleaseProb is not None and 'initReleaseProb' not in already_processed:
            already_processed.add('initReleaseProb')
            outfile.write(' initReleaseProb="%s"' % self.gds_format_float(self.initReleaseProb, input_name='initReleaseProb'))
        if self.tauRec is not None and 'tauRec' not in already_processed:
            already_processed.add('tauRec')
            outfile.write(' tauRec=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tauRec), input_name='tauRec')), ))
        if self.tauFac is not None and 'tauFac' not in already_processed:
            already_processed.add('tauFac')
            outfile.write(' tauFac=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tauFac), input_name='tauFac')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PlasticityMechanism', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_PlasticityTypes(self.type_)    # validate type PlasticityTypes
        value = find_attr_value_('initReleaseProb', node)
        if value is not None and 'initReleaseProb' not in already_processed:
            already_processed.add('initReleaseProb')
            value = self.gds_parse_float(value, node, 'initReleaseProb')
            self.initReleaseProb = value
            self.validate_ZeroToOne(self.initReleaseProb)    # validate type ZeroToOne
        value = find_attr_value_('tauRec', node)
        if value is not None and 'tauRec' not in already_processed:
            already_processed.add('tauRec')
            self.tauRec = value
            self.validate_Nml2Quantity_time(self.tauRec)    # validate type Nml2Quantity_time
        value = find_attr_value_('tauFac', node)
        if value is not None and 'tauFac' not in already_processed:
            already_processed.add('tauFac')
            self.tauFac = value
            self.validate_Nml2Quantity_time(self.tauFac)    # validate type Nml2Quantity_time
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PlasticityMechanism


class SegmentParent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('segment', 'NonNegativeInteger', 0, 0, {'use': 'required'}),
        MemberSpec_('fractionAlong', 'ZeroToOne', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, segment=None, fractionAlong='1', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.segment = _cast(int, segment)
        self.segment_nsprefix_ = None
        self.fractionAlong = _cast(float, fractionAlong)
        self.fractionAlong_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SegmentParent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SegmentParent.subclass:
            return SegmentParent.subclass(*args_, **kwargs_)
        else:
            return SegmentParent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_ZeroToOne(self, value):
        # Validate type ZeroToOne, a restriction on xs:float.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ZeroToOne' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ZeroToOne' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SegmentParent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SegmentParent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SegmentParent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SegmentParent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SegmentParent'):
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            outfile.write(' segment="%s"' % self.gds_format_integer(self.segment, input_name='segment'))
        if self.fractionAlong != 1 and 'fractionAlong' not in already_processed:
            already_processed.add('fractionAlong')
            outfile.write(' fractionAlong="%s"' % self.gds_format_float(self.fractionAlong, input_name='fractionAlong'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SegmentParent', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            self.segment = self.gds_parse_integer(value, node, 'segment')
            if self.segment < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.segment)    # validate type NonNegativeInteger
        value = find_attr_value_('fractionAlong', node)
        if value is not None and 'fractionAlong' not in already_processed:
            already_processed.add('fractionAlong')
            value = self.gds_parse_float(value, node, 'fractionAlong')
            self.fractionAlong = value
            self.validate_ZeroToOne(self.fractionAlong)    # validate type ZeroToOne
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SegmentParent


class Point3DWithDiam(GeneratedsSuper):
    """A 3D point with diameter."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('x', 'xs:double', 0, 0, {'use': 'required'}),
        MemberSpec_('y', 'xs:double', 0, 0, {'use': 'required'}),
        MemberSpec_('z', 'xs:double', 0, 0, {'use': 'required'}),
        MemberSpec_('diameter', 'DoubleGreaterThanZero', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, x=None, y=None, z=None, diameter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.x = _cast(float, x)
        self.x_nsprefix_ = None
        self.y = _cast(float, y)
        self.y_nsprefix_ = None
        self.z = _cast(float, z)
        self.z_nsprefix_ = None
        self.diameter = _cast(float, diameter)
        self.diameter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Point3DWithDiam)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Point3DWithDiam.subclass:
            return Point3DWithDiam.subclass(*args_, **kwargs_)
        else:
            return Point3DWithDiam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_DoubleGreaterThanZero(self, value):
        # Validate type DoubleGreaterThanZero, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value <= 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on DoubleGreaterThanZero' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Point3DWithDiam', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Point3DWithDiam')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Point3DWithDiam')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Point3DWithDiam', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Point3DWithDiam'):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z="%s"' % self.gds_format_double(self.z, input_name='z'))
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.add('diameter')
            outfile.write(' diameter="%s"' % self.gds_format_double(self.diameter, input_name='diameter'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Point3DWithDiam', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            value = self.gds_parse_double(value, node, 'x')
            self.x = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            value = self.gds_parse_double(value, node, 'y')
            self.y = value
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            value = self.gds_parse_double(value, node, 'z')
            self.z = value
        value = find_attr_value_('diameter', node)
        if value is not None and 'diameter' not in already_processed:
            already_processed.add('diameter')
            value = self.gds_parse_double(value, node, 'diameter')
            self.diameter = value
            self.validate_DoubleGreaterThanZero(self.diameter)    # validate type DoubleGreaterThanZero
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass

    def __str__(self):

        return "("+str(self.x)+", "+str(self.y)+", "+str(self.z)+"), diam "+str(self.diameter)+"um"

    def __repr__(self):

        return str(self)

    def distance_to(self, other_3d_point):
        a_x = self.x
        a_y = self.y
        a_z = self.z

        b_x = other_3d_point.x
        b_y = other_3d_point.y
        b_z = other_3d_point.z

        distance = ((a_x-b_x)**2 + (a_y-b_y)**2 + (a_z-b_z)**2)**(0.5)
        return distance

# end class Point3DWithDiam


class ProximalDetails(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('translationStart', 'xs:double', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, translationStart=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.translationStart = _cast(float, translationStart)
        self.translationStart_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProximalDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProximalDetails.subclass:
            return ProximalDetails.subclass(*args_, **kwargs_)
        else:
            return ProximalDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProximalDetails', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProximalDetails')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProximalDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProximalDetails', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProximalDetails'):
        if self.translationStart is not None and 'translationStart' not in already_processed:
            already_processed.add('translationStart')
            outfile.write(' translationStart="%s"' % self.gds_format_double(self.translationStart, input_name='translationStart'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProximalDetails', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('translationStart', node)
        if value is not None and 'translationStart' not in already_processed:
            already_processed.add('translationStart')
            value = self.gds_parse_double(value, node, 'translationStart')
            self.translationStart = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ProximalDetails


class DistalDetails(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('normalizationEnd', 'xs:double', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, normalizationEnd=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.normalizationEnd = _cast(float, normalizationEnd)
        self.normalizationEnd_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DistalDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DistalDetails.subclass:
            return DistalDetails.subclass(*args_, **kwargs_)
        else:
            return DistalDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DistalDetails', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DistalDetails')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DistalDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DistalDetails', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DistalDetails'):
        if self.normalizationEnd is not None and 'normalizationEnd' not in already_processed:
            already_processed.add('normalizationEnd')
            outfile.write(' normalizationEnd="%s"' % self.gds_format_double(self.normalizationEnd, input_name='normalizationEnd'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DistalDetails', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('normalizationEnd', node)
        if value is not None and 'normalizationEnd' not in already_processed:
            already_processed.add('normalizationEnd')
            value = self.gds_parse_double(value, node, 'normalizationEnd')
            self.normalizationEnd = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DistalDetails


class Member(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('segment', 'NonNegativeInteger', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, segment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.segment = _cast(int, segment)
        self.segment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Member)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Member.subclass:
            return Member.subclass(*args_, **kwargs_)
        else:
            return Member(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Member', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Member')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Member')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Member', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Member'):
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            outfile.write(' segment="%s"' % self.gds_format_integer(self.segment, input_name='segment'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Member', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            self.segment = self.gds_parse_integer(value, node, 'segment')
            if self.segment < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.segment)    # validate type NonNegativeInteger
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Member


class Include(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('segmentGroup', 'NmlId', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, segmentGroup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.segmentGroup = _cast(None, segmentGroup)
        self.segmentGroup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Include)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Include.subclass:
            return Include.subclass(*args_, **kwargs_)
        else:
            return Include(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Include', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Include')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Include')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Include', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Include'):
        if self.segmentGroup is not None and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            outfile.write(' segmentGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segmentGroup), input_name='segmentGroup')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Include', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('segmentGroup', node)
        if value is not None and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            self.segmentGroup = value
            self.validate_NmlId(self.segmentGroup)    # validate type NmlId
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Include


class Path(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('from_', 'SegmentEndPoint', 0, 1, {'minOccurs': '0', 'name': 'from', 'type': 'SegmentEndPoint'}, None),
        MemberSpec_('to', 'SegmentEndPoint', 0, 1, {'minOccurs': '0', 'name': 'to', 'type': 'SegmentEndPoint'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, from_=None, to=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.from_ = from_
        self.from__nsprefix_ = None
        self.to = to
        self.to_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Path)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Path.subclass:
            return Path.subclass(*args_, **kwargs_)
        else:
            return Path(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.from_ is not None or
            self.to is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='Path', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Path')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Path')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Path', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Path'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='Path', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.from_ is not None:
            namespaceprefix_ = self.from__nsprefix_ + ':' if (UseCapturedNS_ and self.from__nsprefix_) else ''
            self.from_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='from', pretty_print=pretty_print)
        if self.to is not None:
            namespaceprefix_ = self.to_nsprefix_ + ':' if (UseCapturedNS_ and self.to_nsprefix_) else ''
            self.to.export(outfile, level, namespaceprefix_, namespacedef_='', name_='to', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'from':
            obj_ = SegmentEndPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.from_ = obj_
            obj_.original_tagname_ = 'from'
        elif nodeName_ == 'to':
            obj_ = SegmentEndPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.to = obj_
            obj_.original_tagname_ = 'to'
# end class Path


class SubTree(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('from_', 'SegmentEndPoint', 0, 1, {'minOccurs': '0', 'name': 'from', 'type': 'SegmentEndPoint'}, 3),
        MemberSpec_('to', 'SegmentEndPoint', 0, 1, {'minOccurs': '0', 'name': 'to', 'type': 'SegmentEndPoint'}, 3),
    ]
    subclass = None
    superclass = None
    def __init__(self, from_=None, to=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.from_ = from_
        self.from__nsprefix_ = None
        self.to = to
        self.to_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubTree)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubTree.subclass:
            return SubTree.subclass(*args_, **kwargs_)
        else:
            return SubTree(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.from_ is not None or
            self.to is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='SubTree', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubTree')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubTree')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubTree', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubTree'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='SubTree', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.from_ is not None:
            namespaceprefix_ = self.from__nsprefix_ + ':' if (UseCapturedNS_ and self.from__nsprefix_) else ''
            self.from_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='from', pretty_print=pretty_print)
        if self.to is not None:
            namespaceprefix_ = self.to_nsprefix_ + ':' if (UseCapturedNS_ and self.to_nsprefix_) else ''
            self.to.export(outfile, level, namespaceprefix_, namespacedef_='', name_='to', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'from':
            obj_ = SegmentEndPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.from_ = obj_
            obj_.original_tagname_ = 'from'
        elif nodeName_ == 'to':
            obj_ = SegmentEndPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.to = obj_
            obj_.original_tagname_ = 'to'
# end class SubTree


class SegmentEndPoint(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('segment', 'NonNegativeInteger', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, segment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.segment = _cast(int, segment)
        self.segment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SegmentEndPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SegmentEndPoint.subclass:
            return SegmentEndPoint.subclass(*args_, **kwargs_)
        else:
            return SegmentEndPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SegmentEndPoint', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SegmentEndPoint')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SegmentEndPoint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SegmentEndPoint', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SegmentEndPoint'):
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            outfile.write(' segment="%s"' % self.gds_format_integer(self.segment, input_name='segment'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SegmentEndPoint', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            self.segment = self.gds_parse_integer(value, node, 'segment')
            if self.segment < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.segment)    # validate type NonNegativeInteger
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SegmentEndPoint


class MembraneProperties(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('channelPopulation', 'ChannelPopulation', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'channelPopulation', 'type': 'ChannelPopulation'}, None),
        MemberSpec_('channelDensity', 'ChannelDensity', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'channelDensity', 'type': 'ChannelDensity'}, None),
        MemberSpec_('channelDensityVShift', 'ChannelDensityVShift', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'channelDensityVShift', 'type': 'ChannelDensityVShift'}, None),
        MemberSpec_('channelDensityNernst', 'ChannelDensityNernst', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'channelDensityNernst', 'type': 'ChannelDensityNernst'}, None),
        MemberSpec_('channelDensityGHK', 'ChannelDensityGHK', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'channelDensityGHK', 'type': 'ChannelDensityGHK'}, None),
        MemberSpec_('channelDensityGHK2', 'ChannelDensityGHK2', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'channelDensityGHK2', 'type': 'ChannelDensityGHK2'}, None),
        MemberSpec_('channelDensityNonUniform', 'ChannelDensityNonUniform', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'channelDensityNonUniform', 'type': 'ChannelDensityNonUniform'}, None),
        MemberSpec_('channelDensityNonUniformNernst', 'ChannelDensityNonUniformNernst', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'channelDensityNonUniformNernst', 'type': 'ChannelDensityNonUniformNernst'}, None),
        MemberSpec_('channelDensityNonUniformGHK', 'ChannelDensityNonUniformGHK', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'channelDensityNonUniformGHK', 'type': 'ChannelDensityNonUniformGHK'}, None),
        MemberSpec_('spikeThresh', 'SpikeThresh', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'spikeThresh', 'type': 'SpikeThresh'}, None),
        MemberSpec_('specificCapacitance', 'SpecificCapacitance', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'specificCapacitance', 'type': 'SpecificCapacitance'}, None),
        MemberSpec_('initMembPotential', 'InitMembPotential', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'initMembPotential', 'type': 'InitMembPotential'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, channelPopulation=None, channelDensity=None, channelDensityVShift=None, channelDensityNernst=None, channelDensityGHK=None, channelDensityGHK2=None, channelDensityNonUniform=None, channelDensityNonUniformNernst=None, channelDensityNonUniformGHK=None, spikeThresh=None, specificCapacitance=None, initMembPotential=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if channelPopulation is None:
            self.channelPopulation = []
        else:
            self.channelPopulation = channelPopulation
        self.channelPopulation_nsprefix_ = None
        if channelDensity is None:
            self.channelDensity = []
        else:
            self.channelDensity = channelDensity
        self.channelDensity_nsprefix_ = None
        if channelDensityVShift is None:
            self.channelDensityVShift = []
        else:
            self.channelDensityVShift = channelDensityVShift
        self.channelDensityVShift_nsprefix_ = None
        if channelDensityNernst is None:
            self.channelDensityNernst = []
        else:
            self.channelDensityNernst = channelDensityNernst
        self.channelDensityNernst_nsprefix_ = None
        if channelDensityGHK is None:
            self.channelDensityGHK = []
        else:
            self.channelDensityGHK = channelDensityGHK
        self.channelDensityGHK_nsprefix_ = None
        if channelDensityGHK2 is None:
            self.channelDensityGHK2 = []
        else:
            self.channelDensityGHK2 = channelDensityGHK2
        self.channelDensityGHK2_nsprefix_ = None
        if channelDensityNonUniform is None:
            self.channelDensityNonUniform = []
        else:
            self.channelDensityNonUniform = channelDensityNonUniform
        self.channelDensityNonUniform_nsprefix_ = None
        if channelDensityNonUniformNernst is None:
            self.channelDensityNonUniformNernst = []
        else:
            self.channelDensityNonUniformNernst = channelDensityNonUniformNernst
        self.channelDensityNonUniformNernst_nsprefix_ = None
        if channelDensityNonUniformGHK is None:
            self.channelDensityNonUniformGHK = []
        else:
            self.channelDensityNonUniformGHK = channelDensityNonUniformGHK
        self.channelDensityNonUniformGHK_nsprefix_ = None
        if spikeThresh is None:
            self.spikeThresh = []
        else:
            self.spikeThresh = spikeThresh
        self.spikeThresh_nsprefix_ = None
        if specificCapacitance is None:
            self.specificCapacitance = []
        else:
            self.specificCapacitance = specificCapacitance
        self.specificCapacitance_nsprefix_ = None
        if initMembPotential is None:
            self.initMembPotential = []
        else:
            self.initMembPotential = initMembPotential
        self.initMembPotential_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MembraneProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MembraneProperties.subclass:
            return MembraneProperties.subclass(*args_, **kwargs_)
        else:
            return MembraneProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.channelPopulation or
            self.channelDensity or
            self.channelDensityVShift or
            self.channelDensityNernst or
            self.channelDensityGHK or
            self.channelDensityGHK2 or
            self.channelDensityNonUniform or
            self.channelDensityNonUniformNernst or
            self.channelDensityNonUniformGHK or
            self.spikeThresh or
            self.specificCapacitance or
            self.initMembPotential
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='MembraneProperties', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MembraneProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MembraneProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MembraneProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MembraneProperties'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='MembraneProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for channelPopulation_ in self.channelPopulation:
            namespaceprefix_ = self.channelPopulation_nsprefix_ + ':' if (UseCapturedNS_ and self.channelPopulation_nsprefix_) else ''
            channelPopulation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='channelPopulation', pretty_print=pretty_print)
        for channelDensity_ in self.channelDensity:
            namespaceprefix_ = self.channelDensity_nsprefix_ + ':' if (UseCapturedNS_ and self.channelDensity_nsprefix_) else ''
            channelDensity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='channelDensity', pretty_print=pretty_print)
        for channelDensityVShift_ in self.channelDensityVShift:
            namespaceprefix_ = self.channelDensityVShift_nsprefix_ + ':' if (UseCapturedNS_ and self.channelDensityVShift_nsprefix_) else ''
            channelDensityVShift_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='channelDensityVShift', pretty_print=pretty_print)
        for channelDensityNernst_ in self.channelDensityNernst:
            namespaceprefix_ = self.channelDensityNernst_nsprefix_ + ':' if (UseCapturedNS_ and self.channelDensityNernst_nsprefix_) else ''
            channelDensityNernst_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='channelDensityNernst', pretty_print=pretty_print)
        for channelDensityGHK_ in self.channelDensityGHK:
            namespaceprefix_ = self.channelDensityGHK_nsprefix_ + ':' if (UseCapturedNS_ and self.channelDensityGHK_nsprefix_) else ''
            channelDensityGHK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='channelDensityGHK', pretty_print=pretty_print)
        for channelDensityGHK2_ in self.channelDensityGHK2:
            namespaceprefix_ = self.channelDensityGHK2_nsprefix_ + ':' if (UseCapturedNS_ and self.channelDensityGHK2_nsprefix_) else ''
            channelDensityGHK2_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='channelDensityGHK2', pretty_print=pretty_print)
        for channelDensityNonUniform_ in self.channelDensityNonUniform:
            namespaceprefix_ = self.channelDensityNonUniform_nsprefix_ + ':' if (UseCapturedNS_ and self.channelDensityNonUniform_nsprefix_) else ''
            channelDensityNonUniform_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='channelDensityNonUniform', pretty_print=pretty_print)
        for channelDensityNonUniformNernst_ in self.channelDensityNonUniformNernst:
            namespaceprefix_ = self.channelDensityNonUniformNernst_nsprefix_ + ':' if (UseCapturedNS_ and self.channelDensityNonUniformNernst_nsprefix_) else ''
            channelDensityNonUniformNernst_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='channelDensityNonUniformNernst', pretty_print=pretty_print)
        for channelDensityNonUniformGHK_ in self.channelDensityNonUniformGHK:
            namespaceprefix_ = self.channelDensityNonUniformGHK_nsprefix_ + ':' if (UseCapturedNS_ and self.channelDensityNonUniformGHK_nsprefix_) else ''
            channelDensityNonUniformGHK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='channelDensityNonUniformGHK', pretty_print=pretty_print)
        for spikeThresh_ in self.spikeThresh:
            namespaceprefix_ = self.spikeThresh_nsprefix_ + ':' if (UseCapturedNS_ and self.spikeThresh_nsprefix_) else ''
            spikeThresh_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spikeThresh', pretty_print=pretty_print)
        for specificCapacitance_ in self.specificCapacitance:
            namespaceprefix_ = self.specificCapacitance_nsprefix_ + ':' if (UseCapturedNS_ and self.specificCapacitance_nsprefix_) else ''
            specificCapacitance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='specificCapacitance', pretty_print=pretty_print)
        for initMembPotential_ in self.initMembPotential:
            namespaceprefix_ = self.initMembPotential_nsprefix_ + ':' if (UseCapturedNS_ and self.initMembPotential_nsprefix_) else ''
            initMembPotential_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='initMembPotential', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'channelPopulation':
            obj_ = ChannelPopulation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channelPopulation.append(obj_)
            obj_.original_tagname_ = 'channelPopulation'
        elif nodeName_ == 'channelDensity':
            class_obj_ = self.get_class_obj_(child_, ChannelDensity)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channelDensity.append(obj_)
            obj_.original_tagname_ = 'channelDensity'
        elif nodeName_ == 'channelDensityVShift':
            obj_ = ChannelDensityVShift.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channelDensityVShift.append(obj_)
            obj_.original_tagname_ = 'channelDensityVShift'
        elif nodeName_ == 'channelDensityNernst':
            class_obj_ = self.get_class_obj_(child_, ChannelDensityNernst)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channelDensityNernst.append(obj_)
            obj_.original_tagname_ = 'channelDensityNernst'
        elif nodeName_ == 'channelDensityGHK':
            obj_ = ChannelDensityGHK.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channelDensityGHK.append(obj_)
            obj_.original_tagname_ = 'channelDensityGHK'
        elif nodeName_ == 'channelDensityGHK2':
            obj_ = ChannelDensityGHK2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channelDensityGHK2.append(obj_)
            obj_.original_tagname_ = 'channelDensityGHK2'
        elif nodeName_ == 'channelDensityNonUniform':
            obj_ = ChannelDensityNonUniform.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channelDensityNonUniform.append(obj_)
            obj_.original_tagname_ = 'channelDensityNonUniform'
        elif nodeName_ == 'channelDensityNonUniformNernst':
            obj_ = ChannelDensityNonUniformNernst.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channelDensityNonUniformNernst.append(obj_)
            obj_.original_tagname_ = 'channelDensityNonUniformNernst'
        elif nodeName_ == 'channelDensityNonUniformGHK':
            obj_ = ChannelDensityNonUniformGHK.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channelDensityNonUniformGHK.append(obj_)
            obj_.original_tagname_ = 'channelDensityNonUniformGHK'
        elif nodeName_ == 'spikeThresh':
            obj_ = SpikeThresh.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spikeThresh.append(obj_)
            obj_.original_tagname_ = 'spikeThresh'
        elif nodeName_ == 'specificCapacitance':
            obj_ = SpecificCapacitance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.specificCapacitance.append(obj_)
            obj_.original_tagname_ = 'specificCapacitance'
        elif nodeName_ == 'initMembPotential':
            obj_ = InitMembPotential.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.initMembPotential.append(obj_)
            obj_.original_tagname_ = 'initMembPotential'
# end class MembraneProperties


class MembraneProperties2CaPools(MembraneProperties):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('channelDensityNernstCa2', 'ChannelDensityNernstCa2', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'channelDensityNernstCa2', 'type': 'ChannelDensityNernstCa2'}, None),
    ]
    subclass = None
    superclass = MembraneProperties
    def __init__(self, channelPopulation=None, channelDensity=None, channelDensityVShift=None, channelDensityNernst=None, channelDensityGHK=None, channelDensityGHK2=None, channelDensityNonUniform=None, channelDensityNonUniformNernst=None, channelDensityNonUniformGHK=None, spikeThresh=None, specificCapacitance=None, initMembPotential=None, channelDensityNernstCa2=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MembraneProperties2CaPools, self).__init__(channelPopulation, channelDensity, channelDensityVShift, channelDensityNernst, channelDensityGHK, channelDensityGHK2, channelDensityNonUniform, channelDensityNonUniformNernst, channelDensityNonUniformGHK, spikeThresh, specificCapacitance, initMembPotential,  **kwargs_)
        if channelDensityNernstCa2 is None:
            self.channelDensityNernstCa2 = []
        else:
            self.channelDensityNernstCa2 = channelDensityNernstCa2
        self.channelDensityNernstCa2_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MembraneProperties2CaPools)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MembraneProperties2CaPools.subclass:
            return MembraneProperties2CaPools.subclass(*args_, **kwargs_)
        else:
            return MembraneProperties2CaPools(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.channelDensityNernstCa2 or
            super(MembraneProperties2CaPools, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='MembraneProperties2CaPools', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MembraneProperties2CaPools')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MembraneProperties2CaPools')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MembraneProperties2CaPools', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MembraneProperties2CaPools'):
        super(MembraneProperties2CaPools, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MembraneProperties2CaPools')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='MembraneProperties2CaPools', fromsubclass_=False, pretty_print=True):
        super(MembraneProperties2CaPools, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for channelDensityNernstCa2_ in self.channelDensityNernstCa2:
            namespaceprefix_ = self.channelDensityNernstCa2_nsprefix_ + ':' if (UseCapturedNS_ and self.channelDensityNernstCa2_nsprefix_) else ''
            channelDensityNernstCa2_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='channelDensityNernstCa2', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MembraneProperties2CaPools, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'channelDensityNernstCa2':
            obj_ = ChannelDensityNernstCa2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channelDensityNernstCa2.append(obj_)
            obj_.original_tagname_ = 'channelDensityNernstCa2'
        super(MembraneProperties2CaPools, self).buildChildren(child_, node, nodeName_, True)
# end class MembraneProperties2CaPools


class ValueAcrossSegOrSegGroup(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('value', 'Nml2Quantity', 0, 1, {'use': 'optional'}),
        MemberSpec_('segmentGroup', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('segment', 'NmlId', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, value=None, segmentGroup='all', segment=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.segmentGroup = _cast(None, segmentGroup)
        self.segmentGroup_nsprefix_ = None
        self.segment = _cast(None, segment)
        self.segment_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueAcrossSegOrSegGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueAcrossSegOrSegGroup.subclass:
            return ValueAcrossSegOrSegGroup.subclass(*args_, **kwargs_)
        else:
            return ValueAcrossSegOrSegGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity(self, value):
        # Validate type Nml2Quantity, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_patterns_, ))
    validate_Nml2Quantity_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*([_a-zA-Z0-9])*)$']]
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ValueAcrossSegOrSegGroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValueAcrossSegOrSegGroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ValueAcrossSegOrSegGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ValueAcrossSegOrSegGroup', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ValueAcrossSegOrSegGroup'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.segmentGroup != "all" and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            outfile.write(' segmentGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segmentGroup), input_name='segmentGroup')), ))
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            outfile.write(' segment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segment), input_name='segment')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ValueAcrossSegOrSegGroup', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_Nml2Quantity(self.value)    # validate type Nml2Quantity
        value = find_attr_value_('segmentGroup', node)
        if value is not None and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            self.segmentGroup = value
            self.validate_NmlId(self.segmentGroup)    # validate type NmlId
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            self.segment = value
            self.validate_NmlId(self.segment)    # validate type NmlId
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ValueAcrossSegOrSegGroup


class VariableParameter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('parameter', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('segmentGroup', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('inhomogeneousValue', 'InhomogeneousValue', 0, 1, {'minOccurs': '0', 'name': 'inhomogeneousValue', 'type': 'InhomogeneousValue'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, parameter=None, segmentGroup=None, inhomogeneousValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.parameter = _cast(None, parameter)
        self.parameter_nsprefix_ = None
        self.segmentGroup = _cast(None, segmentGroup)
        self.segmentGroup_nsprefix_ = None
        self.inhomogeneousValue = inhomogeneousValue
        self.inhomogeneousValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableParameter.subclass:
            return VariableParameter.subclass(*args_, **kwargs_)
        else:
            return VariableParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.inhomogeneousValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='VariableParameter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariableParameter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VariableParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VariableParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VariableParameter'):
        if self.parameter is not None and 'parameter' not in already_processed:
            already_processed.add('parameter')
            outfile.write(' parameter=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parameter), input_name='parameter')), ))
        if self.segmentGroup is not None and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            outfile.write(' segmentGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segmentGroup), input_name='segmentGroup')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='VariableParameter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.inhomogeneousValue is not None:
            namespaceprefix_ = self.inhomogeneousValue_nsprefix_ + ':' if (UseCapturedNS_ and self.inhomogeneousValue_nsprefix_) else ''
            self.inhomogeneousValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inhomogeneousValue', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameter', node)
        if value is not None and 'parameter' not in already_processed:
            already_processed.add('parameter')
            self.parameter = value
        value = find_attr_value_('segmentGroup', node)
        if value is not None and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            self.segmentGroup = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'inhomogeneousValue':
            obj_ = InhomogeneousValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inhomogeneousValue = obj_
            obj_.original_tagname_ = 'inhomogeneousValue'
# end class VariableParameter


class InhomogeneousValue(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('inhomogeneousParameter', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('value', 'xs:string', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, inhomogeneousParameter=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.inhomogeneousParameter = _cast(None, inhomogeneousParameter)
        self.inhomogeneousParameter_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InhomogeneousValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InhomogeneousValue.subclass:
            return InhomogeneousValue.subclass(*args_, **kwargs_)
        else:
            return InhomogeneousValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InhomogeneousValue', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InhomogeneousValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InhomogeneousValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InhomogeneousValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InhomogeneousValue'):
        if self.inhomogeneousParameter is not None and 'inhomogeneousParameter' not in already_processed:
            already_processed.add('inhomogeneousParameter')
            outfile.write(' inhomogeneousParameter=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.inhomogeneousParameter), input_name='inhomogeneousParameter')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InhomogeneousValue', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inhomogeneousParameter', node)
        if value is not None and 'inhomogeneousParameter' not in already_processed:
            already_processed.add('inhomogeneousParameter')
            self.inhomogeneousParameter = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class InhomogeneousValue


class Species(ValueAcrossSegOrSegGroup):
    """Specifying the ion here again is redundant, the ion name should be the
    same as id. Kept for now
    until LEMS implementation can select by id. TODO: remove."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('concentrationModel', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('ion', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('initialConcentration', 'Nml2Quantity_concentration', 0, 0, {'use': 'required'}),
        MemberSpec_('initialExtConcentration', 'Nml2Quantity_concentration', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = ValueAcrossSegOrSegGroup
    def __init__(self, value=None, segmentGroup='all', segment=None, id=None, concentrationModel=None, ion=None, initialConcentration=None, initialExtConcentration=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Species, self).__init__(value, segmentGroup, segment,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.concentrationModel = _cast(None, concentrationModel)
        self.concentrationModel_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        self.initialConcentration = _cast(None, initialConcentration)
        self.initialConcentration_nsprefix_ = None
        self.initialExtConcentration = _cast(None, initialExtConcentration)
        self.initialExtConcentration_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Species)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Species.subclass:
            return Species.subclass(*args_, **kwargs_)
        else:
            return Species(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_concentration(self, value):
        # Validate type Nml2Quantity_concentration, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_concentration_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_concentration_patterns_, ))
    validate_Nml2Quantity_concentration_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(mol_per_m3|mol_per_cm3|M|mM))$']]
    def hasContent_(self):
        if (
            super(Species, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Species', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Species')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Species')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Species', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Species'):
        super(Species, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Species')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.concentrationModel is not None and 'concentrationModel' not in already_processed:
            already_processed.add('concentrationModel')
            outfile.write(' concentrationModel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.concentrationModel), input_name='concentrationModel')), ))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            outfile.write(' ion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ion), input_name='ion')), ))
        if self.initialConcentration is not None and 'initialConcentration' not in already_processed:
            already_processed.add('initialConcentration')
            outfile.write(' initialConcentration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.initialConcentration), input_name='initialConcentration')), ))
        if self.initialExtConcentration is not None and 'initialExtConcentration' not in already_processed:
            already_processed.add('initialExtConcentration')
            outfile.write(' initialExtConcentration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.initialExtConcentration), input_name='initialExtConcentration')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Species', fromsubclass_=False, pretty_print=True):
        super(Species, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_NmlId(self.id)    # validate type NmlId
        value = find_attr_value_('concentrationModel', node)
        if value is not None and 'concentrationModel' not in already_processed:
            already_processed.add('concentrationModel')
            self.concentrationModel = value
            self.validate_NmlId(self.concentrationModel)    # validate type NmlId
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            self.ion = value
            self.validate_NmlId(self.ion)    # validate type NmlId
        value = find_attr_value_('initialConcentration', node)
        if value is not None and 'initialConcentration' not in already_processed:
            already_processed.add('initialConcentration')
            self.initialConcentration = value
            self.validate_Nml2Quantity_concentration(self.initialConcentration)    # validate type Nml2Quantity_concentration
        value = find_attr_value_('initialExtConcentration', node)
        if value is not None and 'initialExtConcentration' not in already_processed:
            already_processed.add('initialExtConcentration')
            self.initialExtConcentration = value
            self.validate_Nml2Quantity_concentration(self.initialExtConcentration)    # validate type Nml2Quantity_concentration
        super(Species, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(Species, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Species


class IntracellularProperties(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('species', 'Species', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'species', 'type': 'Species'}, None),
        MemberSpec_('resistivity', 'Resistivity', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'resistivity', 'type': 'Resistivity'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, species=None, resistivity=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if species is None:
            self.species = []
        else:
            self.species = species
        self.species_nsprefix_ = None
        if resistivity is None:
            self.resistivity = []
        else:
            self.resistivity = resistivity
        self.resistivity_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntracellularProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntracellularProperties.subclass:
            return IntracellularProperties.subclass(*args_, **kwargs_)
        else:
            return IntracellularProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.species or
            self.resistivity
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='IntracellularProperties', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IntracellularProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IntracellularProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IntracellularProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IntracellularProperties'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='IntracellularProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for species_ in self.species:
            namespaceprefix_ = self.species_nsprefix_ + ':' if (UseCapturedNS_ and self.species_nsprefix_) else ''
            species_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='species', pretty_print=pretty_print)
        for resistivity_ in self.resistivity:
            namespaceprefix_ = self.resistivity_nsprefix_ + ':' if (UseCapturedNS_ and self.resistivity_nsprefix_) else ''
            resistivity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='resistivity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'species':
            obj_ = Species.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.species.append(obj_)
            obj_.original_tagname_ = 'species'
        elif nodeName_ == 'resistivity':
            obj_ = Resistivity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.resistivity.append(obj_)
            obj_.original_tagname_ = 'resistivity'
# end class IntracellularProperties


class IntracellularProperties2CaPools(IntracellularProperties):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = IntracellularProperties
    def __init__(self, species=None, resistivity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IntracellularProperties2CaPools, self).__init__(species, resistivity,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntracellularProperties2CaPools)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntracellularProperties2CaPools.subclass:
            return IntracellularProperties2CaPools.subclass(*args_, **kwargs_)
        else:
            return IntracellularProperties2CaPools(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(IntracellularProperties2CaPools, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IntracellularProperties2CaPools', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IntracellularProperties2CaPools')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IntracellularProperties2CaPools')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IntracellularProperties2CaPools', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IntracellularProperties2CaPools'):
        super(IntracellularProperties2CaPools, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IntracellularProperties2CaPools')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IntracellularProperties2CaPools', fromsubclass_=False, pretty_print=True):
        super(IntracellularProperties2CaPools, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IntracellularProperties2CaPools, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IntracellularProperties2CaPools, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IntracellularProperties2CaPools


class ExtracellularPropertiesLocal(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('species', 'Species', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'species', 'type': 'Species'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, species=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if species is None:
            self.species = []
        else:
            self.species = species
        self.species_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtracellularPropertiesLocal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtracellularPropertiesLocal.subclass:
            return ExtracellularPropertiesLocal.subclass(*args_, **kwargs_)
        else:
            return ExtracellularPropertiesLocal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.species
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='ExtracellularPropertiesLocal', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExtracellularPropertiesLocal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExtracellularPropertiesLocal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExtracellularPropertiesLocal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExtracellularPropertiesLocal'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='ExtracellularPropertiesLocal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for species_ in self.species:
            namespaceprefix_ = self.species_nsprefix_ + ':' if (UseCapturedNS_ and self.species_nsprefix_) else ''
            species_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='species', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'species':
            obj_ = Species.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.species.append(obj_)
            obj_.original_tagname_ = 'species'
# end class ExtracellularPropertiesLocal


class SpaceStructure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('xSpacing', 'xs:float', 0, 1, {'use': 'optional'}),
        MemberSpec_('ySpacing', 'xs:float', 0, 1, {'use': 'optional'}),
        MemberSpec_('zSpacing', 'xs:float', 0, 1, {'use': 'optional'}),
        MemberSpec_('xStart', 'xs:float', 0, 1, {'use': 'optional'}),
        MemberSpec_('yStart', 'xs:float', 0, 1, {'use': 'optional'}),
        MemberSpec_('zStart', 'xs:float', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, xSpacing=None, ySpacing=None, zSpacing=None, xStart=0, yStart=0, zStart=0, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xSpacing = _cast(float, xSpacing)
        self.xSpacing_nsprefix_ = None
        self.ySpacing = _cast(float, ySpacing)
        self.ySpacing_nsprefix_ = None
        self.zSpacing = _cast(float, zSpacing)
        self.zSpacing_nsprefix_ = None
        self.xStart = _cast(float, xStart)
        self.xStart_nsprefix_ = None
        self.yStart = _cast(float, yStart)
        self.yStart_nsprefix_ = None
        self.zStart = _cast(float, zStart)
        self.zStart_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpaceStructure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpaceStructure.subclass:
            return SpaceStructure.subclass(*args_, **kwargs_)
        else:
            return SpaceStructure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpaceStructure', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpaceStructure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpaceStructure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpaceStructure', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpaceStructure'):
        if self.xSpacing is not None and 'xSpacing' not in already_processed:
            already_processed.add('xSpacing')
            outfile.write(' xSpacing="%s"' % self.gds_format_float(self.xSpacing, input_name='xSpacing'))
        if self.ySpacing is not None and 'ySpacing' not in already_processed:
            already_processed.add('ySpacing')
            outfile.write(' ySpacing="%s"' % self.gds_format_float(self.ySpacing, input_name='ySpacing'))
        if self.zSpacing is not None and 'zSpacing' not in already_processed:
            already_processed.add('zSpacing')
            outfile.write(' zSpacing="%s"' % self.gds_format_float(self.zSpacing, input_name='zSpacing'))
        if self.xStart != 0 and 'xStart' not in already_processed:
            already_processed.add('xStart')
            outfile.write(' xStart="%s"' % self.gds_format_float(self.xStart, input_name='xStart'))
        if self.yStart != 0 and 'yStart' not in already_processed:
            already_processed.add('yStart')
            outfile.write(' yStart="%s"' % self.gds_format_float(self.yStart, input_name='yStart'))
        if self.zStart != 0 and 'zStart' not in already_processed:
            already_processed.add('zStart')
            outfile.write(' zStart="%s"' % self.gds_format_float(self.zStart, input_name='zStart'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpaceStructure', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xSpacing', node)
        if value is not None and 'xSpacing' not in already_processed:
            already_processed.add('xSpacing')
            value = self.gds_parse_float(value, node, 'xSpacing')
            self.xSpacing = value
        value = find_attr_value_('ySpacing', node)
        if value is not None and 'ySpacing' not in already_processed:
            already_processed.add('ySpacing')
            value = self.gds_parse_float(value, node, 'ySpacing')
            self.ySpacing = value
        value = find_attr_value_('zSpacing', node)
        if value is not None and 'zSpacing' not in already_processed:
            already_processed.add('zSpacing')
            value = self.gds_parse_float(value, node, 'zSpacing')
            self.zSpacing = value
        value = find_attr_value_('xStart', node)
        if value is not None and 'xStart' not in already_processed:
            already_processed.add('xStart')
            value = self.gds_parse_float(value, node, 'xStart')
            self.xStart = value
        value = find_attr_value_('yStart', node)
        if value is not None and 'yStart' not in already_processed:
            already_processed.add('yStart')
            value = self.gds_parse_float(value, node, 'yStart')
            self.yStart = value
        value = find_attr_value_('zStart', node)
        if value is not None and 'zStart' not in already_processed:
            already_processed.add('zStart')
            value = self.gds_parse_float(value, node, 'zStart')
            self.zStart = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SpaceStructure


class Layout(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('space', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('random', 'RandomLayout', 0, 0, {'name': 'random', 'type': 'RandomLayout'}, 5),
        MemberSpec_('grid', 'GridLayout', 0, 0, {'name': 'grid', 'type': 'GridLayout'}, 5),
        MemberSpec_('unstructured', 'UnstructuredLayout', 0, 0, {'name': 'unstructured', 'type': 'UnstructuredLayout'}, 5),
    ]
    subclass = None
    superclass = None
    def __init__(self, space=None, random=None, grid=None, unstructured=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.space = _cast(None, space)
        self.space_nsprefix_ = None
        self.random = random
        self.random_nsprefix_ = None
        self.grid = grid
        self.grid_nsprefix_ = None
        self.unstructured = unstructured
        self.unstructured_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Layout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Layout.subclass:
            return Layout.subclass(*args_, **kwargs_)
        else:
            return Layout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            self.random is not None or
            self.grid is not None or
            self.unstructured is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='Layout', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Layout')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Layout')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Layout', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Layout'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='Layout', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.random is not None:
            namespaceprefix_ = self.random_nsprefix_ + ':' if (UseCapturedNS_ and self.random_nsprefix_) else ''
            self.random.export(outfile, level, namespaceprefix_, namespacedef_='', name_='random', pretty_print=pretty_print)
        if self.grid is not None:
            namespaceprefix_ = self.grid_nsprefix_ + ':' if (UseCapturedNS_ and self.grid_nsprefix_) else ''
            self.grid.export(outfile, level, namespaceprefix_, namespacedef_='', name_='grid', pretty_print=pretty_print)
        if self.unstructured is not None:
            namespaceprefix_ = self.unstructured_nsprefix_ + ':' if (UseCapturedNS_ and self.unstructured_nsprefix_) else ''
            self.unstructured.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unstructured', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
            self.validate_NmlId(self.space)    # validate type NmlId
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'random':
            obj_ = RandomLayout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.random = obj_
            obj_.original_tagname_ = 'random'
        elif nodeName_ == 'grid':
            obj_ = GridLayout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.grid = obj_
            obj_.original_tagname_ = 'grid'
        elif nodeName_ == 'unstructured':
            obj_ = UnstructuredLayout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unstructured = obj_
            obj_.original_tagname_ = 'unstructured'
# end class Layout


class UnstructuredLayout(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('number', 'xs:nonNegativeInteger', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, number=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnstructuredLayout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnstructuredLayout.subclass:
            return UnstructuredLayout.subclass(*args_, **kwargs_)
        else:
            return UnstructuredLayout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UnstructuredLayout', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnstructuredLayout')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnstructuredLayout')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnstructuredLayout', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UnstructuredLayout'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UnstructuredLayout', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class UnstructuredLayout


class RandomLayout(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('number', 'xs:nonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('region', 'NmlId', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, number=None, region=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.region = _cast(None, region)
        self.region_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RandomLayout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RandomLayout.subclass:
            return RandomLayout.subclass(*args_, **kwargs_)
        else:
            return RandomLayout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RandomLayout', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RandomLayout')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RandomLayout')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RandomLayout', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RandomLayout'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.region is not None and 'region' not in already_processed:
            already_processed.add('region')
            outfile.write(' region=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.region), input_name='region')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RandomLayout', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('region', node)
        if value is not None and 'region' not in already_processed:
            already_processed.add('region')
            self.region = value
            self.validate_NmlId(self.region)    # validate type NmlId
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RandomLayout


class GridLayout(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('xSize', 'xs:nonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('ySize', 'xs:nonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('zSize', 'xs:nonNegativeInteger', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, xSize=None, ySize=None, zSize=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xSize = _cast(int, xSize)
        self.xSize_nsprefix_ = None
        self.ySize = _cast(int, ySize)
        self.ySize_nsprefix_ = None
        self.zSize = _cast(int, zSize)
        self.zSize_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GridLayout)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GridLayout.subclass:
            return GridLayout.subclass(*args_, **kwargs_)
        else:
            return GridLayout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GridLayout', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GridLayout')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GridLayout')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GridLayout', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GridLayout'):
        if self.xSize is not None and 'xSize' not in already_processed:
            already_processed.add('xSize')
            outfile.write(' xSize="%s"' % self.gds_format_integer(self.xSize, input_name='xSize'))
        if self.ySize is not None and 'ySize' not in already_processed:
            already_processed.add('ySize')
            outfile.write(' ySize="%s"' % self.gds_format_integer(self.ySize, input_name='ySize'))
        if self.zSize is not None and 'zSize' not in already_processed:
            already_processed.add('zSize')
            outfile.write(' zSize="%s"' % self.gds_format_integer(self.zSize, input_name='zSize'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GridLayout', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xSize', node)
        if value is not None and 'xSize' not in already_processed:
            already_processed.add('xSize')
            self.xSize = self.gds_parse_integer(value, node, 'xSize')
            if self.xSize < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('ySize', node)
        if value is not None and 'ySize' not in already_processed:
            already_processed.add('ySize')
            self.ySize = self.gds_parse_integer(value, node, 'ySize')
            if self.ySize < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('zSize', node)
        if value is not None and 'zSize' not in already_processed:
            already_processed.add('zSize')
            self.zSize = self.gds_parse_integer(value, node, 'zSize')
            if self.zSize < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class GridLayout


class Instance(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:nonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('i', 'xs:nonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('j', 'xs:nonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('k', 'xs:nonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('location', 'Location', 0, 0, {'name': 'location', 'type': 'Location'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, i=None, j=None, k=None, location=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.i = _cast(int, i)
        self.i_nsprefix_ = None
        self.j = _cast(int, j)
        self.j_nsprefix_ = None
        self.k = _cast(int, k)
        self.k_nsprefix_ = None
        self.location = location
        self.location_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Instance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Instance.subclass:
            return Instance.subclass(*args_, **kwargs_)
        else:
            return Instance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='Instance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Instance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Instance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Instance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Instance'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.i is not None and 'i' not in already_processed:
            already_processed.add('i')
            outfile.write(' i="%s"' % self.gds_format_integer(self.i, input_name='i'))
        if self.j is not None and 'j' not in already_processed:
            already_processed.add('j')
            outfile.write(' j="%s"' % self.gds_format_integer(self.j, input_name='j'))
        if self.k is not None and 'k' not in already_processed:
            already_processed.add('k')
            outfile.write(' k="%s"' % self.gds_format_integer(self.k, input_name='k'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='Instance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.location is not None:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            self.location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('i', node)
        if value is not None and 'i' not in already_processed:
            already_processed.add('i')
            self.i = self.gds_parse_integer(value, node, 'i')
            if self.i < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('j', node)
        if value is not None and 'j' not in already_processed:
            already_processed.add('j')
            self.j = self.gds_parse_integer(value, node, 'j')
            if self.j < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('k', node)
        if value is not None and 'k' not in already_processed:
            already_processed.add('k')
            self.k = self.gds_parse_integer(value, node, 'k')
            if self.k < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'location':
            obj_ = Location.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'


    def __str__(self):

        return "Instance "+str(self.id)+ (" at location: "+str(self.location) if self.location else "")

    def __repr__(self):

        return str(self)

# end class Instance


class Location(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('x', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('y', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('z', 'xs:float', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, x=None, y=None, z=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.x = _cast(float, x)
        self.x_nsprefix_ = None
        self.y = _cast(float, y)
        self.y_nsprefix_ = None
        self.z = _cast(float, z)
        self.z_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Location)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Location.subclass:
            return Location.subclass(*args_, **kwargs_)
        else:
            return Location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Location', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Location')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Location')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Location', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Location'):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_float(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_float(self.y, input_name='y'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z="%s"' % self.gds_format_float(self.z, input_name='z'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Location', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            value = self.gds_parse_float(value, node, 'x')
            self.x = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            value = self.gds_parse_float(value, node, 'y')
            self.y = value
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            value = self.gds_parse_float(value, node, 'z')
            self.z = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass

    def _format(self,value):

        if int(value)==value:
            return str(int(value))
        else:
            return '%.4f' % value

    def __str__(self):

        return "("+ self._format(self.x) +", "+ self._format(self.y) +", "+ self._format(self.z) +")"

    def __repr__(self):

        return str(self)

# end class Location


class SynapticConnection(GeneratedsSuper):
    """Single explicit connection. Introduced to test connections in LEMS. Will
    probably be removed in favour of
    connections wrapped in projection element"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('from_', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('to', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('synapse', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('destination', 'NmlId', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, from_=None, to=None, synapse=None, destination=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.from_ = _cast(None, from_)
        self.from__nsprefix_ = None
        self.to = _cast(None, to)
        self.to_nsprefix_ = None
        self.synapse = _cast(None, synapse)
        self.synapse_nsprefix_ = None
        self.destination = _cast(None, destination)
        self.destination_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SynapticConnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SynapticConnection.subclass:
            return SynapticConnection.subclass(*args_, **kwargs_)
        else:
            return SynapticConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SynapticConnection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SynapticConnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SynapticConnection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SynapticConnection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SynapticConnection'):
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.from_), input_name='from')), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' to=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.to), input_name='to')), ))
        if self.synapse is not None and 'synapse' not in already_processed:
            already_processed.add('synapse')
            outfile.write(' synapse=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.synapse), input_name='synapse')), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.add('destination')
            outfile.write(' destination=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.destination), input_name='destination')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SynapticConnection', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = value
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            self.to = value
        value = find_attr_value_('synapse', node)
        if value is not None and 'synapse' not in already_processed:
            already_processed.add('synapse')
            self.synapse = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.add('destination')
            self.destination = value
            self.validate_NmlId(self.destination)    # validate type NmlId
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass

    def _get_cell_id(self,ref):
        """Get cell ID"""
        if '[' in ref:
            return int(ref.split('[')[1].split(']')[0])
        else:
            return int(ref.split('/')[2])

    def _get_population(self,ref):
        """Get population"""
        if '[' in ref:
            return ref.split('[')[0]
        else:
            return ref.split('/')[0]

    def __str__(self):

        dest = self.destination if self.destination else 'unspecified'
        return "Synaptic connection from "+str(self._get_population(self.from_))+"(cell "+str(self._get_cell_id(self.from_))+             ") -> "+str(self._get_population(self.to))+"(cell "+str(self._get_cell_id(self.to))+"), syn: "+self.synapse+", destination: "+dest


    # end class SynapticConnection


class ExplicitInput(GeneratedsSuper):
    """Single explicit input. Introduced to test inputs in LEMS. Will probably
    be removed in favour of
    inputs wrapped in inputList element"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('target', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('input', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('destination', 'xs:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, target=None, input=None, destination=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.target = _cast(None, target)
        self.target_nsprefix_ = None
        self.input = _cast(None, input)
        self.input_nsprefix_ = None
        self.destination = _cast(None, destination)
        self.destination_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExplicitInput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExplicitInput.subclass:
            return ExplicitInput.subclass(*args_, **kwargs_)
        else:
            return ExplicitInput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExplicitInput', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExplicitInput')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExplicitInput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExplicitInput', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExplicitInput'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target), input_name='target')), ))
        if self.input is not None and 'input' not in already_processed:
            already_processed.add('input')
            outfile.write(' input=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.input), input_name='input')), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.add('destination')
            outfile.write(' destination=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.destination), input_name='destination')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExplicitInput', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
        value = find_attr_value_('input', node)
        if value is not None and 'input' not in already_processed:
            already_processed.add('input')
            self.input = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.add('destination')
            self.destination = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass

    def _get_cell_id(self, id_string):
        if '[' in id_string:
            return int(id_string.split('[')[1].split(']')[0])
        else:
            return int(id_string.split('/')[2])

    def get_target_cell_id(self):

        return self._get_cell_id(self.target)

    def get_segment_id(self):

        return int(self.segment_id) if self.segment_id else 0

    def get_fraction_along(self):

        return float(self.fraction_along) if self.fraction_along else 0.5

    def __str__(self):

        return "Input "+str(self.id)+": "+str(self.get_target_cell_id())+":"+str(self.get_segment_id())+"("+'%.6f'%self.get_fraction_along()+")"

    
    def get_target_cell_id(self,):
        """Get target cell ID"""
        if '[' in self.target:
            return int(self.target.split('[')[1].split(']')[0])
        else:
            return int(self.target.split('/')[2])

    def get_target_population(self,):
        """Get target population."""
        if '[' in self.target:
            return self.target.split('[')[0]
        else:
            return self.target.split('/')[0]

    def __str__(self):

        dest = self.destination if self.destination else 'unspecified'
        return "Explicit Input of type "+str(self.input)+" to "+self.get_target_population()+"(cell "+str(self.get_target_cell_id())+             "), destination: "+dest


    # end class ExplicitInput


class Input(GeneratedsSuper):
    """Individual input to the cell specified by target"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'NonNegativeInteger', 0, 0, {'use': 'required'}),
        MemberSpec_('target', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('destination', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('segmentId', 'NonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('fractionAlong', 'ZeroToOne', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, target=None, destination=None, segmentId=None, fractionAlong=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.target = _cast(None, target)
        self.target_nsprefix_ = None
        self.destination = _cast(None, destination)
        self.destination_nsprefix_ = None
        self.segmentId = _cast(int, segmentId)
        self.segmentId_nsprefix_ = None
        self.fractionAlong = _cast(float, fractionAlong)
        self.fractionAlong_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Input)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Input.subclass:
            return Input.subclass(*args_, **kwargs_)
        else:
            return Input(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_ZeroToOne(self, value):
        # Validate type ZeroToOne, a restriction on xs:float.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ZeroToOne' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ZeroToOne' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Input', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Input')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Input')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Input', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Input'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target), input_name='target')), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.add('destination')
            outfile.write(' destination=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.destination), input_name='destination')), ))
        if self.segmentId is not None and 'segmentId' not in already_processed:
            already_processed.add('segmentId')
            outfile.write(' segmentId="%s"' % self.gds_format_integer(self.segmentId, input_name='segmentId'))
        if self.fractionAlong is not None and 'fractionAlong' not in already_processed:
            already_processed.add('fractionAlong')
            outfile.write(' fractionAlong="%s"' % self.gds_format_float(self.fractionAlong, input_name='fractionAlong'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Input', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.id)    # validate type NonNegativeInteger
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.add('destination')
            self.destination = value
            self.validate_NmlId(self.destination)    # validate type NmlId
        value = find_attr_value_('segmentId', node)
        if value is not None and 'segmentId' not in already_processed:
            already_processed.add('segmentId')
            self.segmentId = self.gds_parse_integer(value, node, 'segmentId')
            if self.segmentId < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.segmentId)    # validate type NonNegativeInteger
        value = find_attr_value_('fractionAlong', node)
        if value is not None and 'fractionAlong' not in already_processed:
            already_processed.add('fractionAlong')
            value = self.gds_parse_float(value, node, 'fractionAlong')
            self.fractionAlong = value
            self.validate_ZeroToOne(self.fractionAlong)    # validate type ZeroToOne
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass

    def _get_cell_id(self, id_string):
        if '[' in id_string:
            return int(id_string.split('[')[1].split(']')[0])
        else:
            return int(id_string.split('/')[2])

    def get_target_cell_id(self):

        return self._get_cell_id(self.target)

    def get_segment_id(self):

        return int(self.segment_id) if self.segment_id else 0

    def get_fraction_along(self):

        return float(self.fraction_along) if self.fraction_along else 0.5

    def __str__(self):

        return "Input "+str(self.id)+": "+str(self.get_target_cell_id())+":"+str(self.get_segment_id())+"("+'%.6f'%self.get_fraction_along()+")"

    # end class Input


class InputW(Input):
    """Individual input to the cell specified by target. Includes setting of
    _weight for the connection"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('weight', 'xs:float', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Input
    def __init__(self, id=None, target=None, destination=None, segmentId=None, fractionAlong=None, weight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(InputW, self).__init__(id, target, destination, segmentId, fractionAlong,  **kwargs_)
        self.weight = _cast(float, weight)
        self.weight_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InputW)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InputW.subclass:
            return InputW.subclass(*args_, **kwargs_)
        else:
            return InputW(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(InputW, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InputW', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InputW')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InputW')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InputW', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InputW'):
        super(InputW, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InputW')
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight="%s"' % self.gds_format_float(self.weight, input_name='weight'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InputW', fromsubclass_=False, pretty_print=True):
        super(InputW, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            value = self.gds_parse_float(value, node, 'weight')
            self.weight = value
        super(InputW, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(InputW, self).buildChildren(child_, node, nodeName_, True)
        pass

    def get_weight(self):

        return float(self.weight) if self.weight!=None else 1.0

    def __str__(self):

        return "Input (weight) "+str(self.id)+": "+str(self.get_target_cell_id())+":"+str(self.get_segment_id())+"("+'%.6f'%self.get_fraction_along()+"), weight: "+'%.6f'%self.get_weight()

    # end class InputW


class BaseWithoutId(GeneratedsSuper):
    """Base element without ID specified *yet*, e.g. for an element with a
    particular requirement on its id which does not comply with NmlId (e.g.
    Segment needs nonNegativeInteger)."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('neuroLexId', 'NeuroLexId', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, neuroLexId=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.neuroLexId = _cast(None, neuroLexId)
        self.neuroLexId_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseWithoutId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseWithoutId.subclass:
            return BaseWithoutId.subclass(*args_, **kwargs_)
        else:
            return BaseWithoutId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NeuroLexId(self, value):
        # Validate type NeuroLexId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NeuroLexId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NeuroLexId_patterns_, ))
    validate_NeuroLexId_patterns_ = [['^([a-zA-Z0-9_:]*)$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseWithoutId', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseWithoutId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseWithoutId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseWithoutId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseWithoutId'):
        if self.neuroLexId is not None and 'neuroLexId' not in already_processed:
            already_processed.add('neuroLexId')
            outfile.write(' neuroLexId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.neuroLexId), input_name='neuroLexId')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseWithoutId', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('neuroLexId', node)
        if value is not None and 'neuroLexId' not in already_processed:
            already_processed.add('neuroLexId')
            self.neuroLexId = value
            self.validate_NeuroLexId(self.neuroLexId)    # validate type NeuroLexId
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BaseWithoutId


class BaseNonNegativeIntegerId(BaseWithoutId):
    """Anything which can have a unique (within its parent) id, which must be
    an integer zero or greater."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'NonNegativeInteger', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseWithoutId
    def __init__(self, neuroLexId=None, id=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseNonNegativeIntegerId, self).__init__(neuroLexId, extensiontype_,  **kwargs_)
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseNonNegativeIntegerId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseNonNegativeIntegerId.subclass:
            return BaseNonNegativeIntegerId.subclass(*args_, **kwargs_)
        else:
            return BaseNonNegativeIntegerId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            super(BaseNonNegativeIntegerId, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseNonNegativeIntegerId', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseNonNegativeIntegerId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseNonNegativeIntegerId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseNonNegativeIntegerId', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseNonNegativeIntegerId'):
        super(BaseNonNegativeIntegerId, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseNonNegativeIntegerId')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseNonNegativeIntegerId', fromsubclass_=False, pretty_print=True):
        super(BaseNonNegativeIntegerId, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.id)    # validate type NonNegativeInteger
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseNonNegativeIntegerId, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BaseNonNegativeIntegerId, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseNonNegativeIntegerId


class Base(BaseWithoutId):
    """Anything which can have a unique (within its parent) id of the form
    NmlId (spaceless combination of letters, numbers and underscore)."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'NmlId', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseWithoutId
    def __init__(self, neuroLexId=None, id=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Base, self).__init__(neuroLexId, extensiontype_,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Base)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Base.subclass:
            return Base.subclass(*args_, **kwargs_)
        else:
            return Base(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            super(Base, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Base', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Base')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Base')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Base', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Base'):
        super(Base, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Base')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Base', fromsubclass_=False, pretty_print=True):
        super(Base, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_NmlId(self.id)    # validate type NmlId
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Base, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(Base, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Base


class Standalone(Base):
    """Elements which can stand alone and be referenced by id, e.g. cell,
    morphology."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('metaid', 'MetaId', 0, 1, {'use': 'optional'}),
        MemberSpec_('notes', ['Notes', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'notes', 'type': 'xs:string'}, None),
        MemberSpec_('property', 'Property', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'property', 'type': 'Property'}, None),
        MemberSpec_('annotation', 'Annotation', 0, 1, {'minOccurs': '0', 'name': 'annotation', 'type': 'Annotation'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Standalone, self).__init__(neuroLexId, id, extensiontype_,  **kwargs_)
        self.metaid = _cast(None, metaid)
        self.metaid_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        if property is None:
            self.property = []
        else:
            self.property = property
        self.property_nsprefix_ = None
        self.annotation = annotation
        self.annotation_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Standalone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Standalone.subclass:
            return Standalone.subclass(*args_, **kwargs_)
        else:
            return Standalone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_MetaId(self, value):
        # Validate type MetaId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_MetaId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_MetaId_patterns_, ))
    validate_MetaId_patterns_ = [['^([a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            self.notes is not None or
            self.property or
            self.annotation is not None or
            super(Standalone, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='Standalone', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Standalone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Standalone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Standalone', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Standalone'):
        super(Standalone, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Standalone')
        if self.metaid is not None and 'metaid' not in already_processed:
            already_processed.add('metaid')
            outfile.write(' metaid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.metaid), input_name='metaid')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.neuroml.org/schema/neuroml2" ', name_='Standalone', fromsubclass_=False, pretty_print=True):
        super(Standalone, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notes), input_name='notes')), namespaceprefix_ , eol_))
        for property_ in self.property:
            namespaceprefix_ = self.property_nsprefix_ + ':' if (UseCapturedNS_ and self.property_nsprefix_) else ''
            property_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='property', pretty_print=pretty_print)
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('metaid', node)
        if value is not None and 'metaid' not in already_processed:
            already_processed.add('metaid')
            self.metaid = value
            self.validate_MetaId(self.metaid)    # validate type MetaId
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Standalone, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notes')
            value_ = self.gds_validate_string(value_, node, 'notes')
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == 'property':
            obj_ = Property.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        super(Standalone, self).buildChildren(child_, node, nodeName_, True)
# end class Standalone


class SpikeSourcePoisson(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('start', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('duration', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('rate', 'Nml2Quantity_pertime', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, start=None, duration=None, rate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpikeSourcePoisson, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.start = _cast(None, start)
        self.start_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.rate = _cast(None, rate)
        self.rate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpikeSourcePoisson)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeSourcePoisson.subclass:
            return SpikeSourcePoisson.subclass(*args_, **kwargs_)
        else:
            return SpikeSourcePoisson(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_pertime_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_pertime_patterns_, ))
    validate_Nml2Quantity_pertime_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$']]
    def hasContent_(self):
        if (
            super(SpikeSourcePoisson, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeSourcePoisson', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpikeSourcePoisson')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeSourcePoisson')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpikeSourcePoisson', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpikeSourcePoisson'):
        super(SpikeSourcePoisson, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeSourcePoisson')
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            outfile.write(' start=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.start), input_name='start')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.rate is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            outfile.write(' rate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rate), input_name='rate')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeSourcePoisson', fromsubclass_=False, pretty_print=True):
        super(SpikeSourcePoisson, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('start', node)
        if value is not None and 'start' not in already_processed:
            already_processed.add('start')
            self.start = value
            self.validate_Nml2Quantity_time(self.start)    # validate type Nml2Quantity_time
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
            self.validate_Nml2Quantity_time(self.duration)    # validate type Nml2Quantity_time
        value = find_attr_value_('rate', node)
        if value is not None and 'rate' not in already_processed:
            already_processed.add('rate')
            self.rate = value
            self.validate_Nml2Quantity_pertime(self.rate)    # validate type Nml2Quantity_pertime
        super(SpikeSourcePoisson, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SpikeSourcePoisson, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SpikeSourcePoisson


class InputList(Base):
    """List of inputs to a population. Currents will be provided by the
    specified component."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('population', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('component', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('input', 'Input', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'input', 'type': 'Input'}, None),
        MemberSpec_('inputW', 'InputW', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'inputW', 'type': 'InputW'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, population=None, component=None, input=None, inputW=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(InputList, self).__init__(neuroLexId, id,  **kwargs_)
        self.population = _cast(None, population)
        self.population_nsprefix_ = None
        self.component = _cast(None, component)
        self.component_nsprefix_ = None
        if input is None:
            self.input = []
        else:
            self.input = input
        self.input_nsprefix_ = None
        if inputW is None:
            self.inputW = []
        else:
            self.inputW = inputW
        self.inputW_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InputList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InputList.subclass:
            return InputList.subclass(*args_, **kwargs_)
        else:
            return InputList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            self.input or
            self.inputW or
            super(InputList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InputList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InputList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InputList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InputList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InputList'):
        super(InputList, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InputList')
        if self.population is not None and 'population' not in already_processed:
            already_processed.add('population')
            outfile.write(' population=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.population), input_name='population')), ))
        if self.component is not None and 'component' not in already_processed:
            already_processed.add('component')
            outfile.write(' component=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.component), input_name='component')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InputList', fromsubclass_=False, pretty_print=True):
        super(InputList, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for input_ in self.input:
            namespaceprefix_ = self.input_nsprefix_ + ':' if (UseCapturedNS_ and self.input_nsprefix_) else ''
            input_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='input', pretty_print=pretty_print)
        for inputW_ in self.inputW:
            namespaceprefix_ = self.inputW_nsprefix_ + ':' if (UseCapturedNS_ and self.inputW_nsprefix_) else ''
            inputW_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inputW', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('population', node)
        if value is not None and 'population' not in already_processed:
            already_processed.add('population')
            self.population = value
            self.validate_NmlId(self.population)    # validate type NmlId
        value = find_attr_value_('component', node)
        if value is not None and 'component' not in already_processed:
            already_processed.add('component')
            self.component = value
            self.validate_NmlId(self.component)    # validate type NmlId
        super(InputList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'input':
            class_obj_ = self.get_class_obj_(child_, Input)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.input.append(obj_)
            obj_.original_tagname_ = 'input'
        elif nodeName_ == 'inputW':
            obj_ = InputW.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inputW.append(obj_)
            obj_.original_tagname_ = 'inputW'
        super(InputList, self).buildChildren(child_, node, nodeName_, True)

    def exportHdf5(self, h5file, h5Group):
        #print("Exporting InputList: "+str(self.id)+" as HDF5")
        

        import numpy

        ilGroup = h5file.create_group(h5Group, 'inputList_'+self.id)
        ilGroup._f_setattr("id", self.id)
        ilGroup._f_setattr("component", self.component)
        ilGroup._f_setattr("population", self.populations)

        cols = 4

        extra_cols = {}

        num_tot = len(self.input)+len(self.input_ws)

        if len(self.input_ws)>0:
            extra_cols["column_"+str(cols)] = 'weight'
            cols+=1

        #print("Exporting "+str(num_tot)+" inputs")
        a = numpy.zeros([num_tot, cols], numpy.float32)

        count=0

        for input in self.input:
            a[count,0] = input.id
            a[count,1] = input.get_target_cell_id()
            a[count,2] = input.get_segment_id()
            a[count,3] = input.get_fraction_along()
            count+=1

        for input in self.input_ws:
            a[count,0] = input.id
            a[count,1] = input.get_target_cell_id()
            a[count,2] = input.get_segment_id()
            a[count,3] = input.get_fraction_along()
            a[count,4] = input.get_weight()
            count+=1

        array = h5file.create_carray(ilGroup, self.id, obj=a, title="Locations of inputs in "+ self.id)

        array._f_setattr("column_0", "id")
        array._f_setattr("column_1", "target_cell_id")
        array._f_setattr("column_2", "segment_id")
        array._f_setattr("column_3", "fraction_along")
        for k in extra_cols:
            array._f_setattr(k, extra_cols[k])

    def __str__(self):

        return "Input list: "+self.id+" to "+self.populations+", component "+self.component


    # end class InputList


class BaseConnection(BaseNonNegativeIntegerId):
    """Base of all synaptic connections (chemical/electrical/analog, etc.)
    inside projections"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = BaseNonNegativeIntegerId
    def __init__(self, neuroLexId=None, id=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseConnection, self).__init__(neuroLexId, id, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseConnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseConnection.subclass:
            return BaseConnection.subclass(*args_, **kwargs_)
        else:
            return BaseConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(BaseConnection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseConnection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseConnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseConnection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseConnection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseConnection'):
        super(BaseConnection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseConnection')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseConnection', fromsubclass_=False, pretty_print=True):
        super(BaseConnection, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseConnection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BaseConnection, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseConnection


class BaseProjection(Base):
    """Base for projection (set of synaptic connections) between two
    populations"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('presynapticPopulation', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('postsynapticPopulation', 'NmlId', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, presynapticPopulation=None, postsynapticPopulation=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseProjection, self).__init__(neuroLexId, id, extensiontype_,  **kwargs_)
        self.presynapticPopulation = _cast(None, presynapticPopulation)
        self.presynapticPopulation_nsprefix_ = None
        self.postsynapticPopulation = _cast(None, postsynapticPopulation)
        self.postsynapticPopulation_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseProjection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseProjection.subclass:
            return BaseProjection.subclass(*args_, **kwargs_)
        else:
            return BaseProjection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            super(BaseProjection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseProjection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseProjection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseProjection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseProjection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseProjection'):
        super(BaseProjection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseProjection')
        if self.presynapticPopulation is not None and 'presynapticPopulation' not in already_processed:
            already_processed.add('presynapticPopulation')
            outfile.write(' presynapticPopulation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.presynapticPopulation), input_name='presynapticPopulation')), ))
        if self.postsynapticPopulation is not None and 'postsynapticPopulation' not in already_processed:
            already_processed.add('postsynapticPopulation')
            outfile.write(' postsynapticPopulation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.postsynapticPopulation), input_name='postsynapticPopulation')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseProjection', fromsubclass_=False, pretty_print=True):
        super(BaseProjection, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('presynapticPopulation', node)
        if value is not None and 'presynapticPopulation' not in already_processed:
            already_processed.add('presynapticPopulation')
            self.presynapticPopulation = value
            self.validate_NmlId(self.presynapticPopulation)    # validate type NmlId
        value = find_attr_value_('postsynapticPopulation', node)
        if value is not None and 'postsynapticPopulation' not in already_processed:
            already_processed.add('postsynapticPopulation')
            self.postsynapticPopulation = value
            self.validate_NmlId(self.postsynapticPopulation)    # validate type NmlId
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseProjection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BaseProjection, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseProjection


class CellSet(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('select', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('__ANY__', '__ANY__', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'processContents': 'skip'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, select=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CellSet, self).__init__(neuroLexId, id,  **kwargs_)
        self.select = _cast(None, select)
        self.select_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CellSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CellSet.subclass:
            return CellSet.subclass(*args_, **kwargs_)
        else:
            return CellSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            super(CellSet, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CellSet', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CellSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CellSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CellSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CellSet'):
        super(CellSet, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CellSet')
        if self.select is not None and 'select' not in already_processed:
            already_processed.add('select')
            outfile.write(' select=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.select), input_name='select')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CellSet', fromsubclass_=False, pretty_print=True):
        super(CellSet, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('select', node)
        if value is not None and 'select' not in already_processed:
            already_processed.add('select')
            self.select = value
        super(CellSet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'CellSet')
        self.add_anytypeobjs_(content_)
        super(CellSet, self).buildChildren(child_, node, nodeName_, True)
# end class CellSet


class Population(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('component', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('size', 'NonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('type_', 'populationTypes', 0, 1, {'use': 'optional'}),
        MemberSpec_('extracellularProperties', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('layout', 'Layout', 0, 1, {'minOccurs': '0', 'name': 'layout', 'type': 'Layout'}, 4),
        MemberSpec_('instance', 'Instance', 1, 0, {'maxOccurs': 'unbounded', 'name': 'instance', 'type': 'Instance'}, 4),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, component=None, size=None, type_=None, extracellularProperties=None, layout=None, instance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Population, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.component = _cast(None, component)
        self.component_nsprefix_ = None
        self.size = _cast(int, size)
        self.size_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.extracellularProperties = _cast(None, extracellularProperties)
        self.extracellularProperties_nsprefix_ = None
        self.layout = layout
        self.layout_nsprefix_ = None
        if instance is None:
            self.instance = []
        else:
            self.instance = instance
        self.instance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Population)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Population.subclass:
            return Population.subclass(*args_, **kwargs_)
        else:
            return Population(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_populationTypes(self, value):
        # Validate type populationTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['population', 'populationList']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on populationTypes' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.layout is not None or
            self.instance or
            super(Population, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Population', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Population')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Population')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Population', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Population'):
        super(Population, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Population')
        if self.component is not None and 'component' not in already_processed:
            already_processed.add('component')
            outfile.write(' component=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.component), input_name='component')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.extracellularProperties is not None and 'extracellularProperties' not in already_processed:
            already_processed.add('extracellularProperties')
            outfile.write(' extracellularProperties=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.extracellularProperties), input_name='extracellularProperties')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Population', fromsubclass_=False, pretty_print=True):
        super(Population, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.layout is not None:
            namespaceprefix_ = self.layout_nsprefix_ + ':' if (UseCapturedNS_ and self.layout_nsprefix_) else ''
            self.layout.export(outfile, level, namespaceprefix_, namespacedef_='', name_='layout', pretty_print=pretty_print)
        for instance_ in self.instance:
            namespaceprefix_ = self.instance_nsprefix_ + ':' if (UseCapturedNS_ and self.instance_nsprefix_) else ''
            instance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='instance', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('component', node)
        if value is not None and 'component' not in already_processed:
            already_processed.add('component')
            self.component = value
            self.validate_NmlId(self.component)    # validate type NmlId
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = self.gds_parse_integer(value, node, 'size')
            if self.size < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.size)    # validate type NonNegativeInteger
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_populationTypes(self.type_)    # validate type populationTypes
        value = find_attr_value_('extracellularProperties', node)
        if value is not None and 'extracellularProperties' not in already_processed:
            already_processed.add('extracellularProperties')
            self.extracellularProperties = value
            self.validate_NmlId(self.extracellularProperties)    # validate type NmlId
        super(Population, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'layout':
            obj_ = Layout.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.layout = obj_
            obj_.original_tagname_ = 'layout'
        elif nodeName_ == 'instance':
            obj_ = Instance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instance.append(obj_)
            obj_.original_tagname_ = 'instance'
        super(Population, self).buildChildren(child_, node, nodeName_, True)

    def exportHdf5(self, h5file, h5Group):
        #print("Exporting Population: "+str(self.id)+" as HDF5")
        

        import numpy

        popGroup = h5file.create_group(h5Group, 'population_'+self.id)
        popGroup._f_setattr("id", self.id)
        popGroup._f_setattr("component", self.component)
        for p in self.properties:
            popGroup._f_setattr("property:"+p.tag, p.value)


        if len(self.instances)>0:

            colCount = 3
            a = numpy.zeros([len(self.instances), colCount], numpy.float32)

            count=0
            for instance in self.instances:
              a[count,0] = instance.location.x
              a[count,1] = instance.location.y
              a[count,2] = instance.location.z

              count=count+1

            popGroup._f_setattr("size", count)
            popGroup._f_setattr("type", "populationList")

            array = h5file.create_carray(popGroup, self.id, obj=a, title="Locations of cells in "+ self.id)
            array._f_setattr("column_0", "x")
            array._f_setattr("column_1", "y")
            array._f_setattr("column_2", "z")

        else:
            popGroup._f_setattr("size", self.size)

    def get_size(self):
        return len(self.instances) if len(self.instances)>0 else (self.size if self.size else 0)

    def __str__(self):

        return "Population: "+str(self.id)+" with "+str( self.get_size() )+" components of type "+(self.component if self.component else "???")


    # end class Population


class Region(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('space', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('__ANY__', '__ANY__', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'processContents': 'skip'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, space=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Region, self).__init__(neuroLexId, id,  **kwargs_)
        self.space = _cast(None, space)
        self.space_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Region)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Region.subclass:
            return Region.subclass(*args_, **kwargs_)
        else:
            return Region(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            super(Region, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Region', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Region')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Region')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Region', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Region'):
        super(Region, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Region')
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Region', fromsubclass_=False, pretty_print=True):
        super(Region, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
            self.validate_NmlId(self.space)    # validate type NmlId
        super(Region, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'Region')
        self.add_anytypeobjs_(content_)
        super(Region, self).buildChildren(child_, node, nodeName_, True)
# end class Region


class Space(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('basedOn', 'allowedSpaces', 0, 1, {'use': 'optional'}),
        MemberSpec_('structure', 'SpaceStructure', 0, 1, {'minOccurs': '0', 'name': 'structure', 'type': 'SpaceStructure'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, basedOn=None, structure=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Space, self).__init__(neuroLexId, id,  **kwargs_)
        self.basedOn = _cast(None, basedOn)
        self.basedOn_nsprefix_ = None
        self.structure = structure
        self.structure_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Space)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Space.subclass:
            return Space.subclass(*args_, **kwargs_)
        else:
            return Space(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_allowedSpaces(self, value):
        # Validate type allowedSpaces, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Euclidean_1D', 'Euclidean_2D', 'Euclidean_3D', 'Grid_1D', 'Grid_2D', 'Grid_3D']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on allowedSpaces' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.structure is not None or
            super(Space, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Space', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Space')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Space')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Space', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Space'):
        super(Space, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Space')
        if self.basedOn is not None and 'basedOn' not in already_processed:
            already_processed.add('basedOn')
            outfile.write(' basedOn=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.basedOn), input_name='basedOn')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Space', fromsubclass_=False, pretty_print=True):
        super(Space, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.structure is not None:
            namespaceprefix_ = self.structure_nsprefix_ + ':' if (UseCapturedNS_ and self.structure_nsprefix_) else ''
            self.structure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='structure', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('basedOn', node)
        if value is not None and 'basedOn' not in already_processed:
            already_processed.add('basedOn')
            self.basedOn = value
            self.validate_allowedSpaces(self.basedOn)    # validate type allowedSpaces
        super(Space, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'structure':
            obj_ = SpaceStructure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.structure = obj_
            obj_.original_tagname_ = 'structure'
        super(Space, self).buildChildren(child_, node, nodeName_, True)
# end class Space


class Network(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('type_', 'networkTypes', 0, 1, {'use': 'optional'}),
        MemberSpec_('temperature', 'Nml2Quantity_temperature', 0, 1, {'use': 'optional'}),
        MemberSpec_('space', 'Space', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'space', 'type': 'Space'}, None),
        MemberSpec_('region', 'Region', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'region', 'type': 'Region'}, None),
        MemberSpec_('extracellularProperties', 'ExtracellularPropertiesLocal', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'extracellularProperties', 'type': 'ExtracellularPropertiesLocal'}, None),
        MemberSpec_('population', 'Population', 1, 0, {'maxOccurs': 'unbounded', 'name': 'population', 'type': 'Population'}, None),
        MemberSpec_('cellSet', 'CellSet', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'cellSet', 'type': 'CellSet'}, None),
        MemberSpec_('synapticConnection', 'SynapticConnection', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'synapticConnection', 'type': 'SynapticConnection'}, None),
        MemberSpec_('projection', 'Projection', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'projection', 'type': 'Projection'}, None),
        MemberSpec_('electricalProjection', 'ElectricalProjection', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'electricalProjection', 'type': 'ElectricalProjection'}, None),
        MemberSpec_('continuousProjection', 'ContinuousProjection', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'continuousProjection', 'type': 'ContinuousProjection'}, None),
        MemberSpec_('explicitInput', 'ExplicitInput', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'explicitInput', 'type': 'ExplicitInput'}, None),
        MemberSpec_('inputList', 'InputList', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'inputList', 'type': 'InputList'}, None),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, type_=None, temperature=None, space=None, region=None, extracellularProperties=None, population=None, cellSet=None, synapticConnection=None, projection=None, electricalProjection=None, continuousProjection=None, explicitInput=None, inputList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Network, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.temperature = _cast(None, temperature)
        self.temperature_nsprefix_ = None
        if space is None:
            self.space = []
        else:
            self.space = space
        self.space_nsprefix_ = None
        if region is None:
            self.region = []
        else:
            self.region = region
        self.region_nsprefix_ = None
        if extracellularProperties is None:
            self.extracellularProperties = []
        else:
            self.extracellularProperties = extracellularProperties
        self.extracellularProperties_nsprefix_ = None
        if population is None:
            self.population = []
        else:
            self.population = population
        self.population_nsprefix_ = None
        if cellSet is None:
            self.cellSet = []
        else:
            self.cellSet = cellSet
        self.cellSet_nsprefix_ = None
        if synapticConnection is None:
            self.synapticConnection = []
        else:
            self.synapticConnection = synapticConnection
        self.synapticConnection_nsprefix_ = None
        if projection is None:
            self.projection = []
        else:
            self.projection = projection
        self.projection_nsprefix_ = None
        if electricalProjection is None:
            self.electricalProjection = []
        else:
            self.electricalProjection = electricalProjection
        self.electricalProjection_nsprefix_ = None
        if continuousProjection is None:
            self.continuousProjection = []
        else:
            self.continuousProjection = continuousProjection
        self.continuousProjection_nsprefix_ = None
        if explicitInput is None:
            self.explicitInput = []
        else:
            self.explicitInput = explicitInput
        self.explicitInput_nsprefix_ = None
        if inputList is None:
            self.inputList = []
        else:
            self.inputList = inputList
        self.inputList_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Network)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Network.subclass:
            return Network.subclass(*args_, **kwargs_)
        else:
            return Network(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_networkTypes(self, value):
        # Validate type networkTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['network', 'networkWithTemperature']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on networkTypes' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_Nml2Quantity_temperature(self, value):
        # Validate type Nml2Quantity_temperature, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_temperature_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_temperature_patterns_, ))
    validate_Nml2Quantity_temperature_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(degC))$']]
    def hasContent_(self):
        if (
            self.space or
            self.region or
            self.extracellularProperties or
            self.population or
            self.cellSet or
            self.synapticConnection or
            self.projection or
            self.electricalProjection or
            self.continuousProjection or
            self.explicitInput or
            self.inputList or
            super(Network, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Network', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Network')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Network')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Network', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Network'):
        super(Network, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Network')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.temperature is not None and 'temperature' not in already_processed:
            already_processed.add('temperature')
            outfile.write(' temperature=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.temperature), input_name='temperature')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Network', fromsubclass_=False, pretty_print=True):
        super(Network, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for space_ in self.space:
            namespaceprefix_ = self.space_nsprefix_ + ':' if (UseCapturedNS_ and self.space_nsprefix_) else ''
            space_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='space', pretty_print=pretty_print)
        for region_ in self.region:
            namespaceprefix_ = self.region_nsprefix_ + ':' if (UseCapturedNS_ and self.region_nsprefix_) else ''
            region_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='region', pretty_print=pretty_print)
        for extracellularProperties_ in self.extracellularProperties:
            namespaceprefix_ = self.extracellularProperties_nsprefix_ + ':' if (UseCapturedNS_ and self.extracellularProperties_nsprefix_) else ''
            extracellularProperties_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extracellularProperties', pretty_print=pretty_print)
        for population_ in self.population:
            namespaceprefix_ = self.population_nsprefix_ + ':' if (UseCapturedNS_ and self.population_nsprefix_) else ''
            population_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='population', pretty_print=pretty_print)
        for cellSet_ in self.cellSet:
            namespaceprefix_ = self.cellSet_nsprefix_ + ':' if (UseCapturedNS_ and self.cellSet_nsprefix_) else ''
            cellSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cellSet', pretty_print=pretty_print)
        for synapticConnection_ in self.synapticConnection:
            namespaceprefix_ = self.synapticConnection_nsprefix_ + ':' if (UseCapturedNS_ and self.synapticConnection_nsprefix_) else ''
            synapticConnection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='synapticConnection', pretty_print=pretty_print)
        for projection_ in self.projection:
            namespaceprefix_ = self.projection_nsprefix_ + ':' if (UseCapturedNS_ and self.projection_nsprefix_) else ''
            projection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='projection', pretty_print=pretty_print)
        for electricalProjection_ in self.electricalProjection:
            namespaceprefix_ = self.electricalProjection_nsprefix_ + ':' if (UseCapturedNS_ and self.electricalProjection_nsprefix_) else ''
            electricalProjection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='electricalProjection', pretty_print=pretty_print)
        for continuousProjection_ in self.continuousProjection:
            namespaceprefix_ = self.continuousProjection_nsprefix_ + ':' if (UseCapturedNS_ and self.continuousProjection_nsprefix_) else ''
            continuousProjection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='continuousProjection', pretty_print=pretty_print)
        for explicitInput_ in self.explicitInput:
            namespaceprefix_ = self.explicitInput_nsprefix_ + ':' if (UseCapturedNS_ and self.explicitInput_nsprefix_) else ''
            explicitInput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='explicitInput', pretty_print=pretty_print)
        for inputList_ in self.inputList:
            namespaceprefix_ = self.inputList_nsprefix_ + ':' if (UseCapturedNS_ and self.inputList_nsprefix_) else ''
            inputList_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inputList', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_networkTypes(self.type_)    # validate type networkTypes
        value = find_attr_value_('temperature', node)
        if value is not None and 'temperature' not in already_processed:
            already_processed.add('temperature')
            self.temperature = value
            self.validate_Nml2Quantity_temperature(self.temperature)    # validate type Nml2Quantity_temperature
        super(Network, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'space':
            obj_ = Space.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.space.append(obj_)
            obj_.original_tagname_ = 'space'
        elif nodeName_ == 'region':
            obj_ = Region.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.region.append(obj_)
            obj_.original_tagname_ = 'region'
        elif nodeName_ == 'extracellularProperties':
            obj_ = ExtracellularPropertiesLocal.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extracellularProperties.append(obj_)
            obj_.original_tagname_ = 'extracellularProperties'
        elif nodeName_ == 'population':
            obj_ = Population.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.population.append(obj_)
            obj_.original_tagname_ = 'population'
        elif nodeName_ == 'cellSet':
            obj_ = CellSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cellSet.append(obj_)
            obj_.original_tagname_ = 'cellSet'
        elif nodeName_ == 'synapticConnection':
            obj_ = SynapticConnection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.synapticConnection.append(obj_)
            obj_.original_tagname_ = 'synapticConnection'
        elif nodeName_ == 'projection':
            obj_ = Projection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.projection.append(obj_)
            obj_.original_tagname_ = 'projection'
        elif nodeName_ == 'electricalProjection':
            obj_ = ElectricalProjection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.electricalProjection.append(obj_)
            obj_.original_tagname_ = 'electricalProjection'
        elif nodeName_ == 'continuousProjection':
            obj_ = ContinuousProjection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.continuousProjection.append(obj_)
            obj_.original_tagname_ = 'continuousProjection'
        elif nodeName_ == 'explicitInput':
            obj_ = ExplicitInput.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.explicitInput.append(obj_)
            obj_.original_tagname_ = 'explicitInput'
        elif nodeName_ == 'inputList':
            obj_ = InputList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inputList.append(obj_)
            obj_.original_tagname_ = 'inputList'
        super(Network, self).buildChildren(child_, node, nodeName_, True)

    warn_count = 0
    def get_by_id(self,id):
        all_ids = []
        for ms in self.member_data_items_:
            mlist = self.__getattribute__(ms.name)
            for m in mlist:
                if hasattr(m,"id"):
                    if m.id == id:
                        return m
                    else:
                        all_ids.append(m.id)
        from neuroml.loaders import print_
        if self.warn_count<10:
            print_("Id "+id+" not found in <network> element. All ids: "+str(sorted(all_ids)))
            self.warn_count+=1
        elif self.warn_count==10:
            print_(" - Suppressing further warnings about id not found...")
        return None


    def __str__(self):

        return "Network "+str(self.id)+" with "+str(len(self.populations))+" population(s)"

    
    def exportHdf5(self, h5file, h5Group):
        #print("Exporting Network: "+str(self.id)+" as HDF5")
        

        import numpy

        netGroup = h5file.create_group(h5Group, 'network')
        netGroup._f_setattr("id", self.id)
        netGroup._f_setattr("notes", self.notes)
        if self.temperature:
            netGroup._f_setattr("temperature", self.temperature)


        for pop in self.populations:
            pop.exportHdf5(h5file, netGroup)

        if len(self.synaptic_connections) > 0:
            raise Exception("<synapticConnection> not yet supported in HDF5 export")
        if len(self.explicit_inputs) > 0:
            raise Exception("<explicitInput> not yet supported in HDF5 export")

        for proj in self.projections:
            proj.exportHdf5(h5file, netGroup)

        for eproj in self.electrical_projections:
            eproj.exportHdf5(h5file, netGroup)

        for cproj in self.continuous_projections:
            cproj.exportHdf5(h5file, netGroup)

        for il in self.input_lists:
            il.exportHdf5(h5file, netGroup)


    # end class Network


class TransientPoissonFiringSynapse(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('averageRate', 'Nml2Quantity_pertime', 0, 0, {'use': 'required'}),
        MemberSpec_('delay', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('duration', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('synapse', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('spikeTarget', 'xs:string', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, averageRate=None, delay=None, duration=None, synapse=None, spikeTarget=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TransientPoissonFiringSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.averageRate = _cast(None, averageRate)
        self.averageRate_nsprefix_ = None
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.synapse = _cast(None, synapse)
        self.synapse_nsprefix_ = None
        self.spikeTarget = _cast(None, spikeTarget)
        self.spikeTarget_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransientPoissonFiringSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransientPoissonFiringSynapse.subclass:
            return TransientPoissonFiringSynapse.subclass(*args_, **kwargs_)
        else:
            return TransientPoissonFiringSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_pertime_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_pertime_patterns_, ))
    validate_Nml2Quantity_pertime_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$']]
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (
            super(TransientPoissonFiringSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TransientPoissonFiringSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransientPoissonFiringSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransientPoissonFiringSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransientPoissonFiringSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TransientPoissonFiringSynapse'):
        super(TransientPoissonFiringSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransientPoissonFiringSynapse')
        if self.averageRate is not None and 'averageRate' not in already_processed:
            already_processed.add('averageRate')
            outfile.write(' averageRate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.averageRate), input_name='averageRate')), ))
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delay), input_name='delay')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.synapse is not None and 'synapse' not in already_processed:
            already_processed.add('synapse')
            outfile.write(' synapse=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.synapse), input_name='synapse')), ))
        if self.spikeTarget is not None and 'spikeTarget' not in already_processed:
            already_processed.add('spikeTarget')
            outfile.write(' spikeTarget=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.spikeTarget), input_name='spikeTarget')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TransientPoissonFiringSynapse', fromsubclass_=False, pretty_print=True):
        super(TransientPoissonFiringSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('averageRate', node)
        if value is not None and 'averageRate' not in already_processed:
            already_processed.add('averageRate')
            self.averageRate = value
            self.validate_Nml2Quantity_pertime(self.averageRate)    # validate type Nml2Quantity_pertime
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            self.delay = value
            self.validate_Nml2Quantity_time(self.delay)    # validate type Nml2Quantity_time
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
            self.validate_Nml2Quantity_time(self.duration)    # validate type Nml2Quantity_time
        value = find_attr_value_('synapse', node)
        if value is not None and 'synapse' not in already_processed:
            already_processed.add('synapse')
            self.synapse = value
        value = find_attr_value_('spikeTarget', node)
        if value is not None and 'spikeTarget' not in already_processed:
            already_processed.add('spikeTarget')
            self.spikeTarget = value
        super(TransientPoissonFiringSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TransientPoissonFiringSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TransientPoissonFiringSynapse


class PoissonFiringSynapse(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('averageRate', 'Nml2Quantity_pertime', 0, 0, {'use': 'required'}),
        MemberSpec_('synapse', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('spikeTarget', 'xs:string', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, averageRate=None, synapse=None, spikeTarget=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PoissonFiringSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.averageRate = _cast(None, averageRate)
        self.averageRate_nsprefix_ = None
        self.synapse = _cast(None, synapse)
        self.synapse_nsprefix_ = None
        self.spikeTarget = _cast(None, spikeTarget)
        self.spikeTarget_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PoissonFiringSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PoissonFiringSynapse.subclass:
            return PoissonFiringSynapse.subclass(*args_, **kwargs_)
        else:
            return PoissonFiringSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_pertime_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_pertime_patterns_, ))
    validate_Nml2Quantity_pertime_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$']]
    def hasContent_(self):
        if (
            super(PoissonFiringSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PoissonFiringSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PoissonFiringSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PoissonFiringSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PoissonFiringSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PoissonFiringSynapse'):
        super(PoissonFiringSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PoissonFiringSynapse')
        if self.averageRate is not None and 'averageRate' not in already_processed:
            already_processed.add('averageRate')
            outfile.write(' averageRate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.averageRate), input_name='averageRate')), ))
        if self.synapse is not None and 'synapse' not in already_processed:
            already_processed.add('synapse')
            outfile.write(' synapse=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.synapse), input_name='synapse')), ))
        if self.spikeTarget is not None and 'spikeTarget' not in already_processed:
            already_processed.add('spikeTarget')
            outfile.write(' spikeTarget=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.spikeTarget), input_name='spikeTarget')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PoissonFiringSynapse', fromsubclass_=False, pretty_print=True):
        super(PoissonFiringSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('averageRate', node)
        if value is not None and 'averageRate' not in already_processed:
            already_processed.add('averageRate')
            self.averageRate = value
            self.validate_Nml2Quantity_pertime(self.averageRate)    # validate type Nml2Quantity_pertime
        value = find_attr_value_('synapse', node)
        if value is not None and 'synapse' not in already_processed:
            already_processed.add('synapse')
            self.synapse = value
        value = find_attr_value_('spikeTarget', node)
        if value is not None and 'spikeTarget' not in already_processed:
            already_processed.add('spikeTarget')
            self.spikeTarget = value
        super(PoissonFiringSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PoissonFiringSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PoissonFiringSynapse


class SpikeGeneratorPoisson(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('averageRate', 'Nml2Quantity_pertime', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, averageRate=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpikeGeneratorPoisson, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.averageRate = _cast(None, averageRate)
        self.averageRate_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpikeGeneratorPoisson)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeGeneratorPoisson.subclass:
            return SpikeGeneratorPoisson.subclass(*args_, **kwargs_)
        else:
            return SpikeGeneratorPoisson(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_pertime_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_pertime_patterns_, ))
    validate_Nml2Quantity_pertime_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$']]
    def hasContent_(self):
        if (
            super(SpikeGeneratorPoisson, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeGeneratorPoisson', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpikeGeneratorPoisson')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeGeneratorPoisson')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpikeGeneratorPoisson', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpikeGeneratorPoisson'):
        super(SpikeGeneratorPoisson, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeGeneratorPoisson')
        if self.averageRate is not None and 'averageRate' not in already_processed:
            already_processed.add('averageRate')
            outfile.write(' averageRate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.averageRate), input_name='averageRate')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeGeneratorPoisson', fromsubclass_=False, pretty_print=True):
        super(SpikeGeneratorPoisson, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('averageRate', node)
        if value is not None and 'averageRate' not in already_processed:
            already_processed.add('averageRate')
            self.averageRate = value
            self.validate_Nml2Quantity_pertime(self.averageRate)    # validate type Nml2Quantity_pertime
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SpikeGeneratorPoisson, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SpikeGeneratorPoisson, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SpikeGeneratorPoisson


class SpikeGeneratorRandom(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('maxISI', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('minISI', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, maxISI=None, minISI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpikeGeneratorRandom, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.maxISI = _cast(None, maxISI)
        self.maxISI_nsprefix_ = None
        self.minISI = _cast(None, minISI)
        self.minISI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpikeGeneratorRandom)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeGeneratorRandom.subclass:
            return SpikeGeneratorRandom.subclass(*args_, **kwargs_)
        else:
            return SpikeGeneratorRandom(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (
            super(SpikeGeneratorRandom, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeGeneratorRandom', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpikeGeneratorRandom')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeGeneratorRandom')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpikeGeneratorRandom', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpikeGeneratorRandom'):
        super(SpikeGeneratorRandom, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeGeneratorRandom')
        if self.maxISI is not None and 'maxISI' not in already_processed:
            already_processed.add('maxISI')
            outfile.write(' maxISI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.maxISI), input_name='maxISI')), ))
        if self.minISI is not None and 'minISI' not in already_processed:
            already_processed.add('minISI')
            outfile.write(' minISI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.minISI), input_name='minISI')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeGeneratorRandom', fromsubclass_=False, pretty_print=True):
        super(SpikeGeneratorRandom, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maxISI', node)
        if value is not None and 'maxISI' not in already_processed:
            already_processed.add('maxISI')
            self.maxISI = value
            self.validate_Nml2Quantity_time(self.maxISI)    # validate type Nml2Quantity_time
        value = find_attr_value_('minISI', node)
        if value is not None and 'minISI' not in already_processed:
            already_processed.add('minISI')
            self.minISI = value
            self.validate_Nml2Quantity_time(self.minISI)    # validate type Nml2Quantity_time
        super(SpikeGeneratorRandom, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SpikeGeneratorRandom, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SpikeGeneratorRandom


class SpikeGenerator(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('period', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, period=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpikeGenerator, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.period = _cast(None, period)
        self.period_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpikeGenerator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeGenerator.subclass:
            return SpikeGenerator.subclass(*args_, **kwargs_)
        else:
            return SpikeGenerator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (
            super(SpikeGenerator, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeGenerator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpikeGenerator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeGenerator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpikeGenerator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpikeGenerator'):
        super(SpikeGenerator, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeGenerator')
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.period), input_name='period')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeGenerator', fromsubclass_=False, pretty_print=True):
        super(SpikeGenerator, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = value
            self.validate_Nml2Quantity_time(self.period)    # validate type Nml2Quantity_time
        super(SpikeGenerator, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SpikeGenerator, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SpikeGenerator


class TimedSynapticInput(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('synapse', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('spikeTarget', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('spike', 'Spike', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'spike', 'type': 'Spike'}, None),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, synapse=None, spikeTarget=None, spike=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TimedSynapticInput, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.synapse = _cast(None, synapse)
        self.synapse_nsprefix_ = None
        self.spikeTarget = _cast(None, spikeTarget)
        self.spikeTarget_nsprefix_ = None
        if spike is None:
            self.spike = []
        else:
            self.spike = spike
        self.spike_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimedSynapticInput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimedSynapticInput.subclass:
            return TimedSynapticInput.subclass(*args_, **kwargs_)
        else:
            return TimedSynapticInput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            self.spike or
            super(TimedSynapticInput, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimedSynapticInput', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimedSynapticInput')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimedSynapticInput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimedSynapticInput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimedSynapticInput'):
        super(TimedSynapticInput, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimedSynapticInput')
        if self.synapse is not None and 'synapse' not in already_processed:
            already_processed.add('synapse')
            outfile.write(' synapse=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.synapse), input_name='synapse')), ))
        if self.spikeTarget is not None and 'spikeTarget' not in already_processed:
            already_processed.add('spikeTarget')
            outfile.write(' spikeTarget=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.spikeTarget), input_name='spikeTarget')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimedSynapticInput', fromsubclass_=False, pretty_print=True):
        super(TimedSynapticInput, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for spike_ in self.spike:
            namespaceprefix_ = self.spike_nsprefix_ + ':' if (UseCapturedNS_ and self.spike_nsprefix_) else ''
            spike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spike', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('synapse', node)
        if value is not None and 'synapse' not in already_processed:
            already_processed.add('synapse')
            self.synapse = value
            self.validate_NmlId(self.synapse)    # validate type NmlId
        value = find_attr_value_('spikeTarget', node)
        if value is not None and 'spikeTarget' not in already_processed:
            already_processed.add('spikeTarget')
            self.spikeTarget = value
        super(TimedSynapticInput, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'spike':
            obj_ = Spike.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spike.append(obj_)
            obj_.original_tagname_ = 'spike'
        super(TimedSynapticInput, self).buildChildren(child_, node, nodeName_, True)
# end class TimedSynapticInput


class SpikeArray(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('spike', 'Spike', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'spike', 'type': 'Spike'}, None),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, spike=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpikeArray, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        if spike is None:
            self.spike = []
        else:
            self.spike = spike
        self.spike_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpikeArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeArray.subclass:
            return SpikeArray.subclass(*args_, **kwargs_)
        else:
            return SpikeArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.spike or
            super(SpikeArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeArray', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpikeArray')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpikeArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpikeArray'):
        super(SpikeArray, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeArray')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeArray', fromsubclass_=False, pretty_print=True):
        super(SpikeArray, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for spike_ in self.spike:
            namespaceprefix_ = self.spike_nsprefix_ + ':' if (UseCapturedNS_ and self.spike_nsprefix_) else ''
            spike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spike', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SpikeArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'spike':
            obj_ = Spike.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spike.append(obj_)
            obj_.original_tagname_ = 'spike'
        super(SpikeArray, self).buildChildren(child_, node, nodeName_, True)
# end class SpikeArray


class Spike(BaseNonNegativeIntegerId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('time', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseNonNegativeIntegerId
    def __init__(self, neuroLexId=None, id=None, time=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Spike, self).__init__(neuroLexId, id,  **kwargs_)
        self.time = _cast(None, time)
        self.time_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Spike)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Spike.subclass:
            return Spike.subclass(*args_, **kwargs_)
        else:
            return Spike(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (
            super(Spike, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Spike', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Spike')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Spike')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Spike', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Spike'):
        super(Spike, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Spike')
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.time), input_name='time')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Spike', fromsubclass_=False, pretty_print=True):
        super(Spike, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            self.time = value
            self.validate_Nml2Quantity_time(self.time)    # validate type Nml2Quantity_time
        super(Spike, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(Spike, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Spike


class VoltageClampTriple(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('active', 'ZeroOrOne', 0, 0, {'use': 'required'}),
        MemberSpec_('delay', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('duration', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('conditioningVoltage', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('testingVoltage', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('returnVoltage', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('simpleSeriesResistance', 'Nml2Quantity_resistance', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, active=None, delay=None, duration=None, conditioningVoltage=None, testingVoltage=None, returnVoltage=None, simpleSeriesResistance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(VoltageClampTriple, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.active = _cast(float, active)
        self.active_nsprefix_ = None
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.conditioningVoltage = _cast(None, conditioningVoltage)
        self.conditioningVoltage_nsprefix_ = None
        self.testingVoltage = _cast(None, testingVoltage)
        self.testingVoltage_nsprefix_ = None
        self.returnVoltage = _cast(None, returnVoltage)
        self.returnVoltage_nsprefix_ = None
        self.simpleSeriesResistance = _cast(None, simpleSeriesResistance)
        self.simpleSeriesResistance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoltageClampTriple)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoltageClampTriple.subclass:
            return VoltageClampTriple.subclass(*args_, **kwargs_)
        else:
            return VoltageClampTriple(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ZeroOrOne(self, value):
        # Validate type ZeroOrOne, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [0.0, 1.0]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ZeroOrOne' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def validate_Nml2Quantity_resistance(self, value):
        # Validate type Nml2Quantity_resistance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_resistance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_resistance_patterns_, ))
    validate_Nml2Quantity_resistance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(ohm|kohm|Mohm))$']]
    def hasContent_(self):
        if (
            super(VoltageClampTriple, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VoltageClampTriple', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoltageClampTriple')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoltageClampTriple')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VoltageClampTriple', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoltageClampTriple'):
        super(VoltageClampTriple, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoltageClampTriple')
        if self.active is not None and 'active' not in already_processed:
            already_processed.add('active')
            outfile.write(' active="%s"' % self.gds_format_double(self.active, input_name='active'))
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delay), input_name='delay')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.conditioningVoltage is not None and 'conditioningVoltage' not in already_processed:
            already_processed.add('conditioningVoltage')
            outfile.write(' conditioningVoltage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.conditioningVoltage), input_name='conditioningVoltage')), ))
        if self.testingVoltage is not None and 'testingVoltage' not in already_processed:
            already_processed.add('testingVoltage')
            outfile.write(' testingVoltage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.testingVoltage), input_name='testingVoltage')), ))
        if self.returnVoltage is not None and 'returnVoltage' not in already_processed:
            already_processed.add('returnVoltage')
            outfile.write(' returnVoltage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.returnVoltage), input_name='returnVoltage')), ))
        if self.simpleSeriesResistance is not None and 'simpleSeriesResistance' not in already_processed:
            already_processed.add('simpleSeriesResistance')
            outfile.write(' simpleSeriesResistance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.simpleSeriesResistance), input_name='simpleSeriesResistance')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VoltageClampTriple', fromsubclass_=False, pretty_print=True):
        super(VoltageClampTriple, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('active', node)
        if value is not None and 'active' not in already_processed:
            already_processed.add('active')
            value = self.gds_parse_double(value, node, 'active')
            self.active = value
            self.validate_ZeroOrOne(self.active)    # validate type ZeroOrOne
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            self.delay = value
            self.validate_Nml2Quantity_time(self.delay)    # validate type Nml2Quantity_time
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
            self.validate_Nml2Quantity_time(self.duration)    # validate type Nml2Quantity_time
        value = find_attr_value_('conditioningVoltage', node)
        if value is not None and 'conditioningVoltage' not in already_processed:
            already_processed.add('conditioningVoltage')
            self.conditioningVoltage = value
            self.validate_Nml2Quantity_voltage(self.conditioningVoltage)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('testingVoltage', node)
        if value is not None and 'testingVoltage' not in already_processed:
            already_processed.add('testingVoltage')
            self.testingVoltage = value
            self.validate_Nml2Quantity_voltage(self.testingVoltage)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('returnVoltage', node)
        if value is not None and 'returnVoltage' not in already_processed:
            already_processed.add('returnVoltage')
            self.returnVoltage = value
            self.validate_Nml2Quantity_voltage(self.returnVoltage)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('simpleSeriesResistance', node)
        if value is not None and 'simpleSeriesResistance' not in already_processed:
            already_processed.add('simpleSeriesResistance')
            self.simpleSeriesResistance = value
            self.validate_Nml2Quantity_resistance(self.simpleSeriesResistance)    # validate type Nml2Quantity_resistance
        super(VoltageClampTriple, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(VoltageClampTriple, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VoltageClampTriple


class VoltageClamp(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('delay', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('duration', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('targetVoltage', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('simpleSeriesResistance', 'Nml2Quantity_resistance', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, delay=None, duration=None, targetVoltage=None, simpleSeriesResistance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(VoltageClamp, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.targetVoltage = _cast(None, targetVoltage)
        self.targetVoltage_nsprefix_ = None
        self.simpleSeriesResistance = _cast(None, simpleSeriesResistance)
        self.simpleSeriesResistance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoltageClamp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoltageClamp.subclass:
            return VoltageClamp.subclass(*args_, **kwargs_)
        else:
            return VoltageClamp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def validate_Nml2Quantity_resistance(self, value):
        # Validate type Nml2Quantity_resistance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_resistance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_resistance_patterns_, ))
    validate_Nml2Quantity_resistance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(ohm|kohm|Mohm))$']]
    def hasContent_(self):
        if (
            super(VoltageClamp, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VoltageClamp', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoltageClamp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoltageClamp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VoltageClamp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoltageClamp'):
        super(VoltageClamp, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoltageClamp')
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delay), input_name='delay')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.targetVoltage is not None and 'targetVoltage' not in already_processed:
            already_processed.add('targetVoltage')
            outfile.write(' targetVoltage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetVoltage), input_name='targetVoltage')), ))
        if self.simpleSeriesResistance is not None and 'simpleSeriesResistance' not in already_processed:
            already_processed.add('simpleSeriesResistance')
            outfile.write(' simpleSeriesResistance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.simpleSeriesResistance), input_name='simpleSeriesResistance')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VoltageClamp', fromsubclass_=False, pretty_print=True):
        super(VoltageClamp, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            self.delay = value
            self.validate_Nml2Quantity_time(self.delay)    # validate type Nml2Quantity_time
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
            self.validate_Nml2Quantity_time(self.duration)    # validate type Nml2Quantity_time
        value = find_attr_value_('targetVoltage', node)
        if value is not None and 'targetVoltage' not in already_processed:
            already_processed.add('targetVoltage')
            self.targetVoltage = value
            self.validate_Nml2Quantity_voltage(self.targetVoltage)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('simpleSeriesResistance', node)
        if value is not None and 'simpleSeriesResistance' not in already_processed:
            already_processed.add('simpleSeriesResistance')
            self.simpleSeriesResistance = value
            self.validate_Nml2Quantity_resistance(self.simpleSeriesResistance)    # validate type Nml2Quantity_resistance
        super(VoltageClamp, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(VoltageClamp, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VoltageClamp


class CompoundInputDL(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('pulseGeneratorDL', 'PulseGeneratorDL', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'pulseGeneratorDL', 'type': 'PulseGeneratorDL'}, None),
        MemberSpec_('sineGeneratorDL', 'SineGeneratorDL', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'sineGeneratorDL', 'type': 'SineGeneratorDL'}, None),
        MemberSpec_('rampGeneratorDL', 'RampGeneratorDL', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'rampGeneratorDL', 'type': 'RampGeneratorDL'}, None),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, pulseGeneratorDL=None, sineGeneratorDL=None, rampGeneratorDL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CompoundInputDL, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        if pulseGeneratorDL is None:
            self.pulseGeneratorDL = []
        else:
            self.pulseGeneratorDL = pulseGeneratorDL
        self.pulseGeneratorDL_nsprefix_ = None
        if sineGeneratorDL is None:
            self.sineGeneratorDL = []
        else:
            self.sineGeneratorDL = sineGeneratorDL
        self.sineGeneratorDL_nsprefix_ = None
        if rampGeneratorDL is None:
            self.rampGeneratorDL = []
        else:
            self.rampGeneratorDL = rampGeneratorDL
        self.rampGeneratorDL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompoundInputDL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompoundInputDL.subclass:
            return CompoundInputDL.subclass(*args_, **kwargs_)
        else:
            return CompoundInputDL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.pulseGeneratorDL or
            self.sineGeneratorDL or
            self.rampGeneratorDL or
            super(CompoundInputDL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CompoundInputDL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompoundInputDL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompoundInputDL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CompoundInputDL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CompoundInputDL'):
        super(CompoundInputDL, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompoundInputDL')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CompoundInputDL', fromsubclass_=False, pretty_print=True):
        super(CompoundInputDL, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pulseGeneratorDL_ in self.pulseGeneratorDL:
            namespaceprefix_ = self.pulseGeneratorDL_nsprefix_ + ':' if (UseCapturedNS_ and self.pulseGeneratorDL_nsprefix_) else ''
            pulseGeneratorDL_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pulseGeneratorDL', pretty_print=pretty_print)
        for sineGeneratorDL_ in self.sineGeneratorDL:
            namespaceprefix_ = self.sineGeneratorDL_nsprefix_ + ':' if (UseCapturedNS_ and self.sineGeneratorDL_nsprefix_) else ''
            sineGeneratorDL_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sineGeneratorDL', pretty_print=pretty_print)
        for rampGeneratorDL_ in self.rampGeneratorDL:
            namespaceprefix_ = self.rampGeneratorDL_nsprefix_ + ':' if (UseCapturedNS_ and self.rampGeneratorDL_nsprefix_) else ''
            rampGeneratorDL_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rampGeneratorDL', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CompoundInputDL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'pulseGeneratorDL':
            obj_ = PulseGeneratorDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pulseGeneratorDL.append(obj_)
            obj_.original_tagname_ = 'pulseGeneratorDL'
        elif nodeName_ == 'sineGeneratorDL':
            obj_ = SineGeneratorDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sineGeneratorDL.append(obj_)
            obj_.original_tagname_ = 'sineGeneratorDL'
        elif nodeName_ == 'rampGeneratorDL':
            obj_ = RampGeneratorDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rampGeneratorDL.append(obj_)
            obj_.original_tagname_ = 'rampGeneratorDL'
        super(CompoundInputDL, self).buildChildren(child_, node, nodeName_, True)
# end class CompoundInputDL


class CompoundInput(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('pulseGenerator', 'PulseGenerator', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'pulseGenerator', 'type': 'PulseGenerator'}, None),
        MemberSpec_('sineGenerator', 'SineGenerator', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'sineGenerator', 'type': 'SineGenerator'}, None),
        MemberSpec_('rampGenerator', 'RampGenerator', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'rampGenerator', 'type': 'RampGenerator'}, None),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, pulseGenerator=None, sineGenerator=None, rampGenerator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CompoundInput, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        if pulseGenerator is None:
            self.pulseGenerator = []
        else:
            self.pulseGenerator = pulseGenerator
        self.pulseGenerator_nsprefix_ = None
        if sineGenerator is None:
            self.sineGenerator = []
        else:
            self.sineGenerator = sineGenerator
        self.sineGenerator_nsprefix_ = None
        if rampGenerator is None:
            self.rampGenerator = []
        else:
            self.rampGenerator = rampGenerator
        self.rampGenerator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompoundInput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompoundInput.subclass:
            return CompoundInput.subclass(*args_, **kwargs_)
        else:
            return CompoundInput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.pulseGenerator or
            self.sineGenerator or
            self.rampGenerator or
            super(CompoundInput, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CompoundInput', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompoundInput')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompoundInput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CompoundInput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CompoundInput'):
        super(CompoundInput, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompoundInput')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CompoundInput', fromsubclass_=False, pretty_print=True):
        super(CompoundInput, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pulseGenerator_ in self.pulseGenerator:
            namespaceprefix_ = self.pulseGenerator_nsprefix_ + ':' if (UseCapturedNS_ and self.pulseGenerator_nsprefix_) else ''
            pulseGenerator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pulseGenerator', pretty_print=pretty_print)
        for sineGenerator_ in self.sineGenerator:
            namespaceprefix_ = self.sineGenerator_nsprefix_ + ':' if (UseCapturedNS_ and self.sineGenerator_nsprefix_) else ''
            sineGenerator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sineGenerator', pretty_print=pretty_print)
        for rampGenerator_ in self.rampGenerator:
            namespaceprefix_ = self.rampGenerator_nsprefix_ + ':' if (UseCapturedNS_ and self.rampGenerator_nsprefix_) else ''
            rampGenerator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rampGenerator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CompoundInput, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'pulseGenerator':
            obj_ = PulseGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pulseGenerator.append(obj_)
            obj_.original_tagname_ = 'pulseGenerator'
        elif nodeName_ == 'sineGenerator':
            obj_ = SineGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sineGenerator.append(obj_)
            obj_.original_tagname_ = 'sineGenerator'
        elif nodeName_ == 'rampGenerator':
            obj_ = RampGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rampGenerator.append(obj_)
            obj_.original_tagname_ = 'rampGenerator'
        super(CompoundInput, self).buildChildren(child_, node, nodeName_, True)
# end class CompoundInput


class RampGeneratorDL(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('delay', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('duration', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('startAmplitude', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('finishAmplitude', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('baselineAmplitude', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, delay=None, duration=None, startAmplitude=None, finishAmplitude=None, baselineAmplitude=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RampGeneratorDL, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.startAmplitude = _cast(None, startAmplitude)
        self.startAmplitude_nsprefix_ = None
        self.finishAmplitude = _cast(None, finishAmplitude)
        self.finishAmplitude_nsprefix_ = None
        self.baselineAmplitude = _cast(None, baselineAmplitude)
        self.baselineAmplitude_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RampGeneratorDL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RampGeneratorDL.subclass:
            return RampGeneratorDL.subclass(*args_, **kwargs_)
        else:
            return RampGeneratorDL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_none_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_none_patterns_, ))
    validate_Nml2Quantity_none_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$']]
    def hasContent_(self):
        if (
            super(RampGeneratorDL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RampGeneratorDL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RampGeneratorDL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RampGeneratorDL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RampGeneratorDL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RampGeneratorDL'):
        super(RampGeneratorDL, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RampGeneratorDL')
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delay), input_name='delay')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.startAmplitude is not None and 'startAmplitude' not in already_processed:
            already_processed.add('startAmplitude')
            outfile.write(' startAmplitude=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.startAmplitude), input_name='startAmplitude')), ))
        if self.finishAmplitude is not None and 'finishAmplitude' not in already_processed:
            already_processed.add('finishAmplitude')
            outfile.write(' finishAmplitude=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.finishAmplitude), input_name='finishAmplitude')), ))
        if self.baselineAmplitude is not None and 'baselineAmplitude' not in already_processed:
            already_processed.add('baselineAmplitude')
            outfile.write(' baselineAmplitude=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.baselineAmplitude), input_name='baselineAmplitude')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RampGeneratorDL', fromsubclass_=False, pretty_print=True):
        super(RampGeneratorDL, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            self.delay = value
            self.validate_Nml2Quantity_time(self.delay)    # validate type Nml2Quantity_time
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
            self.validate_Nml2Quantity_time(self.duration)    # validate type Nml2Quantity_time
        value = find_attr_value_('startAmplitude', node)
        if value is not None and 'startAmplitude' not in already_processed:
            already_processed.add('startAmplitude')
            self.startAmplitude = value
            self.validate_Nml2Quantity_none(self.startAmplitude)    # validate type Nml2Quantity_none
        value = find_attr_value_('finishAmplitude', node)
        if value is not None and 'finishAmplitude' not in already_processed:
            already_processed.add('finishAmplitude')
            self.finishAmplitude = value
            self.validate_Nml2Quantity_none(self.finishAmplitude)    # validate type Nml2Quantity_none
        value = find_attr_value_('baselineAmplitude', node)
        if value is not None and 'baselineAmplitude' not in already_processed:
            already_processed.add('baselineAmplitude')
            self.baselineAmplitude = value
            self.validate_Nml2Quantity_none(self.baselineAmplitude)    # validate type Nml2Quantity_none
        super(RampGeneratorDL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RampGeneratorDL, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RampGeneratorDL


class RampGenerator(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('delay', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('duration', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('startAmplitude', 'Nml2Quantity_current', 0, 0, {'use': 'required'}),
        MemberSpec_('finishAmplitude', 'Nml2Quantity_current', 0, 0, {'use': 'required'}),
        MemberSpec_('baselineAmplitude', 'Nml2Quantity_current', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, delay=None, duration=None, startAmplitude=None, finishAmplitude=None, baselineAmplitude=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RampGenerator, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.startAmplitude = _cast(None, startAmplitude)
        self.startAmplitude_nsprefix_ = None
        self.finishAmplitude = _cast(None, finishAmplitude)
        self.finishAmplitude_nsprefix_ = None
        self.baselineAmplitude = _cast(None, baselineAmplitude)
        self.baselineAmplitude_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RampGenerator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RampGenerator.subclass:
            return RampGenerator.subclass(*args_, **kwargs_)
        else:
            return RampGenerator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_current_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_current_patterns_, ))
    validate_Nml2Quantity_current_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A|uA|nA|pA))$']]
    def hasContent_(self):
        if (
            super(RampGenerator, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RampGenerator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RampGenerator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RampGenerator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RampGenerator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RampGenerator'):
        super(RampGenerator, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RampGenerator')
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delay), input_name='delay')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.startAmplitude is not None and 'startAmplitude' not in already_processed:
            already_processed.add('startAmplitude')
            outfile.write(' startAmplitude=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.startAmplitude), input_name='startAmplitude')), ))
        if self.finishAmplitude is not None and 'finishAmplitude' not in already_processed:
            already_processed.add('finishAmplitude')
            outfile.write(' finishAmplitude=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.finishAmplitude), input_name='finishAmplitude')), ))
        if self.baselineAmplitude is not None and 'baselineAmplitude' not in already_processed:
            already_processed.add('baselineAmplitude')
            outfile.write(' baselineAmplitude=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.baselineAmplitude), input_name='baselineAmplitude')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RampGenerator', fromsubclass_=False, pretty_print=True):
        super(RampGenerator, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            self.delay = value
            self.validate_Nml2Quantity_time(self.delay)    # validate type Nml2Quantity_time
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
            self.validate_Nml2Quantity_time(self.duration)    # validate type Nml2Quantity_time
        value = find_attr_value_('startAmplitude', node)
        if value is not None and 'startAmplitude' not in already_processed:
            already_processed.add('startAmplitude')
            self.startAmplitude = value
            self.validate_Nml2Quantity_current(self.startAmplitude)    # validate type Nml2Quantity_current
        value = find_attr_value_('finishAmplitude', node)
        if value is not None and 'finishAmplitude' not in already_processed:
            already_processed.add('finishAmplitude')
            self.finishAmplitude = value
            self.validate_Nml2Quantity_current(self.finishAmplitude)    # validate type Nml2Quantity_current
        value = find_attr_value_('baselineAmplitude', node)
        if value is not None and 'baselineAmplitude' not in already_processed:
            already_processed.add('baselineAmplitude')
            self.baselineAmplitude = value
            self.validate_Nml2Quantity_current(self.baselineAmplitude)    # validate type Nml2Quantity_current
        super(RampGenerator, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RampGenerator, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RampGenerator


class SineGeneratorDL(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('delay', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('phase', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('duration', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('amplitude', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('period', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, delay=None, phase=None, duration=None, amplitude=None, period=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SineGeneratorDL, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.phase = _cast(None, phase)
        self.phase_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.amplitude = _cast(None, amplitude)
        self.amplitude_nsprefix_ = None
        self.period = _cast(None, period)
        self.period_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SineGeneratorDL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SineGeneratorDL.subclass:
            return SineGeneratorDL.subclass(*args_, **kwargs_)
        else:
            return SineGeneratorDL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_none_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_none_patterns_, ))
    validate_Nml2Quantity_none_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$']]
    def hasContent_(self):
        if (
            super(SineGeneratorDL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SineGeneratorDL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SineGeneratorDL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SineGeneratorDL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SineGeneratorDL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SineGeneratorDL'):
        super(SineGeneratorDL, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SineGeneratorDL')
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delay), input_name='delay')), ))
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            outfile.write(' phase=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.phase), input_name='phase')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.amplitude is not None and 'amplitude' not in already_processed:
            already_processed.add('amplitude')
            outfile.write(' amplitude=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.amplitude), input_name='amplitude')), ))
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.period), input_name='period')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SineGeneratorDL', fromsubclass_=False, pretty_print=True):
        super(SineGeneratorDL, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            self.delay = value
            self.validate_Nml2Quantity_time(self.delay)    # validate type Nml2Quantity_time
        value = find_attr_value_('phase', node)
        if value is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            self.phase = value
            self.validate_Nml2Quantity_none(self.phase)    # validate type Nml2Quantity_none
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
            self.validate_Nml2Quantity_time(self.duration)    # validate type Nml2Quantity_time
        value = find_attr_value_('amplitude', node)
        if value is not None and 'amplitude' not in already_processed:
            already_processed.add('amplitude')
            self.amplitude = value
            self.validate_Nml2Quantity_none(self.amplitude)    # validate type Nml2Quantity_none
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = value
            self.validate_Nml2Quantity_time(self.period)    # validate type Nml2Quantity_time
        super(SineGeneratorDL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SineGeneratorDL, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SineGeneratorDL


class SineGenerator(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('delay', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('phase', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('duration', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('amplitude', 'Nml2Quantity_current', 0, 0, {'use': 'required'}),
        MemberSpec_('period', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, delay=None, phase=None, duration=None, amplitude=None, period=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SineGenerator, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.phase = _cast(None, phase)
        self.phase_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.amplitude = _cast(None, amplitude)
        self.amplitude_nsprefix_ = None
        self.period = _cast(None, period)
        self.period_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SineGenerator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SineGenerator.subclass:
            return SineGenerator.subclass(*args_, **kwargs_)
        else:
            return SineGenerator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_none_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_none_patterns_, ))
    validate_Nml2Quantity_none_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$']]
    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_current_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_current_patterns_, ))
    validate_Nml2Quantity_current_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A|uA|nA|pA))$']]
    def hasContent_(self):
        if (
            super(SineGenerator, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SineGenerator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SineGenerator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SineGenerator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SineGenerator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SineGenerator'):
        super(SineGenerator, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SineGenerator')
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delay), input_name='delay')), ))
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            outfile.write(' phase=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.phase), input_name='phase')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.amplitude is not None and 'amplitude' not in already_processed:
            already_processed.add('amplitude')
            outfile.write(' amplitude=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.amplitude), input_name='amplitude')), ))
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.period), input_name='period')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SineGenerator', fromsubclass_=False, pretty_print=True):
        super(SineGenerator, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            self.delay = value
            self.validate_Nml2Quantity_time(self.delay)    # validate type Nml2Quantity_time
        value = find_attr_value_('phase', node)
        if value is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            self.phase = value
            self.validate_Nml2Quantity_none(self.phase)    # validate type Nml2Quantity_none
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
            self.validate_Nml2Quantity_time(self.duration)    # validate type Nml2Quantity_time
        value = find_attr_value_('amplitude', node)
        if value is not None and 'amplitude' not in already_processed:
            already_processed.add('amplitude')
            self.amplitude = value
            self.validate_Nml2Quantity_current(self.amplitude)    # validate type Nml2Quantity_current
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = value
            self.validate_Nml2Quantity_time(self.period)    # validate type Nml2Quantity_time
        super(SineGenerator, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SineGenerator, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SineGenerator


class PulseGeneratorDL(Standalone):
    """Generates a constant current pulse of a certain amplitude (non
    dimensional) for a specified duration after a delay."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('delay', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('duration', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('amplitude', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, delay=None, duration=None, amplitude=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PulseGeneratorDL, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.amplitude = _cast(None, amplitude)
        self.amplitude_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PulseGeneratorDL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PulseGeneratorDL.subclass:
            return PulseGeneratorDL.subclass(*args_, **kwargs_)
        else:
            return PulseGeneratorDL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_none_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_none_patterns_, ))
    validate_Nml2Quantity_none_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$']]
    def hasContent_(self):
        if (
            super(PulseGeneratorDL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PulseGeneratorDL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PulseGeneratorDL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PulseGeneratorDL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PulseGeneratorDL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PulseGeneratorDL'):
        super(PulseGeneratorDL, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PulseGeneratorDL')
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delay), input_name='delay')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.amplitude is not None and 'amplitude' not in already_processed:
            already_processed.add('amplitude')
            outfile.write(' amplitude=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.amplitude), input_name='amplitude')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PulseGeneratorDL', fromsubclass_=False, pretty_print=True):
        super(PulseGeneratorDL, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            self.delay = value
            self.validate_Nml2Quantity_time(self.delay)    # validate type Nml2Quantity_time
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
            self.validate_Nml2Quantity_time(self.duration)    # validate type Nml2Quantity_time
        value = find_attr_value_('amplitude', node)
        if value is not None and 'amplitude' not in already_processed:
            already_processed.add('amplitude')
            self.amplitude = value
            self.validate_Nml2Quantity_none(self.amplitude)    # validate type Nml2Quantity_none
        super(PulseGeneratorDL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PulseGeneratorDL, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PulseGeneratorDL


class PulseGenerator(Standalone):
    """Generates a constant current pulse of a certain amplitude (with
    dimensions for current) for a specified duration after a delay."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('delay', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('duration', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('amplitude', 'Nml2Quantity_current', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, delay=None, duration=None, amplitude=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PulseGenerator, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
        self.duration = _cast(None, duration)
        self.duration_nsprefix_ = None
        self.amplitude = _cast(None, amplitude)
        self.amplitude_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PulseGenerator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PulseGenerator.subclass:
            return PulseGenerator.subclass(*args_, **kwargs_)
        else:
            return PulseGenerator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_current_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_current_patterns_, ))
    validate_Nml2Quantity_current_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A|uA|nA|pA))$']]
    def hasContent_(self):
        if (
            super(PulseGenerator, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PulseGenerator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PulseGenerator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PulseGenerator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PulseGenerator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PulseGenerator'):
        super(PulseGenerator, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PulseGenerator')
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delay), input_name='delay')), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.duration), input_name='duration')), ))
        if self.amplitude is not None and 'amplitude' not in already_processed:
            already_processed.add('amplitude')
            outfile.write(' amplitude=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.amplitude), input_name='amplitude')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PulseGenerator', fromsubclass_=False, pretty_print=True):
        super(PulseGenerator, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            self.delay = value
            self.validate_Nml2Quantity_time(self.delay)    # validate type Nml2Quantity_time
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            self.duration = value
            self.validate_Nml2Quantity_time(self.duration)    # validate type Nml2Quantity_time
        value = find_attr_value_('amplitude', node)
        if value is not None and 'amplitude' not in already_processed:
            already_processed.add('amplitude')
            self.amplitude = value
            self.validate_Nml2Quantity_current(self.amplitude)    # validate type Nml2Quantity_current
        super(PulseGenerator, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PulseGenerator, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PulseGenerator


class ReactionScheme(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('source', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('type_', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('__ANY__', '__ANY__', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'processContents': 'skip'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, source=None, type_=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ReactionScheme, self).__init__(neuroLexId, id,  **kwargs_)
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReactionScheme)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReactionScheme.subclass:
            return ReactionScheme.subclass(*args_, **kwargs_)
        else:
            return ReactionScheme(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            super(ReactionScheme, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReactionScheme', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReactionScheme')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReactionScheme')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReactionScheme', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReactionScheme'):
        super(ReactionScheme, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReactionScheme')
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReactionScheme', fromsubclass_=False, pretty_print=True):
        super(ReactionScheme, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(ReactionScheme, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'ReactionScheme')
        self.add_anytypeobjs_(content_)
        super(ReactionScheme, self).buildChildren(child_, node, nodeName_, True)
# end class ReactionScheme


class ExtracellularProperties(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('species', 'Species', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'species', 'type': 'Species'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, species=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ExtracellularProperties, self).__init__(neuroLexId, id,  **kwargs_)
        if species is None:
            self.species = []
        else:
            self.species = species
        self.species_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtracellularProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtracellularProperties.subclass:
            return ExtracellularProperties.subclass(*args_, **kwargs_)
        else:
            return ExtracellularProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.species or
            super(ExtracellularProperties, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExtracellularProperties', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExtracellularProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExtracellularProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExtracellularProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExtracellularProperties'):
        super(ExtracellularProperties, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExtracellularProperties')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExtracellularProperties', fromsubclass_=False, pretty_print=True):
        super(ExtracellularProperties, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for species_ in self.species:
            namespaceprefix_ = self.species_nsprefix_ + ':' if (UseCapturedNS_ and self.species_nsprefix_) else ''
            species_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='species', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExtracellularProperties, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'species':
            obj_ = Species.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.species.append(obj_)
            obj_.original_tagname_ = 'species'
        super(ExtracellularProperties, self).buildChildren(child_, node, nodeName_, True)
# end class ExtracellularProperties


class ChannelDensityGHK2(Base):
    """Specifying the ion here again is redundant, this will be set in
    ionChannel definition. It is added here
    TEMPORARILY since selecting all ca or na conducting channel
    populations/densities in a cell would be difficult otherwise.
    Also, it will make it easier to set the correct native simulator value for
    erev (e.g. ek for ion = k in NEURON).
    Currently a required attribute.
    It should be removed in the longer term, due to possible inconsistencies in
    this value and that in the ionChannel
    element. TODO: remove."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ionChannel', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('condDensity', 'Nml2Quantity_conductanceDensity', 0, 1, {'use': 'optional'}),
        MemberSpec_('segmentGroup', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('segment', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('ion', 'NmlId', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, ionChannel=None, condDensity=None, segmentGroup='all', segment=None, ion=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ChannelDensityGHK2, self).__init__(neuroLexId, id,  **kwargs_)
        self.ionChannel = _cast(None, ionChannel)
        self.ionChannel_nsprefix_ = None
        self.condDensity = _cast(None, condDensity)
        self.condDensity_nsprefix_ = None
        self.segmentGroup = _cast(None, segmentGroup)
        self.segmentGroup_nsprefix_ = None
        self.segment = _cast(None, segment)
        self.segment_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityGHK2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityGHK2.subclass:
            return ChannelDensityGHK2.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityGHK2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_conductanceDensity(self, value):
        # Validate type Nml2Quantity_conductanceDensity, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductanceDensity_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductanceDensity_patterns_, ))
    validate_Nml2Quantity_conductanceDensity_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S_per_m2|mS_per_cm2|S_per_cm2))$']]
    def hasContent_(self):
        if (
            super(ChannelDensityGHK2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityGHK2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelDensityGHK2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityGHK2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChannelDensityGHK2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChannelDensityGHK2'):
        super(ChannelDensityGHK2, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityGHK2')
        if self.ionChannel is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            outfile.write(' ionChannel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ionChannel), input_name='ionChannel')), ))
        if self.condDensity is not None and 'condDensity' not in already_processed:
            already_processed.add('condDensity')
            outfile.write(' condDensity=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.condDensity), input_name='condDensity')), ))
        if self.segmentGroup != "all" and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            outfile.write(' segmentGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segmentGroup), input_name='segmentGroup')), ))
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            outfile.write(' segment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segment), input_name='segment')), ))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            outfile.write(' ion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ion), input_name='ion')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityGHK2', fromsubclass_=False, pretty_print=True):
        super(ChannelDensityGHK2, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ionChannel', node)
        if value is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            self.ionChannel = value
            self.validate_NmlId(self.ionChannel)    # validate type NmlId
        value = find_attr_value_('condDensity', node)
        if value is not None and 'condDensity' not in already_processed:
            already_processed.add('condDensity')
            self.condDensity = value
            self.validate_Nml2Quantity_conductanceDensity(self.condDensity)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('segmentGroup', node)
        if value is not None and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            self.segmentGroup = value
            self.validate_NmlId(self.segmentGroup)    # validate type NmlId
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            self.segment = value
            self.validate_NmlId(self.segment)    # validate type NmlId
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            self.ion = value
            self.validate_NmlId(self.ion)    # validate type NmlId
        super(ChannelDensityGHK2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ChannelDensityGHK2, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ChannelDensityGHK2


class ChannelDensityGHK(Base):
    """Specifying the ion here again is redundant, this will be set in
    ionChannel definition. It is added here
    TEMPORARILY since selecting all ca or na conducting channel
    populations/densities in a cell would be difficult otherwise.
    Also, it will make it easier to set the correct native simulator value for
    erev (e.g. ek for ion = k in NEURON).
    Currently a required attribute.
    It should be removed in the longer term, due to possible inconsistencies in
    this value and that in the ionChannel
    element. TODO: remove."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ionChannel', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('permeability', 'Nml2Quantity_permeability', 0, 0, {'use': 'required'}),
        MemberSpec_('segmentGroup', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('segment', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('ion', 'NmlId', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, ionChannel=None, permeability=None, segmentGroup='all', segment=None, ion=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ChannelDensityGHK, self).__init__(neuroLexId, id,  **kwargs_)
        self.ionChannel = _cast(None, ionChannel)
        self.ionChannel_nsprefix_ = None
        self.permeability = _cast(None, permeability)
        self.permeability_nsprefix_ = None
        self.segmentGroup = _cast(None, segmentGroup)
        self.segmentGroup_nsprefix_ = None
        self.segment = _cast(None, segment)
        self.segment_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityGHK)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityGHK.subclass:
            return ChannelDensityGHK.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityGHK(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_permeability(self, value):
        # Validate type Nml2Quantity_permeability, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_permeability_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_permeability_patterns_, ))
    validate_Nml2Quantity_permeability_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(m_per_s|                        um_per_ms|cm_per_s|cm_per_ms))$']]
    def hasContent_(self):
        if (
            super(ChannelDensityGHK, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityGHK', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelDensityGHK')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityGHK')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChannelDensityGHK', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChannelDensityGHK'):
        super(ChannelDensityGHK, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityGHK')
        if self.ionChannel is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            outfile.write(' ionChannel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ionChannel), input_name='ionChannel')), ))
        if self.permeability is not None and 'permeability' not in already_processed:
            already_processed.add('permeability')
            outfile.write(' permeability=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.permeability), input_name='permeability')), ))
        if self.segmentGroup != "all" and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            outfile.write(' segmentGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segmentGroup), input_name='segmentGroup')), ))
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            outfile.write(' segment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segment), input_name='segment')), ))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            outfile.write(' ion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ion), input_name='ion')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityGHK', fromsubclass_=False, pretty_print=True):
        super(ChannelDensityGHK, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ionChannel', node)
        if value is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            self.ionChannel = value
            self.validate_NmlId(self.ionChannel)    # validate type NmlId
        value = find_attr_value_('permeability', node)
        if value is not None and 'permeability' not in already_processed:
            already_processed.add('permeability')
            self.permeability = value
            self.validate_Nml2Quantity_permeability(self.permeability)    # validate type Nml2Quantity_permeability
        value = find_attr_value_('segmentGroup', node)
        if value is not None and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            self.segmentGroup = value
            self.validate_NmlId(self.segmentGroup)    # validate type NmlId
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            self.segment = value
            self.validate_NmlId(self.segment)    # validate type NmlId
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            self.ion = value
            self.validate_NmlId(self.ion)    # validate type NmlId
        super(ChannelDensityGHK, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ChannelDensityGHK, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ChannelDensityGHK


class ChannelDensityNernst(Base):
    """Specifying the ion here again is redundant, this will be set in
    ionChannel definition. It is added here
    TEMPORARILY since selecting all ca or na conducting channel
    populations/densities in a cell would be difficult otherwise.
    Also, it will make it easier to set the correct native simulator value for
    erev (e.g. ek for ion = k in NEURON).
    Currently a required attribute.
    It should be removed in the longer term, due to possible inconsistencies in
    this value and that in the ionChannel
    element. TODO: remove."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ionChannel', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('condDensity', 'Nml2Quantity_conductanceDensity', 0, 1, {'use': 'optional'}),
        MemberSpec_('segmentGroup', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('segment', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('ion', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('variableParameter', 'VariableParameter', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'variableParameter', 'type': 'VariableParameter'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, ionChannel=None, condDensity=None, segmentGroup='all', segment=None, ion=None, variableParameter=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ChannelDensityNernst, self).__init__(neuroLexId, id, extensiontype_,  **kwargs_)
        self.ionChannel = _cast(None, ionChannel)
        self.ionChannel_nsprefix_ = None
        self.condDensity = _cast(None, condDensity)
        self.condDensity_nsprefix_ = None
        self.segmentGroup = _cast(None, segmentGroup)
        self.segmentGroup_nsprefix_ = None
        self.segment = _cast(None, segment)
        self.segment_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        if variableParameter is None:
            self.variableParameter = []
        else:
            self.variableParameter = variableParameter
        self.variableParameter_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityNernst)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityNernst.subclass:
            return ChannelDensityNernst.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityNernst(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_conductanceDensity(self, value):
        # Validate type Nml2Quantity_conductanceDensity, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductanceDensity_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductanceDensity_patterns_, ))
    validate_Nml2Quantity_conductanceDensity_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S_per_m2|mS_per_cm2|S_per_cm2))$']]
    def hasContent_(self):
        if (
            self.variableParameter or
            super(ChannelDensityNernst, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityNernst', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelDensityNernst')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityNernst')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChannelDensityNernst', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChannelDensityNernst'):
        super(ChannelDensityNernst, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityNernst')
        if self.ionChannel is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            outfile.write(' ionChannel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ionChannel), input_name='ionChannel')), ))
        if self.condDensity is not None and 'condDensity' not in already_processed:
            already_processed.add('condDensity')
            outfile.write(' condDensity=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.condDensity), input_name='condDensity')), ))
        if self.segmentGroup != "all" and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            outfile.write(' segmentGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segmentGroup), input_name='segmentGroup')), ))
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            outfile.write(' segment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segment), input_name='segment')), ))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            outfile.write(' ion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ion), input_name='ion')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityNernst', fromsubclass_=False, pretty_print=True):
        super(ChannelDensityNernst, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for variableParameter_ in self.variableParameter:
            namespaceprefix_ = self.variableParameter_nsprefix_ + ':' if (UseCapturedNS_ and self.variableParameter_nsprefix_) else ''
            variableParameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variableParameter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ionChannel', node)
        if value is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            self.ionChannel = value
            self.validate_NmlId(self.ionChannel)    # validate type NmlId
        value = find_attr_value_('condDensity', node)
        if value is not None and 'condDensity' not in already_processed:
            already_processed.add('condDensity')
            self.condDensity = value
            self.validate_Nml2Quantity_conductanceDensity(self.condDensity)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('segmentGroup', node)
        if value is not None and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            self.segmentGroup = value
            self.validate_NmlId(self.segmentGroup)    # validate type NmlId
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            self.segment = value
            self.validate_NmlId(self.segment)    # validate type NmlId
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            self.ion = value
            self.validate_NmlId(self.ion)    # validate type NmlId
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ChannelDensityNernst, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'variableParameter':
            obj_ = VariableParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variableParameter.append(obj_)
            obj_.original_tagname_ = 'variableParameter'
        super(ChannelDensityNernst, self).buildChildren(child_, node, nodeName_, True)
# end class ChannelDensityNernst


class ChannelDensity(Base):
    """Specifying the ion here again is redundant, this will be set in
    ionChannel definition. It is added here
    TEMPORARILY since selecting all ca or na conducting channel
    populations/densities in a cell would be difficult otherwise.
    Also, it will make it easier to set the correct native simulator value for
    erev (e.g. ek for ion = k in NEURON).
    Currently a required attribute.
    It should be removed in the longer term, due to possible inconsistencies in
    this value and that in the ionChannel
    element. TODO: remove."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ionChannel', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('condDensity', 'Nml2Quantity_conductanceDensity', 0, 1, {'use': 'optional'}),
        MemberSpec_('erev', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('segmentGroup', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('segment', 'NonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('ion', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('variableParameter', 'VariableParameter', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'variableParameter', 'type': 'VariableParameter'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, ionChannel=None, condDensity=None, erev=None, segmentGroup='all', segment=None, ion=None, variableParameter=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ChannelDensity, self).__init__(neuroLexId, id, extensiontype_,  **kwargs_)
        self.ionChannel = _cast(None, ionChannel)
        self.ionChannel_nsprefix_ = None
        self.condDensity = _cast(None, condDensity)
        self.condDensity_nsprefix_ = None
        self.erev = _cast(None, erev)
        self.erev_nsprefix_ = None
        self.segmentGroup = _cast(None, segmentGroup)
        self.segmentGroup_nsprefix_ = None
        self.segment = _cast(int, segment)
        self.segment_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        if variableParameter is None:
            self.variableParameter = []
        else:
            self.variableParameter = variableParameter
        self.variableParameter_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensity.subclass:
            return ChannelDensity.subclass(*args_, **kwargs_)
        else:
            return ChannelDensity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_conductanceDensity(self, value):
        # Validate type Nml2Quantity_conductanceDensity, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductanceDensity_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductanceDensity_patterns_, ))
    validate_Nml2Quantity_conductanceDensity_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S_per_m2|mS_per_cm2|S_per_cm2))$']]
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.variableParameter or
            super(ChannelDensity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelDensity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChannelDensity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChannelDensity'):
        super(ChannelDensity, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensity')
        if self.ionChannel is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            outfile.write(' ionChannel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ionChannel), input_name='ionChannel')), ))
        if self.condDensity is not None and 'condDensity' not in already_processed:
            already_processed.add('condDensity')
            outfile.write(' condDensity=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.condDensity), input_name='condDensity')), ))
        if self.erev is not None and 'erev' not in already_processed:
            already_processed.add('erev')
            outfile.write(' erev=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.erev), input_name='erev')), ))
        if self.segmentGroup != "all" and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            outfile.write(' segmentGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segmentGroup), input_name='segmentGroup')), ))
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            outfile.write(' segment="%s"' % self.gds_format_integer(self.segment, input_name='segment'))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            outfile.write(' ion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ion), input_name='ion')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensity', fromsubclass_=False, pretty_print=True):
        super(ChannelDensity, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for variableParameter_ in self.variableParameter:
            namespaceprefix_ = self.variableParameter_nsprefix_ + ':' if (UseCapturedNS_ and self.variableParameter_nsprefix_) else ''
            variableParameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variableParameter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ionChannel', node)
        if value is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            self.ionChannel = value
            self.validate_NmlId(self.ionChannel)    # validate type NmlId
        value = find_attr_value_('condDensity', node)
        if value is not None and 'condDensity' not in already_processed:
            already_processed.add('condDensity')
            self.condDensity = value
            self.validate_Nml2Quantity_conductanceDensity(self.condDensity)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('erev', node)
        if value is not None and 'erev' not in already_processed:
            already_processed.add('erev')
            self.erev = value
            self.validate_Nml2Quantity_voltage(self.erev)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('segmentGroup', node)
        if value is not None and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            self.segmentGroup = value
            self.validate_NmlId(self.segmentGroup)    # validate type NmlId
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            self.segment = self.gds_parse_integer(value, node, 'segment')
            if self.segment < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.segment)    # validate type NonNegativeInteger
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            self.ion = value
            self.validate_NmlId(self.ion)    # validate type NmlId
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ChannelDensity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'variableParameter':
            obj_ = VariableParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variableParameter.append(obj_)
            obj_.original_tagname_ = 'variableParameter'
        super(ChannelDensity, self).buildChildren(child_, node, nodeName_, True)
# end class ChannelDensity


class ChannelDensityNonUniformGHK(Base):
    """Specifying the ion here again is redundant, this will be set in
    ionChannel definition. It is added here
    TEMPORARILY since selecting all ca or na conducting channel
    populations/densities in a cell would be difficult otherwise.
    Also, it will make it easier to set the correct native simulator value for
    erev (e.g. ek for ion = k in NEURON).
    Currently a required attribute.
    It should be removed in the longer term, due to possible inconsistencies in
    this value and that in the ionChannel
    element. TODO: remove."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ionChannel', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('ion', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('variableParameter', 'VariableParameter', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'variableParameter', 'type': 'VariableParameter'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, ionChannel=None, ion=None, variableParameter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ChannelDensityNonUniformGHK, self).__init__(neuroLexId, id,  **kwargs_)
        self.ionChannel = _cast(None, ionChannel)
        self.ionChannel_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        if variableParameter is None:
            self.variableParameter = []
        else:
            self.variableParameter = variableParameter
        self.variableParameter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityNonUniformGHK)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityNonUniformGHK.subclass:
            return ChannelDensityNonUniformGHK.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityNonUniformGHK(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            self.variableParameter or
            super(ChannelDensityNonUniformGHK, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityNonUniformGHK', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelDensityNonUniformGHK')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityNonUniformGHK')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChannelDensityNonUniformGHK', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChannelDensityNonUniformGHK'):
        super(ChannelDensityNonUniformGHK, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityNonUniformGHK')
        if self.ionChannel is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            outfile.write(' ionChannel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ionChannel), input_name='ionChannel')), ))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            outfile.write(' ion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ion), input_name='ion')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityNonUniformGHK', fromsubclass_=False, pretty_print=True):
        super(ChannelDensityNonUniformGHK, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for variableParameter_ in self.variableParameter:
            namespaceprefix_ = self.variableParameter_nsprefix_ + ':' if (UseCapturedNS_ and self.variableParameter_nsprefix_) else ''
            variableParameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variableParameter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ionChannel', node)
        if value is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            self.ionChannel = value
            self.validate_NmlId(self.ionChannel)    # validate type NmlId
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            self.ion = value
            self.validate_NmlId(self.ion)    # validate type NmlId
        super(ChannelDensityNonUniformGHK, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'variableParameter':
            obj_ = VariableParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variableParameter.append(obj_)
            obj_.original_tagname_ = 'variableParameter'
        super(ChannelDensityNonUniformGHK, self).buildChildren(child_, node, nodeName_, True)
# end class ChannelDensityNonUniformGHK


class ChannelDensityNonUniformNernst(Base):
    """Specifying the ion here again is redundant, this will be set in
    ionChannel definition. It is added here
    TEMPORARILY since selecting all ca or na conducting channel
    populations/densities in a cell would be difficult otherwise.
    Also, it will make it easier to set the correct native simulator value for
    erev (e.g. ek for ion = k in NEURON).
    Currently a required attribute.
    It should be removed in the longer term, due to possible inconsistencies in
    this value and that in the ionChannel
    element. TODO: remove."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ionChannel', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('ion', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('variableParameter', 'VariableParameter', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'variableParameter', 'type': 'VariableParameter'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, ionChannel=None, ion=None, variableParameter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ChannelDensityNonUniformNernst, self).__init__(neuroLexId, id,  **kwargs_)
        self.ionChannel = _cast(None, ionChannel)
        self.ionChannel_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        if variableParameter is None:
            self.variableParameter = []
        else:
            self.variableParameter = variableParameter
        self.variableParameter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityNonUniformNernst)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityNonUniformNernst.subclass:
            return ChannelDensityNonUniformNernst.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityNonUniformNernst(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            self.variableParameter or
            super(ChannelDensityNonUniformNernst, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityNonUniformNernst', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelDensityNonUniformNernst')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityNonUniformNernst')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChannelDensityNonUniformNernst', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChannelDensityNonUniformNernst'):
        super(ChannelDensityNonUniformNernst, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityNonUniformNernst')
        if self.ionChannel is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            outfile.write(' ionChannel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ionChannel), input_name='ionChannel')), ))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            outfile.write(' ion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ion), input_name='ion')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityNonUniformNernst', fromsubclass_=False, pretty_print=True):
        super(ChannelDensityNonUniformNernst, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for variableParameter_ in self.variableParameter:
            namespaceprefix_ = self.variableParameter_nsprefix_ + ':' if (UseCapturedNS_ and self.variableParameter_nsprefix_) else ''
            variableParameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variableParameter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ionChannel', node)
        if value is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            self.ionChannel = value
            self.validate_NmlId(self.ionChannel)    # validate type NmlId
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            self.ion = value
            self.validate_NmlId(self.ion)    # validate type NmlId
        super(ChannelDensityNonUniformNernst, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'variableParameter':
            obj_ = VariableParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variableParameter.append(obj_)
            obj_.original_tagname_ = 'variableParameter'
        super(ChannelDensityNonUniformNernst, self).buildChildren(child_, node, nodeName_, True)
# end class ChannelDensityNonUniformNernst


class ChannelDensityNonUniform(Base):
    """Specifying the ion here again is redundant, this will be set in
    ionChannel definition. It is added here
    TEMPORARILY since selecting all ca or na conducting channel
    populations/densities in a cell would be difficult otherwise.
    Also, it will make it easier to set the correct native simulator value for
    erev (e.g. ek for ion = k in NEURON).
    Currently a required attribute.
    It should be removed in the longer term, due to possible inconsistencies in
    this value and that in the ionChannel
    element. TODO: remove."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ionChannel', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('erev', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('ion', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('variableParameter', 'VariableParameter', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'variableParameter', 'type': 'VariableParameter'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, ionChannel=None, erev=None, ion=None, variableParameter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ChannelDensityNonUniform, self).__init__(neuroLexId, id,  **kwargs_)
        self.ionChannel = _cast(None, ionChannel)
        self.ionChannel_nsprefix_ = None
        self.erev = _cast(None, erev)
        self.erev_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        if variableParameter is None:
            self.variableParameter = []
        else:
            self.variableParameter = variableParameter
        self.variableParameter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityNonUniform)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityNonUniform.subclass:
            return ChannelDensityNonUniform.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityNonUniform(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def hasContent_(self):
        if (
            self.variableParameter or
            super(ChannelDensityNonUniform, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityNonUniform', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelDensityNonUniform')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityNonUniform')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChannelDensityNonUniform', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChannelDensityNonUniform'):
        super(ChannelDensityNonUniform, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityNonUniform')
        if self.ionChannel is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            outfile.write(' ionChannel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ionChannel), input_name='ionChannel')), ))
        if self.erev is not None and 'erev' not in already_processed:
            already_processed.add('erev')
            outfile.write(' erev=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.erev), input_name='erev')), ))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            outfile.write(' ion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ion), input_name='ion')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityNonUniform', fromsubclass_=False, pretty_print=True):
        super(ChannelDensityNonUniform, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for variableParameter_ in self.variableParameter:
            namespaceprefix_ = self.variableParameter_nsprefix_ + ':' if (UseCapturedNS_ and self.variableParameter_nsprefix_) else ''
            variableParameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variableParameter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ionChannel', node)
        if value is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            self.ionChannel = value
            self.validate_NmlId(self.ionChannel)    # validate type NmlId
        value = find_attr_value_('erev', node)
        if value is not None and 'erev' not in already_processed:
            already_processed.add('erev')
            self.erev = value
            self.validate_Nml2Quantity_voltage(self.erev)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            self.ion = value
            self.validate_NmlId(self.ion)    # validate type NmlId
        super(ChannelDensityNonUniform, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'variableParameter':
            obj_ = VariableParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variableParameter.append(obj_)
            obj_.original_tagname_ = 'variableParameter'
        super(ChannelDensityNonUniform, self).buildChildren(child_, node, nodeName_, True)
# end class ChannelDensityNonUniform


class ChannelPopulation(Base):
    """Specifying the ion here again is redundant, this will be set in
    ionChannel definition. It is added here
    TEMPORARILY since selecting all ca or na conducting channel
    populations/densities in a cell would be difficult otherwise.
    Also, it will make it easier to set the correct native simulator value for
    erev (e.g. ek for ion = k in NEURON).
    Currently a required attribute.
    It should be removed in the longer term, due to possible inconsistencies in
    this value and that in the ionChannel
    element. TODO: remove."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ionChannel', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('number', 'NonNegativeInteger', 0, 0, {'use': 'required'}),
        MemberSpec_('erev', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('segmentGroup', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('segment', 'NonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('ion', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('variableParameter', 'VariableParameter', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'variableParameter', 'type': 'VariableParameter'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, ionChannel=None, number=None, erev=None, segmentGroup='all', segment=None, ion=None, variableParameter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ChannelPopulation, self).__init__(neuroLexId, id,  **kwargs_)
        self.ionChannel = _cast(None, ionChannel)
        self.ionChannel_nsprefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.erev = _cast(None, erev)
        self.erev_nsprefix_ = None
        self.segmentGroup = _cast(None, segmentGroup)
        self.segmentGroup_nsprefix_ = None
        self.segment = _cast(int, segment)
        self.segment_nsprefix_ = None
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        if variableParameter is None:
            self.variableParameter = []
        else:
            self.variableParameter = variableParameter
        self.variableParameter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelPopulation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelPopulation.subclass:
            return ChannelPopulation.subclass(*args_, **kwargs_)
        else:
            return ChannelPopulation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def hasContent_(self):
        if (
            self.variableParameter or
            super(ChannelPopulation, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelPopulation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelPopulation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelPopulation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChannelPopulation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChannelPopulation'):
        super(ChannelPopulation, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelPopulation')
        if self.ionChannel is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            outfile.write(' ionChannel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ionChannel), input_name='ionChannel')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.erev is not None and 'erev' not in already_processed:
            already_processed.add('erev')
            outfile.write(' erev=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.erev), input_name='erev')), ))
        if self.segmentGroup != "all" and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            outfile.write(' segmentGroup=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segmentGroup), input_name='segmentGroup')), ))
        if self.segment is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            outfile.write(' segment="%s"' % self.gds_format_integer(self.segment, input_name='segment'))
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            outfile.write(' ion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ion), input_name='ion')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelPopulation', fromsubclass_=False, pretty_print=True):
        super(ChannelPopulation, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for variableParameter_ in self.variableParameter:
            namespaceprefix_ = self.variableParameter_nsprefix_ + ':' if (UseCapturedNS_ and self.variableParameter_nsprefix_) else ''
            variableParameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variableParameter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ionChannel', node)
        if value is not None and 'ionChannel' not in already_processed:
            already_processed.add('ionChannel')
            self.ionChannel = value
            self.validate_NmlId(self.ionChannel)    # validate type NmlId
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.number)    # validate type NonNegativeInteger
        value = find_attr_value_('erev', node)
        if value is not None and 'erev' not in already_processed:
            already_processed.add('erev')
            self.erev = value
            self.validate_Nml2Quantity_voltage(self.erev)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('segmentGroup', node)
        if value is not None and 'segmentGroup' not in already_processed:
            already_processed.add('segmentGroup')
            self.segmentGroup = value
            self.validate_NmlId(self.segmentGroup)    # validate type NmlId
        value = find_attr_value_('segment', node)
        if value is not None and 'segment' not in already_processed:
            already_processed.add('segment')
            self.segment = self.gds_parse_integer(value, node, 'segment')
            if self.segment < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.segment)    # validate type NonNegativeInteger
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            self.ion = value
            self.validate_NmlId(self.ion)    # validate type NmlId
        super(ChannelPopulation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'variableParameter':
            obj_ = VariableParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variableParameter.append(obj_)
            obj_.original_tagname_ = 'variableParameter'
        super(ChannelPopulation, self).buildChildren(child_, node, nodeName_, True)
# end class ChannelPopulation


class Resistivity(ValueAcrossSegOrSegGroup):
    """Using a thin extension of ValueAcrossSegOrSegGroup to facilitate library
    generation (e.g. libNeuroML)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = ValueAcrossSegOrSegGroup
    def __init__(self, value=None, segmentGroup='all', segment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Resistivity, self).__init__(value, segmentGroup, segment,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Resistivity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Resistivity.subclass:
            return Resistivity.subclass(*args_, **kwargs_)
        else:
            return Resistivity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Resistivity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Resistivity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Resistivity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Resistivity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Resistivity', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Resistivity'):
        super(Resistivity, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Resistivity')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Resistivity', fromsubclass_=False, pretty_print=True):
        super(Resistivity, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Resistivity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(Resistivity, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Resistivity


class InitMembPotential(ValueAcrossSegOrSegGroup):
    """Using a thin extension of ValueAcrossSegOrSegGroup to facilitate library
    generation (e.g. libNeuroML)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = ValueAcrossSegOrSegGroup
    def __init__(self, value=None, segmentGroup='all', segment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(InitMembPotential, self).__init__(value, segmentGroup, segment,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InitMembPotential)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InitMembPotential.subclass:
            return InitMembPotential.subclass(*args_, **kwargs_)
        else:
            return InitMembPotential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(InitMembPotential, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InitMembPotential', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InitMembPotential')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InitMembPotential')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InitMembPotential', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InitMembPotential'):
        super(InitMembPotential, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InitMembPotential')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InitMembPotential', fromsubclass_=False, pretty_print=True):
        super(InitMembPotential, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InitMembPotential, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(InitMembPotential, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class InitMembPotential


class SpecificCapacitance(ValueAcrossSegOrSegGroup):
    """Using a thin extension of ValueAcrossSegOrSegGroup to facilitate library
    generation (e.g. libNeuroML)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = ValueAcrossSegOrSegGroup
    def __init__(self, value=None, segmentGroup='all', segment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpecificCapacitance, self).__init__(value, segmentGroup, segment,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpecificCapacitance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpecificCapacitance.subclass:
            return SpecificCapacitance.subclass(*args_, **kwargs_)
        else:
            return SpecificCapacitance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SpecificCapacitance, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpecificCapacitance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpecificCapacitance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpecificCapacitance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpecificCapacitance', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpecificCapacitance'):
        super(SpecificCapacitance, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpecificCapacitance')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpecificCapacitance', fromsubclass_=False, pretty_print=True):
        super(SpecificCapacitance, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SpecificCapacitance, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SpecificCapacitance, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SpecificCapacitance


class SpikeThresh(ValueAcrossSegOrSegGroup):
    """Using a thin extension of ValueAcrossSegOrSegGroup to facilitate library
    generation (e.g. libNeuroML)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = ValueAcrossSegOrSegGroup
    def __init__(self, value=None, segmentGroup='all', segment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpikeThresh, self).__init__(value, segmentGroup, segment,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpikeThresh)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeThresh.subclass:
            return SpikeThresh.subclass(*args_, **kwargs_)
        else:
            return SpikeThresh(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SpikeThresh, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeThresh', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpikeThresh')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeThresh')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpikeThresh', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpikeThresh'):
        super(SpikeThresh, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeThresh')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeThresh', fromsubclass_=False, pretty_print=True):
        super(SpikeThresh, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SpikeThresh, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SpikeThresh, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SpikeThresh


class BiophysicalProperties2CaPools(Standalone):
    """Standalone element which is usually inside a single cell, but could be
    outside and
    referenced by id."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('membraneProperties2CaPools', 'MembraneProperties2CaPools', 0, 0, {'name': 'membraneProperties2CaPools', 'type': 'MembraneProperties2CaPools'}, None),
        MemberSpec_('intracellularProperties2CaPools', 'IntracellularProperties2CaPools', 0, 1, {'minOccurs': '0', 'name': 'intracellularProperties2CaPools', 'type': 'IntracellularProperties2CaPools'}, None),
        MemberSpec_('extracellularProperties', 'ExtracellularProperties', 0, 1, {'minOccurs': '0', 'name': 'extracellularProperties', 'type': 'ExtracellularProperties'}, None),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, membraneProperties2CaPools=None, intracellularProperties2CaPools=None, extracellularProperties=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BiophysicalProperties2CaPools, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.membraneProperties2CaPools = membraneProperties2CaPools
        self.membraneProperties2CaPools_nsprefix_ = None
        self.intracellularProperties2CaPools = intracellularProperties2CaPools
        self.intracellularProperties2CaPools_nsprefix_ = None
        self.extracellularProperties = extracellularProperties
        self.extracellularProperties_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BiophysicalProperties2CaPools)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BiophysicalProperties2CaPools.subclass:
            return BiophysicalProperties2CaPools.subclass(*args_, **kwargs_)
        else:
            return BiophysicalProperties2CaPools(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.membraneProperties2CaPools is not None or
            self.intracellularProperties2CaPools is not None or
            self.extracellularProperties is not None or
            super(BiophysicalProperties2CaPools, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BiophysicalProperties2CaPools', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BiophysicalProperties2CaPools')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BiophysicalProperties2CaPools')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BiophysicalProperties2CaPools', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BiophysicalProperties2CaPools'):
        super(BiophysicalProperties2CaPools, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BiophysicalProperties2CaPools')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BiophysicalProperties2CaPools', fromsubclass_=False, pretty_print=True):
        super(BiophysicalProperties2CaPools, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.membraneProperties2CaPools is not None:
            namespaceprefix_ = self.membraneProperties2CaPools_nsprefix_ + ':' if (UseCapturedNS_ and self.membraneProperties2CaPools_nsprefix_) else ''
            self.membraneProperties2CaPools.export(outfile, level, namespaceprefix_, namespacedef_='', name_='membraneProperties2CaPools', pretty_print=pretty_print)
        if self.intracellularProperties2CaPools is not None:
            namespaceprefix_ = self.intracellularProperties2CaPools_nsprefix_ + ':' if (UseCapturedNS_ and self.intracellularProperties2CaPools_nsprefix_) else ''
            self.intracellularProperties2CaPools.export(outfile, level, namespaceprefix_, namespacedef_='', name_='intracellularProperties2CaPools', pretty_print=pretty_print)
        if self.extracellularProperties is not None:
            namespaceprefix_ = self.extracellularProperties_nsprefix_ + ':' if (UseCapturedNS_ and self.extracellularProperties_nsprefix_) else ''
            self.extracellularProperties.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extracellularProperties', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BiophysicalProperties2CaPools, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'membraneProperties2CaPools':
            obj_ = MembraneProperties2CaPools.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.membraneProperties2CaPools = obj_
            obj_.original_tagname_ = 'membraneProperties2CaPools'
        elif nodeName_ == 'intracellularProperties2CaPools':
            obj_ = IntracellularProperties2CaPools.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intracellularProperties2CaPools = obj_
            obj_.original_tagname_ = 'intracellularProperties2CaPools'
        elif nodeName_ == 'extracellularProperties':
            obj_ = ExtracellularProperties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extracellularProperties = obj_
            obj_.original_tagname_ = 'extracellularProperties'
        super(BiophysicalProperties2CaPools, self).buildChildren(child_, node, nodeName_, True)
# end class BiophysicalProperties2CaPools


class BiophysicalProperties(Standalone):
    """Standalone element which is usually inside a single cell, but could be
    outside and
    referenced by id."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('membraneProperties', 'MembraneProperties', 0, 0, {'name': 'membraneProperties', 'type': 'MembraneProperties'}, None),
        MemberSpec_('intracellularProperties', 'IntracellularProperties', 0, 1, {'minOccurs': '0', 'name': 'intracellularProperties', 'type': 'IntracellularProperties'}, None),
        MemberSpec_('extracellularProperties', 'ExtracellularProperties', 0, 1, {'minOccurs': '0', 'name': 'extracellularProperties', 'type': 'ExtracellularProperties'}, None),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, membraneProperties=None, intracellularProperties=None, extracellularProperties=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BiophysicalProperties, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.membraneProperties = membraneProperties
        self.membraneProperties_nsprefix_ = None
        self.intracellularProperties = intracellularProperties
        self.intracellularProperties_nsprefix_ = None
        self.extracellularProperties = extracellularProperties
        self.extracellularProperties_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BiophysicalProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BiophysicalProperties.subclass:
            return BiophysicalProperties.subclass(*args_, **kwargs_)
        else:
            return BiophysicalProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.membraneProperties is not None or
            self.intracellularProperties is not None or
            self.extracellularProperties is not None or
            super(BiophysicalProperties, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BiophysicalProperties', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BiophysicalProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BiophysicalProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BiophysicalProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BiophysicalProperties'):
        super(BiophysicalProperties, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BiophysicalProperties')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BiophysicalProperties', fromsubclass_=False, pretty_print=True):
        super(BiophysicalProperties, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.membraneProperties is not None:
            namespaceprefix_ = self.membraneProperties_nsprefix_ + ':' if (UseCapturedNS_ and self.membraneProperties_nsprefix_) else ''
            self.membraneProperties.export(outfile, level, namespaceprefix_, namespacedef_='', name_='membraneProperties', pretty_print=pretty_print)
        if self.intracellularProperties is not None:
            namespaceprefix_ = self.intracellularProperties_nsprefix_ + ':' if (UseCapturedNS_ and self.intracellularProperties_nsprefix_) else ''
            self.intracellularProperties.export(outfile, level, namespaceprefix_, namespacedef_='', name_='intracellularProperties', pretty_print=pretty_print)
        if self.extracellularProperties is not None:
            namespaceprefix_ = self.extracellularProperties_nsprefix_ + ':' if (UseCapturedNS_ and self.extracellularProperties_nsprefix_) else ''
            self.extracellularProperties.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extracellularProperties', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BiophysicalProperties, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'membraneProperties':
            class_obj_ = self.get_class_obj_(child_, MembraneProperties)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.membraneProperties = obj_
            obj_.original_tagname_ = 'membraneProperties'
        elif nodeName_ == 'intracellularProperties':
            class_obj_ = self.get_class_obj_(child_, IntracellularProperties)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intracellularProperties = obj_
            obj_.original_tagname_ = 'intracellularProperties'
        elif nodeName_ == 'extracellularProperties':
            obj_ = ExtracellularProperties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extracellularProperties = obj_
            obj_.original_tagname_ = 'extracellularProperties'
        super(BiophysicalProperties, self).buildChildren(child_, node, nodeName_, True)
# end class BiophysicalProperties


class InhomogeneousParameter(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('variable', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('metric', 'Metric', 0, 0, {'use': 'required'}),
        MemberSpec_('proximal', 'ProximalDetails', 0, 1, {'minOccurs': '0', 'name': 'proximal', 'type': 'ProximalDetails'}, None),
        MemberSpec_('distal', 'DistalDetails', 0, 1, {'minOccurs': '0', 'name': 'distal', 'type': 'DistalDetails'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, variable=None, metric=None, proximal=None, distal=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(InhomogeneousParameter, self).__init__(neuroLexId, id,  **kwargs_)
        self.variable = _cast(None, variable)
        self.variable_nsprefix_ = None
        self.metric = _cast(None, metric)
        self.metric_nsprefix_ = None
        self.proximal = proximal
        self.proximal_nsprefix_ = None
        self.distal = distal
        self.distal_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InhomogeneousParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InhomogeneousParameter.subclass:
            return InhomogeneousParameter.subclass(*args_, **kwargs_)
        else:
            return InhomogeneousParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Metric(self, value):
        # Validate type Metric, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Path Length from root']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on Metric' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.proximal is not None or
            self.distal is not None or
            super(InhomogeneousParameter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InhomogeneousParameter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InhomogeneousParameter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InhomogeneousParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InhomogeneousParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InhomogeneousParameter'):
        super(InhomogeneousParameter, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InhomogeneousParameter')
        if self.variable is not None and 'variable' not in already_processed:
            already_processed.add('variable')
            outfile.write(' variable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.variable), input_name='variable')), ))
        if self.metric is not None and 'metric' not in already_processed:
            already_processed.add('metric')
            outfile.write(' metric=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.metric), input_name='metric')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InhomogeneousParameter', fromsubclass_=False, pretty_print=True):
        super(InhomogeneousParameter, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.proximal is not None:
            namespaceprefix_ = self.proximal_nsprefix_ + ':' if (UseCapturedNS_ and self.proximal_nsprefix_) else ''
            self.proximal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='proximal', pretty_print=pretty_print)
        if self.distal is not None:
            namespaceprefix_ = self.distal_nsprefix_ + ':' if (UseCapturedNS_ and self.distal_nsprefix_) else ''
            self.distal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='distal', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('variable', node)
        if value is not None and 'variable' not in already_processed:
            already_processed.add('variable')
            self.variable = value
        value = find_attr_value_('metric', node)
        if value is not None and 'metric' not in already_processed:
            already_processed.add('metric')
            self.metric = value
            self.validate_Metric(self.metric)    # validate type Metric
        super(InhomogeneousParameter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'proximal':
            obj_ = ProximalDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.proximal = obj_
            obj_.original_tagname_ = 'proximal'
        elif nodeName_ == 'distal':
            obj_ = DistalDetails.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distal = obj_
            obj_.original_tagname_ = 'distal'
        super(InhomogeneousParameter, self).buildChildren(child_, node, nodeName_, True)
# end class InhomogeneousParameter


class SegmentGroup(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('notes', ['Notes', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'notes', 'type': 'xs:string'}, None),
        MemberSpec_('property', 'Property', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'property', 'type': 'Property'}, None),
        MemberSpec_('annotation', 'Annotation', 0, 1, {'minOccurs': '0', 'name': 'annotation', 'type': 'Annotation'}, None),
        MemberSpec_('member', 'Member', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'member', 'type': 'Member'}, None),
        MemberSpec_('include', 'Include', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'include', 'type': 'Include'}, None),
        MemberSpec_('path', 'Path', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'path', 'type': 'Path'}, None),
        MemberSpec_('subTree', 'SubTree', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'subTree', 'type': 'SubTree'}, None),
        MemberSpec_('inhomogeneousParameter', 'InhomogeneousParameter', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'inhomogeneousParameter', 'type': 'InhomogeneousParameter'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, notes=None, property=None, annotation=None, member=None, include=None, path=None, subTree=None, inhomogeneousParameter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SegmentGroup, self).__init__(neuroLexId, id,  **kwargs_)
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        if property is None:
            self.property = []
        else:
            self.property = property
        self.property_nsprefix_ = None
        self.annotation = annotation
        self.annotation_nsprefix_ = None
        if member is None:
            self.member = []
        else:
            self.member = member
        self.member_nsprefix_ = None
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if path is None:
            self.path = []
        else:
            self.path = path
        self.path_nsprefix_ = None
        if subTree is None:
            self.subTree = []
        else:
            self.subTree = subTree
        self.subTree_nsprefix_ = None
        if inhomogeneousParameter is None:
            self.inhomogeneousParameter = []
        else:
            self.inhomogeneousParameter = inhomogeneousParameter
        self.inhomogeneousParameter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SegmentGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SegmentGroup.subclass:
            return SegmentGroup.subclass(*args_, **kwargs_)
        else:
            return SegmentGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def hasContent_(self):
        if (
            self.notes is not None or
            self.property or
            self.annotation is not None or
            self.member or
            self.include or
            self.path or
            self.subTree or
            self.inhomogeneousParameter or
            super(SegmentGroup, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SegmentGroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SegmentGroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SegmentGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SegmentGroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SegmentGroup'):
        super(SegmentGroup, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SegmentGroup')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SegmentGroup', fromsubclass_=False, pretty_print=True):
        super(SegmentGroup, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notes), input_name='notes')), namespaceprefix_ , eol_))
        for property_ in self.property:
            namespaceprefix_ = self.property_nsprefix_ + ':' if (UseCapturedNS_ and self.property_nsprefix_) else ''
            property_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='property', pretty_print=pretty_print)
        if self.annotation is not None:
            namespaceprefix_ = self.annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.annotation_nsprefix_) else ''
            self.annotation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annotation', pretty_print=pretty_print)
        for member_ in self.member:
            namespaceprefix_ = self.member_nsprefix_ + ':' if (UseCapturedNS_ and self.member_nsprefix_) else ''
            member_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='member', pretty_print=pretty_print)
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for path_ in self.path:
            namespaceprefix_ = self.path_nsprefix_ + ':' if (UseCapturedNS_ and self.path_nsprefix_) else ''
            path_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='path', pretty_print=pretty_print)
        for subTree_ in self.subTree:
            namespaceprefix_ = self.subTree_nsprefix_ + ':' if (UseCapturedNS_ and self.subTree_nsprefix_) else ''
            subTree_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subTree', pretty_print=pretty_print)
        for inhomogeneousParameter_ in self.inhomogeneousParameter:
            namespaceprefix_ = self.inhomogeneousParameter_nsprefix_ + ':' if (UseCapturedNS_ and self.inhomogeneousParameter_nsprefix_) else ''
            inhomogeneousParameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inhomogeneousParameter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SegmentGroup, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notes')
            value_ = self.gds_validate_string(value_, node, 'notes')
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == 'property':
            obj_ = Property.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
        elif nodeName_ == 'annotation':
            obj_ = Annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'member':
            obj_ = Member.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.member.append(obj_)
            obj_.original_tagname_ = 'member'
        elif nodeName_ == 'include':
            obj_ = Include.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'path':
            obj_ = Path.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.path.append(obj_)
            obj_.original_tagname_ = 'path'
        elif nodeName_ == 'subTree':
            obj_ = SubTree.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subTree.append(obj_)
            obj_.original_tagname_ = 'subTree'
        elif nodeName_ == 'inhomogeneousParameter':
            obj_ = InhomogeneousParameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inhomogeneousParameter.append(obj_)
            obj_.original_tagname_ = 'inhomogeneousParameter'
        super(SegmentGroup, self).buildChildren(child_, node, nodeName_, True)


    def __str__(self):

        return "SegmentGroup: "+str(self.id)+", "+str(len(self.members))+" member(s), "+str(len(self.includes))+" included group(s)"

    def __repr__(self):

        return str(self)

# end class SegmentGroup


class Segment(BaseNonNegativeIntegerId):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('parent', 'SegmentParent', 0, 1, {'minOccurs': '0', 'name': 'parent', 'type': 'SegmentParent'}, None),
        MemberSpec_('proximal', 'Point3DWithDiam', 0, 1, {'minOccurs': '0', 'name': 'proximal', 'type': 'Point3DWithDiam'}, None),
        MemberSpec_('distal', 'Point3DWithDiam', 0, 0, {'minOccurs': '1', 'name': 'distal', 'type': 'Point3DWithDiam'}, None),
    ]
    subclass = None
    superclass = BaseNonNegativeIntegerId
    def __init__(self, neuroLexId=None, id=None, name=None, parent=None, proximal=None, distal=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Segment, self).__init__(neuroLexId, id,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.parent = parent
        self.parent_nsprefix_ = None
        self.proximal = proximal
        self.proximal_nsprefix_ = None
        self.distal = distal
        self.distal_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Segment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Segment.subclass:
            return Segment.subclass(*args_, **kwargs_)
        else:
            return Segment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.parent is not None or
            self.proximal is not None or
            self.distal is not None or
            super(Segment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Segment', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Segment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Segment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Segment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Segment'):
        super(Segment, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Segment')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Segment', fromsubclass_=False, pretty_print=True):
        super(Segment, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.parent is not None:
            namespaceprefix_ = self.parent_nsprefix_ + ':' if (UseCapturedNS_ and self.parent_nsprefix_) else ''
            self.parent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parent', pretty_print=pretty_print)
        if self.proximal is not None:
            namespaceprefix_ = self.proximal_nsprefix_ + ':' if (UseCapturedNS_ and self.proximal_nsprefix_) else ''
            self.proximal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='proximal', pretty_print=pretty_print)
        if self.distal is not None:
            namespaceprefix_ = self.distal_nsprefix_ + ':' if (UseCapturedNS_ and self.distal_nsprefix_) else ''
            self.distal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='distal', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(Segment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'parent':
            obj_ = SegmentParent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parent = obj_
            obj_.original_tagname_ = 'parent'
        elif nodeName_ == 'proximal':
            obj_ = Point3DWithDiam.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.proximal = obj_
            obj_.original_tagname_ = 'proximal'
        elif nodeName_ == 'distal':
            obj_ = Point3DWithDiam.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.distal = obj_
            obj_.original_tagname_ = 'distal'
        super(Segment, self).buildChildren(child_, node, nodeName_, True)
    @property
    def length(self):

        if self.proximal==None:
            raise Exception('Cannot get length of segment '+str(self.id)+' using the length property, since no proximal point is set on it (the proximal point comes from the parent segment). Use the method get_segment_length(segment_id) on the cell instead.')

        prox_x = self.proximal.x
        prox_y = self.proximal.y
        prox_z = self.proximal.z

        dist_x = self.distal.x
        dist_y = self.distal.y
        dist_z = self.distal.z

        length = ((prox_x-dist_x)**2 + (prox_y-dist_y)**2 + (prox_z-dist_z)**2)**(0.5)

        return length

    def __str__(self):

        return "<Segment|"+str(self.id)+("|"+self.name if self.name is not None else '') + ">"

    def __repr__(self):

        return str(self)

    @property
    def volume(self):

        from math import pi
        if self.proximal==None:
            raise Exception('Cannot get volume of segment '+str(self.id)+' using the volume property, since no proximal point is set on it (the proximal point comes from the parent segment). Use the method get_segment_volume(segment_id) on the cell instead.')

        prox_rad = self.proximal.diameter/2.0
        dist_rad = self.distal.diameter/2.0

        if self.proximal.x == self.distal.x and            self.proximal.y == self.distal.y and            self.proximal.z == self.distal.z:

           if prox_rad!=dist_rad:
                raise Exception('Cannot get volume of segment '+str(self.id)+'. The (x,y,z) coordinates of the proximal and distal points match (i.e. it is a sphere), but the diameters of these points are different, making the volume calculation ambiguous.')

           return 4.0/3 * pi * prox_rad**3

        length = self.length

        volume = (pi/3)*length*(prox_rad**2+dist_rad**2+prox_rad*dist_rad)

        return volume
    
    @property
    def surface_area(self):
        from math import pi
        from math import sqrt

        if self.proximal==None:
            raise Exception('Cannot get surface area of segment '+str(self.id)+' using the surface_area property, since no proximal point is set on it (the proximal point comes from the parent segment). Use the method get_segment_surface_area(segment_id) on the cell instead.')

        prox_rad = self.proximal.diameter/2.0
        dist_rad = self.distal.diameter/2.0

        if self.proximal.x == self.distal.x and            self.proximal.y == self.distal.y and            self.proximal.z == self.distal.z:

           if prox_rad!=dist_rad:
                raise Exception('Cannot get surface area of segment '+str(self.id)+'. The (x,y,z) coordinates of the proximal and distal points match (i.e. it is a sphere), but the diameters of these points are different, making the surface area calculation ambiguous.')

           return 4.0 * pi * prox_rad**2

        length = self.length

        surface_area = pi*(prox_rad+dist_rad)*sqrt((prox_rad-dist_rad)**2+length**2)

        return surface_area
    # end class Segment


class Morphology(Standalone):
    """Standalone element which is usually inside a single cell, but could be
    outside and
    referenced by id."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('segment', 'Segment', 1, 0, {'maxOccurs': 'unbounded', 'name': 'segment', 'type': 'Segment'}, None),
        MemberSpec_('segmentGroup', 'SegmentGroup', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'segmentGroup', 'type': 'SegmentGroup'}, None),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, segment=None, segmentGroup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Morphology, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
        self.segment_nsprefix_ = None
        if segmentGroup is None:
            self.segmentGroup = []
        else:
            self.segmentGroup = segmentGroup
        self.segmentGroup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Morphology)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Morphology.subclass:
            return Morphology.subclass(*args_, **kwargs_)
        else:
            return Morphology(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.segment or
            self.segmentGroup or
            super(Morphology, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Morphology', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Morphology')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Morphology')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Morphology', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Morphology'):
        super(Morphology, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Morphology')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Morphology', fromsubclass_=False, pretty_print=True):
        super(Morphology, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for segment_ in self.segment:
            namespaceprefix_ = self.segment_nsprefix_ + ':' if (UseCapturedNS_ and self.segment_nsprefix_) else ''
            segment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='segment', pretty_print=pretty_print)
        for segmentGroup_ in self.segmentGroup:
            namespaceprefix_ = self.segmentGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.segmentGroup_nsprefix_) else ''
            segmentGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='segmentGroup', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Morphology, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'segment':
            obj_ = Segment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.segment.append(obj_)
            obj_.original_tagname_ = 'segment'
        elif nodeName_ == 'segmentGroup':
            obj_ = SegmentGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.segmentGroup.append(obj_)
            obj_.original_tagname_ = 'segmentGroup'
        super(Morphology, self).buildChildren(child_, node, nodeName_, True)
    @property
    def num_segments(self):
        return len(self.segments)
# end class Morphology


class BaseCell(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseCell, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseCell.subclass:
            return BaseCell.subclass(*args_, **kwargs_)
        else:
            return BaseCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(BaseCell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseCell'):
        super(BaseCell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseCell')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseCell', fromsubclass_=False, pretty_print=True):
        super(BaseCell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BaseCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseCell


class BaseSynapse(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseSynapse.subclass:
            return BaseSynapse.subclass(*args_, **kwargs_)
        else:
            return BaseSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(BaseSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseSynapse'):
        super(BaseSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseSynapse')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseSynapse', fromsubclass_=False, pretty_print=True):
        super(BaseSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BaseSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseSynapse


class FixedFactorConcentrationModel(Standalone):
    """Should not be required, as it's present on the species element!"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ion', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('restingConc', 'Nml2Quantity_concentration', 0, 0, {'use': 'required'}),
        MemberSpec_('decayConstant', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('rho', 'Nml2Quantity_rhoFactor', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, ion=None, restingConc=None, decayConstant=None, rho=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FixedFactorConcentrationModel, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        self.restingConc = _cast(None, restingConc)
        self.restingConc_nsprefix_ = None
        self.decayConstant = _cast(None, decayConstant)
        self.decayConstant_nsprefix_ = None
        self.rho = _cast(None, rho)
        self.rho_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FixedFactorConcentrationModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FixedFactorConcentrationModel.subclass:
            return FixedFactorConcentrationModel.subclass(*args_, **kwargs_)
        else:
            return FixedFactorConcentrationModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_concentration(self, value):
        # Validate type Nml2Quantity_concentration, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_concentration_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_concentration_patterns_, ))
    validate_Nml2Quantity_concentration_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(mol_per_m3|mol_per_cm3|M|mM))$']]
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_rhoFactor(self, value):
        # Validate type Nml2Quantity_rhoFactor, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_rhoFactor_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_rhoFactor_patterns_, ))
    validate_Nml2Quantity_rhoFactor_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(mol_per_m_per_A_per_s|mol_per_cm_per_uA_per_ms))$']]
    def hasContent_(self):
        if (
            super(FixedFactorConcentrationModel, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FixedFactorConcentrationModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FixedFactorConcentrationModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FixedFactorConcentrationModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FixedFactorConcentrationModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FixedFactorConcentrationModel'):
        super(FixedFactorConcentrationModel, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FixedFactorConcentrationModel')
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            outfile.write(' ion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ion), input_name='ion')), ))
        if self.restingConc is not None and 'restingConc' not in already_processed:
            already_processed.add('restingConc')
            outfile.write(' restingConc=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.restingConc), input_name='restingConc')), ))
        if self.decayConstant is not None and 'decayConstant' not in already_processed:
            already_processed.add('decayConstant')
            outfile.write(' decayConstant=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.decayConstant), input_name='decayConstant')), ))
        if self.rho is not None and 'rho' not in already_processed:
            already_processed.add('rho')
            outfile.write(' rho=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rho), input_name='rho')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FixedFactorConcentrationModel', fromsubclass_=False, pretty_print=True):
        super(FixedFactorConcentrationModel, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            self.ion = value
            self.validate_NmlId(self.ion)    # validate type NmlId
        value = find_attr_value_('restingConc', node)
        if value is not None and 'restingConc' not in already_processed:
            already_processed.add('restingConc')
            self.restingConc = value
            self.validate_Nml2Quantity_concentration(self.restingConc)    # validate type Nml2Quantity_concentration
        value = find_attr_value_('decayConstant', node)
        if value is not None and 'decayConstant' not in already_processed:
            already_processed.add('decayConstant')
            self.decayConstant = value
            self.validate_Nml2Quantity_time(self.decayConstant)    # validate type Nml2Quantity_time
        value = find_attr_value_('rho', node)
        if value is not None and 'rho' not in already_processed:
            already_processed.add('rho')
            self.rho = value
            self.validate_Nml2Quantity_rhoFactor(self.rho)    # validate type Nml2Quantity_rhoFactor
        super(FixedFactorConcentrationModel, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(FixedFactorConcentrationModel, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FixedFactorConcentrationModel


class DecayingPoolConcentrationModel(Standalone):
    """Should not be required, as it's present on the species element!"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ion', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('restingConc', 'Nml2Quantity_concentration', 0, 0, {'use': 'required'}),
        MemberSpec_('decayConstant', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('shellThickness', 'Nml2Quantity_length', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, ion=None, restingConc=None, decayConstant=None, shellThickness=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DecayingPoolConcentrationModel, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.ion = _cast(None, ion)
        self.ion_nsprefix_ = None
        self.restingConc = _cast(None, restingConc)
        self.restingConc_nsprefix_ = None
        self.decayConstant = _cast(None, decayConstant)
        self.decayConstant_nsprefix_ = None
        self.shellThickness = _cast(None, shellThickness)
        self.shellThickness_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DecayingPoolConcentrationModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DecayingPoolConcentrationModel.subclass:
            return DecayingPoolConcentrationModel.subclass(*args_, **kwargs_)
        else:
            return DecayingPoolConcentrationModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_concentration(self, value):
        # Validate type Nml2Quantity_concentration, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_concentration_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_concentration_patterns_, ))
    validate_Nml2Quantity_concentration_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(mol_per_m3|mol_per_cm3|M|mM))$']]
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_length(self, value):
        # Validate type Nml2Quantity_length, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_length_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_length_patterns_, ))
    validate_Nml2Quantity_length_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(m|cm|um))$']]
    def hasContent_(self):
        if (
            super(DecayingPoolConcentrationModel, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DecayingPoolConcentrationModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DecayingPoolConcentrationModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DecayingPoolConcentrationModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DecayingPoolConcentrationModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DecayingPoolConcentrationModel'):
        super(DecayingPoolConcentrationModel, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DecayingPoolConcentrationModel')
        if self.ion is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            outfile.write(' ion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ion), input_name='ion')), ))
        if self.restingConc is not None and 'restingConc' not in already_processed:
            already_processed.add('restingConc')
            outfile.write(' restingConc=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.restingConc), input_name='restingConc')), ))
        if self.decayConstant is not None and 'decayConstant' not in already_processed:
            already_processed.add('decayConstant')
            outfile.write(' decayConstant=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.decayConstant), input_name='decayConstant')), ))
        if self.shellThickness is not None and 'shellThickness' not in already_processed:
            already_processed.add('shellThickness')
            outfile.write(' shellThickness=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.shellThickness), input_name='shellThickness')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DecayingPoolConcentrationModel', fromsubclass_=False, pretty_print=True):
        super(DecayingPoolConcentrationModel, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ion', node)
        if value is not None and 'ion' not in already_processed:
            already_processed.add('ion')
            self.ion = value
            self.validate_NmlId(self.ion)    # validate type NmlId
        value = find_attr_value_('restingConc', node)
        if value is not None and 'restingConc' not in already_processed:
            already_processed.add('restingConc')
            self.restingConc = value
            self.validate_Nml2Quantity_concentration(self.restingConc)    # validate type Nml2Quantity_concentration
        value = find_attr_value_('decayConstant', node)
        if value is not None and 'decayConstant' not in already_processed:
            already_processed.add('decayConstant')
            self.decayConstant = value
            self.validate_Nml2Quantity_time(self.decayConstant)    # validate type Nml2Quantity_time
        value = find_attr_value_('shellThickness', node)
        if value is not None and 'shellThickness' not in already_processed:
            already_processed.add('shellThickness')
            self.shellThickness = value
            self.validate_Nml2Quantity_length(self.shellThickness)    # validate type Nml2Quantity_length
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(DecayingPoolConcentrationModel, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DecayingPoolConcentrationModel, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DecayingPoolConcentrationModel


class GateFractionalSubgate(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('fractionalConductance', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('notes', ['Notes', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'notes', 'type': 'xs:string'}, None),
        MemberSpec_('q10Settings', 'Q10Settings', 0, 1, {'minOccurs': '0', 'name': 'q10Settings', 'type': 'Q10Settings'}, None),
        MemberSpec_('steadyState', 'HHVariable', 0, 0, {'minOccurs': '1', 'name': 'steadyState', 'type': 'HHVariable'}, None),
        MemberSpec_('timeCourse', 'HHTime', 0, 0, {'minOccurs': '1', 'name': 'timeCourse', 'type': 'HHTime'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, fractionalConductance=None, notes=None, q10Settings=None, steadyState=None, timeCourse=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GateFractionalSubgate, self).__init__(neuroLexId, id,  **kwargs_)
        self.fractionalConductance = _cast(None, fractionalConductance)
        self.fractionalConductance_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10Settings = q10Settings
        self.q10Settings_nsprefix_ = None
        self.steadyState = steadyState
        self.steadyState_nsprefix_ = None
        self.timeCourse = timeCourse
        self.timeCourse_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GateFractionalSubgate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateFractionalSubgate.subclass:
            return GateFractionalSubgate.subclass(*args_, **kwargs_)
        else:
            return GateFractionalSubgate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_none_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_none_patterns_, ))
    validate_Nml2Quantity_none_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$']]
    def hasContent_(self):
        if (
            self.notes is not None or
            self.q10Settings is not None or
            self.steadyState is not None or
            self.timeCourse is not None or
            super(GateFractionalSubgate, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateFractionalSubgate', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GateFractionalSubgate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateFractionalSubgate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GateFractionalSubgate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GateFractionalSubgate'):
        super(GateFractionalSubgate, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateFractionalSubgate')
        if self.fractionalConductance is not None and 'fractionalConductance' not in already_processed:
            already_processed.add('fractionalConductance')
            outfile.write(' fractionalConductance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fractionalConductance), input_name='fractionalConductance')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateFractionalSubgate', fromsubclass_=False, pretty_print=True):
        super(GateFractionalSubgate, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notes), input_name='notes')), namespaceprefix_ , eol_))
        if self.q10Settings is not None:
            namespaceprefix_ = self.q10Settings_nsprefix_ + ':' if (UseCapturedNS_ and self.q10Settings_nsprefix_) else ''
            self.q10Settings.export(outfile, level, namespaceprefix_, namespacedef_='', name_='q10Settings', pretty_print=pretty_print)
        if self.steadyState is not None:
            namespaceprefix_ = self.steadyState_nsprefix_ + ':' if (UseCapturedNS_ and self.steadyState_nsprefix_) else ''
            self.steadyState.export(outfile, level, namespaceprefix_, namespacedef_='', name_='steadyState', pretty_print=pretty_print)
        if self.timeCourse is not None:
            namespaceprefix_ = self.timeCourse_nsprefix_ + ':' if (UseCapturedNS_ and self.timeCourse_nsprefix_) else ''
            self.timeCourse.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timeCourse', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fractionalConductance', node)
        if value is not None and 'fractionalConductance' not in already_processed:
            already_processed.add('fractionalConductance')
            self.fractionalConductance = value
            self.validate_Nml2Quantity_none(self.fractionalConductance)    # validate type Nml2Quantity_none
        super(GateFractionalSubgate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notes')
            value_ = self.gds_validate_string(value_, node, 'notes')
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == 'q10Settings':
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10Settings = obj_
            obj_.original_tagname_ = 'q10Settings'
        elif nodeName_ == 'steadyState':
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steadyState = obj_
            obj_.original_tagname_ = 'steadyState'
        elif nodeName_ == 'timeCourse':
            obj_ = HHTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeCourse = obj_
            obj_.original_tagname_ = 'timeCourse'
        super(GateFractionalSubgate, self).buildChildren(child_, node, nodeName_, True)
# end class GateFractionalSubgate


class GateFractional(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('instances', 'PositiveInteger', 0, 0, {'use': 'required'}),
        MemberSpec_('notes', ['Notes', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'notes', 'type': 'xs:string'}, None),
        MemberSpec_('q10Settings', 'Q10Settings', 0, 1, {'minOccurs': '0', 'name': 'q10Settings', 'type': 'Q10Settings'}, None),
        MemberSpec_('subGate', 'GateFractionalSubgate', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'subGate', 'type': 'GateFractionalSubgate'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, instances=None, notes=None, q10Settings=None, subGate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GateFractional, self).__init__(neuroLexId, id,  **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10Settings = q10Settings
        self.q10Settings_nsprefix_ = None
        if subGate is None:
            self.subGate = []
        else:
            self.subGate = subGate
        self.subGate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GateFractional)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateFractional.subclass:
            return GateFractional.subclass(*args_, **kwargs_)
        else:
            return GateFractional(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.notes is not None or
            self.q10Settings is not None or
            self.subGate or
            super(GateFractional, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateFractional', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GateFractional')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateFractional')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GateFractional', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GateFractional'):
        super(GateFractional, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateFractional')
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            outfile.write(' instances="%s"' % self.gds_format_integer(self.instances, input_name='instances'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateFractional', fromsubclass_=False, pretty_print=True):
        super(GateFractional, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notes), input_name='notes')), namespaceprefix_ , eol_))
        if self.q10Settings is not None:
            namespaceprefix_ = self.q10Settings_nsprefix_ + ':' if (UseCapturedNS_ and self.q10Settings_nsprefix_) else ''
            self.q10Settings.export(outfile, level, namespaceprefix_, namespacedef_='', name_='q10Settings', pretty_print=pretty_print)
        for subGate_ in self.subGate:
            namespaceprefix_ = self.subGate_nsprefix_ + ':' if (UseCapturedNS_ and self.subGate_nsprefix_) else ''
            subGate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subGate', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instances', node)
        if value is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            self.instances = self.gds_parse_integer(value, node, 'instances')
            if self.instances <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_PositiveInteger(self.instances)    # validate type PositiveInteger
        super(GateFractional, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notes')
            value_ = self.gds_validate_string(value_, node, 'notes')
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == 'q10Settings':
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10Settings = obj_
            obj_.original_tagname_ = 'q10Settings'
        elif nodeName_ == 'subGate':
            obj_ = GateFractionalSubgate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subGate.append(obj_)
            obj_.original_tagname_ = 'subGate'
        super(GateFractional, self).buildChildren(child_, node, nodeName_, True)
# end class GateFractional


class GateHHInstantaneous(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('instances', 'PositiveInteger', 0, 0, {'use': 'required'}),
        MemberSpec_('notes', ['Notes', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'notes', 'type': 'xs:string'}, None),
        MemberSpec_('steadyState', 'HHVariable', 0, 0, {'minOccurs': '1', 'name': 'steadyState', 'type': 'HHVariable'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, instances=None, notes=None, steadyState=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GateHHInstantaneous, self).__init__(neuroLexId, id,  **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.steadyState = steadyState
        self.steadyState_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GateHHInstantaneous)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHInstantaneous.subclass:
            return GateHHInstantaneous.subclass(*args_, **kwargs_)
        else:
            return GateHHInstantaneous(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.notes is not None or
            self.steadyState is not None or
            super(GateHHInstantaneous, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHInstantaneous', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GateHHInstantaneous')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHInstantaneous')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GateHHInstantaneous', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GateHHInstantaneous'):
        super(GateHHInstantaneous, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHInstantaneous')
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            outfile.write(' instances="%s"' % self.gds_format_integer(self.instances, input_name='instances'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHInstantaneous', fromsubclass_=False, pretty_print=True):
        super(GateHHInstantaneous, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notes), input_name='notes')), namespaceprefix_ , eol_))
        if self.steadyState is not None:
            namespaceprefix_ = self.steadyState_nsprefix_ + ':' if (UseCapturedNS_ and self.steadyState_nsprefix_) else ''
            self.steadyState.export(outfile, level, namespaceprefix_, namespacedef_='', name_='steadyState', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instances', node)
        if value is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            self.instances = self.gds_parse_integer(value, node, 'instances')
            if self.instances <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_PositiveInteger(self.instances)    # validate type PositiveInteger
        super(GateHHInstantaneous, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notes')
            value_ = self.gds_validate_string(value_, node, 'notes')
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == 'steadyState':
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steadyState = obj_
            obj_.original_tagname_ = 'steadyState'
        super(GateHHInstantaneous, self).buildChildren(child_, node, nodeName_, True)
# end class GateHHInstantaneous


class GateHHRatesInf(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('instances', 'PositiveInteger', 0, 0, {'use': 'required'}),
        MemberSpec_('notes', ['Notes', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'notes', 'type': 'xs:string'}, None),
        MemberSpec_('q10Settings', 'Q10Settings', 0, 1, {'minOccurs': '0', 'name': 'q10Settings', 'type': 'Q10Settings'}, None),
        MemberSpec_('forwardRate', 'HHRate', 0, 0, {'minOccurs': '1', 'name': 'forwardRate', 'type': 'HHRate'}, None),
        MemberSpec_('reverseRate', 'HHRate', 0, 0, {'minOccurs': '1', 'name': 'reverseRate', 'type': 'HHRate'}, None),
        MemberSpec_('steadyState', 'HHVariable', 0, 0, {'minOccurs': '1', 'name': 'steadyState', 'type': 'HHVariable'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, instances=None, notes=None, q10Settings=None, forwardRate=None, reverseRate=None, steadyState=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GateHHRatesInf, self).__init__(neuroLexId, id,  **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10Settings = q10Settings
        self.q10Settings_nsprefix_ = None
        self.forwardRate = forwardRate
        self.forwardRate_nsprefix_ = None
        self.reverseRate = reverseRate
        self.reverseRate_nsprefix_ = None
        self.steadyState = steadyState
        self.steadyState_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GateHHRatesInf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHRatesInf.subclass:
            return GateHHRatesInf.subclass(*args_, **kwargs_)
        else:
            return GateHHRatesInf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.notes is not None or
            self.q10Settings is not None or
            self.forwardRate is not None or
            self.reverseRate is not None or
            self.steadyState is not None or
            super(GateHHRatesInf, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHRatesInf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GateHHRatesInf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHRatesInf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GateHHRatesInf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GateHHRatesInf'):
        super(GateHHRatesInf, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHRatesInf')
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            outfile.write(' instances="%s"' % self.gds_format_integer(self.instances, input_name='instances'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHRatesInf', fromsubclass_=False, pretty_print=True):
        super(GateHHRatesInf, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notes), input_name='notes')), namespaceprefix_ , eol_))
        if self.q10Settings is not None:
            namespaceprefix_ = self.q10Settings_nsprefix_ + ':' if (UseCapturedNS_ and self.q10Settings_nsprefix_) else ''
            self.q10Settings.export(outfile, level, namespaceprefix_, namespacedef_='', name_='q10Settings', pretty_print=pretty_print)
        if self.forwardRate is not None:
            namespaceprefix_ = self.forwardRate_nsprefix_ + ':' if (UseCapturedNS_ and self.forwardRate_nsprefix_) else ''
            self.forwardRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='forwardRate', pretty_print=pretty_print)
        if self.reverseRate is not None:
            namespaceprefix_ = self.reverseRate_nsprefix_ + ':' if (UseCapturedNS_ and self.reverseRate_nsprefix_) else ''
            self.reverseRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reverseRate', pretty_print=pretty_print)
        if self.steadyState is not None:
            namespaceprefix_ = self.steadyState_nsprefix_ + ':' if (UseCapturedNS_ and self.steadyState_nsprefix_) else ''
            self.steadyState.export(outfile, level, namespaceprefix_, namespacedef_='', name_='steadyState', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instances', node)
        if value is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            self.instances = self.gds_parse_integer(value, node, 'instances')
            if self.instances <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_PositiveInteger(self.instances)    # validate type PositiveInteger
        super(GateHHRatesInf, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notes')
            value_ = self.gds_validate_string(value_, node, 'notes')
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == 'q10Settings':
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10Settings = obj_
            obj_.original_tagname_ = 'q10Settings'
        elif nodeName_ == 'forwardRate':
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forwardRate = obj_
            obj_.original_tagname_ = 'forwardRate'
        elif nodeName_ == 'reverseRate':
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reverseRate = obj_
            obj_.original_tagname_ = 'reverseRate'
        elif nodeName_ == 'steadyState':
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steadyState = obj_
            obj_.original_tagname_ = 'steadyState'
        super(GateHHRatesInf, self).buildChildren(child_, node, nodeName_, True)
# end class GateHHRatesInf


class GateHHRatesTau(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('instances', 'PositiveInteger', 0, 0, {'use': 'required'}),
        MemberSpec_('notes', ['Notes', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'notes', 'type': 'xs:string'}, None),
        MemberSpec_('q10Settings', 'Q10Settings', 0, 1, {'minOccurs': '0', 'name': 'q10Settings', 'type': 'Q10Settings'}, None),
        MemberSpec_('forwardRate', 'HHRate', 0, 0, {'minOccurs': '1', 'name': 'forwardRate', 'type': 'HHRate'}, None),
        MemberSpec_('reverseRate', 'HHRate', 0, 0, {'minOccurs': '1', 'name': 'reverseRate', 'type': 'HHRate'}, None),
        MemberSpec_('timeCourse', 'HHTime', 0, 0, {'minOccurs': '1', 'name': 'timeCourse', 'type': 'HHTime'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, instances=None, notes=None, q10Settings=None, forwardRate=None, reverseRate=None, timeCourse=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GateHHRatesTau, self).__init__(neuroLexId, id,  **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10Settings = q10Settings
        self.q10Settings_nsprefix_ = None
        self.forwardRate = forwardRate
        self.forwardRate_nsprefix_ = None
        self.reverseRate = reverseRate
        self.reverseRate_nsprefix_ = None
        self.timeCourse = timeCourse
        self.timeCourse_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GateHHRatesTau)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHRatesTau.subclass:
            return GateHHRatesTau.subclass(*args_, **kwargs_)
        else:
            return GateHHRatesTau(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.notes is not None or
            self.q10Settings is not None or
            self.forwardRate is not None or
            self.reverseRate is not None or
            self.timeCourse is not None or
            super(GateHHRatesTau, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHRatesTau', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GateHHRatesTau')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHRatesTau')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GateHHRatesTau', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GateHHRatesTau'):
        super(GateHHRatesTau, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHRatesTau')
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            outfile.write(' instances="%s"' % self.gds_format_integer(self.instances, input_name='instances'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHRatesTau', fromsubclass_=False, pretty_print=True):
        super(GateHHRatesTau, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notes), input_name='notes')), namespaceprefix_ , eol_))
        if self.q10Settings is not None:
            namespaceprefix_ = self.q10Settings_nsprefix_ + ':' if (UseCapturedNS_ and self.q10Settings_nsprefix_) else ''
            self.q10Settings.export(outfile, level, namespaceprefix_, namespacedef_='', name_='q10Settings', pretty_print=pretty_print)
        if self.forwardRate is not None:
            namespaceprefix_ = self.forwardRate_nsprefix_ + ':' if (UseCapturedNS_ and self.forwardRate_nsprefix_) else ''
            self.forwardRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='forwardRate', pretty_print=pretty_print)
        if self.reverseRate is not None:
            namespaceprefix_ = self.reverseRate_nsprefix_ + ':' if (UseCapturedNS_ and self.reverseRate_nsprefix_) else ''
            self.reverseRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reverseRate', pretty_print=pretty_print)
        if self.timeCourse is not None:
            namespaceprefix_ = self.timeCourse_nsprefix_ + ':' if (UseCapturedNS_ and self.timeCourse_nsprefix_) else ''
            self.timeCourse.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timeCourse', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instances', node)
        if value is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            self.instances = self.gds_parse_integer(value, node, 'instances')
            if self.instances <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_PositiveInteger(self.instances)    # validate type PositiveInteger
        super(GateHHRatesTau, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notes')
            value_ = self.gds_validate_string(value_, node, 'notes')
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == 'q10Settings':
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10Settings = obj_
            obj_.original_tagname_ = 'q10Settings'
        elif nodeName_ == 'forwardRate':
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forwardRate = obj_
            obj_.original_tagname_ = 'forwardRate'
        elif nodeName_ == 'reverseRate':
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reverseRate = obj_
            obj_.original_tagname_ = 'reverseRate'
        elif nodeName_ == 'timeCourse':
            obj_ = HHTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeCourse = obj_
            obj_.original_tagname_ = 'timeCourse'
        super(GateHHRatesTau, self).buildChildren(child_, node, nodeName_, True)
# end class GateHHRatesTau


class GateHHRatesTauInf(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('instances', 'PositiveInteger', 0, 0, {'use': 'required'}),
        MemberSpec_('notes', ['Notes', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'notes', 'type': 'xs:string'}, None),
        MemberSpec_('q10Settings', 'Q10Settings', 0, 1, {'minOccurs': '0', 'name': 'q10Settings', 'type': 'Q10Settings'}, None),
        MemberSpec_('forwardRate', 'HHRate', 0, 0, {'minOccurs': '1', 'name': 'forwardRate', 'type': 'HHRate'}, None),
        MemberSpec_('reverseRate', 'HHRate', 0, 0, {'minOccurs': '1', 'name': 'reverseRate', 'type': 'HHRate'}, None),
        MemberSpec_('timeCourse', 'HHTime', 0, 0, {'minOccurs': '1', 'name': 'timeCourse', 'type': 'HHTime'}, None),
        MemberSpec_('steadyState', 'HHVariable', 0, 0, {'minOccurs': '1', 'name': 'steadyState', 'type': 'HHVariable'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, instances=None, notes=None, q10Settings=None, forwardRate=None, reverseRate=None, timeCourse=None, steadyState=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GateHHRatesTauInf, self).__init__(neuroLexId, id,  **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10Settings = q10Settings
        self.q10Settings_nsprefix_ = None
        self.forwardRate = forwardRate
        self.forwardRate_nsprefix_ = None
        self.reverseRate = reverseRate
        self.reverseRate_nsprefix_ = None
        self.timeCourse = timeCourse
        self.timeCourse_nsprefix_ = None
        self.steadyState = steadyState
        self.steadyState_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GateHHRatesTauInf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHRatesTauInf.subclass:
            return GateHHRatesTauInf.subclass(*args_, **kwargs_)
        else:
            return GateHHRatesTauInf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.notes is not None or
            self.q10Settings is not None or
            self.forwardRate is not None or
            self.reverseRate is not None or
            self.timeCourse is not None or
            self.steadyState is not None or
            super(GateHHRatesTauInf, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHRatesTauInf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GateHHRatesTauInf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHRatesTauInf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GateHHRatesTauInf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GateHHRatesTauInf'):
        super(GateHHRatesTauInf, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHRatesTauInf')
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            outfile.write(' instances="%s"' % self.gds_format_integer(self.instances, input_name='instances'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHRatesTauInf', fromsubclass_=False, pretty_print=True):
        super(GateHHRatesTauInf, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notes), input_name='notes')), namespaceprefix_ , eol_))
        if self.q10Settings is not None:
            namespaceprefix_ = self.q10Settings_nsprefix_ + ':' if (UseCapturedNS_ and self.q10Settings_nsprefix_) else ''
            self.q10Settings.export(outfile, level, namespaceprefix_, namespacedef_='', name_='q10Settings', pretty_print=pretty_print)
        if self.forwardRate is not None:
            namespaceprefix_ = self.forwardRate_nsprefix_ + ':' if (UseCapturedNS_ and self.forwardRate_nsprefix_) else ''
            self.forwardRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='forwardRate', pretty_print=pretty_print)
        if self.reverseRate is not None:
            namespaceprefix_ = self.reverseRate_nsprefix_ + ':' if (UseCapturedNS_ and self.reverseRate_nsprefix_) else ''
            self.reverseRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reverseRate', pretty_print=pretty_print)
        if self.timeCourse is not None:
            namespaceprefix_ = self.timeCourse_nsprefix_ + ':' if (UseCapturedNS_ and self.timeCourse_nsprefix_) else ''
            self.timeCourse.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timeCourse', pretty_print=pretty_print)
        if self.steadyState is not None:
            namespaceprefix_ = self.steadyState_nsprefix_ + ':' if (UseCapturedNS_ and self.steadyState_nsprefix_) else ''
            self.steadyState.export(outfile, level, namespaceprefix_, namespacedef_='', name_='steadyState', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instances', node)
        if value is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            self.instances = self.gds_parse_integer(value, node, 'instances')
            if self.instances <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_PositiveInteger(self.instances)    # validate type PositiveInteger
        super(GateHHRatesTauInf, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notes')
            value_ = self.gds_validate_string(value_, node, 'notes')
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == 'q10Settings':
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10Settings = obj_
            obj_.original_tagname_ = 'q10Settings'
        elif nodeName_ == 'forwardRate':
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forwardRate = obj_
            obj_.original_tagname_ = 'forwardRate'
        elif nodeName_ == 'reverseRate':
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reverseRate = obj_
            obj_.original_tagname_ = 'reverseRate'
        elif nodeName_ == 'timeCourse':
            obj_ = HHTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeCourse = obj_
            obj_.original_tagname_ = 'timeCourse'
        elif nodeName_ == 'steadyState':
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steadyState = obj_
            obj_.original_tagname_ = 'steadyState'
        super(GateHHRatesTauInf, self).buildChildren(child_, node, nodeName_, True)
# end class GateHHRatesTauInf


class GateHHTauInf(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('instances', 'PositiveInteger', 0, 0, {'use': 'required'}),
        MemberSpec_('notes', ['Notes', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'notes', 'type': 'xs:string'}, None),
        MemberSpec_('q10Settings', 'Q10Settings', 0, 1, {'minOccurs': '0', 'name': 'q10Settings', 'type': 'Q10Settings'}, None),
        MemberSpec_('timeCourse', 'HHTime', 0, 0, {'minOccurs': '1', 'name': 'timeCourse', 'type': 'HHTime'}, None),
        MemberSpec_('steadyState', 'HHVariable', 0, 0, {'minOccurs': '1', 'name': 'steadyState', 'type': 'HHVariable'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, instances=None, notes=None, q10Settings=None, timeCourse=None, steadyState=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GateHHTauInf, self).__init__(neuroLexId, id,  **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10Settings = q10Settings
        self.q10Settings_nsprefix_ = None
        self.timeCourse = timeCourse
        self.timeCourse_nsprefix_ = None
        self.steadyState = steadyState
        self.steadyState_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GateHHTauInf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHTauInf.subclass:
            return GateHHTauInf.subclass(*args_, **kwargs_)
        else:
            return GateHHTauInf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.notes is not None or
            self.q10Settings is not None or
            self.timeCourse is not None or
            self.steadyState is not None or
            super(GateHHTauInf, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHTauInf', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GateHHTauInf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHTauInf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GateHHTauInf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GateHHTauInf'):
        super(GateHHTauInf, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHTauInf')
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            outfile.write(' instances="%s"' % self.gds_format_integer(self.instances, input_name='instances'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHTauInf', fromsubclass_=False, pretty_print=True):
        super(GateHHTauInf, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notes), input_name='notes')), namespaceprefix_ , eol_))
        if self.q10Settings is not None:
            namespaceprefix_ = self.q10Settings_nsprefix_ + ':' if (UseCapturedNS_ and self.q10Settings_nsprefix_) else ''
            self.q10Settings.export(outfile, level, namespaceprefix_, namespacedef_='', name_='q10Settings', pretty_print=pretty_print)
        if self.timeCourse is not None:
            namespaceprefix_ = self.timeCourse_nsprefix_ + ':' if (UseCapturedNS_ and self.timeCourse_nsprefix_) else ''
            self.timeCourse.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timeCourse', pretty_print=pretty_print)
        if self.steadyState is not None:
            namespaceprefix_ = self.steadyState_nsprefix_ + ':' if (UseCapturedNS_ and self.steadyState_nsprefix_) else ''
            self.steadyState.export(outfile, level, namespaceprefix_, namespacedef_='', name_='steadyState', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instances', node)
        if value is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            self.instances = self.gds_parse_integer(value, node, 'instances')
            if self.instances <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_PositiveInteger(self.instances)    # validate type PositiveInteger
        super(GateHHTauInf, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notes')
            value_ = self.gds_validate_string(value_, node, 'notes')
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == 'q10Settings':
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10Settings = obj_
            obj_.original_tagname_ = 'q10Settings'
        elif nodeName_ == 'timeCourse':
            obj_ = HHTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeCourse = obj_
            obj_.original_tagname_ = 'timeCourse'
        elif nodeName_ == 'steadyState':
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steadyState = obj_
            obj_.original_tagname_ = 'steadyState'
        super(GateHHTauInf, self).buildChildren(child_, node, nodeName_, True)
# end class GateHHTauInf


class GateHHRates(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('instances', 'PositiveInteger', 0, 0, {'use': 'required'}),
        MemberSpec_('notes', ['Notes', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'notes', 'type': 'xs:string'}, None),
        MemberSpec_('q10Settings', 'Q10Settings', 0, 1, {'minOccurs': '0', 'name': 'q10Settings', 'type': 'Q10Settings'}, None),
        MemberSpec_('forwardRate', 'HHRate', 0, 0, {'minOccurs': '1', 'name': 'forwardRate', 'type': 'HHRate'}, None),
        MemberSpec_('reverseRate', 'HHRate', 0, 0, {'minOccurs': '1', 'name': 'reverseRate', 'type': 'HHRate'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, instances=None, notes=None, q10Settings=None, forwardRate=None, reverseRate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GateHHRates, self).__init__(neuroLexId, id,  **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10Settings = q10Settings
        self.q10Settings_nsprefix_ = None
        self.forwardRate = forwardRate
        self.forwardRate_nsprefix_ = None
        self.reverseRate = reverseRate
        self.reverseRate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GateHHRates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHRates.subclass:
            return GateHHRates.subclass(*args_, **kwargs_)
        else:
            return GateHHRates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.notes is not None or
            self.q10Settings is not None or
            self.forwardRate is not None or
            self.reverseRate is not None or
            super(GateHHRates, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHRates', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GateHHRates')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHRates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GateHHRates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GateHHRates'):
        super(GateHHRates, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHRates')
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            outfile.write(' instances="%s"' % self.gds_format_integer(self.instances, input_name='instances'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHRates', fromsubclass_=False, pretty_print=True):
        super(GateHHRates, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notes), input_name='notes')), namespaceprefix_ , eol_))
        if self.q10Settings is not None:
            namespaceprefix_ = self.q10Settings_nsprefix_ + ':' if (UseCapturedNS_ and self.q10Settings_nsprefix_) else ''
            self.q10Settings.export(outfile, level, namespaceprefix_, namespacedef_='', name_='q10Settings', pretty_print=pretty_print)
        if self.forwardRate is not None:
            namespaceprefix_ = self.forwardRate_nsprefix_ + ':' if (UseCapturedNS_ and self.forwardRate_nsprefix_) else ''
            self.forwardRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='forwardRate', pretty_print=pretty_print)
        if self.reverseRate is not None:
            namespaceprefix_ = self.reverseRate_nsprefix_ + ':' if (UseCapturedNS_ and self.reverseRate_nsprefix_) else ''
            self.reverseRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reverseRate', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instances', node)
        if value is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            self.instances = self.gds_parse_integer(value, node, 'instances')
            if self.instances <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_PositiveInteger(self.instances)    # validate type PositiveInteger
        super(GateHHRates, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notes')
            value_ = self.gds_validate_string(value_, node, 'notes')
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == 'q10Settings':
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10Settings = obj_
            obj_.original_tagname_ = 'q10Settings'
        elif nodeName_ == 'forwardRate':
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forwardRate = obj_
            obj_.original_tagname_ = 'forwardRate'
        elif nodeName_ == 'reverseRate':
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reverseRate = obj_
            obj_.original_tagname_ = 'reverseRate'
        super(GateHHRates, self).buildChildren(child_, node, nodeName_, True)
# end class GateHHRates


class GateHHUndetermined(Base):
    """Note all sub elements for gateHHrates, gateHHratesTau, gateFractional
    etc. allowed here. Which are valid should be constrained by what type
    is set"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('instances', 'PositiveInteger', 0, 0, {'use': 'required'}),
        MemberSpec_('type_', 'gateTypes', 0, 0, {'use': 'required'}),
        MemberSpec_('notes', ['Notes', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'notes', 'type': 'xs:string'}, None),
        MemberSpec_('q10Settings', 'Q10Settings', 0, 1, {'minOccurs': '0', 'name': 'q10Settings', 'type': 'Q10Settings'}, None),
        MemberSpec_('forwardRate', 'HHRate', 0, 1, {'minOccurs': '0', 'name': 'forwardRate', 'type': 'HHRate'}, None),
        MemberSpec_('reverseRate', 'HHRate', 0, 1, {'minOccurs': '0', 'name': 'reverseRate', 'type': 'HHRate'}, None),
        MemberSpec_('timeCourse', 'HHTime', 0, 1, {'minOccurs': '0', 'name': 'timeCourse', 'type': 'HHTime'}, None),
        MemberSpec_('steadyState', 'HHVariable', 0, 1, {'minOccurs': '0', 'name': 'steadyState', 'type': 'HHVariable'}, None),
        MemberSpec_('subGate', 'GateFractionalSubgate', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'subGate', 'type': 'GateFractionalSubgate'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, instances=None, type_=None, notes=None, q10Settings=None, forwardRate=None, reverseRate=None, timeCourse=None, steadyState=None, subGate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GateHHUndetermined, self).__init__(neuroLexId, id,  **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10Settings = q10Settings
        self.q10Settings_nsprefix_ = None
        self.forwardRate = forwardRate
        self.forwardRate_nsprefix_ = None
        self.reverseRate = reverseRate
        self.reverseRate_nsprefix_ = None
        self.timeCourse = timeCourse
        self.timeCourse_nsprefix_ = None
        self.steadyState = steadyState
        self.steadyState_nsprefix_ = None
        if subGate is None:
            self.subGate = []
        else:
            self.subGate = subGate
        self.subGate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GateHHUndetermined)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateHHUndetermined.subclass:
            return GateHHUndetermined.subclass(*args_, **kwargs_)
        else:
            return GateHHUndetermined(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_gateTypes(self, value):
        # Validate type gateTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['gateHHrates', 'gateHHratesTau', 'gateHHtauInf', 'gateHHratesInf', 'gateHHratesTauInf', 'gateHHInstantaneous', 'gateKS', 'gateFractional']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on gateTypes' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.notes is not None or
            self.q10Settings is not None or
            self.forwardRate is not None or
            self.reverseRate is not None or
            self.timeCourse is not None or
            self.steadyState is not None or
            self.subGate or
            super(GateHHUndetermined, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHUndetermined', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GateHHUndetermined')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHUndetermined')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GateHHUndetermined', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GateHHUndetermined'):
        super(GateHHUndetermined, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateHHUndetermined')
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            outfile.write(' instances="%s"' % self.gds_format_integer(self.instances, input_name='instances'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateHHUndetermined', fromsubclass_=False, pretty_print=True):
        super(GateHHUndetermined, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notes), input_name='notes')), namespaceprefix_ , eol_))
        if self.q10Settings is not None:
            namespaceprefix_ = self.q10Settings_nsprefix_ + ':' if (UseCapturedNS_ and self.q10Settings_nsprefix_) else ''
            self.q10Settings.export(outfile, level, namespaceprefix_, namespacedef_='', name_='q10Settings', pretty_print=pretty_print)
        if self.forwardRate is not None:
            namespaceprefix_ = self.forwardRate_nsprefix_ + ':' if (UseCapturedNS_ and self.forwardRate_nsprefix_) else ''
            self.forwardRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='forwardRate', pretty_print=pretty_print)
        if self.reverseRate is not None:
            namespaceprefix_ = self.reverseRate_nsprefix_ + ':' if (UseCapturedNS_ and self.reverseRate_nsprefix_) else ''
            self.reverseRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reverseRate', pretty_print=pretty_print)
        if self.timeCourse is not None:
            namespaceprefix_ = self.timeCourse_nsprefix_ + ':' if (UseCapturedNS_ and self.timeCourse_nsprefix_) else ''
            self.timeCourse.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timeCourse', pretty_print=pretty_print)
        if self.steadyState is not None:
            namespaceprefix_ = self.steadyState_nsprefix_ + ':' if (UseCapturedNS_ and self.steadyState_nsprefix_) else ''
            self.steadyState.export(outfile, level, namespaceprefix_, namespacedef_='', name_='steadyState', pretty_print=pretty_print)
        for subGate_ in self.subGate:
            namespaceprefix_ = self.subGate_nsprefix_ + ':' if (UseCapturedNS_ and self.subGate_nsprefix_) else ''
            subGate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subGate', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instances', node)
        if value is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            self.instances = self.gds_parse_integer(value, node, 'instances')
            if self.instances <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_PositiveInteger(self.instances)    # validate type PositiveInteger
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_gateTypes(self.type_)    # validate type gateTypes
        super(GateHHUndetermined, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notes')
            value_ = self.gds_validate_string(value_, node, 'notes')
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == 'q10Settings':
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10Settings = obj_
            obj_.original_tagname_ = 'q10Settings'
        elif nodeName_ == 'forwardRate':
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forwardRate = obj_
            obj_.original_tagname_ = 'forwardRate'
        elif nodeName_ == 'reverseRate':
            obj_ = HHRate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reverseRate = obj_
            obj_.original_tagname_ = 'reverseRate'
        elif nodeName_ == 'timeCourse':
            obj_ = HHTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeCourse = obj_
            obj_.original_tagname_ = 'timeCourse'
        elif nodeName_ == 'steadyState':
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steadyState = obj_
            obj_.original_tagname_ = 'steadyState'
        elif nodeName_ == 'subGate':
            obj_ = GateFractionalSubgate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subGate.append(obj_)
            obj_.original_tagname_ = 'subGate'
        super(GateHHUndetermined, self).buildChildren(child_, node, nodeName_, True)
# end class GateHHUndetermined


class GateKS(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('instances', 'PositiveInteger', 0, 0, {'use': 'required'}),
        MemberSpec_('notes', ['Notes', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'notes', 'type': 'xs:string'}, None),
        MemberSpec_('q10Settings', 'Q10Settings', 0, 1, {'minOccurs': '0', 'name': 'q10Settings', 'type': 'Q10Settings'}, None),
        MemberSpec_('closedState', 'ClosedState', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'closedState', 'type': 'ClosedState'}, None),
        MemberSpec_('openState', 'OpenState', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'openState', 'type': 'OpenState'}, None),
        MemberSpec_('forwardTransition', 'ForwardTransition', 1, 0, {'name': 'forwardTransition', 'type': 'ForwardTransition'}, 2),
        MemberSpec_('reverseTransition', 'ReverseTransition', 1, 0, {'name': 'reverseTransition', 'type': 'ReverseTransition'}, 2),
        MemberSpec_('tauInfTransition', 'TauInfTransition', 1, 0, {'name': 'tauInfTransition', 'type': 'TauInfTransition'}, 2),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, instances=None, notes=None, q10Settings=None, closedState=None, openState=None, forwardTransition=None, reverseTransition=None, tauInfTransition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GateKS, self).__init__(neuroLexId, id,  **kwargs_)
        self.instances = _cast(int, instances)
        self.instances_nsprefix_ = None
        self.notes = notes
        self.validate_Notes(self.notes)
        self.notes_nsprefix_ = None
        self.q10Settings = q10Settings
        self.q10Settings_nsprefix_ = None
        if closedState is None:
            self.closedState = []
        else:
            self.closedState = closedState
        self.closedState_nsprefix_ = None
        if openState is None:
            self.openState = []
        else:
            self.openState = openState
        self.openState_nsprefix_ = None
        if forwardTransition is None:
            self.forwardTransition = []
        else:
            self.forwardTransition = forwardTransition
        self.forwardTransition_nsprefix_ = None
        if reverseTransition is None:
            self.reverseTransition = []
        else:
            self.reverseTransition = reverseTransition
        self.reverseTransition_nsprefix_ = None
        if tauInfTransition is None:
            self.tauInfTransition = []
        else:
            self.tauInfTransition = tauInfTransition
        self.tauInfTransition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GateKS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GateKS.subclass:
            return GateKS.subclass(*args_, **kwargs_)
        else:
            return GateKS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Notes(self, value):
        result = True
        # Validate type Notes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_PositiveInteger(self, value):
        # Validate type PositiveInteger, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def hasContent_(self):
        if (
            self.notes is not None or
            self.q10Settings is not None or
            self.closedState or
            self.openState or
            self.forwardTransition or
            self.reverseTransition or
            self.tauInfTransition or
            super(GateKS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateKS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GateKS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateKS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GateKS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GateKS'):
        super(GateKS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GateKS')
        if self.instances is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            outfile.write(' instances="%s"' % self.gds_format_integer(self.instances, input_name='instances'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GateKS', fromsubclass_=False, pretty_print=True):
        super(GateKS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notes is not None:
            namespaceprefix_ = self.notes_nsprefix_ + ':' if (UseCapturedNS_ and self.notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotes>%s</%snotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notes), input_name='notes')), namespaceprefix_ , eol_))
        if self.q10Settings is not None:
            namespaceprefix_ = self.q10Settings_nsprefix_ + ':' if (UseCapturedNS_ and self.q10Settings_nsprefix_) else ''
            self.q10Settings.export(outfile, level, namespaceprefix_, namespacedef_='', name_='q10Settings', pretty_print=pretty_print)
        for closedState_ in self.closedState:
            namespaceprefix_ = self.closedState_nsprefix_ + ':' if (UseCapturedNS_ and self.closedState_nsprefix_) else ''
            closedState_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='closedState', pretty_print=pretty_print)
        for openState_ in self.openState:
            namespaceprefix_ = self.openState_nsprefix_ + ':' if (UseCapturedNS_ and self.openState_nsprefix_) else ''
            openState_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='openState', pretty_print=pretty_print)
        for forwardTransition_ in self.forwardTransition:
            namespaceprefix_ = self.forwardTransition_nsprefix_ + ':' if (UseCapturedNS_ and self.forwardTransition_nsprefix_) else ''
            forwardTransition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='forwardTransition', pretty_print=pretty_print)
        for reverseTransition_ in self.reverseTransition:
            namespaceprefix_ = self.reverseTransition_nsprefix_ + ':' if (UseCapturedNS_ and self.reverseTransition_nsprefix_) else ''
            reverseTransition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reverseTransition', pretty_print=pretty_print)
        for tauInfTransition_ in self.tauInfTransition:
            namespaceprefix_ = self.tauInfTransition_nsprefix_ + ':' if (UseCapturedNS_ and self.tauInfTransition_nsprefix_) else ''
            tauInfTransition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tauInfTransition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instances', node)
        if value is not None and 'instances' not in already_processed:
            already_processed.add('instances')
            self.instances = self.gds_parse_integer(value, node, 'instances')
            if self.instances <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_PositiveInteger(self.instances)    # validate type PositiveInteger
        super(GateKS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notes')
            value_ = self.gds_validate_string(value_, node, 'notes')
            self.notes = value_
            self.notes_nsprefix_ = child_.prefix
            # validate type Notes
            self.validate_Notes(self.notes)
        elif nodeName_ == 'q10Settings':
            obj_ = Q10Settings.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10Settings = obj_
            obj_.original_tagname_ = 'q10Settings'
        elif nodeName_ == 'closedState':
            obj_ = ClosedState.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.closedState.append(obj_)
            obj_.original_tagname_ = 'closedState'
        elif nodeName_ == 'openState':
            obj_ = OpenState.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.openState.append(obj_)
            obj_.original_tagname_ = 'openState'
        elif nodeName_ == 'forwardTransition':
            obj_ = ForwardTransition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.forwardTransition.append(obj_)
            obj_.original_tagname_ = 'forwardTransition'
        elif nodeName_ == 'reverseTransition':
            obj_ = ReverseTransition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reverseTransition.append(obj_)
            obj_.original_tagname_ = 'reverseTransition'
        elif nodeName_ == 'tauInfTransition':
            obj_ = TauInfTransition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tauInfTransition.append(obj_)
            obj_.original_tagname_ = 'tauInfTransition'
        super(GateKS, self).buildChildren(child_, node, nodeName_, True)
# end class GateKS


class TauInfTransition(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('from_', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('to', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('steadyState', 'HHVariable', 0, 0, {'name': 'steadyState', 'type': 'HHVariable'}, None),
        MemberSpec_('timeCourse', 'HHTime', 0, 0, {'name': 'timeCourse', 'type': 'HHTime'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, from_=None, to=None, steadyState=None, timeCourse=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TauInfTransition, self).__init__(neuroLexId, id,  **kwargs_)
        self.from_ = _cast(None, from_)
        self.from__nsprefix_ = None
        self.to = _cast(None, to)
        self.to_nsprefix_ = None
        self.steadyState = steadyState
        self.steadyState_nsprefix_ = None
        self.timeCourse = timeCourse
        self.timeCourse_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TauInfTransition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TauInfTransition.subclass:
            return TauInfTransition.subclass(*args_, **kwargs_)
        else:
            return TauInfTransition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            self.steadyState is not None or
            self.timeCourse is not None or
            super(TauInfTransition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TauInfTransition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TauInfTransition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TauInfTransition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TauInfTransition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TauInfTransition'):
        super(TauInfTransition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TauInfTransition')
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.from_), input_name='from')), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' to=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.to), input_name='to')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TauInfTransition', fromsubclass_=False, pretty_print=True):
        super(TauInfTransition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.steadyState is not None:
            namespaceprefix_ = self.steadyState_nsprefix_ + ':' if (UseCapturedNS_ and self.steadyState_nsprefix_) else ''
            self.steadyState.export(outfile, level, namespaceprefix_, namespacedef_='', name_='steadyState', pretty_print=pretty_print)
        if self.timeCourse is not None:
            namespaceprefix_ = self.timeCourse_nsprefix_ + ':' if (UseCapturedNS_ and self.timeCourse_nsprefix_) else ''
            self.timeCourse.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timeCourse', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = value
            self.validate_NmlId(self.from_)    # validate type NmlId
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            self.to = value
            self.validate_NmlId(self.to)    # validate type NmlId
        super(TauInfTransition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'steadyState':
            obj_ = HHVariable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.steadyState = obj_
            obj_.original_tagname_ = 'steadyState'
        elif nodeName_ == 'timeCourse':
            obj_ = HHTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeCourse = obj_
            obj_.original_tagname_ = 'timeCourse'
        super(TauInfTransition, self).buildChildren(child_, node, nodeName_, True)
# end class TauInfTransition


class ReverseTransition(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('from_', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('to', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('__ANY__', '__ANY__', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'processContents': 'skip'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, from_=None, to=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ReverseTransition, self).__init__(neuroLexId, id,  **kwargs_)
        self.from_ = _cast(None, from_)
        self.from__nsprefix_ = None
        self.to = _cast(None, to)
        self.to_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReverseTransition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReverseTransition.subclass:
            return ReverseTransition.subclass(*args_, **kwargs_)
        else:
            return ReverseTransition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            super(ReverseTransition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReverseTransition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReverseTransition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReverseTransition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReverseTransition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReverseTransition'):
        super(ReverseTransition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReverseTransition')
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.from_), input_name='from')), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' to=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.to), input_name='to')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReverseTransition', fromsubclass_=False, pretty_print=True):
        super(ReverseTransition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = value
            self.validate_NmlId(self.from_)    # validate type NmlId
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            self.to = value
            self.validate_NmlId(self.to)    # validate type NmlId
        super(ReverseTransition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'ReverseTransition')
        self.add_anytypeobjs_(content_)
        super(ReverseTransition, self).buildChildren(child_, node, nodeName_, True)
# end class ReverseTransition


class ForwardTransition(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('from_', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('to', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('__ANY__', '__ANY__', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'processContents': 'skip'}, None),
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, from_=None, to=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ForwardTransition, self).__init__(neuroLexId, id,  **kwargs_)
        self.from_ = _cast(None, from_)
        self.from__nsprefix_ = None
        self.to = _cast(None, to)
        self.to_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ForwardTransition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ForwardTransition.subclass:
            return ForwardTransition.subclass(*args_, **kwargs_)
        else:
            return ForwardTransition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            super(ForwardTransition, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ForwardTransition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ForwardTransition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ForwardTransition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ForwardTransition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ForwardTransition'):
        super(ForwardTransition, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ForwardTransition')
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.from_), input_name='from')), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' to=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.to), input_name='to')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ForwardTransition', fromsubclass_=False, pretty_print=True):
        super(ForwardTransition, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = value
            self.validate_NmlId(self.from_)    # validate type NmlId
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            self.to = value
            self.validate_NmlId(self.to)    # validate type NmlId
        super(ForwardTransition, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'ForwardTransition')
        self.add_anytypeobjs_(content_)
        super(ForwardTransition, self).buildChildren(child_, node, nodeName_, True)
# end class ForwardTransition


class OpenState(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(OpenState, self).__init__(neuroLexId, id,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenState)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenState.subclass:
            return OpenState.subclass(*args_, **kwargs_)
        else:
            return OpenState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(OpenState, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OpenState', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OpenState')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OpenState')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OpenState', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OpenState'):
        super(OpenState, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OpenState')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OpenState', fromsubclass_=False, pretty_print=True):
        super(OpenState, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenState, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(OpenState, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class OpenState


class ClosedState(Base):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = Base
    def __init__(self, neuroLexId=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ClosedState, self).__init__(neuroLexId, id,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClosedState)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClosedState.subclass:
            return ClosedState.subclass(*args_, **kwargs_)
        else:
            return ClosedState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ClosedState, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ClosedState', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClosedState')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClosedState')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClosedState', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClosedState'):
        super(ClosedState, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClosedState')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ClosedState', fromsubclass_=False, pretty_print=True):
        super(ClosedState, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ClosedState, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ClosedState, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ClosedState


class IonChannelKS(Standalone):
    """Kinetic scheme based ion channel."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('species', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('conductance', 'Nml2Quantity_conductance', 0, 1, {'use': 'optional'}),
        MemberSpec_('gateKS', 'GateKS', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'gateKS', 'type': 'GateKS'}, None),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, species=None, conductance=None, gateKS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IonChannelKS, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.species = _cast(None, species)
        self.species_nsprefix_ = None
        self.conductance = _cast(None, conductance)
        self.conductance_nsprefix_ = None
        if gateKS is None:
            self.gateKS = []
        else:
            self.gateKS = gateKS
        self.gateKS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IonChannelKS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IonChannelKS.subclass:
            return IonChannelKS.subclass(*args_, **kwargs_)
        else:
            return IonChannelKS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductance_patterns_, ))
    validate_Nml2Quantity_conductance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$']]
    def hasContent_(self):
        if (
            self.gateKS or
            super(IonChannelKS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IonChannelKS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IonChannelKS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IonChannelKS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IonChannelKS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IonChannelKS'):
        super(IonChannelKS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IonChannelKS')
        if self.species is not None and 'species' not in already_processed:
            already_processed.add('species')
            outfile.write(' species=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.species), input_name='species')), ))
        if self.conductance is not None and 'conductance' not in already_processed:
            already_processed.add('conductance')
            outfile.write(' conductance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.conductance), input_name='conductance')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IonChannelKS', fromsubclass_=False, pretty_print=True):
        super(IonChannelKS, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for gateKS_ in self.gateKS:
            namespaceprefix_ = self.gateKS_nsprefix_ + ':' if (UseCapturedNS_ and self.gateKS_nsprefix_) else ''
            gateKS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gateKS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('species', node)
        if value is not None and 'species' not in already_processed:
            already_processed.add('species')
            self.species = value
            self.validate_NmlId(self.species)    # validate type NmlId
        value = find_attr_value_('conductance', node)
        if value is not None and 'conductance' not in already_processed:
            already_processed.add('conductance')
            self.conductance = value
            self.validate_Nml2Quantity_conductance(self.conductance)    # validate type Nml2Quantity_conductance
        super(IonChannelKS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'gateKS':
            obj_ = GateKS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gateKS.append(obj_)
            obj_.original_tagname_ = 'gateKS'
        super(IonChannelKS, self).buildChildren(child_, node, nodeName_, True)
# end class IonChannelKS


class IonChannelScalable(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('q10ConductanceScaling', 'Q10ConductanceScaling', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'q10ConductanceScaling', 'type': 'Q10ConductanceScaling'}, None),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, q10ConductanceScaling=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IonChannelScalable, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        if q10ConductanceScaling is None:
            self.q10ConductanceScaling = []
        else:
            self.q10ConductanceScaling = q10ConductanceScaling
        self.q10ConductanceScaling_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IonChannelScalable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IonChannelScalable.subclass:
            return IonChannelScalable.subclass(*args_, **kwargs_)
        else:
            return IonChannelScalable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.q10ConductanceScaling or
            super(IonChannelScalable, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IonChannelScalable', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IonChannelScalable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IonChannelScalable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IonChannelScalable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IonChannelScalable'):
        super(IonChannelScalable, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IonChannelScalable')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IonChannelScalable', fromsubclass_=False, pretty_print=True):
        super(IonChannelScalable, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for q10ConductanceScaling_ in self.q10ConductanceScaling:
            namespaceprefix_ = self.q10ConductanceScaling_nsprefix_ + ':' if (UseCapturedNS_ and self.q10ConductanceScaling_nsprefix_) else ''
            q10ConductanceScaling_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='q10ConductanceScaling', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IonChannelScalable, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'q10ConductanceScaling':
            obj_ = Q10ConductanceScaling.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.q10ConductanceScaling.append(obj_)
            obj_.original_tagname_ = 'q10ConductanceScaling'
        super(IonChannelScalable, self).buildChildren(child_, node, nodeName_, True)
# end class IonChannelScalable


class NeuroMLDocument(Standalone):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('include', 'IncludeType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'include', 'type': 'IncludeType'}, None),
        MemberSpec_('extracellularProperties', 'ExtracellularProperties', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'extracellularProperties', 'type': 'ExtracellularProperties'}, None),
        MemberSpec_('intracellularProperties', 'IntracellularProperties', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'intracellularProperties', 'type': 'IntracellularProperties'}, None),
        MemberSpec_('morphology', 'Morphology', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'morphology', 'type': 'Morphology'}, None),
        MemberSpec_('ionChannel', 'IonChannel', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'ionChannel', 'type': 'IonChannel'}, None),
        MemberSpec_('ionChannelHH', 'IonChannelHH', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'ionChannelHH', 'type': 'IonChannelHH'}, None),
        MemberSpec_('ionChannelVShift', 'IonChannelVShift', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'ionChannelVShift', 'type': 'IonChannelVShift'}, None),
        MemberSpec_('ionChannelKS', 'IonChannelKS', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'ionChannelKS', 'type': 'IonChannelKS'}, None),
        MemberSpec_('decayingPoolConcentrationModel', 'DecayingPoolConcentrationModel', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'decayingPoolConcentrationModel', 'type': 'DecayingPoolConcentrationModel'}, None),
        MemberSpec_('fixedFactorConcentrationModel', 'FixedFactorConcentrationModel', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'fixedFactorConcentrationModel', 'type': 'FixedFactorConcentrationModel'}, None),
        MemberSpec_('alphaCurrentSynapse', 'AlphaCurrentSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alphaCurrentSynapse', 'type': 'AlphaCurrentSynapse'}, None),
        MemberSpec_('alphaSynapse', 'AlphaSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alphaSynapse', 'type': 'AlphaSynapse'}, None),
        MemberSpec_('expOneSynapse', 'ExpOneSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'expOneSynapse', 'type': 'ExpOneSynapse'}, None),
        MemberSpec_('expTwoSynapse', 'ExpTwoSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'expTwoSynapse', 'type': 'ExpTwoSynapse'}, None),
        MemberSpec_('expThreeSynapse', 'ExpThreeSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'expThreeSynapse', 'type': 'ExpThreeSynapse'}, None),
        MemberSpec_('blockingPlasticSynapse', 'BlockingPlasticSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'blockingPlasticSynapse', 'type': 'BlockingPlasticSynapse'}, None),
        MemberSpec_('doubleSynapse', 'DoubleSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'doubleSynapse', 'type': 'DoubleSynapse'}, None),
        MemberSpec_('gapJunction', 'GapJunction', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'gapJunction', 'type': 'GapJunction'}, None),
        MemberSpec_('silentSynapse', 'SilentSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'silentSynapse', 'type': 'SilentSynapse'}, None),
        MemberSpec_('linearGradedSynapse', 'LinearGradedSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'linearGradedSynapse', 'type': 'LinearGradedSynapse'}, None),
        MemberSpec_('gradedSynapse', 'GradedSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'gradedSynapse', 'type': 'GradedSynapse'}, None),
        MemberSpec_('biophysicalProperties', 'BiophysicalProperties', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'biophysicalProperties', 'type': 'BiophysicalProperties'}, None),
        MemberSpec_('cell', 'Cell', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'cell', 'type': 'Cell'}, None),
        MemberSpec_('cell2CaPools', 'Cell2CaPools', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'cell2CaPools', 'type': 'Cell2CaPools'}, None),
        MemberSpec_('baseCell', 'BaseCell', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'baseCell', 'type': 'BaseCell'}, None),
        MemberSpec_('iafTauCell', 'IafTauCell', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'iafTauCell', 'type': 'IafTauCell'}, None),
        MemberSpec_('iafTauRefCell', 'IafTauRefCell', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'iafTauRefCell', 'type': 'IafTauRefCell'}, None),
        MemberSpec_('iafCell', 'IafCell', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'iafCell', 'type': 'IafCell'}, None),
        MemberSpec_('iafRefCell', 'IafRefCell', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'iafRefCell', 'type': 'IafRefCell'}, None),
        MemberSpec_('izhikevichCell', 'IzhikevichCell', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'izhikevichCell', 'type': 'IzhikevichCell'}, None),
        MemberSpec_('izhikevich2007Cell', 'Izhikevich2007Cell', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'izhikevich2007Cell', 'type': 'Izhikevich2007Cell'}, None),
        MemberSpec_('adExIaFCell', 'AdExIaFCell', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'adExIaFCell', 'type': 'AdExIaFCell'}, None),
        MemberSpec_('fitzHughNagumoCell', 'FitzHughNagumoCell', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'fitzHughNagumoCell', 'type': 'FitzHughNagumoCell'}, None),
        MemberSpec_('fitzHughNagumo1969Cell', 'FitzHughNagumo1969Cell', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'fitzHughNagumo1969Cell', 'type': 'FitzHughNagumo1969Cell'}, None),
        MemberSpec_('pinskyRinzelCA3Cell', 'PinskyRinzelCA3Cell', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'pinskyRinzelCA3Cell', 'type': 'PinskyRinzelCA3Cell'}, None),
        MemberSpec_('pulseGenerator', 'PulseGenerator', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'pulseGenerator', 'type': 'PulseGenerator'}, None),
        MemberSpec_('pulseGeneratorDL', 'PulseGeneratorDL', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'pulseGeneratorDL', 'type': 'PulseGeneratorDL'}, None),
        MemberSpec_('sineGenerator', 'SineGenerator', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'sineGenerator', 'type': 'SineGenerator'}, None),
        MemberSpec_('sineGeneratorDL', 'SineGeneratorDL', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'sineGeneratorDL', 'type': 'SineGeneratorDL'}, None),
        MemberSpec_('rampGenerator', 'RampGenerator', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'rampGenerator', 'type': 'RampGenerator'}, None),
        MemberSpec_('rampGeneratorDL', 'RampGeneratorDL', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'rampGeneratorDL', 'type': 'RampGeneratorDL'}, None),
        MemberSpec_('compoundInput', 'CompoundInput', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'compoundInput', 'type': 'CompoundInput'}, None),
        MemberSpec_('compoundInputDL', 'CompoundInputDL', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'compoundInputDL', 'type': 'CompoundInputDL'}, None),
        MemberSpec_('voltageClamp', 'VoltageClamp', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'voltageClamp', 'type': 'VoltageClamp'}, None),
        MemberSpec_('voltageClampTriple', 'VoltageClampTriple', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'voltageClampTriple', 'type': 'VoltageClampTriple'}, None),
        MemberSpec_('spikeArray', 'SpikeArray', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'spikeArray', 'type': 'SpikeArray'}, None),
        MemberSpec_('timedSynapticInput', 'TimedSynapticInput', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'timedSynapticInput', 'type': 'TimedSynapticInput'}, None),
        MemberSpec_('spikeGenerator', 'SpikeGenerator', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'spikeGenerator', 'type': 'SpikeGenerator'}, None),
        MemberSpec_('spikeGeneratorRandom', 'SpikeGeneratorRandom', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'spikeGeneratorRandom', 'type': 'SpikeGeneratorRandom'}, None),
        MemberSpec_('spikeGeneratorPoisson', 'SpikeGeneratorPoisson', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'spikeGeneratorPoisson', 'type': 'SpikeGeneratorPoisson'}, None),
        MemberSpec_('spikeGeneratorRefPoisson', 'SpikeGeneratorRefPoisson', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'spikeGeneratorRefPoisson', 'type': 'SpikeGeneratorRefPoisson'}, None),
        MemberSpec_('poissonFiringSynapse', 'PoissonFiringSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'poissonFiringSynapse', 'type': 'PoissonFiringSynapse'}, None),
        MemberSpec_('transientPoissonFiringSynapse', 'TransientPoissonFiringSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'transientPoissonFiringSynapse', 'type': 'TransientPoissonFiringSynapse'}, None),
        MemberSpec_('IF_curr_alpha', 'IF_curr_alpha', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'IF_curr_alpha', 'type': 'IF_curr_alpha'}, None),
        MemberSpec_('IF_curr_exp', 'IF_curr_exp', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'IF_curr_exp', 'type': 'IF_curr_exp'}, None),
        MemberSpec_('IF_cond_alpha', 'IF_cond_alpha', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'IF_cond_alpha', 'type': 'IF_cond_alpha'}, None),
        MemberSpec_('IF_cond_exp', 'IF_cond_exp', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'IF_cond_exp', 'type': 'IF_cond_exp'}, None),
        MemberSpec_('EIF_cond_exp_isfa_ista', 'EIF_cond_exp_isfa_ista', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'EIF_cond_exp_isfa_ista', 'type': 'EIF_cond_exp_isfa_ista'}, None),
        MemberSpec_('EIF_cond_alpha_isfa_ista', 'EIF_cond_alpha_isfa_ista', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'EIF_cond_alpha_isfa_ista', 'type': 'EIF_cond_alpha_isfa_ista'}, None),
        MemberSpec_('HH_cond_exp', 'HH_cond_exp', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'HH_cond_exp', 'type': 'HH_cond_exp'}, None),
        MemberSpec_('expCondSynapse', 'ExpCondSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'expCondSynapse', 'type': 'ExpCondSynapse'}, None),
        MemberSpec_('alphaCondSynapse', 'AlphaCondSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alphaCondSynapse', 'type': 'AlphaCondSynapse'}, None),
        MemberSpec_('expCurrSynapse', 'ExpCurrSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'expCurrSynapse', 'type': 'ExpCurrSynapse'}, None),
        MemberSpec_('alphaCurrSynapse', 'AlphaCurrSynapse', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'alphaCurrSynapse', 'type': 'AlphaCurrSynapse'}, None),
        MemberSpec_('SpikeSourcePoisson', 'SpikeSourcePoisson', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'SpikeSourcePoisson', 'type': 'SpikeSourcePoisson'}, None),
        MemberSpec_('network', 'Network', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'network', 'type': 'Network'}, None),
        MemberSpec_('ComponentType', 'ComponentType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'ComponentType', 'type': 'ComponentType'}, None),
    ]
    subclass = None
    superclass = Standalone
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, include=None, extracellularProperties=None, intracellularProperties=None, morphology=None, ionChannel=None, ionChannelHH=None, ionChannelVShift=None, ionChannelKS=None, decayingPoolConcentrationModel=None, fixedFactorConcentrationModel=None, alphaCurrentSynapse=None, alphaSynapse=None, expOneSynapse=None, expTwoSynapse=None, expThreeSynapse=None, blockingPlasticSynapse=None, doubleSynapse=None, gapJunction=None, silentSynapse=None, linearGradedSynapse=None, gradedSynapse=None, biophysicalProperties=None, cell=None, cell2CaPools=None, baseCell=None, iafTauCell=None, iafTauRefCell=None, iafCell=None, iafRefCell=None, izhikevichCell=None, izhikevich2007Cell=None, adExIaFCell=None, fitzHughNagumoCell=None, fitzHughNagumo1969Cell=None, pinskyRinzelCA3Cell=None, pulseGenerator=None, pulseGeneratorDL=None, sineGenerator=None, sineGeneratorDL=None, rampGenerator=None, rampGeneratorDL=None, compoundInput=None, compoundInputDL=None, voltageClamp=None, voltageClampTriple=None, spikeArray=None, timedSynapticInput=None, spikeGenerator=None, spikeGeneratorRandom=None, spikeGeneratorPoisson=None, spikeGeneratorRefPoisson=None, poissonFiringSynapse=None, transientPoissonFiringSynapse=None, IF_curr_alpha=None, IF_curr_exp=None, IF_cond_alpha=None, IF_cond_exp=None, EIF_cond_exp_isfa_ista=None, EIF_cond_alpha_isfa_ista=None, HH_cond_exp=None, expCondSynapse=None, alphaCondSynapse=None, expCurrSynapse=None, alphaCurrSynapse=None, SpikeSourcePoisson=None, network=None, ComponentType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NeuroMLDocument, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        if include is None:
            self.include = []
        else:
            self.include = include
        self.include_nsprefix_ = None
        if extracellularProperties is None:
            self.extracellularProperties = []
        else:
            self.extracellularProperties = extracellularProperties
        self.extracellularProperties_nsprefix_ = None
        if intracellularProperties is None:
            self.intracellularProperties = []
        else:
            self.intracellularProperties = intracellularProperties
        self.intracellularProperties_nsprefix_ = None
        if morphology is None:
            self.morphology = []
        else:
            self.morphology = morphology
        self.morphology_nsprefix_ = None
        if ionChannel is None:
            self.ionChannel = []
        else:
            self.ionChannel = ionChannel
        self.ionChannel_nsprefix_ = None
        if ionChannelHH is None:
            self.ionChannelHH = []
        else:
            self.ionChannelHH = ionChannelHH
        self.ionChannelHH_nsprefix_ = None
        if ionChannelVShift is None:
            self.ionChannelVShift = []
        else:
            self.ionChannelVShift = ionChannelVShift
        self.ionChannelVShift_nsprefix_ = None
        if ionChannelKS is None:
            self.ionChannelKS = []
        else:
            self.ionChannelKS = ionChannelKS
        self.ionChannelKS_nsprefix_ = None
        if decayingPoolConcentrationModel is None:
            self.decayingPoolConcentrationModel = []
        else:
            self.decayingPoolConcentrationModel = decayingPoolConcentrationModel
        self.decayingPoolConcentrationModel_nsprefix_ = None
        if fixedFactorConcentrationModel is None:
            self.fixedFactorConcentrationModel = []
        else:
            self.fixedFactorConcentrationModel = fixedFactorConcentrationModel
        self.fixedFactorConcentrationModel_nsprefix_ = None
        if alphaCurrentSynapse is None:
            self.alphaCurrentSynapse = []
        else:
            self.alphaCurrentSynapse = alphaCurrentSynapse
        self.alphaCurrentSynapse_nsprefix_ = None
        if alphaSynapse is None:
            self.alphaSynapse = []
        else:
            self.alphaSynapse = alphaSynapse
        self.alphaSynapse_nsprefix_ = None
        if expOneSynapse is None:
            self.expOneSynapse = []
        else:
            self.expOneSynapse = expOneSynapse
        self.expOneSynapse_nsprefix_ = None
        if expTwoSynapse is None:
            self.expTwoSynapse = []
        else:
            self.expTwoSynapse = expTwoSynapse
        self.expTwoSynapse_nsprefix_ = None
        if expThreeSynapse is None:
            self.expThreeSynapse = []
        else:
            self.expThreeSynapse = expThreeSynapse
        self.expThreeSynapse_nsprefix_ = None
        if blockingPlasticSynapse is None:
            self.blockingPlasticSynapse = []
        else:
            self.blockingPlasticSynapse = blockingPlasticSynapse
        self.blockingPlasticSynapse_nsprefix_ = None
        if doubleSynapse is None:
            self.doubleSynapse = []
        else:
            self.doubleSynapse = doubleSynapse
        self.doubleSynapse_nsprefix_ = None
        if gapJunction is None:
            self.gapJunction = []
        else:
            self.gapJunction = gapJunction
        self.gapJunction_nsprefix_ = None
        if silentSynapse is None:
            self.silentSynapse = []
        else:
            self.silentSynapse = silentSynapse
        self.silentSynapse_nsprefix_ = None
        if linearGradedSynapse is None:
            self.linearGradedSynapse = []
        else:
            self.linearGradedSynapse = linearGradedSynapse
        self.linearGradedSynapse_nsprefix_ = None
        if gradedSynapse is None:
            self.gradedSynapse = []
        else:
            self.gradedSynapse = gradedSynapse
        self.gradedSynapse_nsprefix_ = None
        if biophysicalProperties is None:
            self.biophysicalProperties = []
        else:
            self.biophysicalProperties = biophysicalProperties
        self.biophysicalProperties_nsprefix_ = None
        if cell is None:
            self.cell = []
        else:
            self.cell = cell
        self.cell_nsprefix_ = None
        if cell2CaPools is None:
            self.cell2CaPools = []
        else:
            self.cell2CaPools = cell2CaPools
        self.cell2CaPools_nsprefix_ = None
        if baseCell is None:
            self.baseCell = []
        else:
            self.baseCell = baseCell
        self.baseCell_nsprefix_ = None
        if iafTauCell is None:
            self.iafTauCell = []
        else:
            self.iafTauCell = iafTauCell
        self.iafTauCell_nsprefix_ = None
        if iafTauRefCell is None:
            self.iafTauRefCell = []
        else:
            self.iafTauRefCell = iafTauRefCell
        self.iafTauRefCell_nsprefix_ = None
        if iafCell is None:
            self.iafCell = []
        else:
            self.iafCell = iafCell
        self.iafCell_nsprefix_ = None
        if iafRefCell is None:
            self.iafRefCell = []
        else:
            self.iafRefCell = iafRefCell
        self.iafRefCell_nsprefix_ = None
        if izhikevichCell is None:
            self.izhikevichCell = []
        else:
            self.izhikevichCell = izhikevichCell
        self.izhikevichCell_nsprefix_ = None
        if izhikevich2007Cell is None:
            self.izhikevich2007Cell = []
        else:
            self.izhikevich2007Cell = izhikevich2007Cell
        self.izhikevich2007Cell_nsprefix_ = None
        if adExIaFCell is None:
            self.adExIaFCell = []
        else:
            self.adExIaFCell = adExIaFCell
        self.adExIaFCell_nsprefix_ = None
        if fitzHughNagumoCell is None:
            self.fitzHughNagumoCell = []
        else:
            self.fitzHughNagumoCell = fitzHughNagumoCell
        self.fitzHughNagumoCell_nsprefix_ = None
        if fitzHughNagumo1969Cell is None:
            self.fitzHughNagumo1969Cell = []
        else:
            self.fitzHughNagumo1969Cell = fitzHughNagumo1969Cell
        self.fitzHughNagumo1969Cell_nsprefix_ = None
        if pinskyRinzelCA3Cell is None:
            self.pinskyRinzelCA3Cell = []
        else:
            self.pinskyRinzelCA3Cell = pinskyRinzelCA3Cell
        self.pinskyRinzelCA3Cell_nsprefix_ = None
        if pulseGenerator is None:
            self.pulseGenerator = []
        else:
            self.pulseGenerator = pulseGenerator
        self.pulseGenerator_nsprefix_ = None
        if pulseGeneratorDL is None:
            self.pulseGeneratorDL = []
        else:
            self.pulseGeneratorDL = pulseGeneratorDL
        self.pulseGeneratorDL_nsprefix_ = None
        if sineGenerator is None:
            self.sineGenerator = []
        else:
            self.sineGenerator = sineGenerator
        self.sineGenerator_nsprefix_ = None
        if sineGeneratorDL is None:
            self.sineGeneratorDL = []
        else:
            self.sineGeneratorDL = sineGeneratorDL
        self.sineGeneratorDL_nsprefix_ = None
        if rampGenerator is None:
            self.rampGenerator = []
        else:
            self.rampGenerator = rampGenerator
        self.rampGenerator_nsprefix_ = None
        if rampGeneratorDL is None:
            self.rampGeneratorDL = []
        else:
            self.rampGeneratorDL = rampGeneratorDL
        self.rampGeneratorDL_nsprefix_ = None
        if compoundInput is None:
            self.compoundInput = []
        else:
            self.compoundInput = compoundInput
        self.compoundInput_nsprefix_ = None
        if compoundInputDL is None:
            self.compoundInputDL = []
        else:
            self.compoundInputDL = compoundInputDL
        self.compoundInputDL_nsprefix_ = None
        if voltageClamp is None:
            self.voltageClamp = []
        else:
            self.voltageClamp = voltageClamp
        self.voltageClamp_nsprefix_ = None
        if voltageClampTriple is None:
            self.voltageClampTriple = []
        else:
            self.voltageClampTriple = voltageClampTriple
        self.voltageClampTriple_nsprefix_ = None
        if spikeArray is None:
            self.spikeArray = []
        else:
            self.spikeArray = spikeArray
        self.spikeArray_nsprefix_ = None
        if timedSynapticInput is None:
            self.timedSynapticInput = []
        else:
            self.timedSynapticInput = timedSynapticInput
        self.timedSynapticInput_nsprefix_ = None
        if spikeGenerator is None:
            self.spikeGenerator = []
        else:
            self.spikeGenerator = spikeGenerator
        self.spikeGenerator_nsprefix_ = None
        if spikeGeneratorRandom is None:
            self.spikeGeneratorRandom = []
        else:
            self.spikeGeneratorRandom = spikeGeneratorRandom
        self.spikeGeneratorRandom_nsprefix_ = None
        if spikeGeneratorPoisson is None:
            self.spikeGeneratorPoisson = []
        else:
            self.spikeGeneratorPoisson = spikeGeneratorPoisson
        self.spikeGeneratorPoisson_nsprefix_ = None
        if spikeGeneratorRefPoisson is None:
            self.spikeGeneratorRefPoisson = []
        else:
            self.spikeGeneratorRefPoisson = spikeGeneratorRefPoisson
        self.spikeGeneratorRefPoisson_nsprefix_ = None
        if poissonFiringSynapse is None:
            self.poissonFiringSynapse = []
        else:
            self.poissonFiringSynapse = poissonFiringSynapse
        self.poissonFiringSynapse_nsprefix_ = None
        if transientPoissonFiringSynapse is None:
            self.transientPoissonFiringSynapse = []
        else:
            self.transientPoissonFiringSynapse = transientPoissonFiringSynapse
        self.transientPoissonFiringSynapse_nsprefix_ = None
        if IF_curr_alpha is None:
            self.IF_curr_alpha = []
        else:
            self.IF_curr_alpha = IF_curr_alpha
        self.IF_curr_alpha_nsprefix_ = None
        if IF_curr_exp is None:
            self.IF_curr_exp = []
        else:
            self.IF_curr_exp = IF_curr_exp
        self.IF_curr_exp_nsprefix_ = None
        if IF_cond_alpha is None:
            self.IF_cond_alpha = []
        else:
            self.IF_cond_alpha = IF_cond_alpha
        self.IF_cond_alpha_nsprefix_ = None
        if IF_cond_exp is None:
            self.IF_cond_exp = []
        else:
            self.IF_cond_exp = IF_cond_exp
        self.IF_cond_exp_nsprefix_ = None
        if EIF_cond_exp_isfa_ista is None:
            self.EIF_cond_exp_isfa_ista = []
        else:
            self.EIF_cond_exp_isfa_ista = EIF_cond_exp_isfa_ista
        self.EIF_cond_exp_isfa_ista_nsprefix_ = None
        if EIF_cond_alpha_isfa_ista is None:
            self.EIF_cond_alpha_isfa_ista = []
        else:
            self.EIF_cond_alpha_isfa_ista = EIF_cond_alpha_isfa_ista
        self.EIF_cond_alpha_isfa_ista_nsprefix_ = None
        if HH_cond_exp is None:
            self.HH_cond_exp = []
        else:
            self.HH_cond_exp = HH_cond_exp
        self.HH_cond_exp_nsprefix_ = None
        if expCondSynapse is None:
            self.expCondSynapse = []
        else:
            self.expCondSynapse = expCondSynapse
        self.expCondSynapse_nsprefix_ = None
        if alphaCondSynapse is None:
            self.alphaCondSynapse = []
        else:
            self.alphaCondSynapse = alphaCondSynapse
        self.alphaCondSynapse_nsprefix_ = None
        if expCurrSynapse is None:
            self.expCurrSynapse = []
        else:
            self.expCurrSynapse = expCurrSynapse
        self.expCurrSynapse_nsprefix_ = None
        if alphaCurrSynapse is None:
            self.alphaCurrSynapse = []
        else:
            self.alphaCurrSynapse = alphaCurrSynapse
        self.alphaCurrSynapse_nsprefix_ = None
        if SpikeSourcePoisson is None:
            self.SpikeSourcePoisson = []
        else:
            self.SpikeSourcePoisson = SpikeSourcePoisson
        self.SpikeSourcePoisson_nsprefix_ = None
        if network is None:
            self.network = []
        else:
            self.network = network
        self.network_nsprefix_ = None
        if ComponentType is None:
            self.ComponentType = []
        else:
            self.ComponentType = ComponentType
        self.ComponentType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeuroMLDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuroMLDocument.subclass:
            return NeuroMLDocument.subclass(*args_, **kwargs_)
        else:
            return NeuroMLDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.include or
            self.extracellularProperties or
            self.intracellularProperties or
            self.morphology or
            self.ionChannel or
            self.ionChannelHH or
            self.ionChannelVShift or
            self.ionChannelKS or
            self.decayingPoolConcentrationModel or
            self.fixedFactorConcentrationModel or
            self.alphaCurrentSynapse or
            self.alphaSynapse or
            self.expOneSynapse or
            self.expTwoSynapse or
            self.expThreeSynapse or
            self.blockingPlasticSynapse or
            self.doubleSynapse or
            self.gapJunction or
            self.silentSynapse or
            self.linearGradedSynapse or
            self.gradedSynapse or
            self.biophysicalProperties or
            self.cell or
            self.cell2CaPools or
            self.baseCell or
            self.iafTauCell or
            self.iafTauRefCell or
            self.iafCell or
            self.iafRefCell or
            self.izhikevichCell or
            self.izhikevich2007Cell or
            self.adExIaFCell or
            self.fitzHughNagumoCell or
            self.fitzHughNagumo1969Cell or
            self.pinskyRinzelCA3Cell or
            self.pulseGenerator or
            self.pulseGeneratorDL or
            self.sineGenerator or
            self.sineGeneratorDL or
            self.rampGenerator or
            self.rampGeneratorDL or
            self.compoundInput or
            self.compoundInputDL or
            self.voltageClamp or
            self.voltageClampTriple or
            self.spikeArray or
            self.timedSynapticInput or
            self.spikeGenerator or
            self.spikeGeneratorRandom or
            self.spikeGeneratorPoisson or
            self.spikeGeneratorRefPoisson or
            self.poissonFiringSynapse or
            self.transientPoissonFiringSynapse or
            self.IF_curr_alpha or
            self.IF_curr_exp or
            self.IF_cond_alpha or
            self.IF_cond_exp or
            self.EIF_cond_exp_isfa_ista or
            self.EIF_cond_alpha_isfa_ista or
            self.HH_cond_exp or
            self.expCondSynapse or
            self.alphaCondSynapse or
            self.expCurrSynapse or
            self.alphaCurrSynapse or
            self.SpikeSourcePoisson or
            self.network or
            self.ComponentType or
            super(NeuroMLDocument, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NeuroMLDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeuroMLDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NeuroMLDocument')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NeuroMLDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NeuroMLDocument'):
        super(NeuroMLDocument, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NeuroMLDocument')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NeuroMLDocument', fromsubclass_=False, pretty_print=True):
        super(NeuroMLDocument, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for include_ in self.include:
            namespaceprefix_ = self.include_nsprefix_ + ':' if (UseCapturedNS_ and self.include_nsprefix_) else ''
            include_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='include', pretty_print=pretty_print)
        for extracellularProperties_ in self.extracellularProperties:
            namespaceprefix_ = self.extracellularProperties_nsprefix_ + ':' if (UseCapturedNS_ and self.extracellularProperties_nsprefix_) else ''
            extracellularProperties_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extracellularProperties', pretty_print=pretty_print)
        for intracellularProperties_ in self.intracellularProperties:
            namespaceprefix_ = self.intracellularProperties_nsprefix_ + ':' if (UseCapturedNS_ and self.intracellularProperties_nsprefix_) else ''
            intracellularProperties_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='intracellularProperties', pretty_print=pretty_print)
        for morphology_ in self.morphology:
            namespaceprefix_ = self.morphology_nsprefix_ + ':' if (UseCapturedNS_ and self.morphology_nsprefix_) else ''
            morphology_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='morphology', pretty_print=pretty_print)
        for ionChannel_ in self.ionChannel:
            namespaceprefix_ = self.ionChannel_nsprefix_ + ':' if (UseCapturedNS_ and self.ionChannel_nsprefix_) else ''
            ionChannel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ionChannel', pretty_print=pretty_print)
        for ionChannelHH_ in self.ionChannelHH:
            namespaceprefix_ = self.ionChannelHH_nsprefix_ + ':' if (UseCapturedNS_ and self.ionChannelHH_nsprefix_) else ''
            ionChannelHH_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ionChannelHH', pretty_print=pretty_print)
        for ionChannelVShift_ in self.ionChannelVShift:
            namespaceprefix_ = self.ionChannelVShift_nsprefix_ + ':' if (UseCapturedNS_ and self.ionChannelVShift_nsprefix_) else ''
            ionChannelVShift_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ionChannelVShift', pretty_print=pretty_print)
        for ionChannelKS_ in self.ionChannelKS:
            namespaceprefix_ = self.ionChannelKS_nsprefix_ + ':' if (UseCapturedNS_ and self.ionChannelKS_nsprefix_) else ''
            ionChannelKS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ionChannelKS', pretty_print=pretty_print)
        for decayingPoolConcentrationModel_ in self.decayingPoolConcentrationModel:
            namespaceprefix_ = self.decayingPoolConcentrationModel_nsprefix_ + ':' if (UseCapturedNS_ and self.decayingPoolConcentrationModel_nsprefix_) else ''
            decayingPoolConcentrationModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='decayingPoolConcentrationModel', pretty_print=pretty_print)
        for fixedFactorConcentrationModel_ in self.fixedFactorConcentrationModel:
            namespaceprefix_ = self.fixedFactorConcentrationModel_nsprefix_ + ':' if (UseCapturedNS_ and self.fixedFactorConcentrationModel_nsprefix_) else ''
            fixedFactorConcentrationModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fixedFactorConcentrationModel', pretty_print=pretty_print)
        for alphaCurrentSynapse_ in self.alphaCurrentSynapse:
            namespaceprefix_ = self.alphaCurrentSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.alphaCurrentSynapse_nsprefix_) else ''
            alphaCurrentSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alphaCurrentSynapse', pretty_print=pretty_print)
        for alphaSynapse_ in self.alphaSynapse:
            namespaceprefix_ = self.alphaSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.alphaSynapse_nsprefix_) else ''
            alphaSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alphaSynapse', pretty_print=pretty_print)
        for expOneSynapse_ in self.expOneSynapse:
            namespaceprefix_ = self.expOneSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.expOneSynapse_nsprefix_) else ''
            expOneSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='expOneSynapse', pretty_print=pretty_print)
        for expTwoSynapse_ in self.expTwoSynapse:
            namespaceprefix_ = self.expTwoSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.expTwoSynapse_nsprefix_) else ''
            expTwoSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='expTwoSynapse', pretty_print=pretty_print)
        for expThreeSynapse_ in self.expThreeSynapse:
            namespaceprefix_ = self.expThreeSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.expThreeSynapse_nsprefix_) else ''
            expThreeSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='expThreeSynapse', pretty_print=pretty_print)
        for blockingPlasticSynapse_ in self.blockingPlasticSynapse:
            namespaceprefix_ = self.blockingPlasticSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.blockingPlasticSynapse_nsprefix_) else ''
            blockingPlasticSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='blockingPlasticSynapse', pretty_print=pretty_print)
        for doubleSynapse_ in self.doubleSynapse:
            namespaceprefix_ = self.doubleSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.doubleSynapse_nsprefix_) else ''
            doubleSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='doubleSynapse', pretty_print=pretty_print)
        for gapJunction_ in self.gapJunction:
            namespaceprefix_ = self.gapJunction_nsprefix_ + ':' if (UseCapturedNS_ and self.gapJunction_nsprefix_) else ''
            gapJunction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gapJunction', pretty_print=pretty_print)
        for silentSynapse_ in self.silentSynapse:
            namespaceprefix_ = self.silentSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.silentSynapse_nsprefix_) else ''
            silentSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='silentSynapse', pretty_print=pretty_print)
        for linearGradedSynapse_ in self.linearGradedSynapse:
            namespaceprefix_ = self.linearGradedSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.linearGradedSynapse_nsprefix_) else ''
            linearGradedSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linearGradedSynapse', pretty_print=pretty_print)
        for gradedSynapse_ in self.gradedSynapse:
            namespaceprefix_ = self.gradedSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.gradedSynapse_nsprefix_) else ''
            gradedSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gradedSynapse', pretty_print=pretty_print)
        for biophysicalProperties_ in self.biophysicalProperties:
            namespaceprefix_ = self.biophysicalProperties_nsprefix_ + ':' if (UseCapturedNS_ and self.biophysicalProperties_nsprefix_) else ''
            biophysicalProperties_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='biophysicalProperties', pretty_print=pretty_print)
        for cell_ in self.cell:
            namespaceprefix_ = self.cell_nsprefix_ + ':' if (UseCapturedNS_ and self.cell_nsprefix_) else ''
            cell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cell', pretty_print=pretty_print)
        for cell2CaPools_ in self.cell2CaPools:
            namespaceprefix_ = self.cell2CaPools_nsprefix_ + ':' if (UseCapturedNS_ and self.cell2CaPools_nsprefix_) else ''
            cell2CaPools_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cell2CaPools', pretty_print=pretty_print)
        for baseCell_ in self.baseCell:
            namespaceprefix_ = self.baseCell_nsprefix_ + ':' if (UseCapturedNS_ and self.baseCell_nsprefix_) else ''
            baseCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='baseCell', pretty_print=pretty_print)
        for iafTauCell_ in self.iafTauCell:
            namespaceprefix_ = self.iafTauCell_nsprefix_ + ':' if (UseCapturedNS_ and self.iafTauCell_nsprefix_) else ''
            iafTauCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='iafTauCell', pretty_print=pretty_print)
        for iafTauRefCell_ in self.iafTauRefCell:
            namespaceprefix_ = self.iafTauRefCell_nsprefix_ + ':' if (UseCapturedNS_ and self.iafTauRefCell_nsprefix_) else ''
            iafTauRefCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='iafTauRefCell', pretty_print=pretty_print)
        for iafCell_ in self.iafCell:
            namespaceprefix_ = self.iafCell_nsprefix_ + ':' if (UseCapturedNS_ and self.iafCell_nsprefix_) else ''
            iafCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='iafCell', pretty_print=pretty_print)
        for iafRefCell_ in self.iafRefCell:
            namespaceprefix_ = self.iafRefCell_nsprefix_ + ':' if (UseCapturedNS_ and self.iafRefCell_nsprefix_) else ''
            iafRefCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='iafRefCell', pretty_print=pretty_print)
        for izhikevichCell_ in self.izhikevichCell:
            namespaceprefix_ = self.izhikevichCell_nsprefix_ + ':' if (UseCapturedNS_ and self.izhikevichCell_nsprefix_) else ''
            izhikevichCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='izhikevichCell', pretty_print=pretty_print)
        for izhikevich2007Cell_ in self.izhikevich2007Cell:
            namespaceprefix_ = self.izhikevich2007Cell_nsprefix_ + ':' if (UseCapturedNS_ and self.izhikevich2007Cell_nsprefix_) else ''
            izhikevich2007Cell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='izhikevich2007Cell', pretty_print=pretty_print)
        for adExIaFCell_ in self.adExIaFCell:
            namespaceprefix_ = self.adExIaFCell_nsprefix_ + ':' if (UseCapturedNS_ and self.adExIaFCell_nsprefix_) else ''
            adExIaFCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='adExIaFCell', pretty_print=pretty_print)
        for fitzHughNagumoCell_ in self.fitzHughNagumoCell:
            namespaceprefix_ = self.fitzHughNagumoCell_nsprefix_ + ':' if (UseCapturedNS_ and self.fitzHughNagumoCell_nsprefix_) else ''
            fitzHughNagumoCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fitzHughNagumoCell', pretty_print=pretty_print)
        for fitzHughNagumo1969Cell_ in self.fitzHughNagumo1969Cell:
            namespaceprefix_ = self.fitzHughNagumo1969Cell_nsprefix_ + ':' if (UseCapturedNS_ and self.fitzHughNagumo1969Cell_nsprefix_) else ''
            fitzHughNagumo1969Cell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fitzHughNagumo1969Cell', pretty_print=pretty_print)
        for pinskyRinzelCA3Cell_ in self.pinskyRinzelCA3Cell:
            namespaceprefix_ = self.pinskyRinzelCA3Cell_nsprefix_ + ':' if (UseCapturedNS_ and self.pinskyRinzelCA3Cell_nsprefix_) else ''
            pinskyRinzelCA3Cell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pinskyRinzelCA3Cell', pretty_print=pretty_print)
        for pulseGenerator_ in self.pulseGenerator:
            namespaceprefix_ = self.pulseGenerator_nsprefix_ + ':' if (UseCapturedNS_ and self.pulseGenerator_nsprefix_) else ''
            pulseGenerator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pulseGenerator', pretty_print=pretty_print)
        for pulseGeneratorDL_ in self.pulseGeneratorDL:
            namespaceprefix_ = self.pulseGeneratorDL_nsprefix_ + ':' if (UseCapturedNS_ and self.pulseGeneratorDL_nsprefix_) else ''
            pulseGeneratorDL_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pulseGeneratorDL', pretty_print=pretty_print)
        for sineGenerator_ in self.sineGenerator:
            namespaceprefix_ = self.sineGenerator_nsprefix_ + ':' if (UseCapturedNS_ and self.sineGenerator_nsprefix_) else ''
            sineGenerator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sineGenerator', pretty_print=pretty_print)
        for sineGeneratorDL_ in self.sineGeneratorDL:
            namespaceprefix_ = self.sineGeneratorDL_nsprefix_ + ':' if (UseCapturedNS_ and self.sineGeneratorDL_nsprefix_) else ''
            sineGeneratorDL_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sineGeneratorDL', pretty_print=pretty_print)
        for rampGenerator_ in self.rampGenerator:
            namespaceprefix_ = self.rampGenerator_nsprefix_ + ':' if (UseCapturedNS_ and self.rampGenerator_nsprefix_) else ''
            rampGenerator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rampGenerator', pretty_print=pretty_print)
        for rampGeneratorDL_ in self.rampGeneratorDL:
            namespaceprefix_ = self.rampGeneratorDL_nsprefix_ + ':' if (UseCapturedNS_ and self.rampGeneratorDL_nsprefix_) else ''
            rampGeneratorDL_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rampGeneratorDL', pretty_print=pretty_print)
        for compoundInput_ in self.compoundInput:
            namespaceprefix_ = self.compoundInput_nsprefix_ + ':' if (UseCapturedNS_ and self.compoundInput_nsprefix_) else ''
            compoundInput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='compoundInput', pretty_print=pretty_print)
        for compoundInputDL_ in self.compoundInputDL:
            namespaceprefix_ = self.compoundInputDL_nsprefix_ + ':' if (UseCapturedNS_ and self.compoundInputDL_nsprefix_) else ''
            compoundInputDL_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='compoundInputDL', pretty_print=pretty_print)
        for voltageClamp_ in self.voltageClamp:
            namespaceprefix_ = self.voltageClamp_nsprefix_ + ':' if (UseCapturedNS_ and self.voltageClamp_nsprefix_) else ''
            voltageClamp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='voltageClamp', pretty_print=pretty_print)
        for voltageClampTriple_ in self.voltageClampTriple:
            namespaceprefix_ = self.voltageClampTriple_nsprefix_ + ':' if (UseCapturedNS_ and self.voltageClampTriple_nsprefix_) else ''
            voltageClampTriple_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='voltageClampTriple', pretty_print=pretty_print)
        for spikeArray_ in self.spikeArray:
            namespaceprefix_ = self.spikeArray_nsprefix_ + ':' if (UseCapturedNS_ and self.spikeArray_nsprefix_) else ''
            spikeArray_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spikeArray', pretty_print=pretty_print)
        for timedSynapticInput_ in self.timedSynapticInput:
            namespaceprefix_ = self.timedSynapticInput_nsprefix_ + ':' if (UseCapturedNS_ and self.timedSynapticInput_nsprefix_) else ''
            timedSynapticInput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timedSynapticInput', pretty_print=pretty_print)
        for spikeGenerator_ in self.spikeGenerator:
            namespaceprefix_ = self.spikeGenerator_nsprefix_ + ':' if (UseCapturedNS_ and self.spikeGenerator_nsprefix_) else ''
            spikeGenerator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spikeGenerator', pretty_print=pretty_print)
        for spikeGeneratorRandom_ in self.spikeGeneratorRandom:
            namespaceprefix_ = self.spikeGeneratorRandom_nsprefix_ + ':' if (UseCapturedNS_ and self.spikeGeneratorRandom_nsprefix_) else ''
            spikeGeneratorRandom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spikeGeneratorRandom', pretty_print=pretty_print)
        for spikeGeneratorPoisson_ in self.spikeGeneratorPoisson:
            namespaceprefix_ = self.spikeGeneratorPoisson_nsprefix_ + ':' if (UseCapturedNS_ and self.spikeGeneratorPoisson_nsprefix_) else ''
            spikeGeneratorPoisson_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spikeGeneratorPoisson', pretty_print=pretty_print)
        for spikeGeneratorRefPoisson_ in self.spikeGeneratorRefPoisson:
            namespaceprefix_ = self.spikeGeneratorRefPoisson_nsprefix_ + ':' if (UseCapturedNS_ and self.spikeGeneratorRefPoisson_nsprefix_) else ''
            spikeGeneratorRefPoisson_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='spikeGeneratorRefPoisson', pretty_print=pretty_print)
        for poissonFiringSynapse_ in self.poissonFiringSynapse:
            namespaceprefix_ = self.poissonFiringSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.poissonFiringSynapse_nsprefix_) else ''
            poissonFiringSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='poissonFiringSynapse', pretty_print=pretty_print)
        for transientPoissonFiringSynapse_ in self.transientPoissonFiringSynapse:
            namespaceprefix_ = self.transientPoissonFiringSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.transientPoissonFiringSynapse_nsprefix_) else ''
            transientPoissonFiringSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='transientPoissonFiringSynapse', pretty_print=pretty_print)
        for IF_curr_alpha_ in self.IF_curr_alpha:
            namespaceprefix_ = self.IF_curr_alpha_nsprefix_ + ':' if (UseCapturedNS_ and self.IF_curr_alpha_nsprefix_) else ''
            IF_curr_alpha_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IF_curr_alpha', pretty_print=pretty_print)
        for IF_curr_exp_ in self.IF_curr_exp:
            namespaceprefix_ = self.IF_curr_exp_nsprefix_ + ':' if (UseCapturedNS_ and self.IF_curr_exp_nsprefix_) else ''
            IF_curr_exp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IF_curr_exp', pretty_print=pretty_print)
        for IF_cond_alpha_ in self.IF_cond_alpha:
            namespaceprefix_ = self.IF_cond_alpha_nsprefix_ + ':' if (UseCapturedNS_ and self.IF_cond_alpha_nsprefix_) else ''
            IF_cond_alpha_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IF_cond_alpha', pretty_print=pretty_print)
        for IF_cond_exp_ in self.IF_cond_exp:
            namespaceprefix_ = self.IF_cond_exp_nsprefix_ + ':' if (UseCapturedNS_ and self.IF_cond_exp_nsprefix_) else ''
            IF_cond_exp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IF_cond_exp', pretty_print=pretty_print)
        for EIF_cond_exp_isfa_ista_ in self.EIF_cond_exp_isfa_ista:
            namespaceprefix_ = self.EIF_cond_exp_isfa_ista_nsprefix_ + ':' if (UseCapturedNS_ and self.EIF_cond_exp_isfa_ista_nsprefix_) else ''
            EIF_cond_exp_isfa_ista_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EIF_cond_exp_isfa_ista', pretty_print=pretty_print)
        for EIF_cond_alpha_isfa_ista_ in self.EIF_cond_alpha_isfa_ista:
            namespaceprefix_ = self.EIF_cond_alpha_isfa_ista_nsprefix_ + ':' if (UseCapturedNS_ and self.EIF_cond_alpha_isfa_ista_nsprefix_) else ''
            EIF_cond_alpha_isfa_ista_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EIF_cond_alpha_isfa_ista', pretty_print=pretty_print)
        for HH_cond_exp_ in self.HH_cond_exp:
            namespaceprefix_ = self.HH_cond_exp_nsprefix_ + ':' if (UseCapturedNS_ and self.HH_cond_exp_nsprefix_) else ''
            HH_cond_exp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HH_cond_exp', pretty_print=pretty_print)
        for expCondSynapse_ in self.expCondSynapse:
            namespaceprefix_ = self.expCondSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.expCondSynapse_nsprefix_) else ''
            expCondSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='expCondSynapse', pretty_print=pretty_print)
        for alphaCondSynapse_ in self.alphaCondSynapse:
            namespaceprefix_ = self.alphaCondSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.alphaCondSynapse_nsprefix_) else ''
            alphaCondSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alphaCondSynapse', pretty_print=pretty_print)
        for expCurrSynapse_ in self.expCurrSynapse:
            namespaceprefix_ = self.expCurrSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.expCurrSynapse_nsprefix_) else ''
            expCurrSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='expCurrSynapse', pretty_print=pretty_print)
        for alphaCurrSynapse_ in self.alphaCurrSynapse:
            namespaceprefix_ = self.alphaCurrSynapse_nsprefix_ + ':' if (UseCapturedNS_ and self.alphaCurrSynapse_nsprefix_) else ''
            alphaCurrSynapse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alphaCurrSynapse', pretty_print=pretty_print)
        for SpikeSourcePoisson_ in self.SpikeSourcePoisson:
            namespaceprefix_ = self.SpikeSourcePoisson_nsprefix_ + ':' if (UseCapturedNS_ and self.SpikeSourcePoisson_nsprefix_) else ''
            SpikeSourcePoisson_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SpikeSourcePoisson', pretty_print=pretty_print)
        for network_ in self.network:
            namespaceprefix_ = self.network_nsprefix_ + ':' if (UseCapturedNS_ and self.network_nsprefix_) else ''
            network_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='network', pretty_print=pretty_print)
        for ComponentType_ in self.ComponentType:
            namespaceprefix_ = self.ComponentType_nsprefix_ + ':' if (UseCapturedNS_ and self.ComponentType_nsprefix_) else ''
            ComponentType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ComponentType', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NeuroMLDocument, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'include':
            obj_ = IncludeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.include.append(obj_)
            obj_.original_tagname_ = 'include'
        elif nodeName_ == 'extracellularProperties':
            obj_ = ExtracellularProperties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extracellularProperties.append(obj_)
            obj_.original_tagname_ = 'extracellularProperties'
        elif nodeName_ == 'intracellularProperties':
            class_obj_ = self.get_class_obj_(child_, IntracellularProperties)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intracellularProperties.append(obj_)
            obj_.original_tagname_ = 'intracellularProperties'
        elif nodeName_ == 'morphology':
            obj_ = Morphology.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.morphology.append(obj_)
            obj_.original_tagname_ = 'morphology'
        elif nodeName_ == 'ionChannel':
            class_obj_ = self.get_class_obj_(child_, IonChannel)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ionChannel.append(obj_)
            obj_.original_tagname_ = 'ionChannel'
        elif nodeName_ == 'ionChannelHH':
            obj_ = IonChannelHH.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ionChannelHH.append(obj_)
            obj_.original_tagname_ = 'ionChannelHH'
        elif nodeName_ == 'ionChannelVShift':
            obj_ = IonChannelVShift.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ionChannelVShift.append(obj_)
            obj_.original_tagname_ = 'ionChannelVShift'
        elif nodeName_ == 'ionChannelKS':
            obj_ = IonChannelKS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ionChannelKS.append(obj_)
            obj_.original_tagname_ = 'ionChannelKS'
        elif nodeName_ == 'decayingPoolConcentrationModel':
            class_obj_ = self.get_class_obj_(child_, DecayingPoolConcentrationModel)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.decayingPoolConcentrationModel.append(obj_)
            obj_.original_tagname_ = 'decayingPoolConcentrationModel'
        elif nodeName_ == 'fixedFactorConcentrationModel':
            obj_ = FixedFactorConcentrationModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fixedFactorConcentrationModel.append(obj_)
            obj_.original_tagname_ = 'fixedFactorConcentrationModel'
        elif nodeName_ == 'alphaCurrentSynapse':
            obj_ = AlphaCurrentSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alphaCurrentSynapse.append(obj_)
            obj_.original_tagname_ = 'alphaCurrentSynapse'
        elif nodeName_ == 'alphaSynapse':
            obj_ = AlphaSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alphaSynapse.append(obj_)
            obj_.original_tagname_ = 'alphaSynapse'
        elif nodeName_ == 'expOneSynapse':
            obj_ = ExpOneSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expOneSynapse.append(obj_)
            obj_.original_tagname_ = 'expOneSynapse'
        elif nodeName_ == 'expTwoSynapse':
            class_obj_ = self.get_class_obj_(child_, ExpTwoSynapse)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expTwoSynapse.append(obj_)
            obj_.original_tagname_ = 'expTwoSynapse'
        elif nodeName_ == 'expThreeSynapse':
            obj_ = ExpThreeSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expThreeSynapse.append(obj_)
            obj_.original_tagname_ = 'expThreeSynapse'
        elif nodeName_ == 'blockingPlasticSynapse':
            obj_ = BlockingPlasticSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.blockingPlasticSynapse.append(obj_)
            obj_.original_tagname_ = 'blockingPlasticSynapse'
        elif nodeName_ == 'doubleSynapse':
            obj_ = DoubleSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.doubleSynapse.append(obj_)
            obj_.original_tagname_ = 'doubleSynapse'
        elif nodeName_ == 'gapJunction':
            obj_ = GapJunction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gapJunction.append(obj_)
            obj_.original_tagname_ = 'gapJunction'
        elif nodeName_ == 'silentSynapse':
            obj_ = SilentSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.silentSynapse.append(obj_)
            obj_.original_tagname_ = 'silentSynapse'
        elif nodeName_ == 'linearGradedSynapse':
            obj_ = LinearGradedSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.linearGradedSynapse.append(obj_)
            obj_.original_tagname_ = 'linearGradedSynapse'
        elif nodeName_ == 'gradedSynapse':
            obj_ = GradedSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gradedSynapse.append(obj_)
            obj_.original_tagname_ = 'gradedSynapse'
        elif nodeName_ == 'biophysicalProperties':
            obj_ = BiophysicalProperties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.biophysicalProperties.append(obj_)
            obj_.original_tagname_ = 'biophysicalProperties'
        elif nodeName_ == 'cell':
            class_obj_ = self.get_class_obj_(child_, Cell)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cell.append(obj_)
            obj_.original_tagname_ = 'cell'
        elif nodeName_ == 'cell2CaPools':
            obj_ = Cell2CaPools.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cell2CaPools.append(obj_)
            obj_.original_tagname_ = 'cell2CaPools'
        elif nodeName_ == 'baseCell':
            class_obj_ = self.get_class_obj_(child_, BaseCell)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.baseCell.append(obj_)
            obj_.original_tagname_ = 'baseCell'
        elif nodeName_ == 'iafTauCell':
            class_obj_ = self.get_class_obj_(child_, IafTauCell)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iafTauCell.append(obj_)
            obj_.original_tagname_ = 'iafTauCell'
        elif nodeName_ == 'iafTauRefCell':
            obj_ = IafTauRefCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iafTauRefCell.append(obj_)
            obj_.original_tagname_ = 'iafTauRefCell'
        elif nodeName_ == 'iafCell':
            class_obj_ = self.get_class_obj_(child_, IafCell)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iafCell.append(obj_)
            obj_.original_tagname_ = 'iafCell'
        elif nodeName_ == 'iafRefCell':
            obj_ = IafRefCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.iafRefCell.append(obj_)
            obj_.original_tagname_ = 'iafRefCell'
        elif nodeName_ == 'izhikevichCell':
            obj_ = IzhikevichCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.izhikevichCell.append(obj_)
            obj_.original_tagname_ = 'izhikevichCell'
        elif nodeName_ == 'izhikevich2007Cell':
            obj_ = Izhikevich2007Cell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.izhikevich2007Cell.append(obj_)
            obj_.original_tagname_ = 'izhikevich2007Cell'
        elif nodeName_ == 'adExIaFCell':
            obj_ = AdExIaFCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.adExIaFCell.append(obj_)
            obj_.original_tagname_ = 'adExIaFCell'
        elif nodeName_ == 'fitzHughNagumoCell':
            obj_ = FitzHughNagumoCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fitzHughNagumoCell.append(obj_)
            obj_.original_tagname_ = 'fitzHughNagumoCell'
        elif nodeName_ == 'fitzHughNagumo1969Cell':
            obj_ = FitzHughNagumo1969Cell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fitzHughNagumo1969Cell.append(obj_)
            obj_.original_tagname_ = 'fitzHughNagumo1969Cell'
        elif nodeName_ == 'pinskyRinzelCA3Cell':
            obj_ = PinskyRinzelCA3Cell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pinskyRinzelCA3Cell.append(obj_)
            obj_.original_tagname_ = 'pinskyRinzelCA3Cell'
        elif nodeName_ == 'pulseGenerator':
            obj_ = PulseGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pulseGenerator.append(obj_)
            obj_.original_tagname_ = 'pulseGenerator'
        elif nodeName_ == 'pulseGeneratorDL':
            obj_ = PulseGeneratorDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pulseGeneratorDL.append(obj_)
            obj_.original_tagname_ = 'pulseGeneratorDL'
        elif nodeName_ == 'sineGenerator':
            obj_ = SineGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sineGenerator.append(obj_)
            obj_.original_tagname_ = 'sineGenerator'
        elif nodeName_ == 'sineGeneratorDL':
            obj_ = SineGeneratorDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sineGeneratorDL.append(obj_)
            obj_.original_tagname_ = 'sineGeneratorDL'
        elif nodeName_ == 'rampGenerator':
            obj_ = RampGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rampGenerator.append(obj_)
            obj_.original_tagname_ = 'rampGenerator'
        elif nodeName_ == 'rampGeneratorDL':
            obj_ = RampGeneratorDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rampGeneratorDL.append(obj_)
            obj_.original_tagname_ = 'rampGeneratorDL'
        elif nodeName_ == 'compoundInput':
            obj_ = CompoundInput.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.compoundInput.append(obj_)
            obj_.original_tagname_ = 'compoundInput'
        elif nodeName_ == 'compoundInputDL':
            obj_ = CompoundInputDL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.compoundInputDL.append(obj_)
            obj_.original_tagname_ = 'compoundInputDL'
        elif nodeName_ == 'voltageClamp':
            obj_ = VoltageClamp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.voltageClamp.append(obj_)
            obj_.original_tagname_ = 'voltageClamp'
        elif nodeName_ == 'voltageClampTriple':
            obj_ = VoltageClampTriple.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.voltageClampTriple.append(obj_)
            obj_.original_tagname_ = 'voltageClampTriple'
        elif nodeName_ == 'spikeArray':
            obj_ = SpikeArray.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spikeArray.append(obj_)
            obj_.original_tagname_ = 'spikeArray'
        elif nodeName_ == 'timedSynapticInput':
            obj_ = TimedSynapticInput.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timedSynapticInput.append(obj_)
            obj_.original_tagname_ = 'timedSynapticInput'
        elif nodeName_ == 'spikeGenerator':
            obj_ = SpikeGenerator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spikeGenerator.append(obj_)
            obj_.original_tagname_ = 'spikeGenerator'
        elif nodeName_ == 'spikeGeneratorRandom':
            obj_ = SpikeGeneratorRandom.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spikeGeneratorRandom.append(obj_)
            obj_.original_tagname_ = 'spikeGeneratorRandom'
        elif nodeName_ == 'spikeGeneratorPoisson':
            class_obj_ = self.get_class_obj_(child_, SpikeGeneratorPoisson)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spikeGeneratorPoisson.append(obj_)
            obj_.original_tagname_ = 'spikeGeneratorPoisson'
        elif nodeName_ == 'spikeGeneratorRefPoisson':
            obj_ = SpikeGeneratorRefPoisson.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.spikeGeneratorRefPoisson.append(obj_)
            obj_.original_tagname_ = 'spikeGeneratorRefPoisson'
        elif nodeName_ == 'poissonFiringSynapse':
            obj_ = PoissonFiringSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.poissonFiringSynapse.append(obj_)
            obj_.original_tagname_ = 'poissonFiringSynapse'
        elif nodeName_ == 'transientPoissonFiringSynapse':
            obj_ = TransientPoissonFiringSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transientPoissonFiringSynapse.append(obj_)
            obj_.original_tagname_ = 'transientPoissonFiringSynapse'
        elif nodeName_ == 'IF_curr_alpha':
            obj_ = IF_curr_alpha.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IF_curr_alpha.append(obj_)
            obj_.original_tagname_ = 'IF_curr_alpha'
        elif nodeName_ == 'IF_curr_exp':
            obj_ = IF_curr_exp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IF_curr_exp.append(obj_)
            obj_.original_tagname_ = 'IF_curr_exp'
        elif nodeName_ == 'IF_cond_alpha':
            obj_ = IF_cond_alpha.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IF_cond_alpha.append(obj_)
            obj_.original_tagname_ = 'IF_cond_alpha'
        elif nodeName_ == 'IF_cond_exp':
            obj_ = IF_cond_exp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IF_cond_exp.append(obj_)
            obj_.original_tagname_ = 'IF_cond_exp'
        elif nodeName_ == 'EIF_cond_exp_isfa_ista':
            class_obj_ = self.get_class_obj_(child_, EIF_cond_exp_isfa_ista)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EIF_cond_exp_isfa_ista.append(obj_)
            obj_.original_tagname_ = 'EIF_cond_exp_isfa_ista'
        elif nodeName_ == 'EIF_cond_alpha_isfa_ista':
            obj_ = EIF_cond_alpha_isfa_ista.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EIF_cond_alpha_isfa_ista.append(obj_)
            obj_.original_tagname_ = 'EIF_cond_alpha_isfa_ista'
        elif nodeName_ == 'HH_cond_exp':
            obj_ = HH_cond_exp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HH_cond_exp.append(obj_)
            obj_.original_tagname_ = 'HH_cond_exp'
        elif nodeName_ == 'expCondSynapse':
            obj_ = ExpCondSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expCondSynapse.append(obj_)
            obj_.original_tagname_ = 'expCondSynapse'
        elif nodeName_ == 'alphaCondSynapse':
            obj_ = AlphaCondSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alphaCondSynapse.append(obj_)
            obj_.original_tagname_ = 'alphaCondSynapse'
        elif nodeName_ == 'expCurrSynapse':
            obj_ = ExpCurrSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expCurrSynapse.append(obj_)
            obj_.original_tagname_ = 'expCurrSynapse'
        elif nodeName_ == 'alphaCurrSynapse':
            obj_ = AlphaCurrSynapse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alphaCurrSynapse.append(obj_)
            obj_.original_tagname_ = 'alphaCurrSynapse'
        elif nodeName_ == 'SpikeSourcePoisson':
            obj_ = SpikeSourcePoisson.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SpikeSourcePoisson.append(obj_)
            obj_.original_tagname_ = 'SpikeSourcePoisson'
        elif nodeName_ == 'network':
            obj_ = Network.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.network.append(obj_)
            obj_.original_tagname_ = 'network'
        elif nodeName_ == 'ComponentType':
            obj_ = ComponentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ComponentType.append(obj_)
            obj_.original_tagname_ = 'ComponentType'
        super(NeuroMLDocument, self).buildChildren(child_, node, nodeName_, True)


    def summary(self, show_includes=True, show_non_network=True):

        import inspect

        info = "*******************************************************\n"
        info+="* NeuroMLDocument: "+self.id+"\n*\n"
        post = ""
        membs = inspect.getmembers(self)
        for memb in membs:
            if isinstance(memb[1], list) and len(memb[1])>0 and not memb[0].endswith('_') and not memb[0] == 'networks':
                if (memb[0] == 'includes' and show_includes) or (not memb[0] == 'includes' and show_non_network):
                    post = "*\n"
                    info+="*  "+str(memb[1][0].__class__.__name__)+": "
                    listed = []
                    for entry in memb[1]:
                        if hasattr(entry,'id'):
                            listed.append(str(entry.id))
                        elif hasattr(entry,'name'):
                            listed.append(str(entry.name))
                        elif hasattr(entry,'href'):
                            listed.append(str(entry.href))
                        elif hasattr(entry,'tag'):
                            listed.append(str(entry.tag)+" = "+str(entry.value))
                    info+= str(sorted(listed))+"\n"
        info+= post

        for network in self.networks:
            info+="*  Network: "+network.id
            if network.temperature:
                info+=" (temperature: "+network.temperature+")"
            info+="\n*\n"
            tot_pop =0
            tot_cells = 0
            pop_info = ""
            for pop in sorted(network.populations, key=lambda x: x.id):
                pop_info+="*     "+str(pop)+"\n"
                tot_pop+=1
                tot_cells+=pop.get_size()
                if len(pop.instances)>0:
                    loc = pop.instances[0].location
                    pop_info+="*       Locations: ["+str(loc)+", ...]\n"
                if len(pop.properties)>0:
                    pop_info+="*       Properties: "
                    for p in pop.properties:
                        pop_info+=(str(p.tag)+'='+str(p.value)+'; ')
                    pop_info+="\n"

            info+="*   "+str(tot_cells)+" cells in "+str(tot_pop)+" populations \n"+pop_info+"*\n"


            tot_proj =0
            tot_conns = 0

            proj_info = ""
            for proj in sorted(network.projections, key=lambda x: x.id):
                proj_info+="*     "+str(proj)+"\n"
                tot_proj+=1
                tot_conns+=len(proj.connections)
                tot_conns+=len(proj.connection_wds)
                if len(proj.connections)>0:
                    proj_info+="*       "+str(len(proj.connections))+" connections: [("+str(proj.connections[0])+"), ...]\n"
                if len(proj.connection_wds)>0:
                    proj_info+="*       "+str(len(proj.connection_wds))+" connections (wd): [("+str(proj.connection_wds[0])+"), ...]\n"

            for proj in sorted(network.electrical_projections, key=lambda x: x.id):
                proj_info+="*     Electrical projection: "+proj.id+" from "+proj.presynaptic_population+" to "+proj.postsynaptic_population+"\n"
                tot_proj+=1
                tot_conns+=len(proj.electrical_connections)
                tot_conns+=len(proj.electrical_connection_instances)
                tot_conns+=len(proj.electrical_connection_instance_ws)
                if len(proj.electrical_connections)>0:
                    proj_info+="*       "+str(len(proj.electrical_connections))+" connections: [("+str(proj.electrical_connections[0])+"), ...]\n"
                if len(proj.electrical_connection_instances)>0:
                    proj_info+="*       "+str(len(proj.electrical_connection_instances))+" connections: [("+str(proj.electrical_connection_instances[0])+"), ...]\n"
                if len(proj.electrical_connection_instance_ws)>0:
                    proj_info+="*       "+str(len(proj.electrical_connection_instance_ws))+" connections: [("+str(proj.electrical_connection_instance_ws[0])+"), ...]\n"

            for proj in sorted(network.continuous_projections, key=lambda x: x.id):
                proj_info+="*     Continuous projection: "+proj.id+" from "+proj.presynaptic_population+" to "+proj.postsynaptic_population+"\n"
                tot_proj+=1
                tot_conns+=len(proj.continuous_connections)
                tot_conns+=len(proj.continuous_connection_instances)
                tot_conns+=len(proj.continuous_connection_instance_ws)
                if len(proj.continuous_connections)>0:
                    proj_info+="*       "+str(len(proj.continuous_connections))+" connections: [("+str(proj.continuous_connections[0])+"), ...]\n"
                if len(proj.continuous_connection_instances)>0:
                    proj_info+="*       "+str(len(proj.continuous_connection_instances))+" connections: [("+str(proj.continuous_connection_instances[0])+"), ...]\n"
                if len(proj.continuous_connection_instance_ws)>0:
                    proj_info+="*       "+str(len(proj.continuous_connection_instance_ws))+" connections (w): [("+str(proj.continuous_connection_instance_ws[0])+"), ...]\n"

            info+="*   "+str(tot_conns)+" connections in "+str(tot_proj)+" projections \n"+proj_info+"*\n"

            if len(network.synaptic_connections)>0:
                info+="*   "+str(len(network.synaptic_connections))+" explicit synaptic connections (outside of projections)\n"
                for sc in network.synaptic_connections:
                    info+="*     "+str(sc)+"\n"
                info+="*\n"

            tot_input_lists = 0
            tot_inputs = 0
            input_info = ""
            for il in sorted(network.input_lists, key=lambda x: x.id):
                input_info+="*     "+str(il)+"\n"
                tot_input_lists += 1
                if len(il.input)>0:
                    input_info+="*       "+str(len(il.input))+" inputs: [("+str(il.input[0])+"), ...]\n"
                    tot_inputs+=len(il.input)
                if len(il.input_ws)>0:
                    input_info+="*       "+str(len(il.input_ws))+" inputs: [("+str(il.input_ws[0])+"), ...]\n"
                    tot_inputs+=len(il.input_ws)

            info+="*   "+str(tot_inputs)+" inputs in "+str(tot_input_lists)+" input lists \n"+input_info+"*\n"

            if len(network.explicit_inputs)>0:
                info+="*   "+str(len(network.explicit_inputs))+" explicit inputs (outside of input lists)\n"
                for el in network.explicit_inputs:
                    info+="*     "+str(el)+"\n"
                info+="*\n"


        info+="*******************************************************"

        return info

    warn_count = 0

    def get_by_id(self,id):
        if len(id)==0:
            import inspect
            callframe = inspect.getouterframes(inspect.currentframe(), 2)
            print('Method: '+ callframe[1][3] + ' is asking for an element with no id...')

            return None
        all_ids = []
        for ms in self.member_data_items_:
            mlist = self.__getattribute__(ms.name)
            for m in mlist:
                if hasattr(m,"id"):
                    if m.id == id:
                        return m
                    else:
                        all_ids.append(m.id)
        from neuroml.loaders import print_
        if self.warn_count<10:
            print_("Id "+id+" not found in <neuroml> element. All ids: "+str(sorted(all_ids)))
            self.warn_count+=1
        elif self.warn_count==10:
            print_(" - Suppressing further warnings about id not found...")
        return None

    def append(self,element):
        from neuroml.utils import append_to_element
        append_to_element(self,element)

    # end class NeuroMLDocument


class BasePynnSynapse(BaseSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('tau_syn', 'xs:float', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, tau_syn=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BasePynnSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.tau_syn = _cast(float, tau_syn)
        self.tau_syn_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasePynnSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasePynnSynapse.subclass:
            return BasePynnSynapse.subclass(*args_, **kwargs_)
        else:
            return BasePynnSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(BasePynnSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BasePynnSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BasePynnSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BasePynnSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BasePynnSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BasePynnSynapse'):
        super(BasePynnSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BasePynnSynapse')
        if self.tau_syn is not None and 'tau_syn' not in already_processed:
            already_processed.add('tau_syn')
            outfile.write(' tau_syn="%s"' % self.gds_format_float(self.tau_syn, input_name='tau_syn'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BasePynnSynapse', fromsubclass_=False, pretty_print=True):
        super(BasePynnSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tau_syn', node)
        if value is not None and 'tau_syn' not in already_processed:
            already_processed.add('tau_syn')
            value = self.gds_parse_float(value, node, 'tau_syn')
            self.tau_syn = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BasePynnSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BasePynnSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BasePynnSynapse


class basePyNNCell(BaseCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('cm', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('i_offset', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('tau_syn_E', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('tau_syn_I', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('v_init', 'xs:float', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, cm=None, i_offset=None, tau_syn_E=None, tau_syn_I=None, v_init=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(basePyNNCell, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.cm = _cast(float, cm)
        self.cm_nsprefix_ = None
        self.i_offset = _cast(float, i_offset)
        self.i_offset_nsprefix_ = None
        self.tau_syn_E = _cast(float, tau_syn_E)
        self.tau_syn_E_nsprefix_ = None
        self.tau_syn_I = _cast(float, tau_syn_I)
        self.tau_syn_I_nsprefix_ = None
        self.v_init = _cast(float, v_init)
        self.v_init_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basePyNNCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basePyNNCell.subclass:
            return basePyNNCell.subclass(*args_, **kwargs_)
        else:
            return basePyNNCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(basePyNNCell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='basePyNNCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basePyNNCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basePyNNCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='basePyNNCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='basePyNNCell'):
        super(basePyNNCell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basePyNNCell')
        if self.cm is not None and 'cm' not in already_processed:
            already_processed.add('cm')
            outfile.write(' cm="%s"' % self.gds_format_float(self.cm, input_name='cm'))
        if self.i_offset is not None and 'i_offset' not in already_processed:
            already_processed.add('i_offset')
            outfile.write(' i_offset="%s"' % self.gds_format_float(self.i_offset, input_name='i_offset'))
        if self.tau_syn_E is not None and 'tau_syn_E' not in already_processed:
            already_processed.add('tau_syn_E')
            outfile.write(' tau_syn_E="%s"' % self.gds_format_float(self.tau_syn_E, input_name='tau_syn_E'))
        if self.tau_syn_I is not None and 'tau_syn_I' not in already_processed:
            already_processed.add('tau_syn_I')
            outfile.write(' tau_syn_I="%s"' % self.gds_format_float(self.tau_syn_I, input_name='tau_syn_I'))
        if self.v_init is not None and 'v_init' not in already_processed:
            already_processed.add('v_init')
            outfile.write(' v_init="%s"' % self.gds_format_float(self.v_init, input_name='v_init'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='basePyNNCell', fromsubclass_=False, pretty_print=True):
        super(basePyNNCell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cm', node)
        if value is not None and 'cm' not in already_processed:
            already_processed.add('cm')
            value = self.gds_parse_float(value, node, 'cm')
            self.cm = value
        value = find_attr_value_('i_offset', node)
        if value is not None and 'i_offset' not in already_processed:
            already_processed.add('i_offset')
            value = self.gds_parse_float(value, node, 'i_offset')
            self.i_offset = value
        value = find_attr_value_('tau_syn_E', node)
        if value is not None and 'tau_syn_E' not in already_processed:
            already_processed.add('tau_syn_E')
            value = self.gds_parse_float(value, node, 'tau_syn_E')
            self.tau_syn_E = value
        value = find_attr_value_('tau_syn_I', node)
        if value is not None and 'tau_syn_I' not in already_processed:
            already_processed.add('tau_syn_I')
            value = self.gds_parse_float(value, node, 'tau_syn_I')
            self.tau_syn_I = value
        value = find_attr_value_('v_init', node)
        if value is not None and 'v_init' not in already_processed:
            already_processed.add('v_init')
            value = self.gds_parse_float(value, node, 'v_init')
            self.v_init = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(basePyNNCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(basePyNNCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class basePyNNCell


class ContinuousProjection(BaseProjection):
    """Projection between two populations consisting of analog connections
    (e.g. graded synapses)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('continuousConnection', 'ContinuousConnection', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'continuousConnection', 'type': 'ContinuousConnection'}, None),
        MemberSpec_('continuousConnectionInstance', 'ContinuousConnectionInstance', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'continuousConnectionInstance', 'type': 'ContinuousConnectionInstance'}, None),
        MemberSpec_('continuousConnectionInstanceW', 'ContinuousConnectionInstanceW', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'continuousConnectionInstanceW', 'type': 'ContinuousConnectionInstanceW'}, None),
    ]
    subclass = None
    superclass = BaseProjection
    def __init__(self, neuroLexId=None, id=None, presynapticPopulation=None, postsynapticPopulation=None, continuousConnection=None, continuousConnectionInstance=None, continuousConnectionInstanceW=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ContinuousProjection, self).__init__(neuroLexId, id, presynapticPopulation, postsynapticPopulation,  **kwargs_)
        if continuousConnection is None:
            self.continuousConnection = []
        else:
            self.continuousConnection = continuousConnection
        self.continuousConnection_nsprefix_ = None
        if continuousConnectionInstance is None:
            self.continuousConnectionInstance = []
        else:
            self.continuousConnectionInstance = continuousConnectionInstance
        self.continuousConnectionInstance_nsprefix_ = None
        if continuousConnectionInstanceW is None:
            self.continuousConnectionInstanceW = []
        else:
            self.continuousConnectionInstanceW = continuousConnectionInstanceW
        self.continuousConnectionInstanceW_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContinuousProjection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContinuousProjection.subclass:
            return ContinuousProjection.subclass(*args_, **kwargs_)
        else:
            return ContinuousProjection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.continuousConnection or
            self.continuousConnectionInstance or
            self.continuousConnectionInstanceW or
            super(ContinuousProjection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContinuousProjection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContinuousProjection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContinuousProjection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContinuousProjection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContinuousProjection'):
        super(ContinuousProjection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContinuousProjection')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContinuousProjection', fromsubclass_=False, pretty_print=True):
        super(ContinuousProjection, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for continuousConnection_ in self.continuousConnection:
            namespaceprefix_ = self.continuousConnection_nsprefix_ + ':' if (UseCapturedNS_ and self.continuousConnection_nsprefix_) else ''
            continuousConnection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='continuousConnection', pretty_print=pretty_print)
        for continuousConnectionInstance_ in self.continuousConnectionInstance:
            namespaceprefix_ = self.continuousConnectionInstance_nsprefix_ + ':' if (UseCapturedNS_ and self.continuousConnectionInstance_nsprefix_) else ''
            continuousConnectionInstance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='continuousConnectionInstance', pretty_print=pretty_print)
        for continuousConnectionInstanceW_ in self.continuousConnectionInstanceW:
            namespaceprefix_ = self.continuousConnectionInstanceW_nsprefix_ + ':' if (UseCapturedNS_ and self.continuousConnectionInstanceW_nsprefix_) else ''
            continuousConnectionInstanceW_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='continuousConnectionInstanceW', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ContinuousProjection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'continuousConnection':
            class_obj_ = self.get_class_obj_(child_, ContinuousConnection)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.continuousConnection.append(obj_)
            obj_.original_tagname_ = 'continuousConnection'
        elif nodeName_ == 'continuousConnectionInstance':
            class_obj_ = self.get_class_obj_(child_, ContinuousConnectionInstance)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.continuousConnectionInstance.append(obj_)
            obj_.original_tagname_ = 'continuousConnectionInstance'
        elif nodeName_ == 'continuousConnectionInstanceW':
            obj_ = ContinuousConnectionInstanceW.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.continuousConnectionInstanceW.append(obj_)
            obj_.original_tagname_ = 'continuousConnectionInstanceW'
        super(ContinuousProjection, self).buildChildren(child_, node, nodeName_, True)

    def exportHdf5(self, h5file, h5Group):
        #print("Exporting ContinuousProjection: "+str(self.id)+" as HDF5")
        

        import numpy

        projGroup = h5file.create_group(h5Group, 'projection_'+self.id)
        projGroup._f_setattr("id", self.id)
        projGroup._f_setattr("type", "continuousProjection")
        projGroup._f_setattr("presynapticPopulation", self.presynaptic_population)
        projGroup._f_setattr("postsynapticPopulation", self.postsynaptic_population)

        pre_comp = self.continuous_connections[0].pre_component if len(self.continuous_connections)>0 else                             self.continuous_connection_instances[0].pre_component if len(self.continuous_connection_instances)>0 else self.continuous_connection_instance_ws[0].pre_component
        projGroup._f_setattr("preComponent", pre_comp )
        post_comp = self.continuous_connections[0].post_component if len(self.continuous_connections)>0 else                             self.continuous_connection_instances[0].post_component if len(self.continuous_connection_instances)>0 else self.continuous_connection_instance_ws[0].post_component
        projGroup._f_setattr("postComponent", post_comp )

        cols = 7
        extra_cols = {}

        num_tot = len(self.continuous_connections)+len(self.continuous_connection_instances)+len(self.continuous_connection_instance_ws)

        if len(self.continuous_connection_instance_ws)>0:
            extra_cols["column_"+str(cols)] = 'weight'
            cols+=1

        #print("Exporting "+str(num_tot)+" continuous connections")
        a = numpy.zeros([num_tot, cols], numpy.float32)

        count=0

        # TODO: optimise for single compartment cells, i.e. where no pre_segment/post_fraction_along etc.
        for connection in self.continuous_connections:
          a[count,0] = connection.id
          a[count,1] = connection.get_pre_cell_id()
          a[count,2] = connection.get_post_cell_id()
          a[count,3] = connection.pre_segment
          a[count,4] = connection.post_segment
          a[count,5] = connection.pre_fraction_along
          a[count,6] = connection.post_fraction_along
          count=count+1

        for connection in self.continuous_connection_instances:
          a[count,0] = connection.id
          a[count,1] = connection.get_pre_cell_id()
          a[count,2] = connection.get_post_cell_id()
          a[count,3] = connection.pre_segment
          a[count,4] = connection.post_segment
          a[count,5] = connection.pre_fraction_along
          a[count,6] = connection.post_fraction_along
          count=count+1


        for connection in self.continuous_connection_instance_ws:
          a[count,0] = connection.id
          a[count,1] = connection.get_pre_cell_id()
          a[count,2] = connection.get_post_cell_id()
          a[count,3] = connection.pre_segment
          a[count,4] = connection.post_segment
          a[count,5] = connection.pre_fraction_along
          a[count,6] = connection.post_fraction_along
          a[count,7] = connection.weight
          count=count+1


        array = h5file.create_carray(projGroup, self.id, obj=a, title="Connections of cells in "+ self.id)

        array._f_setattr("column_0", "id")
        array._f_setattr("column_1", "pre_cell_id")
        array._f_setattr("column_2", "post_cell_id")
        array._f_setattr("column_3", "pre_segment_id")
        array._f_setattr("column_4", "post_segment_id")
        array._f_setattr("column_5", "pre_fraction_along")
        array._f_setattr("column_6", "post_fraction_along")
        for k in extra_cols:
            array._f_setattr(k, extra_cols[k])



    # end class ContinuousProjection


class ElectricalProjection(BaseProjection):
    """Projection between two populations consisting of electrical connections
    (gap junctions)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('electricalConnection', 'ElectricalConnection', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'electricalConnection', 'type': 'ElectricalConnection'}, None),
        MemberSpec_('electricalConnectionInstance', 'ElectricalConnectionInstance', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'electricalConnectionInstance', 'type': 'ElectricalConnectionInstance'}, None),
        MemberSpec_('electricalConnectionInstanceW', 'ElectricalConnectionInstanceW', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'electricalConnectionInstanceW', 'type': 'ElectricalConnectionInstanceW'}, None),
    ]
    subclass = None
    superclass = BaseProjection
    def __init__(self, neuroLexId=None, id=None, presynapticPopulation=None, postsynapticPopulation=None, electricalConnection=None, electricalConnectionInstance=None, electricalConnectionInstanceW=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ElectricalProjection, self).__init__(neuroLexId, id, presynapticPopulation, postsynapticPopulation,  **kwargs_)
        if electricalConnection is None:
            self.electricalConnection = []
        else:
            self.electricalConnection = electricalConnection
        self.electricalConnection_nsprefix_ = None
        if electricalConnectionInstance is None:
            self.electricalConnectionInstance = []
        else:
            self.electricalConnectionInstance = electricalConnectionInstance
        self.electricalConnectionInstance_nsprefix_ = None
        if electricalConnectionInstanceW is None:
            self.electricalConnectionInstanceW = []
        else:
            self.electricalConnectionInstanceW = electricalConnectionInstanceW
        self.electricalConnectionInstanceW_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricalProjection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricalProjection.subclass:
            return ElectricalProjection.subclass(*args_, **kwargs_)
        else:
            return ElectricalProjection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.electricalConnection or
            self.electricalConnectionInstance or
            self.electricalConnectionInstanceW or
            super(ElectricalProjection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ElectricalProjection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElectricalProjection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricalProjection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ElectricalProjection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ElectricalProjection'):
        super(ElectricalProjection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricalProjection')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ElectricalProjection', fromsubclass_=False, pretty_print=True):
        super(ElectricalProjection, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for electricalConnection_ in self.electricalConnection:
            namespaceprefix_ = self.electricalConnection_nsprefix_ + ':' if (UseCapturedNS_ and self.electricalConnection_nsprefix_) else ''
            electricalConnection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='electricalConnection', pretty_print=pretty_print)
        for electricalConnectionInstance_ in self.electricalConnectionInstance:
            namespaceprefix_ = self.electricalConnectionInstance_nsprefix_ + ':' if (UseCapturedNS_ and self.electricalConnectionInstance_nsprefix_) else ''
            electricalConnectionInstance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='electricalConnectionInstance', pretty_print=pretty_print)
        for electricalConnectionInstanceW_ in self.electricalConnectionInstanceW:
            namespaceprefix_ = self.electricalConnectionInstanceW_nsprefix_ + ':' if (UseCapturedNS_ and self.electricalConnectionInstanceW_nsprefix_) else ''
            electricalConnectionInstanceW_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='electricalConnectionInstanceW', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ElectricalProjection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'electricalConnection':
            class_obj_ = self.get_class_obj_(child_, ElectricalConnection)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.electricalConnection.append(obj_)
            obj_.original_tagname_ = 'electricalConnection'
        elif nodeName_ == 'electricalConnectionInstance':
            class_obj_ = self.get_class_obj_(child_, ElectricalConnectionInstance)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.electricalConnectionInstance.append(obj_)
            obj_.original_tagname_ = 'electricalConnectionInstance'
        elif nodeName_ == 'electricalConnectionInstanceW':
            obj_ = ElectricalConnectionInstanceW.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.electricalConnectionInstanceW.append(obj_)
            obj_.original_tagname_ = 'electricalConnectionInstanceW'
        super(ElectricalProjection, self).buildChildren(child_, node, nodeName_, True)

    def exportHdf5(self, h5file, h5Group):
        #print("Exporting ElectricalProjection: "+str(self.id)+" as HDF5")
        

        import numpy

        projGroup = h5file.create_group(h5Group, 'projection_'+self.id)
        projGroup._f_setattr("id", self.id)
        projGroup._f_setattr("type", "electricalProjection")
        projGroup._f_setattr("presynapticPopulation", self.presynaptic_population)
        projGroup._f_setattr("postsynapticPopulation", self.postsynaptic_population)

        syn = self.electrical_connections[0].synapse if len(self.electrical_connections)>0 else                     self.electrical_connection_instances[0].synapse if len(self.electrical_connection_instances)>0 else self.electrical_connection_instance_ws[0].synapse
        projGroup._f_setattr("synapse", syn )

        cols = 7
        extra_cols = {}

        num_tot = len(self.electrical_connections)+len(self.electrical_connection_instances)+len(self.electrical_connection_instance_ws)
        if len(self.electrical_connection_instance_ws)>0:
            extra_cols["column_"+str(cols)] = "weight"
            cols+=1

        #print("Exporting "+str(num_tot)+" electrical connections")
        a = numpy.zeros([num_tot, cols], numpy.float32)

        count=0

        # TODO: optimise for single compartment cells, i.e. where no pre_segment/post_fraction_along etc.
        for connection in self.electrical_connections:
          a[count,0] = connection.id
          a[count,1] = connection.get_pre_cell_id()
          a[count,2] = connection.get_post_cell_id()
          a[count,3] = connection.pre_segment
          a[count,4] = connection.post_segment
          a[count,5] = connection.pre_fraction_along
          a[count,6] = connection.post_fraction_along
          count=count+1

        for connection in self.electrical_connection_instances:
          a[count,0] = connection.id
          a[count,1] = connection.get_pre_cell_id()
          a[count,2] = connection.get_post_cell_id()
          a[count,3] = connection.pre_segment
          a[count,4] = connection.post_segment
          a[count,5] = connection.pre_fraction_along
          a[count,6] = connection.post_fraction_along
          count=count+1

        for connection in self.electrical_connection_instance_ws:
          a[count,0] = connection.id
          a[count,1] = connection.get_pre_cell_id()
          a[count,2] = connection.get_post_cell_id()
          a[count,3] = connection.pre_segment
          a[count,4] = connection.post_segment
          a[count,5] = connection.pre_fraction_along
          a[count,6] = connection.post_fraction_along
          a[count,7] = connection.get_weight()
          count=count+1

        array = h5file.create_carray(projGroup, self.id, obj=a, title="Connections of cells in "+ self.id)

        array._f_setattr("column_0", "id")
        array._f_setattr("column_1", "pre_cell_id")
        array._f_setattr("column_2", "post_cell_id")
        array._f_setattr("column_3", "pre_segment_id")
        array._f_setattr("column_4", "post_segment_id")
        array._f_setattr("column_5", "pre_fraction_along")
        array._f_setattr("column_6", "post_fraction_along")

        for col in extra_cols.keys():
            array._f_setattr(col,extra_cols[col])


    # end class ElectricalProjection


class BaseConnectionNewFormat(BaseConnection):
    """Base of all synaptic connections with preCell, postSegment, etc.
    See BaseConnectionOldFormat"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('preCell', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('preSegment', 'NonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('preFractionAlong', 'ZeroToOne', 0, 1, {'use': 'optional'}),
        MemberSpec_('postCell', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('postSegment', 'NonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('postFractionAlong', 'ZeroToOne', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = BaseConnection
    def __init__(self, neuroLexId=None, id=None, preCell=None, preSegment='0', preFractionAlong='0.5', postCell=None, postSegment='0', postFractionAlong='0.5', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseConnectionNewFormat, self).__init__(neuroLexId, id, extensiontype_,  **kwargs_)
        self.preCell = _cast(None, preCell)
        self.preCell_nsprefix_ = None
        self.preSegment = _cast(int, preSegment)
        self.preSegment_nsprefix_ = None
        self.preFractionAlong = _cast(float, preFractionAlong)
        self.preFractionAlong_nsprefix_ = None
        self.postCell = _cast(None, postCell)
        self.postCell_nsprefix_ = None
        self.postSegment = _cast(int, postSegment)
        self.postSegment_nsprefix_ = None
        self.postFractionAlong = _cast(float, postFractionAlong)
        self.postFractionAlong_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseConnectionNewFormat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseConnectionNewFormat.subclass:
            return BaseConnectionNewFormat.subclass(*args_, **kwargs_)
        else:
            return BaseConnectionNewFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_ZeroToOne(self, value):
        # Validate type ZeroToOne, a restriction on xs:float.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ZeroToOne' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ZeroToOne' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(BaseConnectionNewFormat, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseConnectionNewFormat', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseConnectionNewFormat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseConnectionNewFormat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseConnectionNewFormat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseConnectionNewFormat'):
        super(BaseConnectionNewFormat, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseConnectionNewFormat')
        if self.preCell is not None and 'preCell' not in already_processed:
            already_processed.add('preCell')
            outfile.write(' preCell=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.preCell), input_name='preCell')), ))
        if self.preSegment != 0 and 'preSegment' not in already_processed:
            already_processed.add('preSegment')
            outfile.write(' preSegment="%s"' % self.gds_format_integer(self.preSegment, input_name='preSegment'))
        if self.preFractionAlong != 0.5 and 'preFractionAlong' not in already_processed:
            already_processed.add('preFractionAlong')
            outfile.write(' preFractionAlong="%s"' % self.gds_format_float(self.preFractionAlong, input_name='preFractionAlong'))
        if self.postCell is not None and 'postCell' not in already_processed:
            already_processed.add('postCell')
            outfile.write(' postCell=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.postCell), input_name='postCell')), ))
        if self.postSegment != 0 and 'postSegment' not in already_processed:
            already_processed.add('postSegment')
            outfile.write(' postSegment="%s"' % self.gds_format_integer(self.postSegment, input_name='postSegment'))
        if self.postFractionAlong != 0.5 and 'postFractionAlong' not in already_processed:
            already_processed.add('postFractionAlong')
            outfile.write(' postFractionAlong="%s"' % self.gds_format_float(self.postFractionAlong, input_name='postFractionAlong'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseConnectionNewFormat', fromsubclass_=False, pretty_print=True):
        super(BaseConnectionNewFormat, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('preCell', node)
        if value is not None and 'preCell' not in already_processed:
            already_processed.add('preCell')
            self.preCell = value
        value = find_attr_value_('preSegment', node)
        if value is not None and 'preSegment' not in already_processed:
            already_processed.add('preSegment')
            self.preSegment = self.gds_parse_integer(value, node, 'preSegment')
            if self.preSegment < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.preSegment)    # validate type NonNegativeInteger
        value = find_attr_value_('preFractionAlong', node)
        if value is not None and 'preFractionAlong' not in already_processed:
            already_processed.add('preFractionAlong')
            value = self.gds_parse_float(value, node, 'preFractionAlong')
            self.preFractionAlong = value
            self.validate_ZeroToOne(self.preFractionAlong)    # validate type ZeroToOne
        value = find_attr_value_('postCell', node)
        if value is not None and 'postCell' not in already_processed:
            already_processed.add('postCell')
            self.postCell = value
        value = find_attr_value_('postSegment', node)
        if value is not None and 'postSegment' not in already_processed:
            already_processed.add('postSegment')
            self.postSegment = self.gds_parse_integer(value, node, 'postSegment')
            if self.postSegment < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.postSegment)    # validate type NonNegativeInteger
        value = find_attr_value_('postFractionAlong', node)
        if value is not None and 'postFractionAlong' not in already_processed:
            already_processed.add('postFractionAlong')
            value = self.gds_parse_float(value, node, 'postFractionAlong')
            self.postFractionAlong = value
            self.validate_ZeroToOne(self.postFractionAlong)    # validate type ZeroToOne
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseConnectionNewFormat, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BaseConnectionNewFormat, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseConnectionNewFormat


class BaseConnectionOldFormat(BaseConnection):
    """Base of all synaptic connections with preCellId, postSegmentId, etc.
    Note: this is not the best name for these attributes, since Id is
    superfluous, hence BaseConnectionNewFormat"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('preCellId', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('preSegmentId', 'NonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('preFractionAlong', 'ZeroToOne', 0, 1, {'use': 'optional'}),
        MemberSpec_('postCellId', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('postSegmentId', 'NonNegativeInteger', 0, 1, {'use': 'optional'}),
        MemberSpec_('postFractionAlong', 'ZeroToOne', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = BaseConnection
    def __init__(self, neuroLexId=None, id=None, preCellId=None, preSegmentId='0', preFractionAlong='0.5', postCellId=None, postSegmentId='0', postFractionAlong='0.5', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseConnectionOldFormat, self).__init__(neuroLexId, id, extensiontype_,  **kwargs_)
        self.preCellId = _cast(None, preCellId)
        self.preCellId_nsprefix_ = None
        self.preSegmentId = _cast(int, preSegmentId)
        self.preSegmentId_nsprefix_ = None
        self.preFractionAlong = _cast(float, preFractionAlong)
        self.preFractionAlong_nsprefix_ = None
        self.postCellId = _cast(None, postCellId)
        self.postCellId_nsprefix_ = None
        self.postSegmentId = _cast(int, postSegmentId)
        self.postSegmentId_nsprefix_ = None
        self.postFractionAlong = _cast(float, postFractionAlong)
        self.postFractionAlong_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseConnectionOldFormat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseConnectionOldFormat.subclass:
            return BaseConnectionOldFormat.subclass(*args_, **kwargs_)
        else:
            return BaseConnectionOldFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NonNegativeInteger(self, value):
        # Validate type NonNegativeInteger, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_ZeroToOne(self, value):
        # Validate type ZeroToOne, a restriction on xs:float.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ZeroToOne' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ZeroToOne' % {"value": value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(BaseConnectionOldFormat, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseConnectionOldFormat', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseConnectionOldFormat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseConnectionOldFormat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseConnectionOldFormat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseConnectionOldFormat'):
        super(BaseConnectionOldFormat, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseConnectionOldFormat')
        if self.preCellId is not None and 'preCellId' not in already_processed:
            already_processed.add('preCellId')
            outfile.write(' preCellId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.preCellId), input_name='preCellId')), ))
        if self.preSegmentId != 0 and 'preSegmentId' not in already_processed:
            already_processed.add('preSegmentId')
            outfile.write(' preSegmentId="%s"' % self.gds_format_integer(self.preSegmentId, input_name='preSegmentId'))
        if self.preFractionAlong != 0.5 and 'preFractionAlong' not in already_processed:
            already_processed.add('preFractionAlong')
            outfile.write(' preFractionAlong="%s"' % self.gds_format_float(self.preFractionAlong, input_name='preFractionAlong'))
        if self.postCellId is not None and 'postCellId' not in already_processed:
            already_processed.add('postCellId')
            outfile.write(' postCellId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.postCellId), input_name='postCellId')), ))
        if self.postSegmentId != 0 and 'postSegmentId' not in already_processed:
            already_processed.add('postSegmentId')
            outfile.write(' postSegmentId="%s"' % self.gds_format_integer(self.postSegmentId, input_name='postSegmentId'))
        if self.postFractionAlong != 0.5 and 'postFractionAlong' not in already_processed:
            already_processed.add('postFractionAlong')
            outfile.write(' postFractionAlong="%s"' % self.gds_format_float(self.postFractionAlong, input_name='postFractionAlong'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseConnectionOldFormat', fromsubclass_=False, pretty_print=True):
        super(BaseConnectionOldFormat, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('preCellId', node)
        if value is not None and 'preCellId' not in already_processed:
            already_processed.add('preCellId')
            self.preCellId = value
        value = find_attr_value_('preSegmentId', node)
        if value is not None and 'preSegmentId' not in already_processed:
            already_processed.add('preSegmentId')
            self.preSegmentId = self.gds_parse_integer(value, node, 'preSegmentId')
            if self.preSegmentId < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.preSegmentId)    # validate type NonNegativeInteger
        value = find_attr_value_('preFractionAlong', node)
        if value is not None and 'preFractionAlong' not in already_processed:
            already_processed.add('preFractionAlong')
            value = self.gds_parse_float(value, node, 'preFractionAlong')
            self.preFractionAlong = value
            self.validate_ZeroToOne(self.preFractionAlong)    # validate type ZeroToOne
        value = find_attr_value_('postCellId', node)
        if value is not None and 'postCellId' not in already_processed:
            already_processed.add('postCellId')
            self.postCellId = value
        value = find_attr_value_('postSegmentId', node)
        if value is not None and 'postSegmentId' not in already_processed:
            already_processed.add('postSegmentId')
            self.postSegmentId = self.gds_parse_integer(value, node, 'postSegmentId')
            if self.postSegmentId < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
            self.validate_NonNegativeInteger(self.postSegmentId)    # validate type NonNegativeInteger
        value = find_attr_value_('postFractionAlong', node)
        if value is not None and 'postFractionAlong' not in already_processed:
            already_processed.add('postFractionAlong')
            value = self.gds_parse_float(value, node, 'postFractionAlong')
            self.postFractionAlong = value
            self.validate_ZeroToOne(self.postFractionAlong)    # validate type ZeroToOne
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseConnectionOldFormat, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BaseConnectionOldFormat, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseConnectionOldFormat


class Projection(BaseProjection):
    """Projection (set of synaptic connections) between two populations.
    Chemical/event based synaptic transmission"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('synapse', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('connection', 'Connection', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'connection', 'type': 'Connection'}, None),
        MemberSpec_('connectionWD', 'ConnectionWD', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'connectionWD', 'type': 'ConnectionWD'}, None),
    ]
    subclass = None
    superclass = BaseProjection
    def __init__(self, neuroLexId=None, id=None, presynapticPopulation=None, postsynapticPopulation=None, synapse=None, connection=None, connectionWD=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Projection, self).__init__(neuroLexId, id, presynapticPopulation, postsynapticPopulation,  **kwargs_)
        self.synapse = _cast(None, synapse)
        self.synapse_nsprefix_ = None
        if connection is None:
            self.connection = []
        else:
            self.connection = connection
        self.connection_nsprefix_ = None
        if connectionWD is None:
            self.connectionWD = []
        else:
            self.connectionWD = connectionWD
        self.connectionWD_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Projection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Projection.subclass:
            return Projection.subclass(*args_, **kwargs_)
        else:
            return Projection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            self.connection or
            self.connectionWD or
            super(Projection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Projection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Projection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Projection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Projection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Projection'):
        super(Projection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Projection')
        if self.synapse is not None and 'synapse' not in already_processed:
            already_processed.add('synapse')
            outfile.write(' synapse=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.synapse), input_name='synapse')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Projection', fromsubclass_=False, pretty_print=True):
        super(Projection, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for connection_ in self.connection:
            namespaceprefix_ = self.connection_nsprefix_ + ':' if (UseCapturedNS_ and self.connection_nsprefix_) else ''
            connection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='connection', pretty_print=pretty_print)
        for connectionWD_ in self.connectionWD:
            namespaceprefix_ = self.connectionWD_nsprefix_ + ':' if (UseCapturedNS_ and self.connectionWD_nsprefix_) else ''
            connectionWD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='connectionWD', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('synapse', node)
        if value is not None and 'synapse' not in already_processed:
            already_processed.add('synapse')
            self.synapse = value
            self.validate_NmlId(self.synapse)    # validate type NmlId
        super(Projection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'connection':
            obj_ = Connection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.connection.append(obj_)
            obj_.original_tagname_ = 'connection'
        elif nodeName_ == 'connectionWD':
            obj_ = ConnectionWD.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.connectionWD.append(obj_)
            obj_.original_tagname_ = 'connectionWD'
        super(Projection, self).buildChildren(child_, node, nodeName_, True)

    def exportHdf5(self, h5file, h5Group):
        #print("Exporting Projection: "+str(self.id)+" as HDF5")
        

        import numpy

        projGroup = h5file.create_group(h5Group, 'projection_'+self.id)
        projGroup._f_setattr("id", self.id)
        projGroup._f_setattr("type", "projection")
        projGroup._f_setattr("presynapticPopulation", self.presynaptic_population)
        projGroup._f_setattr("postsynapticPopulation", self.postsynaptic_population)
        projGroup._f_setattr("synapse", self.synapse)

        #print("Exporting "+str(len(self.connections))+" connections, "+str(len(self.connection_wds))+" connections with weight")

        connection_wds = len(self.connection_wds) > 0

        cols = 2

        extra_cols = {}

        from neuroml.utils import has_segment_fraction_info

        include_segment_fraction = has_segment_fraction_info(self.connections) or has_segment_fraction_info(self.connection_wds)

        if include_segment_fraction:
            extra_cols["column_"+str(cols)] = "pre_segment_id"
            extra_cols["column_"+str(cols+1)] = "post_segment_id"
            extra_cols["column_"+str(cols+2)] = "pre_fraction_along"
            extra_cols["column_"+str(cols+3)] = "post_fraction_along"
            cols +=4


        if connection_wds:
            extra_cols["column_"+str(cols)] = "weight"
            extra_cols["column_"+str(cols+1)] = "delay"
            cols+=2

        a = numpy.zeros([len(self.connections)+len(self.connection_wds), cols], numpy.float32)

        count=0

        for connection in self.connections:
          ####a[count,0] = connection.id
          a[count,0] = connection.get_pre_cell_id()
          a[count,1] = connection.get_post_cell_id()
          if include_segment_fraction:
            a[count,2] = connection.pre_segment_id
            a[count,3] = connection.post_segment_id
            a[count,4] = connection.pre_fraction_along
            a[count,5] = connection.post_fraction_along
          count=count+1

        for connection in self.connection_wds:
          ###a[count,0] = connection.id
          a[count,0] = connection.get_pre_cell_id()
          a[count,1] = connection.get_post_cell_id()

          if include_segment_fraction:
            a[count,2] = connection.pre_segment_id
            a[count,3] = connection.post_segment_id
            a[count,4] = connection.pre_fraction_along
            a[count,5] = connection.post_fraction_along

          a[count,cols-2] = connection.weight
          if 'ms' in connection.delay:
            delay = float(connection.delay[:-2].strip())
          elif 's' in connection.delay:
            delay = float(connection.delay[:-1].strip())*1000.
          elif 'us' in connection.delay:
            delay = float(connection.delay[:-2].strip())/1e3

          a[count,cols-1] = delay
          count=count+1

        if len(a)>0:
            array = h5file.create_carray(projGroup, self.id, obj=a, title="Connections of cells in "+ self.id)

            ###array._f_setattr("column_0", "id")
            array._f_setattr("column_0", "pre_cell_id")
            array._f_setattr("column_1", "post_cell_id")

            for col in extra_cols.keys():
                array._f_setattr(col,extra_cols[col])


    def __str__(self):
        return "Projection: "+self.id+" from "+self.presynaptic_population+" to "+self.postsynaptic_population+", synapse: "+self.synapse




    # end class Projection


class SpikeGeneratorRefPoisson(SpikeGeneratorPoisson):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('minimumISI', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = SpikeGeneratorPoisson
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, averageRate=None, minimumISI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpikeGeneratorRefPoisson, self).__init__(neuroLexId, id, metaid, notes, property, annotation, averageRate,  **kwargs_)
        self.minimumISI = _cast(None, minimumISI)
        self.minimumISI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpikeGeneratorRefPoisson)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpikeGeneratorRefPoisson.subclass:
            return SpikeGeneratorRefPoisson.subclass(*args_, **kwargs_)
        else:
            return SpikeGeneratorRefPoisson(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (
            super(SpikeGeneratorRefPoisson, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeGeneratorRefPoisson', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpikeGeneratorRefPoisson')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeGeneratorRefPoisson')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpikeGeneratorRefPoisson', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpikeGeneratorRefPoisson'):
        super(SpikeGeneratorRefPoisson, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpikeGeneratorRefPoisson')
        if self.minimumISI is not None and 'minimumISI' not in already_processed:
            already_processed.add('minimumISI')
            outfile.write(' minimumISI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.minimumISI), input_name='minimumISI')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpikeGeneratorRefPoisson', fromsubclass_=False, pretty_print=True):
        super(SpikeGeneratorRefPoisson, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimumISI', node)
        if value is not None and 'minimumISI' not in already_processed:
            already_processed.add('minimumISI')
            self.minimumISI = value
            self.validate_Nml2Quantity_time(self.minimumISI)    # validate type Nml2Quantity_time
        super(SpikeGeneratorRefPoisson, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SpikeGeneratorRefPoisson, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SpikeGeneratorRefPoisson


class ConcentrationModel_D(DecayingPoolConcentrationModel):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('type_', 'xs:string', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = DecayingPoolConcentrationModel
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, ion=None, restingConc=None, decayConstant=None, shellThickness=None, type_='decayingPoolConcentrationModel', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ConcentrationModel_D, self).__init__(neuroLexId, id, metaid, notes, property, annotation, ion, restingConc, decayConstant, shellThickness,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConcentrationModel_D)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConcentrationModel_D.subclass:
            return ConcentrationModel_D.subclass(*args_, **kwargs_)
        else:
            return ConcentrationModel_D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ConcentrationModel_D, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConcentrationModel_D', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConcentrationModel_D')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConcentrationModel_D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConcentrationModel_D', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConcentrationModel_D'):
        super(ConcentrationModel_D, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConcentrationModel_D')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConcentrationModel_D', fromsubclass_=False, pretty_print=True):
        super(ConcentrationModel_D, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(ConcentrationModel_D, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ConcentrationModel_D, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ConcentrationModel_D


class ChannelDensityNernstCa2(ChannelDensityNernst):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = ChannelDensityNernst
    def __init__(self, neuroLexId=None, id=None, ionChannel=None, condDensity=None, segmentGroup='all', segment=None, ion=None, variableParameter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ChannelDensityNernstCa2, self).__init__(neuroLexId, id, ionChannel, condDensity, segmentGroup, segment, ion, variableParameter,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityNernstCa2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityNernstCa2.subclass:
            return ChannelDensityNernstCa2.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityNernstCa2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ChannelDensityNernstCa2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityNernstCa2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelDensityNernstCa2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityNernstCa2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChannelDensityNernstCa2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChannelDensityNernstCa2'):
        super(ChannelDensityNernstCa2, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityNernstCa2')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityNernstCa2', fromsubclass_=False, pretty_print=True):
        super(ChannelDensityNernstCa2, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ChannelDensityNernstCa2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ChannelDensityNernstCa2, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ChannelDensityNernstCa2


class ChannelDensityVShift(ChannelDensity):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('vShift', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = ChannelDensity
    def __init__(self, neuroLexId=None, id=None, ionChannel=None, condDensity=None, erev=None, segmentGroup='all', segment=None, ion=None, variableParameter=None, vShift=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ChannelDensityVShift, self).__init__(neuroLexId, id, ionChannel, condDensity, erev, segmentGroup, segment, ion, variableParameter,  **kwargs_)
        self.vShift = _cast(None, vShift)
        self.vShift_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelDensityVShift)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelDensityVShift.subclass:
            return ChannelDensityVShift.subclass(*args_, **kwargs_)
        else:
            return ChannelDensityVShift(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def hasContent_(self):
        if (
            super(ChannelDensityVShift, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityVShift', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelDensityVShift')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityVShift')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChannelDensityVShift', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChannelDensityVShift'):
        super(ChannelDensityVShift, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChannelDensityVShift')
        if self.vShift is not None and 'vShift' not in already_processed:
            already_processed.add('vShift')
            outfile.write(' vShift=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vShift), input_name='vShift')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChannelDensityVShift', fromsubclass_=False, pretty_print=True):
        super(ChannelDensityVShift, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vShift', node)
        if value is not None and 'vShift' not in already_processed:
            already_processed.add('vShift')
            self.vShift = value
            self.validate_Nml2Quantity_voltage(self.vShift)    # validate type Nml2Quantity_voltage
        super(ChannelDensityVShift, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ChannelDensityVShift, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ChannelDensityVShift


class Cell(BaseCell):
    """Should only be used if morphology element is outside the cell.
    This points to the id of the morphology
    Should only be used if biophysicalProperties element is outside the cell.
    This points to the id of the biophysicalProperties"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('morphology_attr', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('biophysicalProperties_attr', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('morphology', 'Morphology', 0, 1, {'minOccurs': '0', 'name': 'morphology', 'type': 'Morphology'}, None),
        MemberSpec_('biophysicalProperties', 'BiophysicalProperties', 0, 1, {'minOccurs': '0', 'name': 'biophysicalProperties', 'type': 'BiophysicalProperties'}, None),
    ]
    subclass = None
    superclass = BaseCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, morphology_attr=None, biophysicalProperties_attr=None, morphology=None, biophysicalProperties=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Cell, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.morphology_attr = _cast(None, morphology_attr)
        self.morphology_attr_nsprefix_ = None
        self.biophysicalProperties_attr = _cast(None, biophysicalProperties_attr)
        self.biophysicalProperties_attr_nsprefix_ = None
        self.morphology = morphology
        self.morphology_nsprefix_ = None
        self.biophysicalProperties = biophysicalProperties
        self.biophysicalProperties_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cell.subclass:
            return Cell.subclass(*args_, **kwargs_)
        else:
            return Cell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            self.morphology is not None or
            self.biophysicalProperties is not None or
            super(Cell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Cell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Cell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Cell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Cell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Cell'):
        super(Cell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Cell')
        if self.morphology_attr is not None and 'morphology_attr' not in already_processed:
            already_processed.add('morphology_attr')
            outfile.write(' morphology=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.morphology_attr), input_name='morphology_attr')), ))
        if self.biophysicalProperties_attr is not None and 'biophysicalProperties_attr' not in already_processed:
            already_processed.add('biophysicalProperties_attr')
            outfile.write(' biophysicalProperties=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.biophysicalProperties_attr), input_name='biophysicalProperties_attr')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Cell', fromsubclass_=False, pretty_print=True):
        super(Cell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.morphology is not None:
            namespaceprefix_ = self.morphology_nsprefix_ + ':' if (UseCapturedNS_ and self.morphology_nsprefix_) else ''
            self.morphology.export(outfile, level, namespaceprefix_, namespacedef_='', name_='morphology', pretty_print=pretty_print)
        if self.biophysicalProperties is not None:
            namespaceprefix_ = self.biophysicalProperties_nsprefix_ + ':' if (UseCapturedNS_ and self.biophysicalProperties_nsprefix_) else ''
            self.biophysicalProperties.export(outfile, level, namespaceprefix_, namespacedef_='', name_='biophysicalProperties', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('morphology', node)
        if value is not None and 'morphology_attr' not in already_processed:
            already_processed.add('morphology_attr')
            self.morphology_attr = value
            self.validate_NmlId(self.morphology_attr)    # validate type NmlId
        value = find_attr_value_('biophysicalProperties', node)
        if value is not None and 'biophysicalProperties_attr' not in already_processed:
            already_processed.add('biophysicalProperties_attr')
            self.biophysicalProperties_attr = value
            self.validate_NmlId(self.biophysicalProperties_attr)    # validate type NmlId
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Cell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'morphology':
            obj_ = Morphology.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.morphology = obj_
            obj_.original_tagname_ = 'morphology'
        elif nodeName_ == 'biophysicalProperties':
            obj_ = BiophysicalProperties.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.biophysicalProperties = obj_
            obj_.original_tagname_ = 'biophysicalProperties'
        super(Cell, self).buildChildren(child_, node, nodeName_, True)


    # Get segment object by its id
    def get_segment(self, segment_id):
        """Get segment object by its id

        :param segment_id: ID of segment
        :return: segment

        :raises Exception: if the segment is not found in the cell
        """

        for segment in self.morphology.segments:
            if segment.id == segment_id:
                return segment

        raise Exception("Segment with id "+str(segment_id)+" not found in cell "+str(self.id))

    # Get the proximal point of a segment, even the proximal field is None and
    # so the proximal point is on the parent (at a point set by fraction_along)
    def get_actual_proximal(self, segment_id):

        """Get the proximal point of a segment.

        Get the proximal point of a segment, even the proximal field is None
        and so the proximal point is on the parent (at a point set by
        fraction_along).

        :param segment_id: ID of segment
        :return: proximal point
        """

        segment = self.get_segment(segment_id)
        if segment.proximal:
            return segment.proximal

        parent = self.get_segment(segment.parent.segments)
        fract = float(segment.parent.fraction_along)
        if fract==1:
            return parent.distal
        elif fract==0:
            return self.get_actual_proximal(segment.parent.segments)
        else:
            pd = parent.distal
            pp = self.get_actual_proximal(segment.parent.segments)
            p = Point3DWithDiam((1-fract)*pp.x+fract*pd.x, (1-fract)*pp.y+fract*pd.y, (1-fract)*pp.z+fract*pd.z)
            p.diameter = (1-fract)*pp.diameter+fract*pd.diameter

            return p

    def get_segment_length(self, segment_id):
        """Get the length of the segment.

        :param segment_id: ID of segment
        :return: length of segment
        """

        segment = self.get_segment(segment_id)
        if segment.proximal:
            return segment.length
        else:
            prox = self.get_actual_proximal(segment_id)

            length = segment.distal.distance_to(prox)

            return length

    def get_segment_surface_area(self, segment_id):
        """Get the surface area of the segment.

        :param segment_id: ID of the segment
        :return: surface area of segment
        """

        segment = self.get_segment(segment_id)
        if segment.proximal:
            return segment.surface_area
        else:
            prox = self.get_actual_proximal(segment_id)

            temp_seg = Segment(distal=segment.distal, proximal=prox)

            return temp_seg.surface_area

    def get_segment_volume(self, segment_id):
        """Get volume of segment

        :param segment_id: ID of the segment
        :return: volume of the segment
        """
        segment = self.get_segment(segment_id)
        if segment.proximal:
            return segment.volume
        else:
            prox = self.get_actual_proximal(segment_id)

            temp_seg = Segment(distal=segment.distal, proximal=prox)

            return temp_seg.volume

    def get_segment_ids_vs_segments(self):
        """Get a dictionary of segment IDs and the segments in the cell.

        :return: dictionary with segment ID as key, and segment as value
        """

        segments = {}
        for segment in self.morphology.segments:
            segments[segment.id] = segment

        return segments

    def get_all_segments_in_group(self,
                                  segment_group,
                                  assume_all_means_all=True):
        """Get all the segments in a segment group of the cell.

        :param segment_group: segment group to get all segments of
        :param assume_all_means_all: return all segments if the segment group
            wasn't explicitly defined

        :todo: check docstring

        :return: list of segments

        :raises Exception: if no segment group is found in the cell.
        """

        if isinstance(segment_group, str):
            for sg in self.morphology.segment_groups:
                if sg.id == segment_group:
                    segment_group = sg
            if isinstance(segment_group, str):

                if assume_all_means_all and segment_group=='all': # i.e. wasn't explicitly defined, but assume it means all segments
                    return [seg.id for seg in self.morphology.segments]

                raise Exception('No segment group '+segment_group+ ' found in cell '+self.id)

        all_segs = []

        for member in segment_group.members:
            if not member.segments in all_segs:
                all_segs.append(member.segments)


        for include in segment_group.includes:
            segs_here = self.get_all_segments_in_group(include.segment_groups)
            for s in segs_here:
                if not s in all_segs:
                    all_segs.append(s)

        return all_segs


    def get_ordered_segments_in_groups(self,
                                       group_list,
                                       check_parentage=False,
                                       include_cumulative_lengths=False,
                                       include_path_lengths=False,
                                       path_length_metric="Path Length from root"): # Only option supported
        """
        Get ordered list of segments in specified groups

        :param group_list: list of groups to get segments from
        :param check_parentage: verify parentage
        :param include_commulative_lengths: also include cummulative lengths
        :param include_path_lengths: also include path lengths
        :param path_length_metric:

        :return: dictionary of segments with additional information depending
            on what parameters were used:

        :raises: Exception if check_parentage is True and parentage cannot be verified
        """

        unord_segs = {}
        other_segs = {}

        if isinstance(group_list, str):
            group_list = [group_list]

        segments = self.get_segment_ids_vs_segments()

        for sg in self.morphology.segment_groups:
            all_segs_here = self.get_all_segments_in_group(sg)

            if sg.id in group_list:
                unord_segs[sg.id] = [segments[s] for s in all_segs_here]
            else:
                other_segs[sg.id] = [segments[s] for s in all_segs_here]

        ord_segs = {}

        from operator import attrgetter
        for key in unord_segs.keys():
            segs = unord_segs[key]
            if len(segs)==1 or len(segs)==0:
                ord_segs[key]=segs
            else:
                ord_segs[key]=sorted(segs,key=attrgetter('id'),reverse=False)

        if check_parentage:
            # check parent ordering

            for key in ord_segs.keys():
                existing_ids = []
                for s in ord_segs[key]:
                    if s.id != ord_segs[key][0].id:
                        if not s.parent or not s.parent.segments in existing_ids:
                            raise Exception("Problem with finding parent of seg: "+str(s)+" in list: "+str(ord_segs))
                    existing_ids.append(s.id)


        if include_cumulative_lengths or include_path_lengths:
            import math

            cumulative_lengths = {}
            path_lengths_to_proximal = {}
            path_lengths_to_distal = {}

            for key in ord_segs.keys():
                cumulative_lengths[key] = []
                path_lengths_to_proximal[key] = {}
                path_lengths_to_distal[key] = {}

                tot_len = 0
                for seg in ord_segs[key]:

                    length = self.get_segment_length(seg.id)

                    if not seg.parent or not seg.parent.segments in path_lengths_to_distal[key]:

                        path_lengths_to_proximal[key][seg.id] = 0
                        last_seg = seg
                        par_seg_element = seg.parent
                        while par_seg_element!=None:

                            par_seg = segments[par_seg_element.segments]
                            d = par_seg.distal
                            p = par_seg.proximal

                            if not p:
                                par_seg_parent_seg = segments[par_seg.parent.segments]
                                p = par_seg_parent_seg.distal

                            par_length = math.sqrt( (d.x-p.x)**2 + (d.y-p.y)**2 + (d.z-p.z)**2 )

                            fract = float(last_seg.parent.fraction_along)
                            path_lengths_to_proximal[key][seg.id] += par_length*fract

                            last_seg = par_seg
                            par_seg_element = par_seg.parent


                    else:
                        pd = path_lengths_to_distal[key][seg.parent.segments]
                        pp = path_lengths_to_proximal[key][seg.parent.segments]
                        fract = float(seg.parent.fraction_along)

                        path_lengths_to_proximal[key][seg.id] = pp + (pd - pp)*fract

                    path_lengths_to_distal[key][seg.id] = path_lengths_to_proximal[key][seg.id] + length

                    tot_len += length
                    cumulative_lengths[key].append(tot_len)


        if include_path_lengths and not include_cumulative_lengths:

            return ord_segs, path_lengths_to_proximal, path_lengths_to_distal

        if include_cumulative_lengths and not include_path_lengths:

            return ord_segs, cumulative_lengths

        if include_cumulative_lengths and include_path_lengths:

            return ord_segs, cumulative_lengths, path_lengths_to_proximal, path_lengths_to_distal

        return ord_segs



    def summary(self):
        """Print cell summary."""
        print("*******************************************************")
        print("* Cell: "+str(self.id))
        print("* Notes: "+str(self.notes))
        print("* Segments: "+str(len(self.morphology.segments)))
        print("* SegmentGroups: "+str(len(self.morphology.segment_groups)))
        print("*******************************************************")

    # end class Cell


class PinskyRinzelCA3Cell(BaseCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('iSoma', 'Nml2Quantity_currentDensity', 0, 0, {'use': 'required'}),
        MemberSpec_('iDend', 'Nml2Quantity_currentDensity', 0, 0, {'use': 'required'}),
        MemberSpec_('gc', 'Nml2Quantity_conductanceDensity', 0, 0, {'use': 'required'}),
        MemberSpec_('gLs', 'Nml2Quantity_conductanceDensity', 0, 0, {'use': 'required'}),
        MemberSpec_('gLd', 'Nml2Quantity_conductanceDensity', 0, 0, {'use': 'required'}),
        MemberSpec_('gNa', 'Nml2Quantity_conductanceDensity', 0, 0, {'use': 'required'}),
        MemberSpec_('gKdr', 'Nml2Quantity_conductanceDensity', 0, 0, {'use': 'required'}),
        MemberSpec_('gCa', 'Nml2Quantity_conductanceDensity', 0, 0, {'use': 'required'}),
        MemberSpec_('gKahp', 'Nml2Quantity_conductanceDensity', 0, 0, {'use': 'required'}),
        MemberSpec_('gKC', 'Nml2Quantity_conductanceDensity', 0, 0, {'use': 'required'}),
        MemberSpec_('gNmda', 'Nml2Quantity_conductanceDensity', 0, 0, {'use': 'required'}),
        MemberSpec_('gAmpa', 'Nml2Quantity_conductanceDensity', 0, 0, {'use': 'required'}),
        MemberSpec_('eNa', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('eCa', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('eK', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('eL', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('qd0', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('pp', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('alphac', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('betac', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('cm', 'Nml2Quantity_specificCapacitance', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, iSoma=None, iDend=None, gc=None, gLs=None, gLd=None, gNa=None, gKdr=None, gCa=None, gKahp=None, gKC=None, gNmda=None, gAmpa=None, eNa=None, eCa=None, eK=None, eL=None, qd0=None, pp=None, alphac=None, betac=None, cm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PinskyRinzelCA3Cell, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.iSoma = _cast(None, iSoma)
        self.iSoma_nsprefix_ = None
        self.iDend = _cast(None, iDend)
        self.iDend_nsprefix_ = None
        self.gc = _cast(None, gc)
        self.gc_nsprefix_ = None
        self.gLs = _cast(None, gLs)
        self.gLs_nsprefix_ = None
        self.gLd = _cast(None, gLd)
        self.gLd_nsprefix_ = None
        self.gNa = _cast(None, gNa)
        self.gNa_nsprefix_ = None
        self.gKdr = _cast(None, gKdr)
        self.gKdr_nsprefix_ = None
        self.gCa = _cast(None, gCa)
        self.gCa_nsprefix_ = None
        self.gKahp = _cast(None, gKahp)
        self.gKahp_nsprefix_ = None
        self.gKC = _cast(None, gKC)
        self.gKC_nsprefix_ = None
        self.gNmda = _cast(None, gNmda)
        self.gNmda_nsprefix_ = None
        self.gAmpa = _cast(None, gAmpa)
        self.gAmpa_nsprefix_ = None
        self.eNa = _cast(None, eNa)
        self.eNa_nsprefix_ = None
        self.eCa = _cast(None, eCa)
        self.eCa_nsprefix_ = None
        self.eK = _cast(None, eK)
        self.eK_nsprefix_ = None
        self.eL = _cast(None, eL)
        self.eL_nsprefix_ = None
        self.qd0 = _cast(None, qd0)
        self.qd0_nsprefix_ = None
        self.pp = _cast(None, pp)
        self.pp_nsprefix_ = None
        self.alphac = _cast(None, alphac)
        self.alphac_nsprefix_ = None
        self.betac = _cast(None, betac)
        self.betac_nsprefix_ = None
        self.cm = _cast(None, cm)
        self.cm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PinskyRinzelCA3Cell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PinskyRinzelCA3Cell.subclass:
            return PinskyRinzelCA3Cell.subclass(*args_, **kwargs_)
        else:
            return PinskyRinzelCA3Cell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_currentDensity(self, value):
        # Validate type Nml2Quantity_currentDensity, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_currentDensity_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_currentDensity_patterns_, ))
    validate_Nml2Quantity_currentDensity_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A_per_m2|uA_per_cm2|mA_per_cm2))$']]
    def validate_Nml2Quantity_conductanceDensity(self, value):
        # Validate type Nml2Quantity_conductanceDensity, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductanceDensity_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductanceDensity_patterns_, ))
    validate_Nml2Quantity_conductanceDensity_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S_per_m2|mS_per_cm2|S_per_cm2))$']]
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_none_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_none_patterns_, ))
    validate_Nml2Quantity_none_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$']]
    def validate_Nml2Quantity_specificCapacitance(self, value):
        # Validate type Nml2Quantity_specificCapacitance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_specificCapacitance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_specificCapacitance_patterns_, ))
    validate_Nml2Quantity_specificCapacitance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(F_per_m2|uF_per_cm2))$']]
    def hasContent_(self):
        if (
            super(PinskyRinzelCA3Cell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PinskyRinzelCA3Cell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PinskyRinzelCA3Cell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PinskyRinzelCA3Cell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PinskyRinzelCA3Cell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PinskyRinzelCA3Cell'):
        super(PinskyRinzelCA3Cell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PinskyRinzelCA3Cell')
        if self.iSoma is not None and 'iSoma' not in already_processed:
            already_processed.add('iSoma')
            outfile.write(' iSoma=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.iSoma), input_name='iSoma')), ))
        if self.iDend is not None and 'iDend' not in already_processed:
            already_processed.add('iDend')
            outfile.write(' iDend=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.iDend), input_name='iDend')), ))
        if self.gc is not None and 'gc' not in already_processed:
            already_processed.add('gc')
            outfile.write(' gc=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gc), input_name='gc')), ))
        if self.gLs is not None and 'gLs' not in already_processed:
            already_processed.add('gLs')
            outfile.write(' gLs=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gLs), input_name='gLs')), ))
        if self.gLd is not None and 'gLd' not in already_processed:
            already_processed.add('gLd')
            outfile.write(' gLd=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gLd), input_name='gLd')), ))
        if self.gNa is not None and 'gNa' not in already_processed:
            already_processed.add('gNa')
            outfile.write(' gNa=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gNa), input_name='gNa')), ))
        if self.gKdr is not None and 'gKdr' not in already_processed:
            already_processed.add('gKdr')
            outfile.write(' gKdr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gKdr), input_name='gKdr')), ))
        if self.gCa is not None and 'gCa' not in already_processed:
            already_processed.add('gCa')
            outfile.write(' gCa=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gCa), input_name='gCa')), ))
        if self.gKahp is not None and 'gKahp' not in already_processed:
            already_processed.add('gKahp')
            outfile.write(' gKahp=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gKahp), input_name='gKahp')), ))
        if self.gKC is not None and 'gKC' not in already_processed:
            already_processed.add('gKC')
            outfile.write(' gKC=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gKC), input_name='gKC')), ))
        if self.gNmda is not None and 'gNmda' not in already_processed:
            already_processed.add('gNmda')
            outfile.write(' gNmda=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gNmda), input_name='gNmda')), ))
        if self.gAmpa is not None and 'gAmpa' not in already_processed:
            already_processed.add('gAmpa')
            outfile.write(' gAmpa=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gAmpa), input_name='gAmpa')), ))
        if self.eNa is not None and 'eNa' not in already_processed:
            already_processed.add('eNa')
            outfile.write(' eNa=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.eNa), input_name='eNa')), ))
        if self.eCa is not None and 'eCa' not in already_processed:
            already_processed.add('eCa')
            outfile.write(' eCa=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.eCa), input_name='eCa')), ))
        if self.eK is not None and 'eK' not in already_processed:
            already_processed.add('eK')
            outfile.write(' eK=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.eK), input_name='eK')), ))
        if self.eL is not None and 'eL' not in already_processed:
            already_processed.add('eL')
            outfile.write(' eL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.eL), input_name='eL')), ))
        if self.qd0 is not None and 'qd0' not in already_processed:
            already_processed.add('qd0')
            outfile.write(' qd0=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.qd0), input_name='qd0')), ))
        if self.pp is not None and 'pp' not in already_processed:
            already_processed.add('pp')
            outfile.write(' pp=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pp), input_name='pp')), ))
        if self.alphac is not None and 'alphac' not in already_processed:
            already_processed.add('alphac')
            outfile.write(' alphac=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alphac), input_name='alphac')), ))
        if self.betac is not None and 'betac' not in already_processed:
            already_processed.add('betac')
            outfile.write(' betac=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.betac), input_name='betac')), ))
        if self.cm is not None and 'cm' not in already_processed:
            already_processed.add('cm')
            outfile.write(' cm=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cm), input_name='cm')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PinskyRinzelCA3Cell', fromsubclass_=False, pretty_print=True):
        super(PinskyRinzelCA3Cell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iSoma', node)
        if value is not None and 'iSoma' not in already_processed:
            already_processed.add('iSoma')
            self.iSoma = value
            self.validate_Nml2Quantity_currentDensity(self.iSoma)    # validate type Nml2Quantity_currentDensity
        value = find_attr_value_('iDend', node)
        if value is not None and 'iDend' not in already_processed:
            already_processed.add('iDend')
            self.iDend = value
            self.validate_Nml2Quantity_currentDensity(self.iDend)    # validate type Nml2Quantity_currentDensity
        value = find_attr_value_('gc', node)
        if value is not None and 'gc' not in already_processed:
            already_processed.add('gc')
            self.gc = value
            self.validate_Nml2Quantity_conductanceDensity(self.gc)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('gLs', node)
        if value is not None and 'gLs' not in already_processed:
            already_processed.add('gLs')
            self.gLs = value
            self.validate_Nml2Quantity_conductanceDensity(self.gLs)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('gLd', node)
        if value is not None and 'gLd' not in already_processed:
            already_processed.add('gLd')
            self.gLd = value
            self.validate_Nml2Quantity_conductanceDensity(self.gLd)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('gNa', node)
        if value is not None and 'gNa' not in already_processed:
            already_processed.add('gNa')
            self.gNa = value
            self.validate_Nml2Quantity_conductanceDensity(self.gNa)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('gKdr', node)
        if value is not None and 'gKdr' not in already_processed:
            already_processed.add('gKdr')
            self.gKdr = value
            self.validate_Nml2Quantity_conductanceDensity(self.gKdr)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('gCa', node)
        if value is not None and 'gCa' not in already_processed:
            already_processed.add('gCa')
            self.gCa = value
            self.validate_Nml2Quantity_conductanceDensity(self.gCa)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('gKahp', node)
        if value is not None and 'gKahp' not in already_processed:
            already_processed.add('gKahp')
            self.gKahp = value
            self.validate_Nml2Quantity_conductanceDensity(self.gKahp)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('gKC', node)
        if value is not None and 'gKC' not in already_processed:
            already_processed.add('gKC')
            self.gKC = value
            self.validate_Nml2Quantity_conductanceDensity(self.gKC)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('gNmda', node)
        if value is not None and 'gNmda' not in already_processed:
            already_processed.add('gNmda')
            self.gNmda = value
            self.validate_Nml2Quantity_conductanceDensity(self.gNmda)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('gAmpa', node)
        if value is not None and 'gAmpa' not in already_processed:
            already_processed.add('gAmpa')
            self.gAmpa = value
            self.validate_Nml2Quantity_conductanceDensity(self.gAmpa)    # validate type Nml2Quantity_conductanceDensity
        value = find_attr_value_('eNa', node)
        if value is not None and 'eNa' not in already_processed:
            already_processed.add('eNa')
            self.eNa = value
            self.validate_Nml2Quantity_voltage(self.eNa)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('eCa', node)
        if value is not None and 'eCa' not in already_processed:
            already_processed.add('eCa')
            self.eCa = value
            self.validate_Nml2Quantity_voltage(self.eCa)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('eK', node)
        if value is not None and 'eK' not in already_processed:
            already_processed.add('eK')
            self.eK = value
            self.validate_Nml2Quantity_voltage(self.eK)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('eL', node)
        if value is not None and 'eL' not in already_processed:
            already_processed.add('eL')
            self.eL = value
            self.validate_Nml2Quantity_voltage(self.eL)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('qd0', node)
        if value is not None and 'qd0' not in already_processed:
            already_processed.add('qd0')
            self.qd0 = value
            self.validate_Nml2Quantity_none(self.qd0)    # validate type Nml2Quantity_none
        value = find_attr_value_('pp', node)
        if value is not None and 'pp' not in already_processed:
            already_processed.add('pp')
            self.pp = value
            self.validate_Nml2Quantity_none(self.pp)    # validate type Nml2Quantity_none
        value = find_attr_value_('alphac', node)
        if value is not None and 'alphac' not in already_processed:
            already_processed.add('alphac')
            self.alphac = value
            self.validate_Nml2Quantity_none(self.alphac)    # validate type Nml2Quantity_none
        value = find_attr_value_('betac', node)
        if value is not None and 'betac' not in already_processed:
            already_processed.add('betac')
            self.betac = value
            self.validate_Nml2Quantity_none(self.betac)    # validate type Nml2Quantity_none
        value = find_attr_value_('cm', node)
        if value is not None and 'cm' not in already_processed:
            already_processed.add('cm')
            self.cm = value
            self.validate_Nml2Quantity_specificCapacitance(self.cm)    # validate type Nml2Quantity_specificCapacitance
        super(PinskyRinzelCA3Cell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PinskyRinzelCA3Cell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PinskyRinzelCA3Cell


class FitzHughNagumo1969Cell(BaseCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('a', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('b', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('I', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('phi', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('V0', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('W0', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, a=None, b=None, I=None, phi=None, V0=None, W0=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FitzHughNagumo1969Cell, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.a = _cast(None, a)
        self.a_nsprefix_ = None
        self.b = _cast(None, b)
        self.b_nsprefix_ = None
        self.I = _cast(None, I)
        self.I_nsprefix_ = None
        self.phi = _cast(None, phi)
        self.phi_nsprefix_ = None
        self.V0 = _cast(None, V0)
        self.V0_nsprefix_ = None
        self.W0 = _cast(None, W0)
        self.W0_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FitzHughNagumo1969Cell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FitzHughNagumo1969Cell.subclass:
            return FitzHughNagumo1969Cell.subclass(*args_, **kwargs_)
        else:
            return FitzHughNagumo1969Cell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_none_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_none_patterns_, ))
    validate_Nml2Quantity_none_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$']]
    def hasContent_(self):
        if (
            super(FitzHughNagumo1969Cell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FitzHughNagumo1969Cell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FitzHughNagumo1969Cell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FitzHughNagumo1969Cell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FitzHughNagumo1969Cell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FitzHughNagumo1969Cell'):
        super(FitzHughNagumo1969Cell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FitzHughNagumo1969Cell')
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.a), input_name='a')), ))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.b), input_name='b')), ))
        if self.I is not None and 'I' not in already_processed:
            already_processed.add('I')
            outfile.write(' I=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.I), input_name='I')), ))
        if self.phi is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            outfile.write(' phi=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.phi), input_name='phi')), ))
        if self.V0 is not None and 'V0' not in already_processed:
            already_processed.add('V0')
            outfile.write(' V0=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.V0), input_name='V0')), ))
        if self.W0 is not None and 'W0' not in already_processed:
            already_processed.add('W0')
            outfile.write(' W0=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.W0), input_name='W0')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FitzHughNagumo1969Cell', fromsubclass_=False, pretty_print=True):
        super(FitzHughNagumo1969Cell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            self.a = value
            self.validate_Nml2Quantity_none(self.a)    # validate type Nml2Quantity_none
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            self.b = value
            self.validate_Nml2Quantity_none(self.b)    # validate type Nml2Quantity_none
        value = find_attr_value_('I', node)
        if value is not None and 'I' not in already_processed:
            already_processed.add('I')
            self.I = value
            self.validate_Nml2Quantity_none(self.I)    # validate type Nml2Quantity_none
        value = find_attr_value_('phi', node)
        if value is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            self.phi = value
            self.validate_Nml2Quantity_none(self.phi)    # validate type Nml2Quantity_none
        value = find_attr_value_('V0', node)
        if value is not None and 'V0' not in already_processed:
            already_processed.add('V0')
            self.V0 = value
            self.validate_Nml2Quantity_none(self.V0)    # validate type Nml2Quantity_none
        value = find_attr_value_('W0', node)
        if value is not None and 'W0' not in already_processed:
            already_processed.add('W0')
            self.W0 = value
            self.validate_Nml2Quantity_none(self.W0)    # validate type Nml2Quantity_none
        super(FitzHughNagumo1969Cell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(FitzHughNagumo1969Cell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FitzHughNagumo1969Cell


class FitzHughNagumoCell(BaseCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('I', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, I=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FitzHughNagumoCell, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.I = _cast(None, I)
        self.I_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FitzHughNagumoCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FitzHughNagumoCell.subclass:
            return FitzHughNagumoCell.subclass(*args_, **kwargs_)
        else:
            return FitzHughNagumoCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_none_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_none_patterns_, ))
    validate_Nml2Quantity_none_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$']]
    def hasContent_(self):
        if (
            super(FitzHughNagumoCell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FitzHughNagumoCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FitzHughNagumoCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FitzHughNagumoCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FitzHughNagumoCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FitzHughNagumoCell'):
        super(FitzHughNagumoCell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FitzHughNagumoCell')
        if self.I is not None and 'I' not in already_processed:
            already_processed.add('I')
            outfile.write(' I=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.I), input_name='I')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FitzHughNagumoCell', fromsubclass_=False, pretty_print=True):
        super(FitzHughNagumoCell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('I', node)
        if value is not None and 'I' not in already_processed:
            already_processed.add('I')
            self.I = value
            self.validate_Nml2Quantity_none(self.I)    # validate type Nml2Quantity_none
        super(FitzHughNagumoCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(FitzHughNagumoCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FitzHughNagumoCell


class BaseCellMembPotCap(BaseCell):
    """This is to prevent it conflicting with attribute c (lowercase) e.g. in
    izhikevichCell2007"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('C', 'Nml2Quantity_capacitance', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, C=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseCellMembPotCap, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.C = _cast(None, C)
        self.C_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseCellMembPotCap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseCellMembPotCap.subclass:
            return BaseCellMembPotCap.subclass(*args_, **kwargs_)
        else:
            return BaseCellMembPotCap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_capacitance(self, value):
        # Validate type Nml2Quantity_capacitance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_capacitance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_capacitance_patterns_, ))
    validate_Nml2Quantity_capacitance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(F|uF|nF|pF))$']]
    def hasContent_(self):
        if (
            super(BaseCellMembPotCap, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseCellMembPotCap', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseCellMembPotCap')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseCellMembPotCap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseCellMembPotCap', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseCellMembPotCap'):
        super(BaseCellMembPotCap, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseCellMembPotCap')
        if self.C is not None and 'C' not in already_processed:
            already_processed.add('C')
            outfile.write(' C=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.C), input_name='C')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseCellMembPotCap', fromsubclass_=False, pretty_print=True):
        super(BaseCellMembPotCap, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('C', node)
        if value is not None and 'C' not in already_processed:
            already_processed.add('C')
            self.C = value
            self.validate_Nml2Quantity_capacitance(self.C)    # validate type Nml2Quantity_capacitance
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseCellMembPotCap, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BaseCellMembPotCap, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseCellMembPotCap


class IzhikevichCell(BaseCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('v0', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('thresh', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('a', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('b', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('c', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
        MemberSpec_('d', 'Nml2Quantity_none', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, v0=None, thresh=None, a=None, b=None, c=None, d=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IzhikevichCell, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.v0 = _cast(None, v0)
        self.v0_nsprefix_ = None
        self.thresh = _cast(None, thresh)
        self.thresh_nsprefix_ = None
        self.a = _cast(None, a)
        self.a_nsprefix_ = None
        self.b = _cast(None, b)
        self.b_nsprefix_ = None
        self.c = _cast(None, c)
        self.c_nsprefix_ = None
        self.d = _cast(None, d)
        self.d_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IzhikevichCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IzhikevichCell.subclass:
            return IzhikevichCell.subclass(*args_, **kwargs_)
        else:
            return IzhikevichCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def validate_Nml2Quantity_none(self, value):
        # Validate type Nml2Quantity_none, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_none_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_none_patterns_, ))
    validate_Nml2Quantity_none_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?)$']]
    def hasContent_(self):
        if (
            super(IzhikevichCell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IzhikevichCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IzhikevichCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IzhikevichCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IzhikevichCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IzhikevichCell'):
        super(IzhikevichCell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IzhikevichCell')
        if self.v0 is not None and 'v0' not in already_processed:
            already_processed.add('v0')
            outfile.write(' v0=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.v0), input_name='v0')), ))
        if self.thresh is not None and 'thresh' not in already_processed:
            already_processed.add('thresh')
            outfile.write(' thresh=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.thresh), input_name='thresh')), ))
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.a), input_name='a')), ))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.b), input_name='b')), ))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.c), input_name='c')), ))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.d), input_name='d')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IzhikevichCell', fromsubclass_=False, pretty_print=True):
        super(IzhikevichCell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('v0', node)
        if value is not None and 'v0' not in already_processed:
            already_processed.add('v0')
            self.v0 = value
            self.validate_Nml2Quantity_voltage(self.v0)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('thresh', node)
        if value is not None and 'thresh' not in already_processed:
            already_processed.add('thresh')
            self.thresh = value
            self.validate_Nml2Quantity_voltage(self.thresh)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            self.a = value
            self.validate_Nml2Quantity_none(self.a)    # validate type Nml2Quantity_none
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            self.b = value
            self.validate_Nml2Quantity_none(self.b)    # validate type Nml2Quantity_none
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            self.c = value
            self.validate_Nml2Quantity_none(self.c)    # validate type Nml2Quantity_none
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            self.d = value
            self.validate_Nml2Quantity_none(self.d)    # validate type Nml2Quantity_none
        super(IzhikevichCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IzhikevichCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IzhikevichCell


class IafCell(BaseCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('leakReversal', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('thresh', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('reset', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('C', 'Nml2Quantity_capacitance', 0, 0, {'use': 'required'}),
        MemberSpec_('leakConductance', 'Nml2Quantity_conductance', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, leakReversal=None, thresh=None, reset=None, C=None, leakConductance=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IafCell, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.leakReversal = _cast(None, leakReversal)
        self.leakReversal_nsprefix_ = None
        self.thresh = _cast(None, thresh)
        self.thresh_nsprefix_ = None
        self.reset = _cast(None, reset)
        self.reset_nsprefix_ = None
        self.C = _cast(None, C)
        self.C_nsprefix_ = None
        self.leakConductance = _cast(None, leakConductance)
        self.leakConductance_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IafCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IafCell.subclass:
            return IafCell.subclass(*args_, **kwargs_)
        else:
            return IafCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def validate_Nml2Quantity_capacitance(self, value):
        # Validate type Nml2Quantity_capacitance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_capacitance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_capacitance_patterns_, ))
    validate_Nml2Quantity_capacitance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(F|uF|nF|pF))$']]
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductance_patterns_, ))
    validate_Nml2Quantity_conductance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$']]
    def hasContent_(self):
        if (
            super(IafCell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IafCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IafCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IafCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IafCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IafCell'):
        super(IafCell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IafCell')
        if self.leakReversal is not None and 'leakReversal' not in already_processed:
            already_processed.add('leakReversal')
            outfile.write(' leakReversal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.leakReversal), input_name='leakReversal')), ))
        if self.thresh is not None and 'thresh' not in already_processed:
            already_processed.add('thresh')
            outfile.write(' thresh=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.thresh), input_name='thresh')), ))
        if self.reset is not None and 'reset' not in already_processed:
            already_processed.add('reset')
            outfile.write(' reset=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reset), input_name='reset')), ))
        if self.C is not None and 'C' not in already_processed:
            already_processed.add('C')
            outfile.write(' C=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.C), input_name='C')), ))
        if self.leakConductance is not None and 'leakConductance' not in already_processed:
            already_processed.add('leakConductance')
            outfile.write(' leakConductance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.leakConductance), input_name='leakConductance')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IafCell', fromsubclass_=False, pretty_print=True):
        super(IafCell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('leakReversal', node)
        if value is not None and 'leakReversal' not in already_processed:
            already_processed.add('leakReversal')
            self.leakReversal = value
            self.validate_Nml2Quantity_voltage(self.leakReversal)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('thresh', node)
        if value is not None and 'thresh' not in already_processed:
            already_processed.add('thresh')
            self.thresh = value
            self.validate_Nml2Quantity_voltage(self.thresh)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('reset', node)
        if value is not None and 'reset' not in already_processed:
            already_processed.add('reset')
            self.reset = value
            self.validate_Nml2Quantity_voltage(self.reset)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('C', node)
        if value is not None and 'C' not in already_processed:
            already_processed.add('C')
            self.C = value
            self.validate_Nml2Quantity_capacitance(self.C)    # validate type Nml2Quantity_capacitance
        value = find_attr_value_('leakConductance', node)
        if value is not None and 'leakConductance' not in already_processed:
            already_processed.add('leakConductance')
            self.leakConductance = value
            self.validate_Nml2Quantity_conductance(self.leakConductance)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IafCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IafCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IafCell


class IafTauCell(BaseCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('leakReversal', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('thresh', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('reset', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('tau', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, leakReversal=None, thresh=None, reset=None, tau=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IafTauCell, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.leakReversal = _cast(None, leakReversal)
        self.leakReversal_nsprefix_ = None
        self.thresh = _cast(None, thresh)
        self.thresh_nsprefix_ = None
        self.reset = _cast(None, reset)
        self.reset_nsprefix_ = None
        self.tau = _cast(None, tau)
        self.tau_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IafTauCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IafTauCell.subclass:
            return IafTauCell.subclass(*args_, **kwargs_)
        else:
            return IafTauCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (
            super(IafTauCell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IafTauCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IafTauCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IafTauCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IafTauCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IafTauCell'):
        super(IafTauCell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IafTauCell')
        if self.leakReversal is not None and 'leakReversal' not in already_processed:
            already_processed.add('leakReversal')
            outfile.write(' leakReversal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.leakReversal), input_name='leakReversal')), ))
        if self.thresh is not None and 'thresh' not in already_processed:
            already_processed.add('thresh')
            outfile.write(' thresh=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.thresh), input_name='thresh')), ))
        if self.reset is not None and 'reset' not in already_processed:
            already_processed.add('reset')
            outfile.write(' reset=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reset), input_name='reset')), ))
        if self.tau is not None and 'tau' not in already_processed:
            already_processed.add('tau')
            outfile.write(' tau=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tau), input_name='tau')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IafTauCell', fromsubclass_=False, pretty_print=True):
        super(IafTauCell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('leakReversal', node)
        if value is not None and 'leakReversal' not in already_processed:
            already_processed.add('leakReversal')
            self.leakReversal = value
            self.validate_Nml2Quantity_voltage(self.leakReversal)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('thresh', node)
        if value is not None and 'thresh' not in already_processed:
            already_processed.add('thresh')
            self.thresh = value
            self.validate_Nml2Quantity_voltage(self.thresh)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('reset', node)
        if value is not None and 'reset' not in already_processed:
            already_processed.add('reset')
            self.reset = value
            self.validate_Nml2Quantity_voltage(self.reset)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('tau', node)
        if value is not None and 'tau' not in already_processed:
            already_processed.add('tau')
            self.tau = value
            self.validate_Nml2Quantity_time(self.tau)    # validate type Nml2Quantity_time
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IafTauCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IafTauCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IafTauCell


class GradedSynapse(BaseSynapse):
    """Based on synapse in Methods of
    http://www.nature.com/neuro/journal/v7/n12/abs/nn1352.html."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('conductance', 'Nml2Quantity_conductance', 0, 0, {'use': 'required'}),
        MemberSpec_('delta', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('Vth', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('k', 'Nml2Quantity_pertime', 0, 0, {'use': 'required'}),
        MemberSpec_('erev', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, conductance=None, delta=None, Vth=None, k=None, erev=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GradedSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.conductance = _cast(None, conductance)
        self.conductance_nsprefix_ = None
        self.delta = _cast(None, delta)
        self.delta_nsprefix_ = None
        self.Vth = _cast(None, Vth)
        self.Vth_nsprefix_ = None
        self.k = _cast(None, k)
        self.k_nsprefix_ = None
        self.erev = _cast(None, erev)
        self.erev_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GradedSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GradedSynapse.subclass:
            return GradedSynapse.subclass(*args_, **kwargs_)
        else:
            return GradedSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductance_patterns_, ))
    validate_Nml2Quantity_conductance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$']]
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_pertime_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_pertime_patterns_, ))
    validate_Nml2Quantity_pertime_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$']]
    def hasContent_(self):
        if (
            super(GradedSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GradedSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GradedSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GradedSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GradedSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GradedSynapse'):
        super(GradedSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GradedSynapse')
        if self.conductance is not None and 'conductance' not in already_processed:
            already_processed.add('conductance')
            outfile.write(' conductance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.conductance), input_name='conductance')), ))
        if self.delta is not None and 'delta' not in already_processed:
            already_processed.add('delta')
            outfile.write(' delta=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delta), input_name='delta')), ))
        if self.Vth is not None and 'Vth' not in already_processed:
            already_processed.add('Vth')
            outfile.write(' Vth=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Vth), input_name='Vth')), ))
        if self.k is not None and 'k' not in already_processed:
            already_processed.add('k')
            outfile.write(' k=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.k), input_name='k')), ))
        if self.erev is not None and 'erev' not in already_processed:
            already_processed.add('erev')
            outfile.write(' erev=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.erev), input_name='erev')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GradedSynapse', fromsubclass_=False, pretty_print=True):
        super(GradedSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('conductance', node)
        if value is not None and 'conductance' not in already_processed:
            already_processed.add('conductance')
            self.conductance = value
            self.validate_Nml2Quantity_conductance(self.conductance)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('delta', node)
        if value is not None and 'delta' not in already_processed:
            already_processed.add('delta')
            self.delta = value
            self.validate_Nml2Quantity_voltage(self.delta)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('Vth', node)
        if value is not None and 'Vth' not in already_processed:
            already_processed.add('Vth')
            self.Vth = value
            self.validate_Nml2Quantity_voltage(self.Vth)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('k', node)
        if value is not None and 'k' not in already_processed:
            already_processed.add('k')
            self.k = value
            self.validate_Nml2Quantity_pertime(self.k)    # validate type Nml2Quantity_pertime
        value = find_attr_value_('erev', node)
        if value is not None and 'erev' not in already_processed:
            already_processed.add('erev')
            self.erev = value
            self.validate_Nml2Quantity_voltage(self.erev)    # validate type Nml2Quantity_voltage
        super(GradedSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(GradedSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GradedSynapse


class LinearGradedSynapse(BaseSynapse):
    """Behaves just like a one way gap junction."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('conductance', 'Nml2Quantity_conductance', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, conductance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LinearGradedSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.conductance = _cast(None, conductance)
        self.conductance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinearGradedSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinearGradedSynapse.subclass:
            return LinearGradedSynapse.subclass(*args_, **kwargs_)
        else:
            return LinearGradedSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductance_patterns_, ))
    validate_Nml2Quantity_conductance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$']]
    def hasContent_(self):
        if (
            super(LinearGradedSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LinearGradedSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LinearGradedSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LinearGradedSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LinearGradedSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LinearGradedSynapse'):
        super(LinearGradedSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LinearGradedSynapse')
        if self.conductance is not None and 'conductance' not in already_processed:
            already_processed.add('conductance')
            outfile.write(' conductance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.conductance), input_name='conductance')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LinearGradedSynapse', fromsubclass_=False, pretty_print=True):
        super(LinearGradedSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('conductance', node)
        if value is not None and 'conductance' not in already_processed:
            already_processed.add('conductance')
            self.conductance = value
            self.validate_Nml2Quantity_conductance(self.conductance)    # validate type Nml2Quantity_conductance
        super(LinearGradedSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(LinearGradedSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LinearGradedSynapse


class SilentSynapse(BaseSynapse):
    """Dummy synapse which emits no current. Used as presynaptic endpoint for
    analog synaptic connection (continuousConnection)."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = BaseSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SilentSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SilentSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SilentSynapse.subclass:
            return SilentSynapse.subclass(*args_, **kwargs_)
        else:
            return SilentSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SilentSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SilentSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SilentSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SilentSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SilentSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SilentSynapse'):
        super(SilentSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SilentSynapse')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SilentSynapse', fromsubclass_=False, pretty_print=True):
        super(SilentSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SilentSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SilentSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SilentSynapse


class GapJunction(BaseSynapse):
    """Gap junction/single electrical connection"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('conductance', 'Nml2Quantity_conductance', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, conductance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GapJunction, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.conductance = _cast(None, conductance)
        self.conductance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GapJunction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GapJunction.subclass:
            return GapJunction.subclass(*args_, **kwargs_)
        else:
            return GapJunction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductance_patterns_, ))
    validate_Nml2Quantity_conductance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$']]
    def hasContent_(self):
        if (
            super(GapJunction, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GapJunction', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GapJunction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GapJunction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GapJunction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GapJunction'):
        super(GapJunction, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GapJunction')
        if self.conductance is not None and 'conductance' not in already_processed:
            already_processed.add('conductance')
            outfile.write(' conductance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.conductance), input_name='conductance')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GapJunction', fromsubclass_=False, pretty_print=True):
        super(GapJunction, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('conductance', node)
        if value is not None and 'conductance' not in already_processed:
            already_processed.add('conductance')
            self.conductance = value
            self.validate_Nml2Quantity_conductance(self.conductance)    # validate type Nml2Quantity_conductance
        super(GapJunction, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(GapJunction, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GapJunction


class BaseCurrentBasedSynapse(BaseSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = BaseSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseCurrentBasedSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseCurrentBasedSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseCurrentBasedSynapse.subclass:
            return BaseCurrentBasedSynapse.subclass(*args_, **kwargs_)
        else:
            return BaseCurrentBasedSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(BaseCurrentBasedSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseCurrentBasedSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseCurrentBasedSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseCurrentBasedSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseCurrentBasedSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseCurrentBasedSynapse'):
        super(BaseCurrentBasedSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseCurrentBasedSynapse')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseCurrentBasedSynapse', fromsubclass_=False, pretty_print=True):
        super(BaseCurrentBasedSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseCurrentBasedSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BaseCurrentBasedSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseCurrentBasedSynapse


class BaseVoltageDepSynapse(BaseSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = BaseSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseVoltageDepSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseVoltageDepSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseVoltageDepSynapse.subclass:
            return BaseVoltageDepSynapse.subclass(*args_, **kwargs_)
        else:
            return BaseVoltageDepSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(BaseVoltageDepSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseVoltageDepSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseVoltageDepSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseVoltageDepSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseVoltageDepSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseVoltageDepSynapse'):
        super(BaseVoltageDepSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseVoltageDepSynapse')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseVoltageDepSynapse', fromsubclass_=False, pretty_print=True):
        super(BaseVoltageDepSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseVoltageDepSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BaseVoltageDepSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseVoltageDepSynapse


class IonChannel(IonChannelScalable):
    """Note ionChannel and ionChannelHH are currently functionally identical.
    This is needed since many existing examples use ionChannel, some use
    ionChannelHH.
    NeuroML v2beta4 should remove one of these, probably ionChannelHH."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('species', 'NmlId', 0, 1, {'use': 'optional'}),
        MemberSpec_('type_', 'channelTypes', 0, 1, {'use': 'optional'}),
        MemberSpec_('conductance', 'Nml2Quantity_conductance', 0, 1, {'use': 'optional'}),
        MemberSpec_('gate', 'GateHHUndetermined', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'gate', 'type': 'GateHHUndetermined'}, 1),
        MemberSpec_('gateHHrates', 'GateHHRates', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'gateHHrates', 'type': 'GateHHRates'}, 1),
        MemberSpec_('gateHHratesTau', 'GateHHRatesTau', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'gateHHratesTau', 'type': 'GateHHRatesTau'}, 1),
        MemberSpec_('gateHHtauInf', 'GateHHTauInf', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'gateHHtauInf', 'type': 'GateHHTauInf'}, 1),
        MemberSpec_('gateHHratesInf', 'GateHHRatesInf', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'gateHHratesInf', 'type': 'GateHHRatesInf'}, 1),
        MemberSpec_('gateHHratesTauInf', 'GateHHRatesTauInf', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'gateHHratesTauInf', 'type': 'GateHHRatesTauInf'}, 1),
        MemberSpec_('gateHHInstantaneous', 'GateHHInstantaneous', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'gateHHInstantaneous', 'type': 'GateHHInstantaneous'}, 1),
        MemberSpec_('gateFractional', 'GateFractional', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'gateFractional', 'type': 'GateFractional'}, 1),
    ]
    subclass = None
    superclass = IonChannelScalable
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, q10ConductanceScaling=None, species=None, type_=None, conductance=None, gate=None, gateHHrates=None, gateHHratesTau=None, gateHHtauInf=None, gateHHratesInf=None, gateHHratesTauInf=None, gateHHInstantaneous=None, gateFractional=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IonChannel, self).__init__(neuroLexId, id, metaid, notes, property, annotation, q10ConductanceScaling, extensiontype_,  **kwargs_)
        self.species = _cast(None, species)
        self.species_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.conductance = _cast(None, conductance)
        self.conductance_nsprefix_ = None
        if gate is None:
            self.gate = []
        else:
            self.gate = gate
        self.gate_nsprefix_ = None
        if gateHHrates is None:
            self.gateHHrates = []
        else:
            self.gateHHrates = gateHHrates
        self.gateHHrates_nsprefix_ = None
        if gateHHratesTau is None:
            self.gateHHratesTau = []
        else:
            self.gateHHratesTau = gateHHratesTau
        self.gateHHratesTau_nsprefix_ = None
        if gateHHtauInf is None:
            self.gateHHtauInf = []
        else:
            self.gateHHtauInf = gateHHtauInf
        self.gateHHtauInf_nsprefix_ = None
        if gateHHratesInf is None:
            self.gateHHratesInf = []
        else:
            self.gateHHratesInf = gateHHratesInf
        self.gateHHratesInf_nsprefix_ = None
        if gateHHratesTauInf is None:
            self.gateHHratesTauInf = []
        else:
            self.gateHHratesTauInf = gateHHratesTauInf
        self.gateHHratesTauInf_nsprefix_ = None
        if gateHHInstantaneous is None:
            self.gateHHInstantaneous = []
        else:
            self.gateHHInstantaneous = gateHHInstantaneous
        self.gateHHInstantaneous_nsprefix_ = None
        if gateFractional is None:
            self.gateFractional = []
        else:
            self.gateFractional = gateFractional
        self.gateFractional_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IonChannel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IonChannel.subclass:
            return IonChannel.subclass(*args_, **kwargs_)
        else:
            return IonChannel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def validate_channelTypes(self, value):
        # Validate type channelTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ionChannelPassive', 'ionChannelHH']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on channelTypes' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductance_patterns_, ))
    validate_Nml2Quantity_conductance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$']]
    def hasContent_(self):
        if (
            self.gate or
            self.gateHHrates or
            self.gateHHratesTau or
            self.gateHHtauInf or
            self.gateHHratesInf or
            self.gateHHratesTauInf or
            self.gateHHInstantaneous or
            self.gateFractional or
            super(IonChannel, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IonChannel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IonChannel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IonChannel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IonChannel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IonChannel'):
        super(IonChannel, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IonChannel')
        if self.species is not None and 'species' not in already_processed:
            already_processed.add('species')
            outfile.write(' species=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.species), input_name='species')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.conductance is not None and 'conductance' not in already_processed:
            already_processed.add('conductance')
            outfile.write(' conductance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.conductance), input_name='conductance')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IonChannel', fromsubclass_=False, pretty_print=True):
        super(IonChannel, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for gate_ in self.gate:
            namespaceprefix_ = self.gate_nsprefix_ + ':' if (UseCapturedNS_ and self.gate_nsprefix_) else ''
            gate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gate', pretty_print=pretty_print)
        for gateHHrates_ in self.gateHHrates:
            namespaceprefix_ = self.gateHHrates_nsprefix_ + ':' if (UseCapturedNS_ and self.gateHHrates_nsprefix_) else ''
            gateHHrates_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gateHHrates', pretty_print=pretty_print)
        for gateHHratesTau_ in self.gateHHratesTau:
            namespaceprefix_ = self.gateHHratesTau_nsprefix_ + ':' if (UseCapturedNS_ and self.gateHHratesTau_nsprefix_) else ''
            gateHHratesTau_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gateHHratesTau', pretty_print=pretty_print)
        for gateHHtauInf_ in self.gateHHtauInf:
            namespaceprefix_ = self.gateHHtauInf_nsprefix_ + ':' if (UseCapturedNS_ and self.gateHHtauInf_nsprefix_) else ''
            gateHHtauInf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gateHHtauInf', pretty_print=pretty_print)
        for gateHHratesInf_ in self.gateHHratesInf:
            namespaceprefix_ = self.gateHHratesInf_nsprefix_ + ':' if (UseCapturedNS_ and self.gateHHratesInf_nsprefix_) else ''
            gateHHratesInf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gateHHratesInf', pretty_print=pretty_print)
        for gateHHratesTauInf_ in self.gateHHratesTauInf:
            namespaceprefix_ = self.gateHHratesTauInf_nsprefix_ + ':' if (UseCapturedNS_ and self.gateHHratesTauInf_nsprefix_) else ''
            gateHHratesTauInf_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gateHHratesTauInf', pretty_print=pretty_print)
        for gateHHInstantaneous_ in self.gateHHInstantaneous:
            namespaceprefix_ = self.gateHHInstantaneous_nsprefix_ + ':' if (UseCapturedNS_ and self.gateHHInstantaneous_nsprefix_) else ''
            gateHHInstantaneous_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gateHHInstantaneous', pretty_print=pretty_print)
        for gateFractional_ in self.gateFractional:
            namespaceprefix_ = self.gateFractional_nsprefix_ + ':' if (UseCapturedNS_ and self.gateFractional_nsprefix_) else ''
            gateFractional_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gateFractional', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('species', node)
        if value is not None and 'species' not in already_processed:
            already_processed.add('species')
            self.species = value
            self.validate_NmlId(self.species)    # validate type NmlId
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_channelTypes(self.type_)    # validate type channelTypes
        value = find_attr_value_('conductance', node)
        if value is not None and 'conductance' not in already_processed:
            already_processed.add('conductance')
            self.conductance = value
            self.validate_Nml2Quantity_conductance(self.conductance)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IonChannel, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'gate':
            obj_ = GateHHUndetermined.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gate.append(obj_)
            obj_.original_tagname_ = 'gate'
        elif nodeName_ == 'gateHHrates':
            obj_ = GateHHRates.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gateHHrates.append(obj_)
            obj_.original_tagname_ = 'gateHHrates'
        elif nodeName_ == 'gateHHratesTau':
            obj_ = GateHHRatesTau.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gateHHratesTau.append(obj_)
            obj_.original_tagname_ = 'gateHHratesTau'
        elif nodeName_ == 'gateHHtauInf':
            obj_ = GateHHTauInf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gateHHtauInf.append(obj_)
            obj_.original_tagname_ = 'gateHHtauInf'
        elif nodeName_ == 'gateHHratesInf':
            obj_ = GateHHRatesInf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gateHHratesInf.append(obj_)
            obj_.original_tagname_ = 'gateHHratesInf'
        elif nodeName_ == 'gateHHratesTauInf':
            obj_ = GateHHRatesTauInf.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gateHHratesTauInf.append(obj_)
            obj_.original_tagname_ = 'gateHHratesTauInf'
        elif nodeName_ == 'gateHHInstantaneous':
            obj_ = GateHHInstantaneous.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gateHHInstantaneous.append(obj_)
            obj_.original_tagname_ = 'gateHHInstantaneous'
        elif nodeName_ == 'gateFractional':
            obj_ = GateFractional.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gateFractional.append(obj_)
            obj_.original_tagname_ = 'gateFractional'
        super(IonChannel, self).buildChildren(child_, node, nodeName_, True)
# end class IonChannel


class AlphaCurrSynapse(BasePynnSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = BasePynnSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, tau_syn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AlphaCurrSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, tau_syn,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlphaCurrSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlphaCurrSynapse.subclass:
            return AlphaCurrSynapse.subclass(*args_, **kwargs_)
        else:
            return AlphaCurrSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(AlphaCurrSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlphaCurrSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlphaCurrSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlphaCurrSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlphaCurrSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlphaCurrSynapse'):
        super(AlphaCurrSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlphaCurrSynapse')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlphaCurrSynapse', fromsubclass_=False, pretty_print=True):
        super(AlphaCurrSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AlphaCurrSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AlphaCurrSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AlphaCurrSynapse


class ExpCurrSynapse(BasePynnSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = BasePynnSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, tau_syn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ExpCurrSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, tau_syn,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExpCurrSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpCurrSynapse.subclass:
            return ExpCurrSynapse.subclass(*args_, **kwargs_)
        else:
            return ExpCurrSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ExpCurrSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExpCurrSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExpCurrSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExpCurrSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExpCurrSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExpCurrSynapse'):
        super(ExpCurrSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExpCurrSynapse')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExpCurrSynapse', fromsubclass_=False, pretty_print=True):
        super(ExpCurrSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExpCurrSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ExpCurrSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExpCurrSynapse


class AlphaCondSynapse(BasePynnSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('e_rev', 'xs:float', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BasePynnSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, tau_syn=None, e_rev=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AlphaCondSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, tau_syn,  **kwargs_)
        self.e_rev = _cast(float, e_rev)
        self.e_rev_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlphaCondSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlphaCondSynapse.subclass:
            return AlphaCondSynapse.subclass(*args_, **kwargs_)
        else:
            return AlphaCondSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(AlphaCondSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlphaCondSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlphaCondSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlphaCondSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlphaCondSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlphaCondSynapse'):
        super(AlphaCondSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlphaCondSynapse')
        if self.e_rev is not None and 'e_rev' not in already_processed:
            already_processed.add('e_rev')
            outfile.write(' e_rev="%s"' % self.gds_format_float(self.e_rev, input_name='e_rev'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlphaCondSynapse', fromsubclass_=False, pretty_print=True):
        super(AlphaCondSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('e_rev', node)
        if value is not None and 'e_rev' not in already_processed:
            already_processed.add('e_rev')
            value = self.gds_parse_float(value, node, 'e_rev')
            self.e_rev = value
        super(AlphaCondSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AlphaCondSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AlphaCondSynapse


class ExpCondSynapse(BasePynnSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('e_rev', 'xs:float', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BasePynnSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, tau_syn=None, e_rev=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ExpCondSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, tau_syn,  **kwargs_)
        self.e_rev = _cast(float, e_rev)
        self.e_rev_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExpCondSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpCondSynapse.subclass:
            return ExpCondSynapse.subclass(*args_, **kwargs_)
        else:
            return ExpCondSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ExpCondSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExpCondSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExpCondSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExpCondSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExpCondSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExpCondSynapse'):
        super(ExpCondSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExpCondSynapse')
        if self.e_rev is not None and 'e_rev' not in already_processed:
            already_processed.add('e_rev')
            outfile.write(' e_rev="%s"' % self.gds_format_float(self.e_rev, input_name='e_rev'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExpCondSynapse', fromsubclass_=False, pretty_print=True):
        super(ExpCondSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('e_rev', node)
        if value is not None and 'e_rev' not in already_processed:
            already_processed.add('e_rev')
            value = self.gds_parse_float(value, node, 'e_rev')
            self.e_rev = value
        super(ExpCondSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ExpCondSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExpCondSynapse


class HH_cond_exp(basePyNNCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('v_offset', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('e_rev_E', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('e_rev_I', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('e_rev_K', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('e_rev_Na', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('e_rev_leak', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('g_leak', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('gbar_K', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('gbar_Na', 'xs:float', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = basePyNNCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, cm=None, i_offset=None, tau_syn_E=None, tau_syn_I=None, v_init=None, v_offset=None, e_rev_E=None, e_rev_I=None, e_rev_K=None, e_rev_Na=None, e_rev_leak=None, g_leak=None, gbar_K=None, gbar_Na=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(HH_cond_exp, self).__init__(neuroLexId, id, metaid, notes, property, annotation, cm, i_offset, tau_syn_E, tau_syn_I, v_init,  **kwargs_)
        self.v_offset = _cast(float, v_offset)
        self.v_offset_nsprefix_ = None
        self.e_rev_E = _cast(float, e_rev_E)
        self.e_rev_E_nsprefix_ = None
        self.e_rev_I = _cast(float, e_rev_I)
        self.e_rev_I_nsprefix_ = None
        self.e_rev_K = _cast(float, e_rev_K)
        self.e_rev_K_nsprefix_ = None
        self.e_rev_Na = _cast(float, e_rev_Na)
        self.e_rev_Na_nsprefix_ = None
        self.e_rev_leak = _cast(float, e_rev_leak)
        self.e_rev_leak_nsprefix_ = None
        self.g_leak = _cast(float, g_leak)
        self.g_leak_nsprefix_ = None
        self.gbar_K = _cast(float, gbar_K)
        self.gbar_K_nsprefix_ = None
        self.gbar_Na = _cast(float, gbar_Na)
        self.gbar_Na_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HH_cond_exp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HH_cond_exp.subclass:
            return HH_cond_exp.subclass(*args_, **kwargs_)
        else:
            return HH_cond_exp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(HH_cond_exp, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HH_cond_exp', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HH_cond_exp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HH_cond_exp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HH_cond_exp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HH_cond_exp'):
        super(HH_cond_exp, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HH_cond_exp')
        if self.v_offset is not None and 'v_offset' not in already_processed:
            already_processed.add('v_offset')
            outfile.write(' v_offset="%s"' % self.gds_format_float(self.v_offset, input_name='v_offset'))
        if self.e_rev_E is not None and 'e_rev_E' not in already_processed:
            already_processed.add('e_rev_E')
            outfile.write(' e_rev_E="%s"' % self.gds_format_float(self.e_rev_E, input_name='e_rev_E'))
        if self.e_rev_I is not None and 'e_rev_I' not in already_processed:
            already_processed.add('e_rev_I')
            outfile.write(' e_rev_I="%s"' % self.gds_format_float(self.e_rev_I, input_name='e_rev_I'))
        if self.e_rev_K is not None and 'e_rev_K' not in already_processed:
            already_processed.add('e_rev_K')
            outfile.write(' e_rev_K="%s"' % self.gds_format_float(self.e_rev_K, input_name='e_rev_K'))
        if self.e_rev_Na is not None and 'e_rev_Na' not in already_processed:
            already_processed.add('e_rev_Na')
            outfile.write(' e_rev_Na="%s"' % self.gds_format_float(self.e_rev_Na, input_name='e_rev_Na'))
        if self.e_rev_leak is not None and 'e_rev_leak' not in already_processed:
            already_processed.add('e_rev_leak')
            outfile.write(' e_rev_leak="%s"' % self.gds_format_float(self.e_rev_leak, input_name='e_rev_leak'))
        if self.g_leak is not None and 'g_leak' not in already_processed:
            already_processed.add('g_leak')
            outfile.write(' g_leak="%s"' % self.gds_format_float(self.g_leak, input_name='g_leak'))
        if self.gbar_K is not None and 'gbar_K' not in already_processed:
            already_processed.add('gbar_K')
            outfile.write(' gbar_K="%s"' % self.gds_format_float(self.gbar_K, input_name='gbar_K'))
        if self.gbar_Na is not None and 'gbar_Na' not in already_processed:
            already_processed.add('gbar_Na')
            outfile.write(' gbar_Na="%s"' % self.gds_format_float(self.gbar_Na, input_name='gbar_Na'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HH_cond_exp', fromsubclass_=False, pretty_print=True):
        super(HH_cond_exp, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('v_offset', node)
        if value is not None and 'v_offset' not in already_processed:
            already_processed.add('v_offset')
            value = self.gds_parse_float(value, node, 'v_offset')
            self.v_offset = value
        value = find_attr_value_('e_rev_E', node)
        if value is not None and 'e_rev_E' not in already_processed:
            already_processed.add('e_rev_E')
            value = self.gds_parse_float(value, node, 'e_rev_E')
            self.e_rev_E = value
        value = find_attr_value_('e_rev_I', node)
        if value is not None and 'e_rev_I' not in already_processed:
            already_processed.add('e_rev_I')
            value = self.gds_parse_float(value, node, 'e_rev_I')
            self.e_rev_I = value
        value = find_attr_value_('e_rev_K', node)
        if value is not None and 'e_rev_K' not in already_processed:
            already_processed.add('e_rev_K')
            value = self.gds_parse_float(value, node, 'e_rev_K')
            self.e_rev_K = value
        value = find_attr_value_('e_rev_Na', node)
        if value is not None and 'e_rev_Na' not in already_processed:
            already_processed.add('e_rev_Na')
            value = self.gds_parse_float(value, node, 'e_rev_Na')
            self.e_rev_Na = value
        value = find_attr_value_('e_rev_leak', node)
        if value is not None and 'e_rev_leak' not in already_processed:
            already_processed.add('e_rev_leak')
            value = self.gds_parse_float(value, node, 'e_rev_leak')
            self.e_rev_leak = value
        value = find_attr_value_('g_leak', node)
        if value is not None and 'g_leak' not in already_processed:
            already_processed.add('g_leak')
            value = self.gds_parse_float(value, node, 'g_leak')
            self.g_leak = value
        value = find_attr_value_('gbar_K', node)
        if value is not None and 'gbar_K' not in already_processed:
            already_processed.add('gbar_K')
            value = self.gds_parse_float(value, node, 'gbar_K')
            self.gbar_K = value
        value = find_attr_value_('gbar_Na', node)
        if value is not None and 'gbar_Na' not in already_processed:
            already_processed.add('gbar_Na')
            value = self.gds_parse_float(value, node, 'gbar_Na')
            self.gbar_Na = value
        super(HH_cond_exp, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(HH_cond_exp, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class HH_cond_exp


class basePyNNIaFCell(basePyNNCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('tau_m', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('tau_refrac', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('v_reset', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('v_rest', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('v_thresh', 'xs:float', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = basePyNNCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, cm=None, i_offset=None, tau_syn_E=None, tau_syn_I=None, v_init=None, tau_m=None, tau_refrac=None, v_reset=None, v_rest=None, v_thresh=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(basePyNNIaFCell, self).__init__(neuroLexId, id, metaid, notes, property, annotation, cm, i_offset, tau_syn_E, tau_syn_I, v_init, extensiontype_,  **kwargs_)
        self.tau_m = _cast(float, tau_m)
        self.tau_m_nsprefix_ = None
        self.tau_refrac = _cast(float, tau_refrac)
        self.tau_refrac_nsprefix_ = None
        self.v_reset = _cast(float, v_reset)
        self.v_reset_nsprefix_ = None
        self.v_rest = _cast(float, v_rest)
        self.v_rest_nsprefix_ = None
        self.v_thresh = _cast(float, v_thresh)
        self.v_thresh_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basePyNNIaFCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basePyNNIaFCell.subclass:
            return basePyNNIaFCell.subclass(*args_, **kwargs_)
        else:
            return basePyNNIaFCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(basePyNNIaFCell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='basePyNNIaFCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basePyNNIaFCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basePyNNIaFCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='basePyNNIaFCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='basePyNNIaFCell'):
        super(basePyNNIaFCell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basePyNNIaFCell')
        if self.tau_m is not None and 'tau_m' not in already_processed:
            already_processed.add('tau_m')
            outfile.write(' tau_m="%s"' % self.gds_format_float(self.tau_m, input_name='tau_m'))
        if self.tau_refrac is not None and 'tau_refrac' not in already_processed:
            already_processed.add('tau_refrac')
            outfile.write(' tau_refrac="%s"' % self.gds_format_float(self.tau_refrac, input_name='tau_refrac'))
        if self.v_reset is not None and 'v_reset' not in already_processed:
            already_processed.add('v_reset')
            outfile.write(' v_reset="%s"' % self.gds_format_float(self.v_reset, input_name='v_reset'))
        if self.v_rest is not None and 'v_rest' not in already_processed:
            already_processed.add('v_rest')
            outfile.write(' v_rest="%s"' % self.gds_format_float(self.v_rest, input_name='v_rest'))
        if self.v_thresh is not None and 'v_thresh' not in already_processed:
            already_processed.add('v_thresh')
            outfile.write(' v_thresh="%s"' % self.gds_format_float(self.v_thresh, input_name='v_thresh'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='basePyNNIaFCell', fromsubclass_=False, pretty_print=True):
        super(basePyNNIaFCell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tau_m', node)
        if value is not None and 'tau_m' not in already_processed:
            already_processed.add('tau_m')
            value = self.gds_parse_float(value, node, 'tau_m')
            self.tau_m = value
        value = find_attr_value_('tau_refrac', node)
        if value is not None and 'tau_refrac' not in already_processed:
            already_processed.add('tau_refrac')
            value = self.gds_parse_float(value, node, 'tau_refrac')
            self.tau_refrac = value
        value = find_attr_value_('v_reset', node)
        if value is not None and 'v_reset' not in already_processed:
            already_processed.add('v_reset')
            value = self.gds_parse_float(value, node, 'v_reset')
            self.v_reset = value
        value = find_attr_value_('v_rest', node)
        if value is not None and 'v_rest' not in already_processed:
            already_processed.add('v_rest')
            value = self.gds_parse_float(value, node, 'v_rest')
            self.v_rest = value
        value = find_attr_value_('v_thresh', node)
        if value is not None and 'v_thresh' not in already_processed:
            already_processed.add('v_thresh')
            value = self.gds_parse_float(value, node, 'v_thresh')
            self.v_thresh = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(basePyNNIaFCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(basePyNNIaFCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class basePyNNIaFCell


class ContinuousConnection(BaseConnectionNewFormat):
    """Individual continuous/analog synaptic connection"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('preComponent', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('postComponent', 'NmlId', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseConnectionNewFormat
    def __init__(self, neuroLexId=None, id=None, preCell=None, preSegment='0', preFractionAlong='0.5', postCell=None, postSegment='0', postFractionAlong='0.5', preComponent=None, postComponent=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ContinuousConnection, self).__init__(neuroLexId, id, preCell, preSegment, preFractionAlong, postCell, postSegment, postFractionAlong, extensiontype_,  **kwargs_)
        self.preComponent = _cast(None, preComponent)
        self.preComponent_nsprefix_ = None
        self.postComponent = _cast(None, postComponent)
        self.postComponent_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContinuousConnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContinuousConnection.subclass:
            return ContinuousConnection.subclass(*args_, **kwargs_)
        else:
            return ContinuousConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            super(ContinuousConnection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContinuousConnection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContinuousConnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContinuousConnection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContinuousConnection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContinuousConnection'):
        super(ContinuousConnection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContinuousConnection')
        if self.preComponent is not None and 'preComponent' not in already_processed:
            already_processed.add('preComponent')
            outfile.write(' preComponent=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.preComponent), input_name='preComponent')), ))
        if self.postComponent is not None and 'postComponent' not in already_processed:
            already_processed.add('postComponent')
            outfile.write(' postComponent=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.postComponent), input_name='postComponent')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContinuousConnection', fromsubclass_=False, pretty_print=True):
        super(ContinuousConnection, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('preComponent', node)
        if value is not None and 'preComponent' not in already_processed:
            already_processed.add('preComponent')
            self.preComponent = value
            self.validate_NmlId(self.preComponent)    # validate type NmlId
        value = find_attr_value_('postComponent', node)
        if value is not None and 'postComponent' not in already_processed:
            already_processed.add('postComponent')
            self.postComponent = value
            self.validate_NmlId(self.postComponent)    # validate type NmlId
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ContinuousConnection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ContinuousConnection, self).buildChildren(child_, node, nodeName_, True)
        pass

    def _get_cell_id(self, id_string):
            return int(float(id_string))


    def get_pre_cell_id(self):

        return self._get_cell_id(self.pre_cell)

    def get_post_cell_id(self):

        return self._get_cell_id(self.post_cell)

    def get_pre_segment_id(self):

        return int(self.pre_segment)

    def get_post_segment_id(self):

        return int(self.post_segment)

    def get_pre_fraction_along(self):

        return float(self.pre_fraction_along)

    def get_post_fraction_along(self):

        return float(self.post_fraction_along)


    def get_pre_info(self):

        return str(self.get_pre_cell_id())+(':'+str(self.get_pre_segment_id())+'('+ '%.5f'%self.get_pre_fraction_along()+')' if self.get_pre_segment_id()!=0 or self.get_pre_fraction_along()!=0.5 else '')

    def get_post_info(self):

        return str(self.get_post_cell_id())+(':'+str(self.get_post_segment_id())+'('+ '%.5f'%self.get_post_fraction_along()+')' if self.get_post_segment_id()!=0 or self.get_post_fraction_along()!=0.5 else '')


    def __str__(self):

        return "Continuous Connection "+str(self.id)+": "+str(self.get_pre_info())+" -> "+str(self.get_post_info())+             ", pre comp: "+str(self.pre_component)+", post comp: "+str(self.post_component)


    # end class ContinuousConnection


class ElectricalConnection(BaseConnectionNewFormat):
    """Individual electrical synaptic connection"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('synapse', 'NmlId', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseConnectionNewFormat
    def __init__(self, neuroLexId=None, id=None, preCell=None, preSegment='0', preFractionAlong='0.5', postCell=None, postSegment='0', postFractionAlong='0.5', synapse=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ElectricalConnection, self).__init__(neuroLexId, id, preCell, preSegment, preFractionAlong, postCell, postSegment, postFractionAlong, extensiontype_,  **kwargs_)
        self.synapse = _cast(None, synapse)
        self.synapse_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricalConnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricalConnection.subclass:
            return ElectricalConnection.subclass(*args_, **kwargs_)
        else:
            return ElectricalConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            super(ElectricalConnection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ElectricalConnection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElectricalConnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricalConnection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ElectricalConnection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ElectricalConnection'):
        super(ElectricalConnection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricalConnection')
        if self.synapse is not None and 'synapse' not in already_processed:
            already_processed.add('synapse')
            outfile.write(' synapse=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.synapse), input_name='synapse')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ElectricalConnection', fromsubclass_=False, pretty_print=True):
        super(ElectricalConnection, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('synapse', node)
        if value is not None and 'synapse' not in already_processed:
            already_processed.add('synapse')
            self.synapse = value
            self.validate_NmlId(self.synapse)    # validate type NmlId
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ElectricalConnection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ElectricalConnection, self).buildChildren(child_, node, nodeName_, True)
        pass

    def _get_cell_id(self, id_string):
            return int(float(id_string))

    def get_pre_cell_id(self):

        return self._get_cell_id(self.pre_cell)

    def get_post_cell_id(self):

        return self._get_cell_id(self.post_cell)

    def get_pre_segment_id(self):

        return int(self.pre_segment)

    def get_post_segment_id(self):

        return int(self.post_segment)

    def get_pre_fraction_along(self):

        return float(self.pre_fraction_along)

    def get_post_fraction_along(self):

        return float(self.post_fraction_along)


    def get_pre_info(self):

        return str(self.get_pre_cell_id())+(':'+str(self.get_pre_segment_id())+'('+ '%.5f'%self.get_pre_fraction_along()+')' if self.get_pre_segment_id()!=0 or self.get_pre_fraction_along()!=0.5 else '')

    def get_post_info(self):

        return str(self.get_post_cell_id())+(':'+str(self.get_post_segment_id())+'('+ '%.5f'%self.get_post_fraction_along()+')' if self.get_post_segment_id()!=0 or self.get_post_fraction_along()!=0.5 else '')


    def __str__(self):

        return "Electrical Connection "+str(self.id)+": "+str(self.get_pre_info())+" -> "+str(self.get_post_info())+             ", synapse: "+str(self.synapse)


    # end class ElectricalConnection


class ConnectionWD(BaseConnectionOldFormat):
    """Individual synaptic connection with weight and delay"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('weight', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('delay', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseConnectionOldFormat
    def __init__(self, neuroLexId=None, id=None, preCellId=None, preSegmentId='0', preFractionAlong='0.5', postCellId=None, postSegmentId='0', postFractionAlong='0.5', weight=None, delay=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ConnectionWD, self).__init__(neuroLexId, id, preCellId, preSegmentId, preFractionAlong, postCellId, postSegmentId, postFractionAlong,  **kwargs_)
        self.weight = _cast(float, weight)
        self.weight_nsprefix_ = None
        self.delay = _cast(None, delay)
        self.delay_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConnectionWD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConnectionWD.subclass:
            return ConnectionWD.subclass(*args_, **kwargs_)
        else:
            return ConnectionWD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (
            super(ConnectionWD, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConnectionWD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConnectionWD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConnectionWD')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConnectionWD', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConnectionWD'):
        super(ConnectionWD, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConnectionWD')
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight="%s"' % self.gds_format_float(self.weight, input_name='weight'))
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delay), input_name='delay')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConnectionWD', fromsubclass_=False, pretty_print=True):
        super(ConnectionWD, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            value = self.gds_parse_float(value, node, 'weight')
            self.weight = value
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            self.delay = value
            self.validate_Nml2Quantity_time(self.delay)    # validate type Nml2Quantity_time
        super(ConnectionWD, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ConnectionWD, self).buildChildren(child_, node, nodeName_, True)
        pass

    def _get_cell_id(self, id_string):
        if '[' in id_string:
            return int(id_string.split('[')[1].split(']')[0])
        else:
            return int(id_string.split('/')[2])

    def get_pre_cell_id(self):

        return self._get_cell_id(self.pre_cell_id)

    def get_post_cell_id(self):

        return self._get_cell_id(self.post_cell_id)

    def get_pre_segment_id(self):

        return int(self.pre_segment_id)

    def get_post_segment_id(self):

        return int(self.post_segment_id)

    def get_pre_fraction_along(self):

        return float(self.pre_fraction_along)

    def get_post_fraction_along(self):

        return float(self.post_fraction_along)


    def get_pre_info(self):

        return str(self.get_pre_cell_id())+(':'+str(self.get_pre_segment_id())+'('+ '%.5f'%self.get_pre_fraction_along()+')' if self.get_pre_segment_id()!=0 or self.get_pre_fraction_along()!=0.5 else '')

    def get_post_info(self):

        return str(self.get_post_cell_id())+(':'+str(self.get_post_segment_id())+'('+ '%.5f'%self.get_post_fraction_along()+')' if self.get_post_segment_id()!=0 or self.get_post_fraction_along()!=0.5 else '')

    def __str__(self):

        return "Connection "+str(self.id)+": "+str(self.get_pre_info())+" -> "+str(self.get_post_info())

    
    def __str__(self):

        return "Connection "+str(self.id)+": "+str(self.get_pre_info())+" -> "+str(self.get_post_info())+             ", weight: "+'%f' % (float(self.weight))+", delay: "+'%.5f' % (self.get_delay_in_ms())+" ms"

    def get_delay_in_ms(self):
        if 'ms' in self.delay:
            return float(self.delay[:-2].strip())
        elif 's' in self.delay:
            return float(self.delay[:-1].strip())*1000.0

    # end class ConnectionWD


class Connection(BaseConnectionOldFormat):
    """Individual chemical (event based) synaptic connection, weight==1 and no
    delay"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = BaseConnectionOldFormat
    def __init__(self, neuroLexId=None, id=None, preCellId=None, preSegmentId='0', preFractionAlong='0.5', postCellId=None, postSegmentId='0', postFractionAlong='0.5', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Connection, self).__init__(neuroLexId, id, preCellId, preSegmentId, preFractionAlong, postCellId, postSegmentId, postFractionAlong,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Connection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Connection.subclass:
            return Connection.subclass(*args_, **kwargs_)
        else:
            return Connection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Connection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Connection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Connection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Connection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Connection', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Connection'):
        super(Connection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Connection')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Connection', fromsubclass_=False, pretty_print=True):
        super(Connection, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Connection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(Connection, self).buildChildren(child_, node, nodeName_, True)
        pass

    def _get_cell_id(self, id_string):
        if '[' in id_string:
            return int(id_string.split('[')[1].split(']')[0])
        else:
            return int(id_string.split('/')[2])

    def get_pre_cell_id(self):

        return self._get_cell_id(self.pre_cell_id)

    def get_post_cell_id(self):

        return self._get_cell_id(self.post_cell_id)

    def get_pre_segment_id(self):

        return int(self.pre_segment_id)

    def get_post_segment_id(self):

        return int(self.post_segment_id)

    def get_pre_fraction_along(self):

        return float(self.pre_fraction_along)

    def get_post_fraction_along(self):

        return float(self.post_fraction_along)


    def get_pre_info(self):

        return str(self.get_pre_cell_id())+(':'+str(self.get_pre_segment_id())+'('+ '%.5f'%self.get_pre_fraction_along()+')' if self.get_pre_segment_id()!=0 or self.get_pre_fraction_along()!=0.5 else '')

    def get_post_info(self):

        return str(self.get_post_cell_id())+(':'+str(self.get_post_segment_id())+'('+ '%.5f'%self.get_post_fraction_along()+')' if self.get_post_segment_id()!=0 or self.get_post_fraction_along()!=0.5 else '')

    def __str__(self):

        return "Connection "+str(self.id)+": "+str(self.get_pre_info())+" -> "+str(self.get_post_info())

    # end class Connection


class Cell2CaPools(Cell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('biophysicalProperties2CaPools', 'BiophysicalProperties2CaPools', 0, 1, {'minOccurs': '0', 'name': 'biophysicalProperties2CaPools', 'type': 'BiophysicalProperties2CaPools'}, None),
    ]
    subclass = None
    superclass = Cell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, morphology_attr=None, biophysicalProperties_attr=None, morphology=None, biophysicalProperties=None, biophysicalProperties2CaPools=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Cell2CaPools, self).__init__(neuroLexId, id, metaid, notes, property, annotation, morphology_attr, biophysicalProperties_attr, morphology, biophysicalProperties,  **kwargs_)
        self.biophysicalProperties2CaPools = biophysicalProperties2CaPools
        self.biophysicalProperties2CaPools_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cell2CaPools)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cell2CaPools.subclass:
            return Cell2CaPools.subclass(*args_, **kwargs_)
        else:
            return Cell2CaPools(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.biophysicalProperties2CaPools is not None or
            super(Cell2CaPools, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Cell2CaPools', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Cell2CaPools')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Cell2CaPools')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Cell2CaPools', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Cell2CaPools'):
        super(Cell2CaPools, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Cell2CaPools')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Cell2CaPools', fromsubclass_=False, pretty_print=True):
        super(Cell2CaPools, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.biophysicalProperties2CaPools is not None:
            namespaceprefix_ = self.biophysicalProperties2CaPools_nsprefix_ + ':' if (UseCapturedNS_ and self.biophysicalProperties2CaPools_nsprefix_) else ''
            self.biophysicalProperties2CaPools.export(outfile, level, namespaceprefix_, namespacedef_='', name_='biophysicalProperties2CaPools', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Cell2CaPools, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'biophysicalProperties2CaPools':
            obj_ = BiophysicalProperties2CaPools.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.biophysicalProperties2CaPools = obj_
            obj_.original_tagname_ = 'biophysicalProperties2CaPools'
        super(Cell2CaPools, self).buildChildren(child_, node, nodeName_, True)
# end class Cell2CaPools


class AdExIaFCell(BaseCellMembPotCap):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('gL', 'Nml2Quantity_conductance', 0, 0, {'use': 'required'}),
        MemberSpec_('EL', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('reset', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('VT', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('thresh', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('delT', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('tauw', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('refract', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('a', 'Nml2Quantity_conductance', 0, 0, {'use': 'required'}),
        MemberSpec_('b', 'Nml2Quantity_current', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseCellMembPotCap
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, C=None, gL=None, EL=None, reset=None, VT=None, thresh=None, delT=None, tauw=None, refract=None, a=None, b=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AdExIaFCell, self).__init__(neuroLexId, id, metaid, notes, property, annotation, C,  **kwargs_)
        self.gL = _cast(None, gL)
        self.gL_nsprefix_ = None
        self.EL = _cast(None, EL)
        self.EL_nsprefix_ = None
        self.reset = _cast(None, reset)
        self.reset_nsprefix_ = None
        self.VT = _cast(None, VT)
        self.VT_nsprefix_ = None
        self.thresh = _cast(None, thresh)
        self.thresh_nsprefix_ = None
        self.delT = _cast(None, delT)
        self.delT_nsprefix_ = None
        self.tauw = _cast(None, tauw)
        self.tauw_nsprefix_ = None
        self.refract = _cast(None, refract)
        self.refract_nsprefix_ = None
        self.a = _cast(None, a)
        self.a_nsprefix_ = None
        self.b = _cast(None, b)
        self.b_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdExIaFCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdExIaFCell.subclass:
            return AdExIaFCell.subclass(*args_, **kwargs_)
        else:
            return AdExIaFCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductance_patterns_, ))
    validate_Nml2Quantity_conductance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$']]
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_current_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_current_patterns_, ))
    validate_Nml2Quantity_current_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A|uA|nA|pA))$']]
    def hasContent_(self):
        if (
            super(AdExIaFCell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AdExIaFCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdExIaFCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdExIaFCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AdExIaFCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AdExIaFCell'):
        super(AdExIaFCell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdExIaFCell')
        if self.gL is not None and 'gL' not in already_processed:
            already_processed.add('gL')
            outfile.write(' gL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gL), input_name='gL')), ))
        if self.EL is not None and 'EL' not in already_processed:
            already_processed.add('EL')
            outfile.write(' EL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.EL), input_name='EL')), ))
        if self.reset is not None and 'reset' not in already_processed:
            already_processed.add('reset')
            outfile.write(' reset=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reset), input_name='reset')), ))
        if self.VT is not None and 'VT' not in already_processed:
            already_processed.add('VT')
            outfile.write(' VT=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.VT), input_name='VT')), ))
        if self.thresh is not None and 'thresh' not in already_processed:
            already_processed.add('thresh')
            outfile.write(' thresh=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.thresh), input_name='thresh')), ))
        if self.delT is not None and 'delT' not in already_processed:
            already_processed.add('delT')
            outfile.write(' delT=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delT), input_name='delT')), ))
        if self.tauw is not None and 'tauw' not in already_processed:
            already_processed.add('tauw')
            outfile.write(' tauw=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tauw), input_name='tauw')), ))
        if self.refract is not None and 'refract' not in already_processed:
            already_processed.add('refract')
            outfile.write(' refract=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refract), input_name='refract')), ))
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.a), input_name='a')), ))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.b), input_name='b')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AdExIaFCell', fromsubclass_=False, pretty_print=True):
        super(AdExIaFCell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gL', node)
        if value is not None and 'gL' not in already_processed:
            already_processed.add('gL')
            self.gL = value
            self.validate_Nml2Quantity_conductance(self.gL)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('EL', node)
        if value is not None and 'EL' not in already_processed:
            already_processed.add('EL')
            self.EL = value
            self.validate_Nml2Quantity_voltage(self.EL)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('reset', node)
        if value is not None and 'reset' not in already_processed:
            already_processed.add('reset')
            self.reset = value
            self.validate_Nml2Quantity_voltage(self.reset)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('VT', node)
        if value is not None and 'VT' not in already_processed:
            already_processed.add('VT')
            self.VT = value
            self.validate_Nml2Quantity_voltage(self.VT)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('thresh', node)
        if value is not None and 'thresh' not in already_processed:
            already_processed.add('thresh')
            self.thresh = value
            self.validate_Nml2Quantity_voltage(self.thresh)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('delT', node)
        if value is not None and 'delT' not in already_processed:
            already_processed.add('delT')
            self.delT = value
            self.validate_Nml2Quantity_voltage(self.delT)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('tauw', node)
        if value is not None and 'tauw' not in already_processed:
            already_processed.add('tauw')
            self.tauw = value
            self.validate_Nml2Quantity_time(self.tauw)    # validate type Nml2Quantity_time
        value = find_attr_value_('refract', node)
        if value is not None and 'refract' not in already_processed:
            already_processed.add('refract')
            self.refract = value
            self.validate_Nml2Quantity_time(self.refract)    # validate type Nml2Quantity_time
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            self.a = value
            self.validate_Nml2Quantity_conductance(self.a)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            self.b = value
            self.validate_Nml2Quantity_current(self.b)    # validate type Nml2Quantity_current
        super(AdExIaFCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AdExIaFCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AdExIaFCell


class Izhikevich2007Cell(BaseCellMembPotCap):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('v0', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('k', 'Nml2Quantity_conductancePerVoltage', 0, 0, {'use': 'required'}),
        MemberSpec_('vr', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('vt', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('vpeak', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('a', 'Nml2Quantity_pertime', 0, 0, {'use': 'required'}),
        MemberSpec_('b', 'Nml2Quantity_conductance', 0, 0, {'use': 'required'}),
        MemberSpec_('c', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
        MemberSpec_('d', 'Nml2Quantity_current', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseCellMembPotCap
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, C=None, v0=None, k=None, vr=None, vt=None, vpeak=None, a=None, b=None, c=None, d=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Izhikevich2007Cell, self).__init__(neuroLexId, id, metaid, notes, property, annotation, C,  **kwargs_)
        self.v0 = _cast(None, v0)
        self.v0_nsprefix_ = None
        self.k = _cast(None, k)
        self.k_nsprefix_ = None
        self.vr = _cast(None, vr)
        self.vr_nsprefix_ = None
        self.vt = _cast(None, vt)
        self.vt_nsprefix_ = None
        self.vpeak = _cast(None, vpeak)
        self.vpeak_nsprefix_ = None
        self.a = _cast(None, a)
        self.a_nsprefix_ = None
        self.b = _cast(None, b)
        self.b_nsprefix_ = None
        self.c = _cast(None, c)
        self.c_nsprefix_ = None
        self.d = _cast(None, d)
        self.d_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Izhikevich2007Cell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Izhikevich2007Cell.subclass:
            return Izhikevich2007Cell.subclass(*args_, **kwargs_)
        else:
            return Izhikevich2007Cell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def validate_Nml2Quantity_conductancePerVoltage(self, value):
        # Validate type Nml2Quantity_conductancePerVoltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductancePerVoltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductancePerVoltage_patterns_, ))
    validate_Nml2Quantity_conductancePerVoltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S_per_V|nS_per_mV))$']]
    def validate_Nml2Quantity_pertime(self, value):
        # Validate type Nml2Quantity_pertime, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_pertime_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_pertime_patterns_, ))
    validate_Nml2Quantity_pertime_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(per_s|per_ms|Hz))$']]
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductance_patterns_, ))
    validate_Nml2Quantity_conductance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$']]
    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_current_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_current_patterns_, ))
    validate_Nml2Quantity_current_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A|uA|nA|pA))$']]
    def hasContent_(self):
        if (
            super(Izhikevich2007Cell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Izhikevich2007Cell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Izhikevich2007Cell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Izhikevich2007Cell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Izhikevich2007Cell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Izhikevich2007Cell'):
        super(Izhikevich2007Cell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Izhikevich2007Cell')
        if self.v0 is not None and 'v0' not in already_processed:
            already_processed.add('v0')
            outfile.write(' v0=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.v0), input_name='v0')), ))
        if self.k is not None and 'k' not in already_processed:
            already_processed.add('k')
            outfile.write(' k=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.k), input_name='k')), ))
        if self.vr is not None and 'vr' not in already_processed:
            already_processed.add('vr')
            outfile.write(' vr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vr), input_name='vr')), ))
        if self.vt is not None and 'vt' not in already_processed:
            already_processed.add('vt')
            outfile.write(' vt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vt), input_name='vt')), ))
        if self.vpeak is not None and 'vpeak' not in already_processed:
            already_processed.add('vpeak')
            outfile.write(' vpeak=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vpeak), input_name='vpeak')), ))
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.a), input_name='a')), ))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.b), input_name='b')), ))
        if self.c is not None and 'c' not in already_processed:
            already_processed.add('c')
            outfile.write(' c=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.c), input_name='c')), ))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.d), input_name='d')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Izhikevich2007Cell', fromsubclass_=False, pretty_print=True):
        super(Izhikevich2007Cell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('v0', node)
        if value is not None and 'v0' not in already_processed:
            already_processed.add('v0')
            self.v0 = value
            self.validate_Nml2Quantity_voltage(self.v0)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('k', node)
        if value is not None and 'k' not in already_processed:
            already_processed.add('k')
            self.k = value
            self.validate_Nml2Quantity_conductancePerVoltage(self.k)    # validate type Nml2Quantity_conductancePerVoltage
        value = find_attr_value_('vr', node)
        if value is not None and 'vr' not in already_processed:
            already_processed.add('vr')
            self.vr = value
            self.validate_Nml2Quantity_voltage(self.vr)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('vt', node)
        if value is not None and 'vt' not in already_processed:
            already_processed.add('vt')
            self.vt = value
            self.validate_Nml2Quantity_voltage(self.vt)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('vpeak', node)
        if value is not None and 'vpeak' not in already_processed:
            already_processed.add('vpeak')
            self.vpeak = value
            self.validate_Nml2Quantity_voltage(self.vpeak)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            self.a = value
            self.validate_Nml2Quantity_pertime(self.a)    # validate type Nml2Quantity_pertime
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            self.b = value
            self.validate_Nml2Quantity_conductance(self.b)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('c', node)
        if value is not None and 'c' not in already_processed:
            already_processed.add('c')
            self.c = value
            self.validate_Nml2Quantity_voltage(self.c)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            self.d = value
            self.validate_Nml2Quantity_current(self.d)    # validate type Nml2Quantity_current
        super(Izhikevich2007Cell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(Izhikevich2007Cell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Izhikevich2007Cell


class IafRefCell(IafCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('refract', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = IafCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, leakReversal=None, thresh=None, reset=None, C=None, leakConductance=None, refract=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IafRefCell, self).__init__(neuroLexId, id, metaid, notes, property, annotation, leakReversal, thresh, reset, C, leakConductance,  **kwargs_)
        self.refract = _cast(None, refract)
        self.refract_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IafRefCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IafRefCell.subclass:
            return IafRefCell.subclass(*args_, **kwargs_)
        else:
            return IafRefCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (
            super(IafRefCell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IafRefCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IafRefCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IafRefCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IafRefCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IafRefCell'):
        super(IafRefCell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IafRefCell')
        if self.refract is not None and 'refract' not in already_processed:
            already_processed.add('refract')
            outfile.write(' refract=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refract), input_name='refract')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IafRefCell', fromsubclass_=False, pretty_print=True):
        super(IafRefCell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refract', node)
        if value is not None and 'refract' not in already_processed:
            already_processed.add('refract')
            self.refract = value
            self.validate_Nml2Quantity_time(self.refract)    # validate type Nml2Quantity_time
        super(IafRefCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IafRefCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IafRefCell


class IafTauRefCell(IafTauCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('refract', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = IafTauCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, leakReversal=None, thresh=None, reset=None, tau=None, refract=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IafTauRefCell, self).__init__(neuroLexId, id, metaid, notes, property, annotation, leakReversal, thresh, reset, tau,  **kwargs_)
        self.refract = _cast(None, refract)
        self.refract_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IafTauRefCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IafTauRefCell.subclass:
            return IafTauRefCell.subclass(*args_, **kwargs_)
        else:
            return IafTauRefCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (
            super(IafTauRefCell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IafTauRefCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IafTauRefCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IafTauRefCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IafTauRefCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IafTauRefCell'):
        super(IafTauRefCell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IafTauRefCell')
        if self.refract is not None and 'refract' not in already_processed:
            already_processed.add('refract')
            outfile.write(' refract=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refract), input_name='refract')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IafTauRefCell', fromsubclass_=False, pretty_print=True):
        super(IafTauRefCell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refract', node)
        if value is not None and 'refract' not in already_processed:
            already_processed.add('refract')
            self.refract = value
            self.validate_Nml2Quantity_time(self.refract)    # validate type Nml2Quantity_time
        super(IafTauRefCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IafTauRefCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IafTauRefCell


class DoubleSynapse(BaseVoltageDepSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('synapse1', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('synapse2', 'NmlId', 0, 0, {'use': 'required'}),
        MemberSpec_('synapse1Path', 'xs:string', 0, 0, {'use': 'required'}),
        MemberSpec_('synapse2Path', 'xs:string', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseVoltageDepSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, synapse1=None, synapse2=None, synapse1Path=None, synapse2Path=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DoubleSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.synapse1 = _cast(None, synapse1)
        self.synapse1_nsprefix_ = None
        self.synapse2 = _cast(None, synapse2)
        self.synapse2_nsprefix_ = None
        self.synapse1Path = _cast(None, synapse1Path)
        self.synapse1Path_nsprefix_ = None
        self.synapse2Path = _cast(None, synapse2Path)
        self.synapse2Path_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DoubleSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoubleSynapse.subclass:
            return DoubleSynapse.subclass(*args_, **kwargs_)
        else:
            return DoubleSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NmlId(self, value):
        # Validate type NmlId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_NmlId_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_NmlId_patterns_, ))
    validate_NmlId_patterns_ = [['^([a-zA-Z_][a-zA-Z0-9_]*)$']]
    def hasContent_(self):
        if (
            super(DoubleSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DoubleSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DoubleSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DoubleSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DoubleSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DoubleSynapse'):
        super(DoubleSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DoubleSynapse')
        if self.synapse1 is not None and 'synapse1' not in already_processed:
            already_processed.add('synapse1')
            outfile.write(' synapse1=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.synapse1), input_name='synapse1')), ))
        if self.synapse2 is not None and 'synapse2' not in already_processed:
            already_processed.add('synapse2')
            outfile.write(' synapse2=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.synapse2), input_name='synapse2')), ))
        if self.synapse1Path is not None and 'synapse1Path' not in already_processed:
            already_processed.add('synapse1Path')
            outfile.write(' synapse1Path=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.synapse1Path), input_name='synapse1Path')), ))
        if self.synapse2Path is not None and 'synapse2Path' not in already_processed:
            already_processed.add('synapse2Path')
            outfile.write(' synapse2Path=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.synapse2Path), input_name='synapse2Path')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DoubleSynapse', fromsubclass_=False, pretty_print=True):
        super(DoubleSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('synapse1', node)
        if value is not None and 'synapse1' not in already_processed:
            already_processed.add('synapse1')
            self.synapse1 = value
            self.validate_NmlId(self.synapse1)    # validate type NmlId
        value = find_attr_value_('synapse2', node)
        if value is not None and 'synapse2' not in already_processed:
            already_processed.add('synapse2')
            self.synapse2 = value
            self.validate_NmlId(self.synapse2)    # validate type NmlId
        value = find_attr_value_('synapse1Path', node)
        if value is not None and 'synapse1Path' not in already_processed:
            already_processed.add('synapse1Path')
            self.synapse1Path = value
        value = find_attr_value_('synapse2Path', node)
        if value is not None and 'synapse2Path' not in already_processed:
            already_processed.add('synapse2Path')
            self.synapse2Path = value
        super(DoubleSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DoubleSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DoubleSynapse


class AlphaCurrentSynapse(BaseCurrentBasedSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('tau', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('ibase', 'Nml2Quantity_current', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseCurrentBasedSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, tau=None, ibase=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AlphaCurrentSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation,  **kwargs_)
        self.tau = _cast(None, tau)
        self.tau_nsprefix_ = None
        self.ibase = _cast(None, ibase)
        self.ibase_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlphaCurrentSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlphaCurrentSynapse.subclass:
            return AlphaCurrentSynapse.subclass(*args_, **kwargs_)
        else:
            return AlphaCurrentSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def validate_Nml2Quantity_current(self, value):
        # Validate type Nml2Quantity_current, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_current_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_current_patterns_, ))
    validate_Nml2Quantity_current_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(A|uA|nA|pA))$']]
    def hasContent_(self):
        if (
            super(AlphaCurrentSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlphaCurrentSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlphaCurrentSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlphaCurrentSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlphaCurrentSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlphaCurrentSynapse'):
        super(AlphaCurrentSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlphaCurrentSynapse')
        if self.tau is not None and 'tau' not in already_processed:
            already_processed.add('tau')
            outfile.write(' tau=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tau), input_name='tau')), ))
        if self.ibase is not None and 'ibase' not in already_processed:
            already_processed.add('ibase')
            outfile.write(' ibase=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ibase), input_name='ibase')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlphaCurrentSynapse', fromsubclass_=False, pretty_print=True):
        super(AlphaCurrentSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tau', node)
        if value is not None and 'tau' not in already_processed:
            already_processed.add('tau')
            self.tau = value
            self.validate_Nml2Quantity_time(self.tau)    # validate type Nml2Quantity_time
        value = find_attr_value_('ibase', node)
        if value is not None and 'ibase' not in already_processed:
            already_processed.add('ibase')
            self.ibase = value
            self.validate_Nml2Quantity_current(self.ibase)    # validate type Nml2Quantity_current
        super(AlphaCurrentSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AlphaCurrentSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AlphaCurrentSynapse


class BaseConductanceBasedSynapseTwo(BaseVoltageDepSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('gbase1', 'Nml2Quantity_conductance', 0, 0, {'use': 'required'}),
        MemberSpec_('gbase2', 'Nml2Quantity_conductance', 0, 0, {'use': 'required'}),
        MemberSpec_('erev', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseVoltageDepSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, gbase1=None, gbase2=None, erev=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseConductanceBasedSynapseTwo, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.gbase1 = _cast(None, gbase1)
        self.gbase1_nsprefix_ = None
        self.gbase2 = _cast(None, gbase2)
        self.gbase2_nsprefix_ = None
        self.erev = _cast(None, erev)
        self.erev_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseConductanceBasedSynapseTwo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseConductanceBasedSynapseTwo.subclass:
            return BaseConductanceBasedSynapseTwo.subclass(*args_, **kwargs_)
        else:
            return BaseConductanceBasedSynapseTwo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductance_patterns_, ))
    validate_Nml2Quantity_conductance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$']]
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def hasContent_(self):
        if (
            super(BaseConductanceBasedSynapseTwo, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseConductanceBasedSynapseTwo', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseConductanceBasedSynapseTwo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseConductanceBasedSynapseTwo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseConductanceBasedSynapseTwo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseConductanceBasedSynapseTwo'):
        super(BaseConductanceBasedSynapseTwo, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseConductanceBasedSynapseTwo')
        if self.gbase1 is not None and 'gbase1' not in already_processed:
            already_processed.add('gbase1')
            outfile.write(' gbase1=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gbase1), input_name='gbase1')), ))
        if self.gbase2 is not None and 'gbase2' not in already_processed:
            already_processed.add('gbase2')
            outfile.write(' gbase2=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gbase2), input_name='gbase2')), ))
        if self.erev is not None and 'erev' not in already_processed:
            already_processed.add('erev')
            outfile.write(' erev=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.erev), input_name='erev')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseConductanceBasedSynapseTwo', fromsubclass_=False, pretty_print=True):
        super(BaseConductanceBasedSynapseTwo, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gbase1', node)
        if value is not None and 'gbase1' not in already_processed:
            already_processed.add('gbase1')
            self.gbase1 = value
            self.validate_Nml2Quantity_conductance(self.gbase1)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('gbase2', node)
        if value is not None and 'gbase2' not in already_processed:
            already_processed.add('gbase2')
            self.gbase2 = value
            self.validate_Nml2Quantity_conductance(self.gbase2)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('erev', node)
        if value is not None and 'erev' not in already_processed:
            already_processed.add('erev')
            self.erev = value
            self.validate_Nml2Quantity_voltage(self.erev)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseConductanceBasedSynapseTwo, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BaseConductanceBasedSynapseTwo, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseConductanceBasedSynapseTwo


class BaseConductanceBasedSynapse(BaseVoltageDepSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('gbase', 'Nml2Quantity_conductance', 0, 0, {'use': 'required'}),
        MemberSpec_('erev', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseVoltageDepSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, gbase=None, erev=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BaseConductanceBasedSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, extensiontype_,  **kwargs_)
        self.gbase = _cast(None, gbase)
        self.gbase_nsprefix_ = None
        self.erev = _cast(None, erev)
        self.erev_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseConductanceBasedSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseConductanceBasedSynapse.subclass:
            return BaseConductanceBasedSynapse.subclass(*args_, **kwargs_)
        else:
            return BaseConductanceBasedSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_conductance(self, value):
        # Validate type Nml2Quantity_conductance, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_conductance_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_conductance_patterns_, ))
    validate_Nml2Quantity_conductance_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(S|mS|uS|nS|pS))$']]
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def hasContent_(self):
        if (
            super(BaseConductanceBasedSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseConductanceBasedSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseConductanceBasedSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseConductanceBasedSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseConductanceBasedSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseConductanceBasedSynapse'):
        super(BaseConductanceBasedSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseConductanceBasedSynapse')
        if self.gbase is not None and 'gbase' not in already_processed:
            already_processed.add('gbase')
            outfile.write(' gbase=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gbase), input_name='gbase')), ))
        if self.erev is not None and 'erev' not in already_processed:
            already_processed.add('erev')
            outfile.write(' erev=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.erev), input_name='erev')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseConductanceBasedSynapse', fromsubclass_=False, pretty_print=True):
        super(BaseConductanceBasedSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gbase', node)
        if value is not None and 'gbase' not in already_processed:
            already_processed.add('gbase')
            self.gbase = value
            self.validate_Nml2Quantity_conductance(self.gbase)    # validate type Nml2Quantity_conductance
        value = find_attr_value_('erev', node)
        if value is not None and 'erev' not in already_processed:
            already_processed.add('erev')
            self.erev = value
            self.validate_Nml2Quantity_voltage(self.erev)    # validate type Nml2Quantity_voltage
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseConductanceBasedSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BaseConductanceBasedSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseConductanceBasedSynapse


class IonChannelVShift(IonChannel):
    """Same as ionChannel, but with a vShift parameter to change voltage
    activation of gates. The exact usage of vShift in expressions for rates
    is determined by the individual gates."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('vShift', 'Nml2Quantity_voltage', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = IonChannel
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, q10ConductanceScaling=None, species=None, type_=None, conductance=None, gate=None, gateHHrates=None, gateHHratesTau=None, gateHHtauInf=None, gateHHratesInf=None, gateHHratesTauInf=None, gateHHInstantaneous=None, gateFractional=None, vShift=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IonChannelVShift, self).__init__(neuroLexId, id, metaid, notes, property, annotation, q10ConductanceScaling, species, type_, conductance, gate, gateHHrates, gateHHratesTau, gateHHtauInf, gateHHratesInf, gateHHratesTauInf, gateHHInstantaneous, gateFractional,  **kwargs_)
        self.vShift = _cast(None, vShift)
        self.vShift_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IonChannelVShift)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IonChannelVShift.subclass:
            return IonChannelVShift.subclass(*args_, **kwargs_)
        else:
            return IonChannelVShift(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_voltage(self, value):
        # Validate type Nml2Quantity_voltage, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_voltage_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_voltage_patterns_, ))
    validate_Nml2Quantity_voltage_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(V|mV))$']]
    def hasContent_(self):
        if (
            super(IonChannelVShift, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IonChannelVShift', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IonChannelVShift')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IonChannelVShift')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IonChannelVShift', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IonChannelVShift'):
        super(IonChannelVShift, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IonChannelVShift')
        if self.vShift is not None and 'vShift' not in already_processed:
            already_processed.add('vShift')
            outfile.write(' vShift=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vShift), input_name='vShift')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IonChannelVShift', fromsubclass_=False, pretty_print=True):
        super(IonChannelVShift, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vShift', node)
        if value is not None and 'vShift' not in already_processed:
            already_processed.add('vShift')
            self.vShift = value
            self.validate_Nml2Quantity_voltage(self.vShift)    # validate type Nml2Quantity_voltage
        super(IonChannelVShift, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IonChannelVShift, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IonChannelVShift


class IonChannelHH(IonChannel):
    """Note ionChannel and ionChannelHH are currently functionally identical.
    This is needed since many existing examples use ionChannel, some use
    ionChannelHH.
    NeuroML v2beta4 should remove one of these, probably ionChannelHH."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = IonChannel
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, q10ConductanceScaling=None, species=None, type_=None, conductance=None, gate=None, gateHHrates=None, gateHHratesTau=None, gateHHtauInf=None, gateHHratesInf=None, gateHHratesTauInf=None, gateHHInstantaneous=None, gateFractional=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IonChannelHH, self).__init__(neuroLexId, id, metaid, notes, property, annotation, q10ConductanceScaling, species, type_, conductance, gate, gateHHrates, gateHHratesTau, gateHHtauInf, gateHHratesInf, gateHHratesTauInf, gateHHInstantaneous, gateFractional,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IonChannelHH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IonChannelHH.subclass:
            return IonChannelHH.subclass(*args_, **kwargs_)
        else:
            return IonChannelHH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(IonChannelHH, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IonChannelHH', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IonChannelHH')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IonChannelHH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IonChannelHH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IonChannelHH'):
        super(IonChannelHH, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IonChannelHH')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IonChannelHH', fromsubclass_=False, pretty_print=True):
        super(IonChannelHH, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IonChannelHH, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IonChannelHH, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IonChannelHH


class IF_curr_exp(basePyNNIaFCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = basePyNNIaFCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, cm=None, i_offset=None, tau_syn_E=None, tau_syn_I=None, v_init=None, tau_m=None, tau_refrac=None, v_reset=None, v_rest=None, v_thresh=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IF_curr_exp, self).__init__(neuroLexId, id, metaid, notes, property, annotation, cm, i_offset, tau_syn_E, tau_syn_I, v_init, tau_m, tau_refrac, v_reset, v_rest, v_thresh,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IF_curr_exp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IF_curr_exp.subclass:
            return IF_curr_exp.subclass(*args_, **kwargs_)
        else:
            return IF_curr_exp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(IF_curr_exp, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IF_curr_exp', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IF_curr_exp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IF_curr_exp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IF_curr_exp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IF_curr_exp'):
        super(IF_curr_exp, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IF_curr_exp')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IF_curr_exp', fromsubclass_=False, pretty_print=True):
        super(IF_curr_exp, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IF_curr_exp, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IF_curr_exp, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IF_curr_exp


class IF_curr_alpha(basePyNNIaFCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = basePyNNIaFCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, cm=None, i_offset=None, tau_syn_E=None, tau_syn_I=None, v_init=None, tau_m=None, tau_refrac=None, v_reset=None, v_rest=None, v_thresh=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IF_curr_alpha, self).__init__(neuroLexId, id, metaid, notes, property, annotation, cm, i_offset, tau_syn_E, tau_syn_I, v_init, tau_m, tau_refrac, v_reset, v_rest, v_thresh,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IF_curr_alpha)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IF_curr_alpha.subclass:
            return IF_curr_alpha.subclass(*args_, **kwargs_)
        else:
            return IF_curr_alpha(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(IF_curr_alpha, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IF_curr_alpha', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IF_curr_alpha')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IF_curr_alpha')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IF_curr_alpha', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IF_curr_alpha'):
        super(IF_curr_alpha, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IF_curr_alpha')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IF_curr_alpha', fromsubclass_=False, pretty_print=True):
        super(IF_curr_alpha, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IF_curr_alpha, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IF_curr_alpha, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IF_curr_alpha


class basePyNNIaFCondCell(basePyNNIaFCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('e_rev_E', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('e_rev_I', 'xs:float', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = basePyNNIaFCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, cm=None, i_offset=None, tau_syn_E=None, tau_syn_I=None, v_init=None, tau_m=None, tau_refrac=None, v_reset=None, v_rest=None, v_thresh=None, e_rev_E=None, e_rev_I=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(basePyNNIaFCondCell, self).__init__(neuroLexId, id, metaid, notes, property, annotation, cm, i_offset, tau_syn_E, tau_syn_I, v_init, tau_m, tau_refrac, v_reset, v_rest, v_thresh, extensiontype_,  **kwargs_)
        self.e_rev_E = _cast(float, e_rev_E)
        self.e_rev_E_nsprefix_ = None
        self.e_rev_I = _cast(float, e_rev_I)
        self.e_rev_I_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basePyNNIaFCondCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basePyNNIaFCondCell.subclass:
            return basePyNNIaFCondCell.subclass(*args_, **kwargs_)
        else:
            return basePyNNIaFCondCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(basePyNNIaFCondCell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='basePyNNIaFCondCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basePyNNIaFCondCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basePyNNIaFCondCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='basePyNNIaFCondCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='basePyNNIaFCondCell'):
        super(basePyNNIaFCondCell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basePyNNIaFCondCell')
        if self.e_rev_E is not None and 'e_rev_E' not in already_processed:
            already_processed.add('e_rev_E')
            outfile.write(' e_rev_E="%s"' % self.gds_format_float(self.e_rev_E, input_name='e_rev_E'))
        if self.e_rev_I is not None and 'e_rev_I' not in already_processed:
            already_processed.add('e_rev_I')
            outfile.write(' e_rev_I="%s"' % self.gds_format_float(self.e_rev_I, input_name='e_rev_I'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='basePyNNIaFCondCell', fromsubclass_=False, pretty_print=True):
        super(basePyNNIaFCondCell, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('e_rev_E', node)
        if value is not None and 'e_rev_E' not in already_processed:
            already_processed.add('e_rev_E')
            value = self.gds_parse_float(value, node, 'e_rev_E')
            self.e_rev_E = value
        value = find_attr_value_('e_rev_I', node)
        if value is not None and 'e_rev_I' not in already_processed:
            already_processed.add('e_rev_I')
            value = self.gds_parse_float(value, node, 'e_rev_I')
            self.e_rev_I = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(basePyNNIaFCondCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(basePyNNIaFCondCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class basePyNNIaFCondCell


class ContinuousConnectionInstance(ContinuousConnection):
    """Individual continuous/analog synaptic connection - instance based"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = ContinuousConnection
    def __init__(self, neuroLexId=None, id=None, preCell=None, preSegment='0', preFractionAlong='0.5', postCell=None, postSegment='0', postFractionAlong='0.5', preComponent=None, postComponent=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ContinuousConnectionInstance, self).__init__(neuroLexId, id, preCell, preSegment, preFractionAlong, postCell, postSegment, postFractionAlong, preComponent, postComponent, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContinuousConnectionInstance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContinuousConnectionInstance.subclass:
            return ContinuousConnectionInstance.subclass(*args_, **kwargs_)
        else:
            return ContinuousConnectionInstance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ContinuousConnectionInstance, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContinuousConnectionInstance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContinuousConnectionInstance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContinuousConnectionInstance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContinuousConnectionInstance', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContinuousConnectionInstance'):
        super(ContinuousConnectionInstance, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContinuousConnectionInstance')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContinuousConnectionInstance', fromsubclass_=False, pretty_print=True):
        super(ContinuousConnectionInstance, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ContinuousConnectionInstance, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ContinuousConnectionInstance, self).buildChildren(child_, node, nodeName_, True)
        pass

    def _get_cell_id(self, id_string):
        if '[' in id_string:
            return int(id_string.split('[')[1].split(']')[0])
        else:
            return int(id_string.split('/')[2])


    def __str__(self):

        return "Continuous Connection (Instance based) "+str(self.id)+": "+str(self.get_pre_info())+" -> "+str(self.get_post_info())+             ", pre comp: "+str(self.pre_component)+", post comp: "+str(self.post_component)


    # end class ContinuousConnectionInstance


class ElectricalConnectionInstance(ElectricalConnection):
    """Projection between two populations consisting of analog connections
    (e.g. graded synapses)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = ElectricalConnection
    def __init__(self, neuroLexId=None, id=None, preCell=None, preSegment='0', preFractionAlong='0.5', postCell=None, postSegment='0', postFractionAlong='0.5', synapse=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ElectricalConnectionInstance, self).__init__(neuroLexId, id, preCell, preSegment, preFractionAlong, postCell, postSegment, postFractionAlong, synapse, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricalConnectionInstance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricalConnectionInstance.subclass:
            return ElectricalConnectionInstance.subclass(*args_, **kwargs_)
        else:
            return ElectricalConnectionInstance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ElectricalConnectionInstance, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ElectricalConnectionInstance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElectricalConnectionInstance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricalConnectionInstance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ElectricalConnectionInstance', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ElectricalConnectionInstance'):
        super(ElectricalConnectionInstance, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricalConnectionInstance')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ElectricalConnectionInstance', fromsubclass_=False, pretty_print=True):
        super(ElectricalConnectionInstance, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ElectricalConnectionInstance, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ElectricalConnectionInstance, self).buildChildren(child_, node, nodeName_, True)
        pass

    def _get_cell_id(self, id_string):
        if '[' in id_string:
            return int(id_string.split('[')[1].split(']')[0])
        else:
            return int(id_string.split('/')[2])

    def __str__(self):

        return "Electrical Connection (Instance based) "+str(self.id)+": "+str(self.get_pre_info())+" -> "+str(self.get_post_info())+             ", synapse: "+str(self.synapse)


    # end class ElectricalConnectionInstance


class ExpThreeSynapse(BaseConductanceBasedSynapseTwo):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('tauDecay1', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('tauDecay2', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('tauRise', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseConductanceBasedSynapseTwo
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, gbase1=None, gbase2=None, erev=None, tauDecay1=None, tauDecay2=None, tauRise=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ExpThreeSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, gbase1, gbase2, erev,  **kwargs_)
        self.tauDecay1 = _cast(None, tauDecay1)
        self.tauDecay1_nsprefix_ = None
        self.tauDecay2 = _cast(None, tauDecay2)
        self.tauDecay2_nsprefix_ = None
        self.tauRise = _cast(None, tauRise)
        self.tauRise_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExpThreeSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpThreeSynapse.subclass:
            return ExpThreeSynapse.subclass(*args_, **kwargs_)
        else:
            return ExpThreeSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (
            super(ExpThreeSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExpThreeSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExpThreeSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExpThreeSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExpThreeSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExpThreeSynapse'):
        super(ExpThreeSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExpThreeSynapse')
        if self.tauDecay1 is not None and 'tauDecay1' not in already_processed:
            already_processed.add('tauDecay1')
            outfile.write(' tauDecay1=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tauDecay1), input_name='tauDecay1')), ))
        if self.tauDecay2 is not None and 'tauDecay2' not in already_processed:
            already_processed.add('tauDecay2')
            outfile.write(' tauDecay2=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tauDecay2), input_name='tauDecay2')), ))
        if self.tauRise is not None and 'tauRise' not in already_processed:
            already_processed.add('tauRise')
            outfile.write(' tauRise=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tauRise), input_name='tauRise')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExpThreeSynapse', fromsubclass_=False, pretty_print=True):
        super(ExpThreeSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tauDecay1', node)
        if value is not None and 'tauDecay1' not in already_processed:
            already_processed.add('tauDecay1')
            self.tauDecay1 = value
            self.validate_Nml2Quantity_time(self.tauDecay1)    # validate type Nml2Quantity_time
        value = find_attr_value_('tauDecay2', node)
        if value is not None and 'tauDecay2' not in already_processed:
            already_processed.add('tauDecay2')
            self.tauDecay2 = value
            self.validate_Nml2Quantity_time(self.tauDecay2)    # validate type Nml2Quantity_time
        value = find_attr_value_('tauRise', node)
        if value is not None and 'tauRise' not in already_processed:
            already_processed.add('tauRise')
            self.tauRise = value
            self.validate_Nml2Quantity_time(self.tauRise)    # validate type Nml2Quantity_time
        super(ExpThreeSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ExpThreeSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExpThreeSynapse


class ExpTwoSynapse(BaseConductanceBasedSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('tauDecay', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
        MemberSpec_('tauRise', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseConductanceBasedSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, gbase=None, erev=None, tauDecay=None, tauRise=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ExpTwoSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, gbase, erev, extensiontype_,  **kwargs_)
        self.tauDecay = _cast(None, tauDecay)
        self.tauDecay_nsprefix_ = None
        self.tauRise = _cast(None, tauRise)
        self.tauRise_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExpTwoSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpTwoSynapse.subclass:
            return ExpTwoSynapse.subclass(*args_, **kwargs_)
        else:
            return ExpTwoSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (
            super(ExpTwoSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExpTwoSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExpTwoSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExpTwoSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExpTwoSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExpTwoSynapse'):
        super(ExpTwoSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExpTwoSynapse')
        if self.tauDecay is not None and 'tauDecay' not in already_processed:
            already_processed.add('tauDecay')
            outfile.write(' tauDecay=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tauDecay), input_name='tauDecay')), ))
        if self.tauRise is not None and 'tauRise' not in already_processed:
            already_processed.add('tauRise')
            outfile.write(' tauRise=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tauRise), input_name='tauRise')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExpTwoSynapse', fromsubclass_=False, pretty_print=True):
        super(ExpTwoSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tauDecay', node)
        if value is not None and 'tauDecay' not in already_processed:
            already_processed.add('tauDecay')
            self.tauDecay = value
            self.validate_Nml2Quantity_time(self.tauDecay)    # validate type Nml2Quantity_time
        value = find_attr_value_('tauRise', node)
        if value is not None and 'tauRise' not in already_processed:
            already_processed.add('tauRise')
            self.tauRise = value
            self.validate_Nml2Quantity_time(self.tauRise)    # validate type Nml2Quantity_time
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ExpTwoSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ExpTwoSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExpTwoSynapse


class ExpOneSynapse(BaseConductanceBasedSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('tauDecay', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseConductanceBasedSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, gbase=None, erev=None, tauDecay=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ExpOneSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, gbase, erev,  **kwargs_)
        self.tauDecay = _cast(None, tauDecay)
        self.tauDecay_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExpOneSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpOneSynapse.subclass:
            return ExpOneSynapse.subclass(*args_, **kwargs_)
        else:
            return ExpOneSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (
            super(ExpOneSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExpOneSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExpOneSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExpOneSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExpOneSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExpOneSynapse'):
        super(ExpOneSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExpOneSynapse')
        if self.tauDecay is not None and 'tauDecay' not in already_processed:
            already_processed.add('tauDecay')
            outfile.write(' tauDecay=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tauDecay), input_name='tauDecay')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExpOneSynapse', fromsubclass_=False, pretty_print=True):
        super(ExpOneSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tauDecay', node)
        if value is not None and 'tauDecay' not in already_processed:
            already_processed.add('tauDecay')
            self.tauDecay = value
            self.validate_Nml2Quantity_time(self.tauDecay)    # validate type Nml2Quantity_time
        super(ExpOneSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ExpOneSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExpOneSynapse


class AlphaSynapse(BaseConductanceBasedSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('tau', 'Nml2Quantity_time', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = BaseConductanceBasedSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, gbase=None, erev=None, tau=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AlphaSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, gbase, erev,  **kwargs_)
        self.tau = _cast(None, tau)
        self.tau_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlphaSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlphaSynapse.subclass:
            return AlphaSynapse.subclass(*args_, **kwargs_)
        else:
            return AlphaSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Nml2Quantity_time(self, value):
        # Validate type Nml2Quantity_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_Nml2Quantity_time_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_Nml2Quantity_time_patterns_, ))
    validate_Nml2Quantity_time_patterns_ = [['^(-?([0-9]*(\\.[0-9]+)?)([eE]-?[0-9]+)?[\\s]*(s|ms))$']]
    def hasContent_(self):
        if (
            super(AlphaSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlphaSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlphaSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlphaSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlphaSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlphaSynapse'):
        super(AlphaSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlphaSynapse')
        if self.tau is not None and 'tau' not in already_processed:
            already_processed.add('tau')
            outfile.write(' tau=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tau), input_name='tau')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlphaSynapse', fromsubclass_=False, pretty_print=True):
        super(AlphaSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tau', node)
        if value is not None and 'tau' not in already_processed:
            already_processed.add('tau')
            self.tau = value
            self.validate_Nml2Quantity_time(self.tau)    # validate type Nml2Quantity_time
        super(AlphaSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AlphaSynapse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AlphaSynapse


class EIF_cond_exp_isfa_ista(basePyNNIaFCondCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('a', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('b', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('delta_T', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('tau_w', 'xs:float', 0, 0, {'use': 'required'}),
        MemberSpec_('v_spike', 'xs:float', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = basePyNNIaFCondCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, cm=None, i_offset=None, tau_syn_E=None, tau_syn_I=None, v_init=None, tau_m=None, tau_refrac=None, v_reset=None, v_rest=None, v_thresh=None, e_rev_E=None, e_rev_I=None, a=None, b=None, delta_T=None, tau_w=None, v_spike=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EIF_cond_exp_isfa_ista, self).__init__(neuroLexId, id, metaid, notes, property, annotation, cm, i_offset, tau_syn_E, tau_syn_I, v_init, tau_m, tau_refrac, v_reset, v_rest, v_thresh, e_rev_E, e_rev_I, extensiontype_,  **kwargs_)
        self.a = _cast(float, a)
        self.a_nsprefix_ = None
        self.b = _cast(float, b)
        self.b_nsprefix_ = None
        self.delta_T = _cast(float, delta_T)
        self.delta_T_nsprefix_ = None
        self.tau_w = _cast(float, tau_w)
        self.tau_w_nsprefix_ = None
        self.v_spike = _cast(float, v_spike)
        self.v_spike_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EIF_cond_exp_isfa_ista)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EIF_cond_exp_isfa_ista.subclass:
            return EIF_cond_exp_isfa_ista.subclass(*args_, **kwargs_)
        else:
            return EIF_cond_exp_isfa_ista(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EIF_cond_exp_isfa_ista, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIF_cond_exp_isfa_ista', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EIF_cond_exp_isfa_ista')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIF_cond_exp_isfa_ista')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EIF_cond_exp_isfa_ista', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EIF_cond_exp_isfa_ista'):
        super(EIF_cond_exp_isfa_ista, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIF_cond_exp_isfa_ista')
        if self.a is not None and 'a' not in already_processed:
            already_processed.add('a')
            outfile.write(' a="%s"' % self.gds_format_float(self.a, input_name='a'))
        if self.b is not None and 'b' not in already_processed:
            already_processed.add('b')
            outfile.write(' b="%s"' % self.gds_format_float(self.b, input_name='b'))
        if self.delta_T is not None and 'delta_T' not in already_processed:
            already_processed.add('delta_T')
            outfile.write(' delta_T="%s"' % self.gds_format_float(self.delta_T, input_name='delta_T'))
        if self.tau_w is not None and 'tau_w' not in already_processed:
            already_processed.add('tau_w')
            outfile.write(' tau_w="%s"' % self.gds_format_float(self.tau_w, input_name='tau_w'))
        if self.v_spike is not None and 'v_spike' not in already_processed:
            already_processed.add('v_spike')
            outfile.write(' v_spike="%s"' % self.gds_format_float(self.v_spike, input_name='v_spike'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIF_cond_exp_isfa_ista', fromsubclass_=False, pretty_print=True):
        super(EIF_cond_exp_isfa_ista, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.add('a')
            value = self.gds_parse_float(value, node, 'a')
            self.a = value
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.add('b')
            value = self.gds_parse_float(value, node, 'b')
            self.b = value
        value = find_attr_value_('delta_T', node)
        if value is not None and 'delta_T' not in already_processed:
            already_processed.add('delta_T')
            value = self.gds_parse_float(value, node, 'delta_T')
            self.delta_T = value
        value = find_attr_value_('tau_w', node)
        if value is not None and 'tau_w' not in already_processed:
            already_processed.add('tau_w')
            value = self.gds_parse_float(value, node, 'tau_w')
            self.tau_w = value
        value = find_attr_value_('v_spike', node)
        if value is not None and 'v_spike' not in already_processed:
            already_processed.add('v_spike')
            value = self.gds_parse_float(value, node, 'v_spike')
            self.v_spike = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EIF_cond_exp_isfa_ista, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(EIF_cond_exp_isfa_ista, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EIF_cond_exp_isfa_ista


class IF_cond_exp(basePyNNIaFCondCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = basePyNNIaFCondCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, cm=None, i_offset=None, tau_syn_E=None, tau_syn_I=None, v_init=None, tau_m=None, tau_refrac=None, v_reset=None, v_rest=None, v_thresh=None, e_rev_E=None, e_rev_I=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IF_cond_exp, self).__init__(neuroLexId, id, metaid, notes, property, annotation, cm, i_offset, tau_syn_E, tau_syn_I, v_init, tau_m, tau_refrac, v_reset, v_rest, v_thresh, e_rev_E, e_rev_I,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IF_cond_exp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IF_cond_exp.subclass:
            return IF_cond_exp.subclass(*args_, **kwargs_)
        else:
            return IF_cond_exp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(IF_cond_exp, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IF_cond_exp', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IF_cond_exp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IF_cond_exp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IF_cond_exp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IF_cond_exp'):
        super(IF_cond_exp, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IF_cond_exp')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IF_cond_exp', fromsubclass_=False, pretty_print=True):
        super(IF_cond_exp, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IF_cond_exp, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IF_cond_exp, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IF_cond_exp


class IF_cond_alpha(basePyNNIaFCondCell):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = basePyNNIaFCondCell
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, cm=None, i_offset=None, tau_syn_E=None, tau_syn_I=None, v_init=None, tau_m=None, tau_refrac=None, v_reset=None, v_rest=None, v_thresh=None, e_rev_E=None, e_rev_I=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IF_cond_alpha, self).__init__(neuroLexId, id, metaid, notes, property, annotation, cm, i_offset, tau_syn_E, tau_syn_I, v_init, tau_m, tau_refrac, v_reset, v_rest, v_thresh, e_rev_E, e_rev_I,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IF_cond_alpha)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IF_cond_alpha.subclass:
            return IF_cond_alpha.subclass(*args_, **kwargs_)
        else:
            return IF_cond_alpha(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(IF_cond_alpha, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IF_cond_alpha', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IF_cond_alpha')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IF_cond_alpha')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IF_cond_alpha', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IF_cond_alpha'):
        super(IF_cond_alpha, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IF_cond_alpha')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IF_cond_alpha', fromsubclass_=False, pretty_print=True):
        super(IF_cond_alpha, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IF_cond_alpha, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IF_cond_alpha, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IF_cond_alpha


class ContinuousConnectionInstanceW(ContinuousConnectionInstance):
    """Individual continuous/analog synaptic connection - instance based.
    Includes setting of _weight for the connection"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('weight', 'xs:float', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = ContinuousConnectionInstance
    def __init__(self, neuroLexId=None, id=None, preCell=None, preSegment='0', preFractionAlong='0.5', postCell=None, postSegment='0', postFractionAlong='0.5', preComponent=None, postComponent=None, weight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ContinuousConnectionInstanceW, self).__init__(neuroLexId, id, preCell, preSegment, preFractionAlong, postCell, postSegment, postFractionAlong, preComponent, postComponent,  **kwargs_)
        self.weight = _cast(float, weight)
        self.weight_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContinuousConnectionInstanceW)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContinuousConnectionInstanceW.subclass:
            return ContinuousConnectionInstanceW.subclass(*args_, **kwargs_)
        else:
            return ContinuousConnectionInstanceW(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ContinuousConnectionInstanceW, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContinuousConnectionInstanceW', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContinuousConnectionInstanceW')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContinuousConnectionInstanceW')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContinuousConnectionInstanceW', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContinuousConnectionInstanceW'):
        super(ContinuousConnectionInstanceW, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContinuousConnectionInstanceW')
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight="%s"' % self.gds_format_float(self.weight, input_name='weight'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContinuousConnectionInstanceW', fromsubclass_=False, pretty_print=True):
        super(ContinuousConnectionInstanceW, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            value = self.gds_parse_float(value, node, 'weight')
            self.weight = value
        super(ContinuousConnectionInstanceW, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ContinuousConnectionInstanceW, self).buildChildren(child_, node, nodeName_, True)
        pass

    def get_weight(self):

        return float(self.weight) if self.weight!=None else 1.0

    def __str__(self):

        return "Continuous Connection (Instance based & weight) "+str(self.id)+": "+str(self.get_pre_info())+" -> "+str(self.get_post_info())+             ", pre comp: "+str(self.pre_component)+", post comp: "+str(self.post_component)+", weight: "+'%.6f'%self.get_weight()


    # end class ContinuousConnectionInstanceW


class ElectricalConnectionInstanceW(ElectricalConnectionInstance):
    """Projection between two populations consisting of analog connections
    (e.g. graded synapses). Includes setting of weight for the
    connection"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('weight', 'xs:float', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = ElectricalConnectionInstance
    def __init__(self, neuroLexId=None, id=None, preCell=None, preSegment='0', preFractionAlong='0.5', postCell=None, postSegment='0', postFractionAlong='0.5', synapse=None, weight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ElectricalConnectionInstanceW, self).__init__(neuroLexId, id, preCell, preSegment, preFractionAlong, postCell, postSegment, postFractionAlong, synapse,  **kwargs_)
        self.weight = _cast(float, weight)
        self.weight_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricalConnectionInstanceW)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricalConnectionInstanceW.subclass:
            return ElectricalConnectionInstanceW.subclass(*args_, **kwargs_)
        else:
            return ElectricalConnectionInstanceW(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ElectricalConnectionInstanceW, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ElectricalConnectionInstanceW', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElectricalConnectionInstanceW')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricalConnectionInstanceW')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ElectricalConnectionInstanceW', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ElectricalConnectionInstanceW'):
        super(ElectricalConnectionInstanceW, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricalConnectionInstanceW')
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight="%s"' % self.gds_format_float(self.weight, input_name='weight'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ElectricalConnectionInstanceW', fromsubclass_=False, pretty_print=True):
        super(ElectricalConnectionInstanceW, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            value = self.gds_parse_float(value, node, 'weight')
            self.weight = value
        super(ElectricalConnectionInstanceW, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ElectricalConnectionInstanceW, self).buildChildren(child_, node, nodeName_, True)
        pass

    def get_weight(self):

        return float(self.weight) if self.weight!=None else 1.0

    def __str__(self):

        return "Electrical Connection (Instance based & weight) "+str(self.id)+": "+str(self.get_pre_info())+" -> "+str(self.get_post_info())+             ", synapse: "+str(self.synapse) + ", weight: "+'%.6f'%self.get_weight()

    # end class ElectricalConnectionInstanceW


class BlockingPlasticSynapse(ExpTwoSynapse):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('plasticityMechanism', 'PlasticityMechanism', 0, 1, {'minOccurs': '0', 'name': 'plasticityMechanism', 'type': 'PlasticityMechanism'}, None),
        MemberSpec_('blockMechanism', 'BlockMechanism', 0, 1, {'minOccurs': '0', 'name': 'blockMechanism', 'type': 'BlockMechanism'}, None),
    ]
    subclass = None
    superclass = ExpTwoSynapse
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, gbase=None, erev=None, tauDecay=None, tauRise=None, plasticityMechanism=None, blockMechanism=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BlockingPlasticSynapse, self).__init__(neuroLexId, id, metaid, notes, property, annotation, gbase, erev, tauDecay, tauRise,  **kwargs_)
        self.plasticityMechanism = plasticityMechanism
        self.plasticityMechanism_nsprefix_ = None
        self.blockMechanism = blockMechanism
        self.blockMechanism_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BlockingPlasticSynapse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockingPlasticSynapse.subclass:
            return BlockingPlasticSynapse.subclass(*args_, **kwargs_)
        else:
            return BlockingPlasticSynapse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.plasticityMechanism is not None or
            self.blockMechanism is not None or
            super(BlockingPlasticSynapse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BlockingPlasticSynapse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BlockingPlasticSynapse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BlockingPlasticSynapse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BlockingPlasticSynapse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BlockingPlasticSynapse'):
        super(BlockingPlasticSynapse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BlockingPlasticSynapse')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BlockingPlasticSynapse', fromsubclass_=False, pretty_print=True):
        super(BlockingPlasticSynapse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.plasticityMechanism is not None:
            namespaceprefix_ = self.plasticityMechanism_nsprefix_ + ':' if (UseCapturedNS_ and self.plasticityMechanism_nsprefix_) else ''
            self.plasticityMechanism.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plasticityMechanism', pretty_print=pretty_print)
        if self.blockMechanism is not None:
            namespaceprefix_ = self.blockMechanism_nsprefix_ + ':' if (UseCapturedNS_ and self.blockMechanism_nsprefix_) else ''
            self.blockMechanism.export(outfile, level, namespaceprefix_, namespacedef_='', name_='blockMechanism', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BlockingPlasticSynapse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'plasticityMechanism':
            obj_ = PlasticityMechanism.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.plasticityMechanism = obj_
            obj_.original_tagname_ = 'plasticityMechanism'
        elif nodeName_ == 'blockMechanism':
            obj_ = BlockMechanism.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.blockMechanism = obj_
            obj_.original_tagname_ = 'blockMechanism'
        super(BlockingPlasticSynapse, self).buildChildren(child_, node, nodeName_, True)
# end class BlockingPlasticSynapse


class EIF_cond_alpha_isfa_ista(EIF_cond_exp_isfa_ista):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = EIF_cond_exp_isfa_ista
    def __init__(self, neuroLexId=None, id=None, metaid=None, notes=None, property=None, annotation=None, cm=None, i_offset=None, tau_syn_E=None, tau_syn_I=None, v_init=None, tau_m=None, tau_refrac=None, v_reset=None, v_rest=None, v_thresh=None, e_rev_E=None, e_rev_I=None, a=None, b=None, delta_T=None, tau_w=None, v_spike=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EIF_cond_alpha_isfa_ista, self).__init__(neuroLexId, id, metaid, notes, property, annotation, cm, i_offset, tau_syn_E, tau_syn_I, v_init, tau_m, tau_refrac, v_reset, v_rest, v_thresh, e_rev_E, e_rev_I, a, b, delta_T, tau_w, v_spike,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EIF_cond_alpha_isfa_ista)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EIF_cond_alpha_isfa_ista.subclass:
            return EIF_cond_alpha_isfa_ista.subclass(*args_, **kwargs_)
        else:
            return EIF_cond_alpha_isfa_ista(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EIF_cond_alpha_isfa_ista, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIF_cond_alpha_isfa_ista', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EIF_cond_alpha_isfa_ista')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIF_cond_alpha_isfa_ista')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EIF_cond_alpha_isfa_ista', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EIF_cond_alpha_isfa_ista'):
        super(EIF_cond_alpha_isfa_ista, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EIF_cond_alpha_isfa_ista')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EIF_cond_alpha_isfa_ista', fromsubclass_=False, pretty_print=True):
        super(EIF_cond_alpha_isfa_ista, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EIF_cond_alpha_isfa_ista, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(EIF_cond_alpha_isfa_ista, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EIF_cond_alpha_isfa_ista


GDSClassesMapping = {
    'neuroml': NeuroMLDocument,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Property'
        rootClass = Property
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_=namespacedefs,
##             pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Property'
        rootClass = Property
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         content = etree_.tostring(
##             rootElement, pretty_print=True,
##             xml_declaration=True, encoding="utf-8")
##         sys.stdout.write(str(content))
##         sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Property'
        rootClass = Property
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Property'
        rootClass = Property
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
##     if not silence:
##         sys.stdout.write('#from nml import *\n\n')
##         sys.stdout.write('import nml as model_\n\n')
##         sys.stdout.write('rootObj = model_.rootClass(\n')
##         rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##         sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

__all__ = [
    "AdExIaFCell",
    "AlphaCondSynapse",
    "AlphaCurrSynapse",
    "AlphaCurrentSynapse",
    "AlphaSynapse",
    "Annotation",
    "Base",
    "BaseCell",
    "BaseCellMembPotCap",
    "BaseConductanceBasedSynapse",
    "BaseConductanceBasedSynapseTwo",
    "BaseConnection",
    "BaseConnectionNewFormat",
    "BaseConnectionOldFormat",
    "BaseCurrentBasedSynapse",
    "BaseNonNegativeIntegerId",
    "BaseProjection",
    "BasePynnSynapse",
    "BaseSynapse",
    "BaseVoltageDepSynapse",
    "BaseWithoutId",
    "BiophysicalProperties",
    "BiophysicalProperties2CaPools",
    "BlockMechanism",
    "BlockingPlasticSynapse",
    "Case",
    "Cell",
    "Cell2CaPools",
    "CellSet",
    "ChannelDensity",
    "ChannelDensityGHK",
    "ChannelDensityGHK2",
    "ChannelDensityNernst",
    "ChannelDensityNernstCa2",
    "ChannelDensityNonUniform",
    "ChannelDensityNonUniformGHK",
    "ChannelDensityNonUniformNernst",
    "ChannelDensityVShift",
    "ChannelPopulation",
    "ClosedState",
    "ComponentType",
    "CompoundInput",
    "CompoundInputDL",
    "ConcentrationModel_D",
    "ConditionalDerivedVariable",
    "Connection",
    "ConnectionWD",
    "Constant",
    "ContinuousConnection",
    "ContinuousConnectionInstance",
    "ContinuousConnectionInstanceW",
    "ContinuousProjection",
    "DecayingPoolConcentrationModel",
    "DerivedVariable",
    "DistalDetails",
    "DoubleSynapse",
    "Dynamics",
    "EIF_cond_alpha_isfa_ista",
    "EIF_cond_exp_isfa_ista",
    "ElectricalConnection",
    "ElectricalConnectionInstance",
    "ElectricalConnectionInstanceW",
    "ElectricalProjection",
    "ExpCondSynapse",
    "ExpCurrSynapse",
    "ExpOneSynapse",
    "ExpThreeSynapse",
    "ExpTwoSynapse",
    "ExplicitInput",
    "Exposure",
    "ExtracellularProperties",
    "ExtracellularPropertiesLocal",
    "FitzHughNagumo1969Cell",
    "FitzHughNagumoCell",
    "FixedFactorConcentrationModel",
    "ForwardTransition",
    "GapJunction",
    "GateFractional",
    "GateFractionalSubgate",
    "GateHHInstantaneous",
    "GateHHRates",
    "GateHHRatesInf",
    "GateHHRatesTau",
    "GateHHRatesTauInf",
    "GateHHTauInf",
    "GateHHUndetermined",
    "GateKS",
    "GradedSynapse",
    "GridLayout",
    "HHRate",
    "HHTime",
    "HHVariable",
    "HH_cond_exp",
    "IF_cond_alpha",
    "IF_cond_exp",
    "IF_curr_alpha",
    "IF_curr_exp",
    "IafCell",
    "IafRefCell",
    "IafTauCell",
    "IafTauRefCell",
    "Include",
    "IncludeType",
    "InhomogeneousParameter",
    "InhomogeneousValue",
    "InitMembPotential",
    "Input",
    "InputList",
    "InputW",
    "Instance",
    "InstanceRequirement",
    "IntracellularProperties",
    "IntracellularProperties2CaPools",
    "IonChannel",
    "IonChannelHH",
    "IonChannelKS",
    "IonChannelScalable",
    "IonChannelVShift",
    "Izhikevich2007Cell",
    "IzhikevichCell",
    "LEMS_Property",
    "Layout",
    "LinearGradedSynapse",
    "Location",
    "Member",
    "MembraneProperties",
    "MembraneProperties2CaPools",
    "Morphology",
    "NamedDimensionalType",
    "NamedDimensionalVariable",
    "Network",
    "NeuroMLDocument",
    "OpenState",
    "Parameter",
    "Path",
    "PinskyRinzelCA3Cell",
    "PlasticityMechanism",
    "Point3DWithDiam",
    "PoissonFiringSynapse",
    "Population",
    "Projection",
    "Property",
    "ProximalDetails",
    "PulseGenerator",
    "PulseGeneratorDL",
    "Q10ConductanceScaling",
    "Q10Settings",
    "RampGenerator",
    "RampGeneratorDL",
    "RandomLayout",
    "ReactionScheme",
    "Region",
    "Requirement",
    "Resistivity",
    "ReverseTransition",
    "Segment",
    "SegmentEndPoint",
    "SegmentGroup",
    "SegmentParent",
    "SilentSynapse",
    "SineGenerator",
    "SineGeneratorDL",
    "Space",
    "SpaceStructure",
    "Species",
    "SpecificCapacitance",
    "Spike",
    "SpikeArray",
    "SpikeGenerator",
    "SpikeGeneratorPoisson",
    "SpikeGeneratorRandom",
    "SpikeGeneratorRefPoisson",
    "SpikeSourcePoisson",
    "SpikeThresh",
    "Standalone",
    "StateVariable",
    "SubTree",
    "SynapticConnection",
    "TauInfTransition",
    "TimeDerivative",
    "TimedSynapticInput",
    "TransientPoissonFiringSynapse",
    "UnstructuredLayout",
    "ValueAcrossSegOrSegGroup",
    "VariableParameter",
    "VoltageClamp",
    "VoltageClampTriple",
    "basePyNNCell",
    "basePyNNIaFCell",
    "basePyNNIaFCondCell"
]
